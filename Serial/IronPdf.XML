<?xml version="1.0" encoding="utf-8"?>
<doc>
    <assembly>
        <name>IronPdf</name>
    </assembly>
    <members>
        <member name="T:IronPdf.NamespaceDoc">
            <summary>
            IronPDF is a.NET library allowing the  generation and manipulation of PDF files in C# and other .Net projects.
            Supports .Net 4 + , .Net Standard 2+,  .Net Core 2+
            </summary>
        </member>
        <member name="T:IronPdf.Installation">
            <summary>
            Global installation and setup preferences for all instances of IronPDF 
            </summary>
        </member>
        <member name="P:IronPdf.Installation.TempFolderPath">
            <summary>
            The temporary folder path which temporary files and rendering engine DLLs will be deployed to where necessary.
            The default location is the system temp folder which is appropriate for most use cases. 
            </summary>
        </member>
        <member name="T:IronPdf.Util">
            <summary>
            Useful methods for working with HTML and PDF files.
            </summary>
        </member>
        <member name="M:IronPdf.Util.ImageToDataUri(System.Drawing.Image,System.Boolean)">
            <summary>
             Turns a System.Drawing.Image or System.Drawing.Bitmap into a DataUri which can used to embed the Image directly into an HTML document.
              <para>Read standard <see href="https://en.wikipedia.org/wiki/Data_URI_scheme">https://en.wikipedia.org/wiki/Data_URI_scheme</see></para></summary>
            <param name="Image">A non-null System.Drawing.Image or System.Drawing.Bitmap</param>
            <param name="Rasterize">Optional flag to flatten the image to raw pixels to increase compatibility with HTML (may affect PDF file size and rendering time)</param>
            <returns> A data URL which can be used as the src attribute of an HTML &lt;img tag</returns>
        </member>
        <member name="T:IronPdf.VersionInfo">
            <exclude />
        </member>
        <member name="P:IronPdf.VersionInfo.IronPdfAssemblyVersion">
            <exclude />
        </member>
        <member name="T:IronPdf.HtmlToPdf">
            <summary>
            IronPdf.HtmlToPdf allows any web page or Html 'snippet' to be turned into a PDF document.
            </summary>
        </member>
        <member name="M:IronPdf.HtmlToPdf.StaticRenderUrlAsPdf(System.Uri,IronPdf.PdfPrintOptions,IronPdf.HttpLoginCredentials)">
            <summary>    Static version of the <see cref="M:IronPdf.HtmlToPdf.RenderUrlAsPdf(System.Uri)" /> function.  Renders all Html and assets at a given Url into a PDF file.</summary>
            <param name="Url">              An absolute Uri.  Points to the Html document to be rendered as a PDF. </param>
            <param name="PrintOptions">     Instance of  <see cref="T:IronPdf.PdfPrintOptions" />. Optional print
                                             options and settings. </param>
            <param name="LoginCredentials"> Instance of  <see cref="T:IronPdf.HttpLoginCredentials" />.
                                             Optional login credentials for Windows, Linux and Html Form
                                             login environments. </param>
            <returns> A <see cref="T:IronPdf.PdfDocument" /></returns>
        </member>
        <member name="M:IronPdf.HtmlToPdf.StaticRenderUrlAsPdf(System.String,IronPdf.PdfPrintOptions,IronPdf.HttpLoginCredentials)">
            <summary>    Static version of the <see cref="M:IronPdf.HtmlToPdf.RenderUrlAsPdf(System.String)" /> function.  Renders all Html and assets at a given Url into a PDF file.</summary>
            <param name="UrlOrPath">        An absolute Url or file path.  Points to the Html document to be rendered as a PDF. </param>
            <param name="PrintOptions">     Instance of  <see cref="T:IronPdf.PdfPrintOptions" />. Optional print
                                             options and settings. </param>
            <param name="LoginCredentials"> Instance of  <see cref="T:IronPdf.HttpLoginCredentials" />.
                                             Optional login credentials for Windows, Linux and Html Form
                                             login environments. </param>
            <returns> A <see cref="T:IronPdf.PdfDocument" /></returns>
        </member>
        <member name="M:IronPdf.HtmlToPdf.StaticRenderHTMLFileAsPdf(System.String,IronPdf.PdfPrintOptions)">
            <summary>   Renders an HTML file as PDF binary data. </summary>
            <param name="FilePath">  Path to an Html file.</param>
            <param name="PrintOptions">     Instance of  <see cref="T:IronPdf.PdfPrintOptions" />. Optional print options and settings. </param>
            <returns>   A <see cref="T:IronPdf.PdfDocument" /></returns>
        </member>
        <member name="M:IronPdf.HtmlToPdf.StaticRenderHtmlAsPdf(System.String,System.String,IronPdf.PdfPrintOptions,System.String)">
            <summary>
                 Static version of the <see cref="M:IronPdf.HtmlToPdf.RenderHtmlAsPdf(System.String,System.String,System.String)" /> function.  Renders any Html strings into a
                 PDF document.
             </summary>
            <param name="Html">     Html to be turned into a PDF. </param>
            <param name="BaseUrlOrPath">  Setting the BaseUrlOrPath property gives the Html a relative for content links such as hyper-links, images, CSS and JavaScript files.</param>
            <param name="PrintOptions">     Instance of  <see cref="T:IronPdf.PdfPrintOptions" />. Optional print options and settings. </param>
            <param name="Proxy"> Specifies an Http proxy server.   Use the pattern: http(s)://user-name:password@host:port/</param>
            <returns> A <see cref="T:IronPdf.PdfDocument" /></returns>
        </member>
        <member name="M:IronPdf.HtmlToPdf.StaticRenderHtmlAsPdf(System.String,System.Uri,IronPdf.PdfPrintOptions,System.String)">
            <summary>
                 Static version of the <see cref="M:IronPdf.HtmlToPdf.RenderHtmlAsPdf(System.String,System.Uri,System.String)" /> function.  Renders any Html strings into a
                 PDF document.
             </summary>
            <param name="Html">     Html to be turned into a PDF. </param>
            <param name="BaseUrl">  Setting the BaseURL property gives the Html a relative for content links such as hyper-links, images, CSS and JavaScript files.</param>
            <param name="PrintOptions">     Instance of  <see cref="T:IronPdf.PdfPrintOptions" />. Optional print options and settings. </param>
            <param name="Proxy"> Specifies an Http proxy server.   Use the pattern: http(s)://user-name:password@host:port/</param>
            <returns> A <see cref="T:IronPdf.PdfDocument" /></returns>
        </member>
        <member name="M:IronPdf.HtmlToPdf.RenderUrlAsPdf(System.Uri)">
            <summary>   Renders the URL as PDF binary data. </summary>
            <param name="Url"> An absolute Uri.  Points to the Html document to be rendered as a PDF. </param>
            <returns>   A <see cref="T:IronPdf.PdfDocument" /></returns>
            <example>
                <code>HtmlToPdf myHtmlToPdf = new IronPdf.HtmlToPdf();
                  Uri  myUri = new Uri("http://www.example.com");
                  myHtmlToPdf.RenderUrlAsPdf(myUri).SaveAs(@"Path\File.Pdf");
                 </code>
            </example>
        </member>
        <member name="M:IronPdf.HtmlToPdf.RenderUrlAsPdf(System.String)">
            <summary>   Renders the URL as PDF binary data. </summary>
            <param name="UrlOrPath"> A url or file path.</param>
            <returns>   A <see cref="T:IronPdf.PdfDocument" /></returns>
        </member>
        <member name="M:IronPdf.HtmlToPdf.RenderHTMLFileAsPdf(System.String)">
            <summary>   Renders an HTML file  as PDF binary data. </summary>
            <param name="FilePath">  Path to an Html file.</param>
            <returns>   A <see cref="T:IronPdf.PdfDocument" /></returns>
        </member>
        <member name="M:IronPdf.HtmlToPdf.RenderHtmlAsPdf(System.String,System.Uri,System.String)">
            <summary>
            Creates a PDF file from an Html string, and returns it as an  IronPdf.PdfDocument
            </summary>
            <param name="Html">The Html to be rendered as a PDF.</param>
            <param name="BaseUrl">Setting the BaseURL property gives the relative context for hyper-links, images, CSS and JavaScript files.</param>
            <param name="Proxy">Specifies an Http proxy server. Use the pattern: http(s)://user-name:password@host:port</param>
            <returns>
            A <see cref="T:IronPdf.PdfDocument" /></returns>
            <example>
                <code>HtmlToPdf myHtmlToPdf = new IronPdf.HtmlToPdf();
            myHtmlToPdf.RenderHtmlAsPdf("&lt;p&gt;html&lt;/p&gt;").SaveAs(@"Path\File.Pdf");
            </code>
            </example>
        </member>
        <member name="M:IronPdf.HtmlToPdf.RenderHtmlAsPdf(System.String,System.String,System.String)">
            <summary>
            Creates a PDF file from an Html string, and returns it as an  IronPdf.PdfDocument
            </summary>
            <param name="Html">The Html to be rendered as a PDF.</param>
            <param name="BaseUrlOrPath">Setting the BaseUrlOrPath property gives the relative context for hyper-links, images, CSS and JavaScript files.</param>
            <param name="Proxy">Specifies an Http proxy server. Use the pattern: http(s)://user-name:password@host:port</param>
            <returns>
            A <see cref="T:IronPdf.PdfDocument" /></returns>
            <example>
                <code>HtmlToPdf myHtmlToPdf = new IronPdf.HtmlToPdf();
            myHtmlToPdf.RenderHtmlAsPdf("&lt;p&gt;html&lt;/p&gt;").SaveAs(@"Path\File.Pdf");
            </code>
            </example>
        </member>
        <member name="F:IronPdf.HtmlToPdf.PrintOptions">
            <summary>
            An instance of the <see cref="T:IronPdf.PdfPrintOptions" />  class.
            Sets PDF output options such as Paper-Size, DPI, Headers and Footers.
            </summary>
        </member>
        <member name="F:IronPdf.HtmlToPdf.LoginCredentials">
            <summary>
             An instance of the <see cref="T:IronPdf.HttpLoginCredentials" />  class.  Allows developers to specify login credentials using  Windows, Linux or Html Forms based authentication.
             This allows PDFs to be printed, even if they reside on private Intranets, Extranets or within 'login' areas of websites.
            
             </summary>
        </member>
        <member name="M:IronPdf.HtmlToPdf.#ctor">
            <summary>
            The IronPdf.HtmlToPdf allows developers to create PDF files from any web page or Html Snippet
            </summary>
        </member>
        <member name="M:IronPdf.HtmlToPdf.#ctor(IronPdf.PdfPrintOptions)">
            <param name="PrintOptions">Sets PDF output options such as paper-size, DPI, headers and footers using an instance of the IronPdf.PdfPrintOptions Class.</param>
        </member>
        <member name="T:IronPdf.AspxToPdf">
            <summary>
                 Renders any .Net Web Page (ASPX) into a PDF Document. Simply add it to  the Page_Load
                 event.
                 
             <para>Not available in .Net Core because ASPX is superseded by the MVC model</para></summary>
        </member>
        <member name="T:IronPdf.AspxToPdf.FileBehavior">
            <summary>
                 Determines the web browser behavior towards a PDF document. 
             </summary>
        </member>
        <member name="F:IronPdf.AspxToPdf.FileBehavior.Attachment">
            <summary>Instructs the user's web-browser to download the PDF as a file.</summary>
        </member>
        <member name="F:IronPdf.AspxToPdf.FileBehavior.InBrowser">
            <summary>Instructs the user's web-browser to render the PDF wherever possible.</summary>
        </member>
        <member name="M:IronPdf.AspxToPdf.RenderThisPageAsPdf(IronPdf.AspxToPdf.FileBehavior,System.String,IronPdf.PdfPrintOptions)">
            <summary>
                 Automatically renders any ASPX page into PDF instead of Html.  Use it in the Page_Load
                 Event.
                   <para>Example:</para><code>protected void Page_Load(object sender, EventArgs e){ 
                   IronPdf.AspxToPdf.RenderThisPageAsPdf(FileBehavior.Attachment, "MyPdf.pdf", new  PdfPrintOptions(){ Dpi = 300 });
                 }
                 </code></summary>
            <param name="PdfBehavior"> Specifies if the PDF file should be downloaded as an attachment,
                                         or displayed directly in the browser of users. </param>
            <param name="PdfFileName">  The file-name of the PDF.  If no name is set, a suitable name
                                         will be automatically assigned chosen based on the Html title,
                                         PrintOptions or name of the ASPX page. </param>
            <param name="PrintOptions"> Sets PDF output options such as PDF Title, paper-size, DPI,
                                         headers and footers. </param>
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.IronDeployment">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IronDeployment.#ctor(System.String)">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.IronDeployment.Deployment_Directory">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.IronDeployment.Deployment_Root">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IronDeployment.deploy">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.IronDeployment.Path">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.CropSettings">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.CropSettings.Top">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.CropSettings.Bottom">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.CropSettings.Width">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.CropSettings.Height">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.FooterSettings">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.FooterSettings.CenterText">
            <summary>
            Sets center text for the header/footer. Following replaces occur in this text:
            * [page]       Replaced by the number of the pages currently being printed
            * [frompage]   Replaced by the number of the first page to be printed
            * [topage]     Replaced by the number of the last page to be printed
            * [webpage]    Replaced by the URL of the page being printed
            * [section]    Replaced by the name of the current section
            * [subsection] Replaced by the name of the current subsection
            * [date]       Replaced by the current date in system local format
            * [time]       Replaced by the current time in system local format
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.FooterSettings.ContentSpacing">
            <summary>
            Amount of space between header/footer and content in millimeters
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.FooterSettings.FontName">
            <summary>
            Font name for the header, e.g. "Courier New"
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.FooterSettings.FontSize">
            <summary>
            The font size in pt
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.FooterSettings.HtmlUrl">
            <summary>
            URL for the HTML document to use as a header
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.FooterSettings.LeftText">
            <summary>
            Sets left text for the header/footer. Following replaces occur in this text:
            * [page]       Replaced by the number of the pages currently being printed
            * [frompage]   Replaced by the number of the first page to be printed
            * [topage]     Replaced by the number of the last page to be printed
            * [webpage]    Replaced by the URL of the page being printed
            * [section]    Replaced by the name of the current section
            * [subsection] Replaced by the name of the current subsection
            * [date]       Replaced by the current date in system local format
            * [time]       Replaced by the current time in system local format
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.FooterSettings.RightText">
            <summary>
            Sets right text for the header/footer. Following replaces occur in this text:
            * [page]       Replaced by the number of the pages currently being printed
            * [frompage]   Replaced by the number of the first page to be printed
            * [topage]     Replaced by the number of the last page to be printed
            * [webpage]    Replaced by the URL of the page being printed
            * [section]    Replaced by the name of the current section
            * [subsection] Replaced by the name of the current subsection
            * [date]       Replaced by the current date in system local format
            * [time]       Replaced by the current time in system local format
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.FooterSettings.UseLineSeparator">
            <summary>
            Whether or not to print a line between the header/footer and content (Default: false)
            </summary>
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.DocumentColorMode">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.DocumentColorMode.Color">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.DocumentColorMode.Grayscale">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.DocumentOutputFormat">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.DocumentOutputFormat.PDF">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.DocumentOutputFormat.PS">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.PaperOrientation">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.PaperOrientation.Portrait">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.PaperOrientation.Landscape">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.ViewportSize">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.Collate">
            <summary>
            Whether to collate the copies. (Default: false)
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.ColorMode">
            <summary>
            Whether to print in color or gray-scale. (Default: color)
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.CookieJar">
            <summary>
            The path of a file used to store cookies.
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.Copies">
            <summary>
            How many copies to print. (Default: 1)
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.DocumentTitle">
            <summary>
            The title of the PDF document.
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.DPI">
            <summary>
            The DPI to use when printing.
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.DumpOutline">
            <summary>
            The path of a file to dump an XML outline of the document to.
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.ImageDPI">
            <summary>
            The maximum DPI to use for images printed in the document.
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.ImageQuality">
            <summary>
            Gets or sets the image quality.
            </summary>
            <value>
            The image quality.
            </value>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.Margins">
            <summary>
            The margins to use throughout the document.
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.Orientation">
            <summary>
            The orientation of the output document, either Portrait or Landscape. (Default: Portrait)
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.OutlineDepth">
            <summary>
            The maximum depth of the outline. (Default: 4)
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.OutputFile">
            <summary>
            A path to output the converted document to.
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.OutputFormat">
            <summary>
            Whether to output PDF or PostScript. (Default: PDF)
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.PageOffset">
            <summary>
            A number that is added to all page numbers when printing headers, footers and table of content.
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.PaperSize">
            <summary>
            The size of the output document.
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.ProduceOutline">
            <summary>
            Whether to generate an outline for the document. (Default: false)
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.UseCompression">
            <summary>
            Whether to use lossless compression when creating the PDF file. (Default: true)
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.PaperHeight">
            <summary>
            The height of the output document, e.g. "12in".
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ChromeRenderingGlobalSettings.PaperWidth">
            <summary>
            The with of the output document, e.g. "4cm".
            </summary>
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.HeaderSettings">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HeaderSettings.CenterText">
            <summary>
            Sets center text for the header/footer. Following replaces occur in this text:
            * [page]       Replaced by the number of the pages currently being printed
            * [frompage]   Replaced by the number of the first page to be printed
            * [topage]     Replaced by the number of the last page to be printed
            * [webpage]    Replaced by the URL of the page being printed
            * [section]    Replaced by the name of the current section
            * [subsection] Replaced by the name of the current subsection
            * [date]       Replaced by the current date in system local format
            * [time]       Replaced by the current time in system local format
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HeaderSettings.ContentSpacing">
            <summary>
            Amount of space between header/footer and content in millimeters
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HeaderSettings.FontName">
            <summary>
            Font name for the header, e.g. "Courier New"
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HeaderSettings.FontSize">
            <summary>
            The font size in pt
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HeaderSettings.HtmlUrl">
            <summary>
            URL for the HTML document to use as a header
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HeaderSettings.LeftText">
            <summary>
            Sets left text for the header/footer. Following replaces occur in this text:
            * [page]       Replaced by the number of the pages currently being printed
            * [frompage]   Replaced by the number of the first page to be printed
            * [topage]     Replaced by the number of the last page to be printed
            * [webpage]    Replaced by the URL of the page being printed
            * [section]    Replaced by the name of the current section
            * [subsection] Replaced by the name of the current subsection
            * [date]       Replaced by the current date in system local format
            * [time]       Replaced by the current time in system local format
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HeaderSettings.UseLineSeparator">
            <summary>
            Whether or not to print a line between the header/footer and content (Default: false)
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HeaderSettings.RightText">
            <summary>
            Sets right text for the header/footer. Following replaces occur in this text:
            * [page]       Replaced by the number of the pages currently being printed
            * [frompage]   Replaced by the number of the first page to be printed
            * [topage]     Replaced by the number of the last page to be printed
            * [webpage]    Replaced by the URL of the page being printed
            * [section]    Replaced by the name of the current section
            * [subsection] Replaced by the name of the current subsection
            * [date]       Replaced by the current date in system local format
            * [time]       Replaced by the current time in system local format
            </summary>
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.HtmlToImageDocument">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToImageDocument.ScreenHeight">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToImageDocument.ScreenWidth">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToImageDocument.Quality">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToImageDocument.Format">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToImageDocument.Out">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToImageDocument.In">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToImageDocument.Transparent">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToImageDocument.CropSettings">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToImageDocument.LoadSettings">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToImageDocument.WebSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.HtmlToImageDocument.GetObjects">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.HtmlToPdfDocument">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.HtmlToPdfDocument.#ctor">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.HtmlToPdfDocument.#ctor(System.String)">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToPdfDocument.Objects">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.HtmlToPdfDocument.GetObjects">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.HtmlToPdfDocument.GlobalSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.HtmlToPdfDocument.op_Implicit(System.String)~IronPdf.ThreadSaftyManager.HtmlToPdfDocument">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.NamespaceDoc">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.LoadSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.LoadSettings.#ctor">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.LoadSettings.ContentErrorHandling">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.LoadSettings.ContentErrorHandling.Abort">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.LoadSettings.ContentErrorHandling.Skip">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.LoadSettings.ContentErrorHandling.Ignore">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.BlockLocalFileAccess">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.Cookies">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.CustomHeaders">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.DebugJavascript">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.ErrorHandling">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.Password">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.PostItems">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.Proxy">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.RenderDelay">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.RepeatCustomHeaders">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.StopSlowScript">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.Username">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.WindowStatus">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.LoadSettings.ZoomFactor">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.MarginSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.MarginSettings.#ctor">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.MarginSettings.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.MarginSettings.Bottom">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.MarginSettings.Left">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.MarginSettings.Right">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.MarginSettings.Top">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.MarginSettings.All">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.MarginSettings.Unit">
            <summary>
            Defaults to Inches.
            </summary>
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ObjectSettings">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.IncludeInOutline">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.CountPages">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.PageUrl">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.ProduceForms">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.ProduceExternalLinks">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.ProduceLocalLinks">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.FooterSettings">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.HeaderSettings">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.HtmlText">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.LoadSettings">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.RawData">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ObjectSettings.WebSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ObjectSettings.GetData">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ObjectSettings.op_Implicit(System.String)~IronPdf.ThreadSaftyManager.ObjectSettings">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.PkPaperSize">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.PkPaperSize.#ctor(System.String,System.String)">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.PkPaperSize.Height">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.PkPaperSize.Width">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.PkPaperSize.op_Implicit(System.Drawing.Printing.PaperKind)~IronPdf.ThreadSaftyManager.PkPaperSize">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.PostItem">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.PostItem.Name">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.PostItem.Value">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.PostItem.IsFile">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.Unit">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.Unit.Inches">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.Unit.Millimeters">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.Unit.Centimeters">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.WebSettings">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WebSettings.DefaultEncoding">
            <summary>
            What encoding should we guess content is using if they do not specify it properly? E.g. "utf-8"
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WebSettings.EnableIntelligentShrinking">
            <summary>
            Whether or not to enable intelligent compression of content to fit in the page
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WebSettings.EnableJavascript">
            <summary>
            Whether or not to enable JavaScript
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WebSettings.EnablePlugins">
            <summary>
            Whether to enable plugins (maybe like Flash? unsure)
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WebSettings.LoadImages">
            <summary>
            Whether or not to load images
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WebSettings.MinimumFontSize">
            <summary>
            The minimum font size to use
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WebSettings.PrintBackground">
            <summary>
            Whether or not to print the background on elements
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WebSettings.PrintMediaType">
            <summary>
            Whether to print the content using the print media type instead of the screen media type
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WebSettings.UserStyleSheet">
            <summary>
            Path to a user specified style sheet
            </summary>
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.EmbeddedDeployment">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.EmbeddedDeployment.Path">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.EmbeddedDeployment.#ctor(IronPdf.ThreadSaftyManager.IDeployment)">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.EmbeddedDeployment.physical">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.EmbeddedDeployment.GetContents">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.BeginEventArgs">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.BeginEventArgs.Document">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.BeginEventArgs.ExpectedPhaseCount">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ErrorEventArgs">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ErrorEventArgs.Document">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ErrorEventArgs.ErrorMessage">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.FinishEventArgs">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.FinishEventArgs.Document">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.FinishEventArgs.Success">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.PhaseChangeEventArgs">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.PhaseChangeEventArgs.Document">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.PhaseChangeEventArgs.PhaseNumber">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.PhaseChangeEventArgs.PhaseDescription">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ProgressChangeEventArgs">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ProgressChangeEventArgs.Document">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ProgressChangeEventArgs.Progress">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ProgressChangeEventArgs.ProgressDescription">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.WarningEventArgs">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WarningEventArgs.Document">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WarningEventArgs.WarningMessage">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ImageToolset">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.ImageToolset.Unloaded">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ImageToolset.Deployment">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.ImageToolset.Loaded">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.#ctor">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.#ctor(IronPdf.ThreadSaftyManager.IDeployment)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.Load(IronPdf.ThreadSaftyManager.IDeployment)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.Unload">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.InitializeLifetimeService">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.CreateGlobalSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.CreateObjectSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.SetGlobalSetting(System.IntPtr,System.String,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.GetGlobalSetting(System.IntPtr,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.SetObjectSetting(System.IntPtr,System.String,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.GetObjectSetting(System.IntPtr,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.CreateConverter(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.DestroyConverter(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.SetWarningCallback(System.IntPtr,IronPdf.ThreadSaftyManager.StringCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.SetErrorCallback(System.IntPtr,IronPdf.ThreadSaftyManager.StringCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.SetFinishedCallback(System.IntPtr,IronPdf.ThreadSaftyManager.IntCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.SetPhaseChangedCallback(System.IntPtr,IronPdf.ThreadSaftyManager.VoidCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.SetProgressChangedCallback(System.IntPtr,IronPdf.ThreadSaftyManager.IntCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.PerformConversion(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.AddObject(System.IntPtr,System.IntPtr,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.AddObject(System.IntPtr,System.IntPtr,System.Byte[])">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.GetPhaseNumber(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.GetPhaseCount(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.GetPhaseDescription(System.IntPtr,System.Int32)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.GetProgressDescription(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.GetHttpErrorCode(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ImageToolset.GetConverterResult(System.IntPtr)">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.IConverter">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IConverter.Convert(IronPdf.ThreadSaftyManager.IDocument)">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.IConverter.Begin">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.IConverter.Warning">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.IConverter.Error">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.IConverter.PhaseChange">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.IConverter.ProgressChange">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.IConverter.Finish">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.IDeployment">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.IDeployment.Path">
            <summary>
            Represent a path to a folder that contains the wkhtmltox.dll 
            library and any dependencies it may have.
            </summary>
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.IDocument">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IDocument.GetObjects">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.IObject">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IObject.GetData">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ISettings">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.IToolset">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.Load(IronPdf.ThreadSaftyManager.IDeployment)">
            <summary>
            Loads the toolset's deployment from its path. It must behave importantly,
            performing no operation if the deployment is already loaded.
            </summary>
            <param name="deployment">
            Optionally supplies a specific deployment to be used.
            </param>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.IToolset.Loaded">
            <summary>
            Gets whether the toolset's deployment has been loaded.
            </summary>
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.Unload">
            <summary>
            Unloads the toolset's deployment.
            </summary>
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.IToolset.Unloaded">
            <summary>
            Fires when the toolset's deployment is unloaded.
            </summary>
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.IToolset.Deployment">
            <summary>
            The deployment loaded by (or to be loaded by) the toolset.
            </summary>
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.AddObject(System.IntPtr,System.IntPtr,System.Byte[])">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.AddObject(System.IntPtr,System.IntPtr,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.CreateConverter(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.CreateGlobalSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.CreateObjectSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.DestroyConverter(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.GetConverterResult(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.GetGlobalSetting(System.IntPtr,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.GetHttpErrorCode(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.GetObjectSetting(System.IntPtr,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.GetPhaseCount(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.GetPhaseDescription(System.IntPtr,System.Int32)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.GetPhaseNumber(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.GetProgressDescription(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.PerformConversion(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.SetErrorCallback(System.IntPtr,IronPdf.ThreadSaftyManager.StringCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.SetFinishedCallback(System.IntPtr,IronPdf.ThreadSaftyManager.IntCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.SetGlobalSetting(System.IntPtr,System.String,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.SetObjectSetting(System.IntPtr,System.String,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.SetPhaseChangedCallback(System.IntPtr,IronPdf.ThreadSaftyManager.VoidCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.SetProgressChangedCallback(System.IntPtr,IronPdf.ThreadSaftyManager.IntCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.IToolset.SetWarningCallback(System.IntPtr,IronPdf.ThreadSaftyManager.StringCallback)">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.NestingToolset">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.NestingToolset.Unloaded">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.NestingToolset.BeforeUnload">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.NestingToolset.Deployment">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.NestingToolset.Loaded">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.NestingToolset.NestedToolset">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.Load(IronPdf.ThreadSaftyManager.IDeployment)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.Unload">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.InitializeLifetimeService">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.OnBeforeUnload(System.Object)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.AddObject(System.IntPtr,System.IntPtr,System.Byte[])">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.AddObject(System.IntPtr,System.IntPtr,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.CreateConverter(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.CreateGlobalSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.CreateObjectSettings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.DestroyConverter(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.GetConverterResult(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.GetGlobalSetting(System.IntPtr,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.GetHttpErrorCode(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.GetObjectSetting(System.IntPtr,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.GetPhaseCount(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.GetPhaseDescription(System.IntPtr,System.Int32)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.GetPhaseNumber(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.GetProgressDescription(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.PerformConversion(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.SetErrorCallback(System.IntPtr,IronPdf.ThreadSaftyManager.StringCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.SetFinishedCallback(System.IntPtr,IronPdf.ThreadSaftyManager.IntCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.SetGlobalSetting(System.IntPtr,System.String,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.SetObjectSetting(System.IntPtr,System.String,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.SetPhaseChangedCallback(System.IntPtr,IronPdf.ThreadSaftyManager.VoidCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.SetProgressChangedCallback(System.IntPtr,IronPdf.ThreadSaftyManager.IntCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.NestingToolset.SetWarningCallback(System.IntPtr,IronPdf.ThreadSaftyManager.StringCallback)">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.RemotingToolset`1">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.RemotingToolset`1.#ctor(IronPdf.ThreadSaftyManager.IDeployment)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.RemotingToolset`1.Load(IronPdf.ThreadSaftyManager.IDeployment)">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.RemotingToolset`1.Unloaded">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.RemotingToolset`1.Unload">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.StandardConverter">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.StandardConverter.Toolset">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.StandardConverter.ProcessingDocument">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.StandardConverter.#ctor(IronPdf.ThreadSaftyManager.IToolset)">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.StandardConverter.Begin">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.StandardConverter.Error">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.StandardConverter.Finish">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.StandardConverter.PhaseChange">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.StandardConverter.ProgressChange">
            <exclude />
        </member>
        <member name="E:IronPdf.ThreadSaftyManager.StandardConverter.Warning">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.StandardConverter.Convert(IronPdf.ThreadSaftyManager.IDocument)">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.StaticDeployment">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.StaticDeployment.Path">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.StaticDeployment.#ctor(System.String)">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ThreadSafeConverter">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ThreadSafeConverter.#ctor(IronPdf.ThreadSaftyManager.IToolset)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ThreadSafeConverter.Convert(IronPdf.ThreadSaftyManager.IDocument)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ThreadSafeConverter.Invoke``1(IronPdf.ThreadSaftyManager.FuncShim{``0})">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.ThreadSafeConverter.Invoke(IronPdf.ThreadSaftyManager.ActionShim)">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.IntCallback">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.FuncShim`1">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.FuncShim`3">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.ActionShim">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.StringCallback">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.Utf8Marshaler">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.Utf8Marshaler.MarshalManagedToNative(System.Object)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.Utf8Marshaler.MarshalNativeToManaged(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.Utf8Marshaler.CleanUpNativeData(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.Utf8Marshaler.CleanUpManagedData(System.Object)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.Utf8Marshaler.GetNativeDataSize">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.Utf8Marshaler.GetInstance(System.String)">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.VoidCallback">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.WkhtmltoxBindings">
            <exclude />
        </member>
        <member name="F:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.DLLNAME">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_add_object(System.IntPtr,System.IntPtr,System.String)">
            <exclude />
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_add_object(System.IntPtr,System.IntPtr,System.Byte[])">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_convert(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_create_converter(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_create_global_settings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_create_object_settings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_current_phase(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_deinit">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_destroy_converter(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_extended_qt">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_get_global_setting(System.IntPtr,System.String,System.Byte*,System.Int32)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_get_object_setting(System.IntPtr,System.String,System.Byte*,System.Int32)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_get_output(System.IntPtr,System.IntPtr@)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_http_error_code(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_init(System.Int32)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_phase_count(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_phase_description(System.IntPtr,System.Int32)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_progress_string(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_set_error_callback(System.IntPtr,IronPdf.ThreadSaftyManager.StringCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_set_finished_callback(System.IntPtr,IronPdf.ThreadSaftyManager.IntCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_set_global_setting(System.IntPtr,System.String,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_set_object_setting(System.IntPtr,System.String,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_set_phase_changed_callback(System.IntPtr,IronPdf.ThreadSaftyManager.VoidCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_set_progress_changed_callback(System.IntPtr,IronPdf.ThreadSaftyManager.IntCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltopdf_set_warning_callback(System.IntPtr,IronPdf.ThreadSaftyManager.StringCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_convert(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_create_converter(System.IntPtr,System.Byte[])">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_create_global_settings">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_current_phase(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_deinit">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_destroy_converter(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_extended_qt">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_get_global_setting(System.IntPtr,System.String,System.Byte*,System.Int32)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_get_output(System.IntPtr,System.IntPtr@)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_http_error_code(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_init(System.Int32)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_phase_count(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_phase_description(System.IntPtr,System.Int32)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_progress_string(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_set_error_callback(System.IntPtr,IronPdf.ThreadSaftyManager.StringCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_set_finished_callback(System.IntPtr,IronPdf.ThreadSaftyManager.IntCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_set_global_setting(System.IntPtr,System.String,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_set_phase_changed_callback(System.IntPtr,IronPdf.ThreadSaftyManager.VoidCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_set_progress_changed_callback(System.IntPtr,IronPdf.ThreadSaftyManager.IntCallback)">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxBindings.wkhtmltoimage_set_warning_callback(System.IntPtr,IronPdf.ThreadSaftyManager.StringCallback)">
            <exclude />
        </member>
        <member name="T:IronPdf.ThreadSaftyManager.WkhtmltoxSettingAttribute">
            <exclude />
        </member>
        <member name="P:IronPdf.ThreadSaftyManager.WkhtmltoxSettingAttribute.Name">
            <exclude />
        </member>
        <member name="M:IronPdf.ThreadSaftyManager.WkhtmltoxSettingAttribute.#ctor(System.String)">
            <exclude />
        </member>
        <member name="T:IronPdf.HtmlHeaderFooter">
            <summary>
            A Html Header or Footer which will be printed onto every page of the PDF.    This can be used to override <see cref="F:IronPdf.PdfPrintOptions.Header" /> and <see cref="F:IronPdf.PdfPrintOptions.Footer" /><para>When using HtmlHeaderFooter it is important to set <see cref="F:IronPdf.HtmlHeaderFooter.HtmlFragment" /> and <see cref="F:IronPdf.HtmlHeaderFooter.Height" /></para><para> Merge meta-data into your html using any of these placeholder strings: {page} {total-pages} {url} {date} {time} {html-title} {pdf-title}</para></summary>
            <seealso cref="F:IronPdf.PdfPrintOptions.Header" />
            <seealso cref="F:IronPdf.PdfPrintOptions.Footer" />
        </member>
        <member name="F:IronPdf.HtmlHeaderFooter.LeftText">
            <exclude />
        </member>
        <member name="F:IronPdf.HtmlHeaderFooter.CenterText">
            <exclude />
        </member>
        <member name="F:IronPdf.HtmlHeaderFooter.RightText">
            <exclude />
        </member>
        <member name="M:IronPdf.HtmlHeaderFooter.Clone">
            <summary>
            Clones this instance.
            </summary>
            <returns>System.Object of type HtmlHeaderFooter</returns>
        </member>
        <member name="F:IronPdf.HtmlHeaderFooter.Height">
            <summary>
            Height of the Html Header / Footer in millimeters.  This value must be set sufficiently high to display the full html header / footer content.
            </summary>
        </member>
        <member name="F:IronPdf.HtmlHeaderFooter.HtmlFragment">
            <summary>
             The Html which will be use to render the Header / Footer.  Should be  an HTML snippet rather than a complete document.  May contain styles &amp; images.
             <para> Merge meta-data into the HtmlFragment by putting any of these placeholder strings into the text: {page} {total-pages} {url} {date} {time} {html-title} {pdf-title}.  An alternative mail-merge style using the pattern &lt;span class='total-pages'&gt;&lt;/span&gt; also workd</para><para>HtmlFragment is a stand alone HTML document which does not inherit styles or settings from your main HTML content unless <see cref="F:IronPdf.HtmlHeaderFooter.LoadStylesAndCSSFromMainHtmlDocument" /> is set <c>true</c></para></summary>
        </member>
        <member name="F:IronPdf.HtmlHeaderFooter.BaseUrl">
            <summary>
            The Base URL all URLS in the <see cref="F:IronPdf.HtmlHeaderFooter.HtmlFragment">HtmlFragment</see> will be relative to.
            This includes 'src' attributes on images, scripts, style-sheets and also hrefs on hyper-links.
            </summary>
        </member>
        <member name="F:IronPdf.HtmlHeaderFooter.LoadStylesAndCSSFromMainHtmlDocument">
            <summary>
            Loads style code blocks and links to CSS style sheets from the main HTML document (which provides the PDF content) into the <see cref="T:IronPdf.HtmlHeaderFooter" /> .
            <para>By default, Html Headers and Footers are stand-alone HTML documents with their own default styles.  Setting <see cref="F:IronPdf.HtmlHeaderFooter.LoadStylesAndCSSFromMainHtmlDocument" /> to <c>true</c> will attempt to load all STYLE and LINK tags from the main HTML document (which renders teh PDF) into the <see cref="T:IronPdf.HtmlHeaderFooter" />.</para><para>If your main HTML document contains complex CSS frameworks,  styles the HEAD or BODY element heavily or loads CSS from javascript then this method may not work as intended.</para><para>This feature is not available for <see cref="M:IronPdf.HtmlToPdf.RenderUrlAsPdf(System.String)" /> and other RenderUrlAsPdf methods.  It works for HTMLToPdf and HtmlFileToPdf conversions only. </para><para>It is often preferable to load style sheets explicitly into your HTML Headers and Footers as STYLE and LINK tags within the <see cref="F:IronPdf.HtmlHeaderFooter.HtmlFragment" /> for granular control</para></summary>
        </member>
        <member name="T:IronPdf.PDFHeaderFooter">
            <exclude />
        </member>
        <member name="T:IronPdf.SimpleHeaderFooter">
            <summary>
            Defines PDF Header and Footer display options.
            </summary>
        </member>
        <member name="M:IronPdf.SimpleHeaderFooter.Clone">
            <summary>
            Clones this instance.
            </summary>
            <returns>System.Object of type SimpleHeaderFooter</returns>
        </member>
        <member name="F:IronPdf.SimpleHeaderFooter.LeftText">
            <summary>
            Sets the left hand side header text for the PDF document.
            <para> Merge meta-data into your header using any of these placeholder strings: {page} {total-pages} {url} {date} {time} {html-title} {pdf-title}</para></summary>
        </member>
        <member name="F:IronPdf.SimpleHeaderFooter.CenterText">
            <summary>
            Sets the centered header text for the PDF document.
            <para> Merge meta-data into your header using any of these placeholder strings: {page} {total-pages} {url} {date} {time} {html-title} {pdf-title}</para></summary>
        </member>
        <member name="F:IronPdf.SimpleHeaderFooter.RightText">
            <summary>
            Sets the right hand side header text for the PDF document.
            <para> Merge meta-data into your header using any of these placeholder strings: {page} {total-pages} {url} {date} {time} {html-title} {pdf-title}</para></summary>
        </member>
        <member name="F:IronPdf.SimpleHeaderFooter.FontFamily">
            <summary>
             Font used to render the PDF header.
            </summary>
        </member>
        <member name="F:IronPdf.SimpleHeaderFooter.FontSize">
            <summary>
             Font size in px.
            </summary>
        </member>
        <member name="F:IronPdf.SimpleHeaderFooter.DrawDividerLine">
            <summary>
            Adds a horizontal line divider between the header / footer and the page content on every page of the PDF document.
            </summary>
        </member>
        <member name="F:IronPdf.SimpleHeaderFooter.Spacing">
            <summary>
            Space between the header and page content in millimeters.
            </summary>
        </member>
        <member name="T:IronPdf.HttpLoginCredentials">
            <summary>   Provides credentials for IronPdf to log-in to an intranet, extranet or website, impersonating a user.  
                         This allows a unique ability to render web-pages as PDFs even on secure intranets, extranets and websites.            
                         </summary>
        </member>
        <member name="F:IronPdf.HttpLoginCredentials.NetworkUsername">
            <summary>
            Optional: User-name credential for Windows / Linux network security authentication.
            </summary>
        </member>
        <member name="F:IronPdf.HttpLoginCredentials.NetworkPassword">
            <summary>
            Optional: Password credential for Windows / Linux network security authentication.
            </summary>
        </member>
        <member name="P:IronPdf.HttpLoginCredentials.UserAgent">
            <summary>
            The Http User-Agent header which will be used to fetch any remote HTML.
            </summary>
        </member>
        <member name="F:IronPdf.HttpLoginCredentials.LoginFormUrl">
            <summary>
             Optional:  Gives the URL to post website login-form authentication.  Should be the absolute Url which the form's action attribute specifies.
            </summary>
        </member>
        <member name="F:IronPdf.HttpLoginCredentials.LoginFormPostVariables">
            <summary>
             Optional:  Specifies a collection of HTTP form variables to post/submit to <see cref="F:IronPdf.HttpLoginCredentials.LoginFormUrl" />.  
            </summary>
        </member>
        <member name="F:IronPdf.HttpLoginCredentials.CustomPostVariables">
            <summary>
             Optional:  Specifies a collection of HTTP 'POST' variables to submit on every PDF rendering request.  
             <para>Note: The 'key' is the name of the post field, The 'value' is its value.  UrlEncoding is not required.</para><para>Note: Not implemented in .Net Core.</para></summary>
        </member>
        <member name="F:IronPdf.HttpLoginCredentials.CustomPostFiles">
            <summary>
             Optional, Advanced Usage:  Specifies a collection files to summited on every PDF rendering request.  Allows images and documents to be submitted to forms such that the output will be rendered as an PDF.
              <para>Note: The Key is the name of the post field, The value is the full file path.. UrlEncoding is not required.</para></summary>
        </member>
        <member name="F:IronPdf.HttpLoginCredentials.CustomCookies">
            <summary>
            A Dictionary which allows custom cookies to be posted with every login request, and HTTP request made by RenderUriToHml methods.
            </summary>
        </member>
        <member name="F:IronPdf.HttpLoginCredentials.EnableCookies">
            <summary>
            Enables cookies to be stored and sent when using RenderUriToHml methods.
            </summary>
        </member>
        <member name="F:IronPdf.HttpLoginCredentials.Proxy">
            <summary>e
            Specifies an Http proxy server.   Use the pattern: http(s)://user-name:password@host:port/
            </summary>
        </member>
        <member name="F:IronPdf.HttpLoginCredentials.CustomHttpHeaders">
            <summary>
            A dictionary of custom HTTP headers to be sent with every HTTP Request
            </summary>
        </member>
        <member name="M:IronPdf.HttpLoginCredentials.Finalize">
            <summary>
            Destructor cleans up all temporary cookies files for the  HttpLoginCredentials instance.
            </summary>
        </member>
        <member name="T:IronPdf.ImageToPdfConverter">
            <summary>
             The ImageToPdfConveter class can be used to create PDF documents from images.  It accepts both image files and <see cref="T:System.Drawing.Image" /> objects as input.
             <para> The ImageToPdf static methods create simple PDF documents containing each image as one page of the created PDF.</para><para> To rasterize PDF documents as images (the reverse operation), see <see cref="M:IronPdf.PdfDocument.ToBitmap(System.Int32)" /> and <see cref="M:IronPdf.PdfDocument.RasterizeToImageFiles(System.String,IronPdf.ImageType,System.Int32)" /></para></summary>
        </member>
        <member name="M:IronPdf.ImageToPdfConverter.ImageToPdf(System.String)">
            <summary>
            Converts a single image file to an identical PDF document of matching dimensions. 
            </summary>
            <param name="ImageFileName">File path of the image file.</param>
            <returns>
            Returns a <see cref="T:IronPdf.PdfDocument" /> document which can then be edited, saved or served over the web.
            </returns>
        </member>
        <member name="M:IronPdf.ImageToPdfConverter.ImageToPdf(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Converts multiple image files to a PDF document.  Each image creates 1 page which matches the image dimensions.
            </summary>
            <param name="ImageFileNames">The image file path names.</param>
            <returns>
            Returns a <see cref="T:IronPdf.PdfDocument" /> document which can then be edited, saved or served over the web.
            </returns>
        </member>
        <member name="M:IronPdf.ImageToPdfConverter.ImageToPdf(System.Drawing.Image)">
            <summary>
            Converts a single <see cref="T:System.Drawing.Image" /> object or Bitmap to a PDF document of matching dimensions.
            </summary>
            <param name="Image">The image object.   Requires a project reference to the System.Drawing Assembly.</param>
            <returns>
            Returns a <see cref="T:IronPdf.PdfDocument" /> document which can then be edited, saved or served over the web.
            </returns>
        </member>
        <member name="M:IronPdf.ImageToPdfConverter.ImageToPdf(System.Collections.Generic.IEnumerable{System.Drawing.Image})">
            <summary>
            Converts multiple  <see cref="T:System.Drawing.Image" /> objects or Bitmaps  into a PDF document.  Each image creates 1 page which matches the image dimensions.
            </summary>
            <param name="Images">The image objects.   Requires a project reference to the System.Drawing Assembly.</param>
            <returns>
            Returns a <see cref="T:IronPdf.PdfDocument" /> document which can then be edited, saved or served over the web.
            </returns>
        </member>
        <member name="T:IronPdf.Lic">
            <summary />
        </member>
        <member name="M:IronPdf.Lic.Split(System.String,System.Char)">
            <exclude />
        </member>
        <member name="M:IronPdf.Lic.Validate(System.String[],System.String)">
            <exclude />
        </member>
        <member name="T:IronPdf.PdfDocument">
            <summary>
            A PDF Document
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.BookMarks">
            <summary>
            An PdfOutline object allowing developers to add, edit  and remove navigational bookmarks from PDF documents.
            </summary>
        </member>
        <member name="M:IronPdf.PdfDocument.AddTextAnnotation(IronPdf.PdfDocument.TextAnnotation,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds an annotation to a page of this <see cref="T:IronPdf.PdfDocument" /></summary>
            <param name="TextAnnotation">The annotation as a <see cref="T:IronPdf.PdfDocument.TextAnnotation" /> object.</param>
            <param name="PageIndex">Index of the page to add the annotation. The first page has a PageIndex of 0</param>
            <param name="X">The horizontal X position of the annotation on your page in pixels</param>
            <param name="Y">The vertical Y position of the annotation on your page in pixels.  Measured from top downwards.</param>
            <param name="Width">The width of your annotation's icon and interactive area in pixels</param>
            <param name="Height">The height of your annotation's icon and interactive area in pixels</param>
        </member>
        <member name="M:IronPdf.PdfDocument.AddTextAnnotation(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,IronPdf.PdfDocument.TextAnnotation.AnnotationIcon,System.Boolean,System.Boolean,System.Boolean,System.String,System.Double)">
            <summary>
            Adds an annotation to a page of this <see cref="T:IronPdf.PdfDocument" /></summary>
            <param name="Title">The title of the annotation</param>
            <param name="Subject">The subject or 'subheading' of the annotation</param>
            <param name="Contents">The text content of the annotation</param>
            <param name="PageIndex">Index of the page to add the annotation. The first page has a PageIndex of 0</param>
            <param name="X">The horizontal X position of the annotation on your page in pixels</param>
            <param name="Y">The vertical Y position of the annotation on your page in pixels.  Measured from top downwards.</param>
            <param name="Width">The width of your annotation's icon and interactive area in pixels</param>
            <param name="Height">The height of your annotation's icon and interactive area in pixels</param>
            <param name="Icon">The icon used to display the interactive annotation within the PDF</param>
            <param name="Open">Sets the annotation to be opened and readable by default, without user interaction</param>
            <param name="ReadOnly">Makes the annotation non user editable</param>
            <param name="Printable">Makes the annotation render during user PDF printing operations</param>
            <param name="RgbColor">Color of the annotation's background 'sticky note' using Html color notation.  E.g. '#FFFF33'.</param>
            <param name="Opacity">The opacity of the annotation (valid values are from 0.0 to 1.0)</param>
        </member>
        <member name="T:IronPdf.PdfDocument.TextAnnotation">
            <summary>
            Defines a Sticky-Note style PDF annotation.
            <seealso cref="M:IronPdf.PdfDocument.AddTextAnnotation(IronPdf.PdfDocument.TextAnnotation,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" /></summary>
        </member>
        <member name="T:IronPdf.PdfDocument.TextAnnotation.AnnotationIcon">
            <summary>
            Icons used to interact with (open/close) the annotation with the PDF page.
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.AnnotationIcon.NoIcon">
            <summary>
            No icon, this is useful when an annotation will be signified by an existing graphic or object.
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.AnnotationIcon.Comment">
            <summary>
            A Comment Icon
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.AnnotationIcon.Help">
            <summary>
            A Help Icon
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.AnnotationIcon.Insert">
            <summary>
            An 'Insert' Icon
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.AnnotationIcon.Key">
            <summary>
            A Key Icon
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.AnnotationIcon.NewParagraph">
            <summary>
            A New Paragraph Icon
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.AnnotationIcon.Note">
            <summary>
            A Note Icon
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.AnnotationIcon.Paragraph">
            <summary>
            A 'Paragraph of Text' Icon
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.Title">
            <summary>
            The main title of the annotation as displayed in the header of the 'sticky note'
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.Subject">
            <summary>
            The sub title of the annotation as displayed in the header of the 'sticky note'
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.Contents">
            <summary>
            The contents of the 'sticky note' annotation
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.Icon">
            <summary>
            An icon to visually represent the 'sticky note' annotation
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.Opacity">
            <summary>
              The opacity of the annotation (valid values are from 0.0 to 1.0) 
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.OpenByDefault">
            <summary>
            Sets the annotation to be opened and readable by default, without user interaction
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.Hidden">
            <summary>
            Hides the annotation from users
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.Rotateable">
            <summary>
            Allows the annotation to be rotated.  E.g.  when the containing page os rotated 
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.Printable">
            <summary>
            Allows the annotation to be printed when users print the PDF
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.ReadOnly">
            <summary>
            Allows the annotation to be printed when users print the PDF
            </summary>
        </member>
        <member name="M:IronPdf.PdfDocument.TextAnnotation.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this annotation.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="F:IronPdf.PdfDocument.TextAnnotation.Color">
            <summary>
            The color of the annotation's 'Sticky Note'
            </summary>
        </member>
        <member name="P:IronPdf.PdfDocument.Form">
            <summary>
            Gets an object returning any PDF editable form fields which can have their values both read and set programmatically.
            </summary>
            <value>
            The form.
            </value>
        </member>
        <member name="M:IronPdf.PdfDocument.AddHeaders(IronPdf.SimpleHeaderFooter,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Renders page headers to an existing PDF File
            <para>Margin spacing on the PDF page for the header are set to default values of 25mm. An overload method allow header margins to be chosen specifically or set to zero.</para></summary>
            <param name="Header">An new instance of IronPdf.SimpleHeaderFooter that defines the header content and layout.</param>
            <param name="SkipFirstPage">if set to <c>true</c>, the first (cover) page is not counted or stamped with a header.</param>
            <param name="PageIndexesToAddHeadersTo">Optional.  The PageIndexes (zero-based page numbers) to which the header will be added.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddHeaders(IronPdf.SimpleHeaderFooter,System.Double,System.Double,System.Double,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Renders page headers to an existing PDF File
            </summary>
            <param name="Header">An new instance of IronPdf.SimpleHeaderFooter that defines the header content and layout.</param>
            <param name="MarginLeft">The left margin of the header on the page in mm.</param>
            <param name="MarginRight">The right margin of the header on the page in mm.</param>
            <param name="MarginTop">The top margin of the header on the page in mm.</param>
            <param name="SkipFirstPage">if set to <c>true</c>, the first (cover) page is not counted or stamped with a header.</param>
            <param name="PageIndexesToAddHeadersTo">Optional.  The PageIndexes (zero-based page numbers) to which the header will be added.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddFooters(IronPdf.SimpleHeaderFooter,System.Double,System.Double,System.Double,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Renders page footers to an existing PDF File
            </summary>
            <param name="Footer">An new instance of IronPdf.SimpleHeaderFooter that defines the footer content and layout.</param>
            <param name="MarginLeft">The left margin of the footer on the page in mm.</param>
            <param name="MarginRight">The right margin of the footer on the page in mm.</param>
            <param name="MarginBottom">The bottom margin of the footer on the page in mm.</param>
            <param name="SkipFirstPage">if set to <c>true</c>, the first (cover) page is not counted or stamped with a footer.</param>
            <param name="PageIndexesToAddFootersTo">Optional.  The PageIndexes (zero-based page numbers) to which the footer will be added.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddFooters(IronPdf.SimpleHeaderFooter,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Renders page footers to an existing PDF File
            <para>Margin spacing on the PDF page for the footer are set to default values of 25mm. An overload method allow footer margins to be chosen specifically or set to zero.</para></summary>
            <param name="Footer">An new instance of IronPdf.SimpleHeaderFooter that defines the footer content and layout.</param>
            <param name="SkipFirstPage">if set to <c>true</c>, the first (cover) page is not counted or stamped with a footer.</param>
            <param name="PageIndexesToAddFootersTo">Optional.  The PageIndexes (zero-based page numbers) to which the footer will be added.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddHTMLHeaders(IronPdf.HtmlHeaderFooter,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Renders HTML page headers to an existing PDF File
            <para>Margin spacing on the PDF page for the header are set to default values of 25mm. An overload method allow header margins to be chosen specifically or set to zero.</para></summary>
            <param name="Header">An new instance of IronPdf.HtmlHeaderFooter that defines the header content and layout.</param>
            <param name="SkipFirstPage">if set to <c>true</c>, the first (cover) page is not counted or stamped with a header.</param>
            <param name="PageIndexesToAddHeadersTo">Optional.  The PageIndexes (zero-based page numbers) to which the header will be added.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddHTMLHeaders(IronPdf.HtmlHeaderFooter,System.Double,System.Double,System.Double,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Renders HTML page headers to an existing PDF File
            </summary>
            <param name="Header">An new instance of IronPdf.HtmlHeaderFooter that defines the header content and layout.</param>
            <param name="MarginLeft">The left margin of the header on the page in mm.</param>
            <param name="MarginRight">The right margin of the header on the page in mm.</param>
            <param name="MarginTop">The top margin of the header on the page in mm.</param>
            <param name="SkipFirstPage">if set to <c>true</c>, the first (cover) page is not counted or stamped with a header.</param>
            <param name="PageIndexesToAddHeadersTo">Optional.  The PageIndexes (zero-based page numbers) to which the header will be added.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddHTMLFooters(IronPdf.HtmlHeaderFooter,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Renders HTML page footers to an existing PDF File
             <para>Margin spacing on the PDF page for the footer are set to default values of 25mm. An overload method allow footer margins to be chosen specifically or set to zero.</para></summary>
            <param name="Footer">An new instance of IronPdf.HtmlHeaderFooter that defines the footer content and layout.</param>
            <param name="SkipFirstPage">if set to <c>true</c>, the first (cover) page is not counted or stamped with a footer.</param>
            <param name="PageIndexesToAddFootersTo">Optional.  The PageIndexes (zero-based page numbers) to which the footer will be added.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddHTMLFooters(IronPdf.HtmlHeaderFooter,System.Double,System.Double,System.Double,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Renders HTML page footers to an existing PDF File
            </summary>
            <param name="Footer">An new instance of IronPdf.HtmlHeaderFooter that defines the footer content and layout.</param>
            <param name="MarginLeft">The left margin of the footer on the page in mm.</param>
            <param name="MarginRight">The right margin of the footer on the page in mm.</param>
            <param name="MarginBottom">The bottom margin of the footer on the page in mm.</param>
            <param name="SkipFirstPage">if set to <c>true</c>, the first (cover) page is not counted or stamped with a footer.</param>
            <param name="PageIndexesToAddFootersTo">Optional.  The PageIndexes (zero-based page numbers) to which the footer will be added.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddBackgroundPdf(System.String,System.Int32)">
            <summary>
            Adds a background to each page of this PDF. The background is copied from a page in another PDF document.
            </summary>
            <param name="BackgroundPdfPath">The background PDF's file path.</param>
            <param name="BackgroundPdfPageIndex">Index (zero-based page number) to copy from the BackgroundPdf.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddBackgroundPdfToPage(System.Int32,System.String,System.Int32)">
            <summary>
            Adds the background to one page of this PDF.  The background is copied from a page in another PDF document.
            </summary>
            <param name="ToPageIndex">Index (zero-based page number) of the page of this PDF to which the background will be applied to.</param>
            <param name="BackgroundPdfPath">The background PDF path.</param>
            <param name="BackgroundPdfPageIndex">Index (zero-based page number) to copy from the BackgroundPdf.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddBackgroundPdfToPageRange(System.Collections.Generic.IEnumerable{System.Int32},System.String,System.Int32)">
            <summary>
            Adds the background to specified pages of this PDF.  The background is copied from a page in another PDF document.
            </summary>
            <param name="ToPageIndexes">A list of Indexes (zero-based page numbers) of pages in this PDF to which the background will be applied to.</param>
            <param name="BackgroundPdfPath">The background PDF path.</param>
            <param name="BackgroundPdfPageIndex">Index (zero-based page number) to copy from the BackgroundPdf.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddBackgroundPdfToPageRange(System.Int32,System.Int32,System.String,System.Int32)">
            <summary>
            Adds the background to a range of pages in this PDF.  The background is copied from a page in another PDF document.
            </summary>
            <param name="StartPageIndex">First index  (zero-based page number) to start adding backgrounds to .</param>
            <param name="EndPageIndex">Last index  (zero-based page number) to end adding backgrounds to.</param>
            <param name="BackgroundPdfPath">The background PDF path.</param>
            <param name="BackgroundPdfPageIndex">Index (zero-based page number) to copy from the BackgroundPdf.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddBackgroundPdf(IronPdf.PdfDocument,System.Int32)">
            <summary>
            Adds a background to each page of this PDF. The background is copied from a page in another PDF document.
            </summary>
            <param name="BackgroundPdf">The Background PDF as a <see cref="T:IronPdf.PdfDocument" />.</param>
            <param name="BackgroundPdfPageIndex">Index (zero-based page number) to copy from the BackgroundPdf.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddBackgroundPdfToPage(System.Int32,IronPdf.PdfDocument,System.Int32)">
            <summary>
            Adds the background to one page of this PDF.  The background is copied from a page in another PDF document.
            </summary>
            <param name="ToPageIndex">Index (zero-based page number) of the page of this PDF to which the background will be applied to.</param>
            <param name="BackgroundPdf">The Background PDF as a <see cref="T:IronPdf.PdfDocument" />.</param>
            <param name="BackgroundPdfPageIndex">Index (zero-based page number) to copy from the BackgroundPdf.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddBackgroundPdfToPageRange(System.Int32,System.Int32,IronPdf.PdfDocument,System.Int32)">
            <summary>
            Adds the background to a range of pages in this PDF.  The background is copied from a page in another PDF document.
            </summary>
            <param name="StartPageIndex">First index  (zero-based page number) to start adding backgrounds to .</param>
            <param name="EndPageIndex">Last index  (zero-based page number) to end adding backgrounds to.</param>
            <param name="BackgroundPdf">The Background PDF as a <see cref="T:IronPdf.PdfDocument" />.</param>
            <param name="BackgroundPdfPageIndex">Index (zero-based page number) to copy from the BackgroundPdf.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddBackgroundPdfToPageRange(System.Collections.Generic.IEnumerable{System.Int32},IronPdf.PdfDocument,System.Int32)">
            <summary>
            Adds the background to specified pages of this PDF.  The background is copied from a page in another PDF document.
            </summary>
            <param name="ToPageIndexes">A list of Indexes (zero-based page numbers) of pages in this PDF to which the background will be applied to.</param>
            <param name="BackgroundPdf">The Background PDF as a <see cref="T:IronPdf.PdfDocument" />.</param>
            <param name="BackgroundPdfPageIndex">Index (zero-based page number) to copy from the BackgroundPdf.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddForegroundOverlayPdf(System.String,System.Int32)">
            <summary>
            Adds an overlay to each page of this PDF. The foreground overlay is copied from a page in another PDF document.
            </summary>
            <param name="OverlayPdfPath">The background PDF's file path.</param>
            <param name="OverlayPdfPageIndex">Index (zero-based page number) to copy from the Overlay PDF.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddForegroundOverlayPdfToPage(System.Int32,System.String,System.Int32)">
            <summary>
            Adds an overlay to one page of this PDF. The foreground overlay is copied from a page in another PDF document.
            </summary>
            <param name="ToPageIndex">Index (zero-based page number) of the page of this PDF to which the foreground will be applied to.</param>
            <param name="OverlayPdfPath">The overlay PDF path.</param>
            <param name="OverlayPdfPageIndex">Index (zero-based page number) to copy from the Overlay PDF.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddForegroundOverlayPdfToPageRange(System.Collections.Generic.IEnumerable{System.Int32},System.String,System.Int32)">
            <summary>
            Adds an overlay to a range page of this PDF. The foreground overlay is copied from a page in another PDF document.
            </summary>
            <param name="ToPageIndexes">A list of Indexes (zero-based page numbers) of pages in this PDF to which the overlay will be applied to.</param>
            <param name="OverlayPdfPath">The overlay PDF path.</param>
            <param name="OverlayPdfPageIndex">Index (zero-based page number) to copy from the Overlay PDF.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddForegroundOverlayPdfToPageRange(System.Int32,System.Int32,System.String,System.Int32)">
            <summary>
            Adds an overlay to a range page of this PDF. The foreground overlay is copied from a page in another PDF document.
            </summary>
            <param name="StartPageIndex">First index  (zero-based page number) to start adding overlays to .</param>
            <param name="EndPageIndex">Last index  (zero-based page number) to end adding overlays to.</param>
            <param name="OverlayPdfPath">The overlay PDF path.</param>
            <param name="OverlayPdfPageIndex">Index (zero-based page number) to copy from the Overlay PDF.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddForegroundOverlayPdf(IronPdf.PdfDocument,System.Int32)">
            <summary>
            Adds an overlay to each page of this PDF. The foreground overlay is copied from a page in another PDF document.
            </summary>
            <param name="OverlayPdf">The overlay PDF as a <see cref="T:IronPdf.PdfDocument" />.</param>
            <param name="OverlayPdfPageIndex">Index (zero-based page number) to copy from the Overlay PDF.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddForegroundOverlayPdfToPage(System.Int32,IronPdf.PdfDocument,System.Int32)">
            <summary>
            Adds an overlay to one page of this PDF. The foreground overlay is copied from a page in another PDF document.
            </summary>
            <param name="ToPageIndex">Index (zero-based page number) of the page of this PDF to which the foreground will be applied to.</param>
            <param name="OverlayPdf">The overlay PDF as a <see cref="T:IronPdf.PdfDocument" />.</param>
            <param name="OverlayPdfPageIndex">Index (zero-based page number) to copy from the Overlay PDF.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddForegroundOverlayPdfToPageRange(System.Int32,System.Int32,IronPdf.PdfDocument,System.Int32)">
            <summary>
            Adds an overlay to a range page of this PDF. The foreground overlay is copied from a page in another PDF document.
            </summary>
            <param name="StartPageIndex">First index  (zero-based page number) to start adding overlays to .</param>
            <param name="EndPageIndex">Last index  (zero-based page number) to end adding overlays to.</param>
            <param name="OverlayPdf">The overlay PDF as a <see cref="T:IronPdf.PdfDocument" />.</param>
            <param name="OverlayPdfPageIndex">Index (zero-based page number) to copy from the Overlay PDF.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AddForegroundOverlayPdfToPageRange(System.Collections.Generic.IEnumerable{System.Int32},IronPdf.PdfDocument,System.Int32)">
            <summary>
            Adds an overlay to a range page of this PDF. The foreground overlay is copied from a page in another PDF document.
            </summary>
            <param name="ToPageIndexes">A list of Indexes (zero-based page numbers) of pages in this PDF to which the overlay will be applied to.</param>
            <param name="OverlayPdf">The overlay PDF as a <see cref="T:IronPdf.PdfDocument" />.</param>
            <param name="OverlayPdfPageIndex">Index (zero-based page number) to copy from the Overlay PDF.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.GetPageRotation(System.Int32)">
            <summary>
            Gets the rotation of a PDF page in degrees.
            </summary>
            <param name="PageIndex">Index of the page to inspect. PageIndex is a 'Zero based' page number, the first page being 0.</param>
            <returns>A number of degrees rotation</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.RotateAllPages(System.Int32)">
            <summary>
            Rotates all pages of the PdfDocument by a specified number of degrees.
            </summary>
            <param name="Degrees">The number of degrees to rotate the pages.  0, 90, 180 or 270 are accepted values.</param>
        </member>
        <member name="M:IronPdf.PdfDocument.RotatePage(System.Int32,System.Int32)">
            <summary>
            Rotates one page of the PdfDocument by a specified number of degrees.
            </summary>
            <param name="PageIndex">Index of the page to rotate. PageIndex is a 'Zero based' page number, the first page being 0.</param>
            <param name="Degrees">The number of degrees to rotate the pages.  0, 90, 180 or 270 are accepted values.</param>
        </member>
        <member name="M:IronPdf.PdfDocument.RotateSelectedPages(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Rotates selected pages of the PdfDocument by a specified number of degrees.
            </summary>
            <param name="PageIndexes">Indexes of the pages to rotate in an IEnumerable, list or array. PageIndex is a 'Zero based' page number, the first page being 0.</param>
            <param name="Degrees">The number of degrees to rotate the pages.  0, 90, 180 or 270 are accepted values.</param>
        </member>
        <member name="M:IronPdf.PdfDocument.QuickSignPdfWithDigitalSignatureFile(System.String,System.String)">
            <summary>
            Sign PDF with digital signature certificate.  For more advanced Options please see <see cref="M:IronPdf.PdfDocument.QuickSignPdfWithDigitalSignatureFile(System.String,System.String)" /><para> Note that the PDF will not be fully signed until Saved using <see cref="M:IronPdf.PdfDocument.SaveAs(System.String)" />,  <see cref="M:IronPdf.PdfDocument.TrySaveAs(System.String)" />,  <see cref="P:IronPdf.PdfDocument.Stream" /> or  <see cref="P:IronPdf.PdfDocument.BinaryData" />.  Multiple certificates may be used.</para><para>Not implemented in .Net Core</para></summary>
            <seealso cref="T:IronPdf.PdfSignature" />
            <param name="CertificateFilePath">The file path to a .pfx or .p12 digital signing certificate which may be generated using Adobe Acrobat Viewer.</param>
            <param name="Password">The certificate password as a String.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.SignPdfWithDigitalSignature(IronPdf.PdfSignature)">
            <summary>
            Signs the PDF with digital signature with advanced options. 
            <para> Note that the PDF will not be fully signed until Saved using <see cref="M:IronPdf.PdfDocument.SaveAs(System.String)" />,  <see cref="M:IronPdf.PdfDocument.TrySaveAs(System.String)" />,  <see cref="P:IronPdf.PdfDocument.Stream" /> or  <see cref="P:IronPdf.PdfDocument.BinaryData" />.  Multiple certificates may be used.</para><para>Not implemented in .Net Core</para></summary>
            <param name="Signature">The PdfSignature.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.StampHTML(IronPdf.HtmlStamp,System.Int32)">
            <summary>
            Edits the PDF by adding rendered HTML either behind or in-front of the existing contents of one page.
            </summary>
            <param name="Stamp">The <see cref="T:IronPdf.HtmlStamp" /> stamp. </param>
            <param name="PageIndexToStamp">The page index (zero-based page number) to stamp.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.StampHTML(IronPdf.HtmlStamp)">
            <summary>
            Edits the PDF by adding rendered HTML either behind or in-front of the existing contents of every page.
            </summary>
            <param name="Stamp">The <see cref="T:IronPdf.HtmlStamp" /> stamp. </param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.StampHTML(IronPdf.HtmlStamp,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Edits the PDF by adding rendered HTML either behind or in-front of the existing contents of specified pages.
            </summary>
            <param name="Stamp">The <see cref="T:IronPdf.HtmlStamp" /> stamp. </param>
            <param name="PageIndexesToStamp">The list page indexes (zero-based page number) to stamp.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="P:IronPdf.PdfDocument.Password">
            <summary>
             Sets a Password used to protect and encrypt the PDF File.
             Setting a password will cause IronPDF to automatically protect the PDF file content using strong 128 bit encryption.
             Setting the password to null will remove any existing password.
            </summary>
        </member>
        <member name="M:IronPdf.PdfDocument.FromFile(System.String,System.String)">
            <summary>
            Opens an existing PDF document for editing.
            </summary>
            <param name="PdfFilePath">The PDF file path.</param>
            <param name="Password">Optional password if the PDF document is protected / encrypted.</param>
            <exception cref="T:System.IO.IOException">Exception thrown if can not be opened.</exception>
            <returns>An IronPdf.PdfDocument object as loaded from the file path.</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.#ctor(System.String,System.String)">
            <summary>
            Opens an existing PDF document for editing.
            </summary>
            <param name="PdfFilePath">The PDF file path.</param>
            <param name="Password">Optional password if the PDF document is protected / encrypted.</param>
            <exception cref="T:System.IO.IOException">Exception thrown if can not be opened.</exception>
        </member>
        <member name="M:IronPdf.PdfDocument.#ctor(System.IO.Stream,System.String)">
            <summary>
            Opens an existing PDF document for editing.
            </summary>
            <param name="PdfDataStream">The PDF file data as a Stream.</param>
            <param name="Password">Optional password if the PDF document is protected / encrypted.</param>
            <exception cref="T:System.IO.IOException">Exception thrown if can not be opened.</exception>
        </member>
        <member name="M:IronPdf.PdfDocument.#ctor(System.Byte[],System.String)">
            <summary>
            Opens an existing PDF document for editing.
            </summary>
            <param name="PdfData">The PDF file data as byte array.</param>
            <param name="Password">Optional password if the PDF document is protected / encrypted.</param>
            <exception cref="T:System.IO.IOException">Exception thrown if can not be opened.</exception>
        </member>
        <member name="P:IronPdf.PdfDocument.Stream">
            <summary>
             Gets the binary data for the full PDF file as a Stream
            </summary>
            <value>
            The PDF file as a MemoryStream
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.BinaryData">
            <summary>
            Gets the binary data for the full PDF file as a byte array;
            </summary>
            <value>
            The PDF file as a byte array.
            </value>
        </member>
        <member name="M:IronPdf.PdfDocument.SaveAs(System.String)">
            <summary>
            Saves the PdfDocument to a file.
            <para>Supports site relative paths staring with "~/" in .Net Framework Web 4+ Applications</para></summary>
            <param name="FileName">File Path</param>
            <returns>This PdfDocument for fluid code notation. </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.TrySaveAs(System.String)">
            <summary>
            Attempt to save the PdfDocument to a file.
            </summary>
            <param name="FileName">File Path</param>
            <returns>}<c>true</c> if the file was saved successfully.  <c>false</c> if an error occurred (e.g. file was locked or insufficient permissions). </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.CopyPage(System.Int32)">
            <summary>
            Creates a new PDF by copying a page from this PdfDocument.
            </summary>
            <param name="PageIndex">Index of the page.  Note: Page 1 has index 0...</param>
            <returns>This PdfDocument for a LINQ like 'fluent' coding style.</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.CopyPages(System.Int32,System.Int32)">
            <summary>
            Creates a new PDF by copying a range of pages from this <see cref="T:IronPdf.PdfDocument" />.
            </summary>
            <param name="StartIndex">The index of the first PDF page to copy.. Note: Page 1 has index 0 </param>
            <param name="EndIndex">The index of the last PDF page to copy.&gt;</param>
            <returns>This PdfDocument for a LINQ like 'fluent' coding style.</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.CopyPages(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates a new PDF by copying a range of pages from this PdfDocument.
            </summary>
            <param name="PageIndexes">An IEnumerable of page indexes to copy into the new PDF. </param>
            <returns>This PdfDocument for a LINQ like 'fluent' coding style.</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractAllBitmaps">
            <summary>
            Finds all embedded Images from within the PDF and returns then as System.Drawing.Bitmap objects
            </summary>
            <returns>IEnumerable of Bitmap.  The extracted images as System.Drawing Objects</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractBitmapsFromPage(System.Int32)">
            <summary>
            Finds all embedded Images from within one page of the PDF and returns them as System.Drawing.Bitmap objects
            </summary>
            <param name="PageIndex">Index of the page.  Note: Page 1 has index 0...</param>
            <returns>IEnumerable of Bitmap.  The extracted images as System.Drawing Objects</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractBitmapsFromPages(System.Int32,System.Int32)">
            <summary>
            Finds all embedded Images from within a range of pages in the PDF and returns them as System.Drawing.Bitmap objects
            </summary>
            <param name="StartIndex">The index of the first PDF page  to extract images from.. Note: Page 1 has index 0 </param>
            <param name="EndIndex">The index of the last PDF page to extract images from.</param>
            <returns>IEnumerable of Bitmap.  The extracted images as System.Drawing Objects</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractBitmapsFromPages(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Finds all embedded Images from within a specified  pages in the PDF and returns them as System.Drawing.Bitmap objects
            </summary>
            <param name="PageIndexes">An IEnumerable list of page indexes. </param>
            <returns>IEnumerable of Bitmap.  The extracted images as System.Drawing Objects</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractAllImages">
            <summary>
            Finds all embedded Images from within the PDF and returns then as System.Drawing.Image objects
            </summary>
            <returns>IEnumerable of Image.  The extracted images as System.Drawing Objects</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractImagesFromPage(System.Int32)">
            <summary>
            Finds all embedded Images from within one page of the PDF and returns them as System.Drawing.Image objects
            </summary>
            <param name="PageIndex">Index of the page.  Note: Page 1 has index 0...</param>
            <returns>IEnumerable of Image.  The extracted images as System.Drawing Objects</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractImagesFromPages(System.Int32,System.Int32)">
            <summary>
            Finds all embedded Images from within a range of pages in the PDF and returns them as System.Drawing.Bitmap objects
            </summary>
            <param name="StartIndex">The index of the first PDF page  to extract images from.. Note: Page 1 has index 0 </param>
            <param name="EndIndex">The index of the last PDF page to extract images from.</param>
            <returns>IEnumerable of Image.  The extracted images as System.Drawing Objects</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractImagesFromPages(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Finds all embedded Images from within a specified  pages in the PDF and returns them as System.Drawing.Image objects
            </summary>
            <param name="PageIndexes">An IEnumerable list of page indexes. </param>
            <returns>IEnumerable of Image.  The extracted images as System.Drawing Objects</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.Merge(IronPdf.PdfDocument,IronPdf.PdfDocument)">
            <summary>
            Static method that joins (concatenates) 2 PDF documents together into one final PDF document. 
            </summary>
            <param name="A">A PDF</param>
            <param name="B">A Seconds PDF</param>
            <returns>
            A new merged PDF file.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.Merge(System.Collections.Generic.IEnumerable{IronPdf.PdfDocument})">
            <summary>
            Static method that joins (concatenates) multiple PDF documents together into one compiled PDF document. 
            </summary>
            <param name="PDFs">A IEnumerable of PdfDocument.  To merge existing PDF files you may use the PdfDocument.FromFile static method in conjunction with Merge.</param>
            <returns>
            The merged PDF file.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.AppendPdf(IronPdf.PdfDocument)">
            <summary>
            Appends another PDF to the end of the current PdfDocument
            </summary>
            <param name="AnotherPdfFile"> PdfDocument to append.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.PrependPdf(IronPdf.PdfDocument)">
            <summary>
            Adds another PDF to the beginning of the current PdfDocument
            </summary>
            <param name="AnotherPdfFile"> PdfDocument to prepend.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.InsertPdf(IronPdf.PdfDocument,System.Int32)">
            <summary>
            Inserts another PDF into of the current PdfDocument, starting at a given Page Index.
            </summary>
            <param name="AnotherPdfFile">Another PdfDocument.</param>
            <param name="AtIndex">Index at which to insert the new content.  Note: Page 1 has index 0...</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="P:IronPdf.PdfDocument.PageCount">
            <summary>
            Gets the number of pages in the PDF document.         
            </summary>
            <value>
            The page count.
            </value>
        </member>
        <member name="M:IronPdf.PdfDocument.RemovePage(System.Int32)">
            <summary>
            Removes a page from the PDF at the given index.
            </summary>
            <param name="PageIndex">Index of the page.  Note: Page 1 has index 0...</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.RemovePages(System.Int32,System.Int32)">
            <summary>
            Removes a range of pages from the PDF
            </summary>
            <param name="StartIndex">The start index. Note: Page 1 has index 0 </param>
            <param name="EndIndex">The end index. Note: The last page has index <c>PageCount -1</c></param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.RemovePages(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Removes a range of pages from the PDF
            </summary>
            <param name="PageIndexes">An list of pages indexes to remove.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractAllText">
            <summary>
            Extracts the written text content from the PDF and returns it as a string. 
            Pages will be separated by 4 consecutive newline characters ("\n\n\n\n")
            </summary>
            <returns>
            All text in the PDF as a string.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractTextFromPage(System.Int32)">
            <summary>
            Extracts the text content from one page of the PDF and returns it as a string. 
            </summary>
            <param name="PageIndex">Index of the page.  Note: Page 1 has index 0...</param>
            <returns>The text extracted from the PDF page as a string. </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractTextFromPages(System.Int32,System.Int32)">
            <summary>
            Extracts the written text content from a range of pages within the PDF and returns it as a string.   
            Pages will be separated by 4 consecutive newline characters ("\n\n\n\n")
            </summary>
            <param name="StartIndex">The start page index. Note: Page 1 has index 0 </param>
            <param name="EndIndex">The end page index. Note: The last page has index <c>PageCount -1</c></param>
            <returns>The text extracted from the PDF pages as a string. </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ExtractTextFromPages(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Extracts the written text content from specified pages in the PDF PDF and returns it as a string.  
            Pages will be separated by 4 consecutive newline characters ("\n\n\n\n")
            </summary>
            <param name="PageIndexes">An IEnumerable list of page indexes. </param>
            <returns>The text extracted from the PDF pages as a string. </returns>
        </member>
        <member name="P:IronPdf.PdfDocument.SecuritySettings">
            <summary>
            Advanced security settings for the PDF.
            <para>Allows the developer to control user access passwords, encryption, and also who may edit, print and copy content from the PDF document</para></summary>
            <value>
            Advanced security settings for this PDF as an instance of <see cref="T:IronPdf.PdfDocument.PdfSecuritySettings" /></value>
        </member>
        <member name="P:IronPdf.PdfDocument.MetaData">
            <summary>
            MetaData information settings for the PDF.
            <para>Allows File meta-data to be read and set including: Authors, File Dates, Keywords, Title and Subject</para></summary>
            <value>
            MetaData settings for this PDF as an instance of <see cref="T:IronPdf.PdfDocument.PdfMetaData" /></value>
        </member>
        <member name="T:IronPdf.PdfDocument.PdfSecuritySettings">
            <summary>
            A class defining user security settings for a PDF document.
            <para>Allows the developer to control user access passwords, encryption, and also who may edit, print and copy content from the PDF document</para><para>Implemented in <see cref="P:IronPdf.PdfDocument.SecuritySettings" />. </para></summary>
        </member>
        <member name="T:IronPdf.PdfDocument.PdfSecuritySettings.PdfPrintSecrity">
            <summary>
            Enumeration defining levels of PDF user access rights to print a PDF.
            <para>See <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserPrinting" /></para></summary>
        </member>
        <member name="F:IronPdf.PdfDocument.PdfSecuritySettings.PdfPrintSecrity.NoPrint">
            <summary>
            The user may not print the PDF unless they have the Owner password.
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.PdfSecuritySettings.PdfPrintSecrity.PrintLowQuality">
            <summary>
            The user may only print the PDF at low resolution unless they have the Owner password.
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.PdfSecuritySettings.PdfPrintSecrity.FullPrintRights">
            <summary>
            Users may print the PDF without restriction.
            </summary>
        </member>
        <member name="T:IronPdf.PdfDocument.PdfSecuritySettings.PdfEditSecurity">
            <summary>
            Enumeration defining levels of PDF user access rights to edit a PDF.  Edit rights may also be limited by the User's PDF document client software.
            <para>See <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserEdits" /></para></summary>
        </member>
        <member name="F:IronPdf.PdfDocument.PdfSecuritySettings.PdfEditSecurity.NoEdit">
            <summary>
            The user may not edit the PDF unless they have the Owner password.
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.PdfSecuritySettings.PdfEditSecurity.EditPages">
            <summary>
            The user may re-arrange pages, rotate pages and manage PDF thumbnails, but may not otherwise edit the PDF unless they have the Owner password.
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.PdfSecuritySettings.PdfEditSecurity.EditAll">
            <summary>
            The user may edit the PDF as allowed by their PDF client software.
            </summary>
        </member>
        <member name="M:IronPdf.PdfDocument.PdfSecuritySettings.MakePdfDocumentReadOnly(System.String)">
            <summary>
            Makes this PDF document read only such that:
            <para>Content is encrypted at 128 bit. Copy and paste of content is disallowed. Annotations and form editing are disabled. </para></summary>
            <param name="OwnerPassword">The owner password for the PDF.  A string for owner password is required to enable PDF encryption and all document security options.</param>
        </member>
        <member name="M:IronPdf.PdfDocument.PdfSecuritySettings.RemovePasswordsAndEncryption">
            <summary>
            Removes all user and owner password security for a PDF document.  Also disables content encryption.
            <para>Content is encrypted at 128 bit. Copy and paste of content is disallowed. Annotations and form editing are disabled. </para></summary>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfSecuritySettings.OwnerPassword">
            <summary>
            Sets the owner password and enables 128Bit encryption of PDF content. An owner password is one used to enable and disable all other security settings.
            <para>OwnerPassword must be set to a non empty string value for <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserCopyPasteContent" />, <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserAnnotations" />, <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserFormData" />,s <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserPrinting" /> and <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserEdits" /> to be restricted. </para></summary>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfSecuritySettings.UserPassword">
            <summary>
            Sets the user password and enables 128Bit encryption of PDF content .
            <para>A user password if a password that each user must enter to open or print the PDF document.</para></summary>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserCopyPasteContent">
            <summary>
            Gets or sets the permissions for users to extract or 'copy &amp; paste' content (text and images) from f the PDF document.
            <para>If AllowUserCopyPasteContent is set <c>false</c>,  the <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.OwnerPassword" /> must also be set for the security measure to take effect.</para></summary>
            <value>
                <c>true</c> if users may 'copy and paste' content out of the PDF otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserAnnotations">
            <summary>
            Gets or sets the permissions for users to annotate the PDF document with comments.
            <para>If AllowUserAnnotations is set <c>false</c>, the <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.OwnerPassword" /> must be set for the security measure to take effect.</para></summary>
            <value>
                <c>true</c> if users may annotate the PDF document, otherwise <c>false</c>.
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserFormData">
            <summary>
            Gets or sets the permissions for users to fill-in (enter data into) forms in the PDF document.
            <para>If AllowUserFormData is set <c>false</c>, the <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.OwnerPassword" /> must be set for the security measure to take effect.</para></summary>
            <value>
                <c>true</c> if users may annotate the PDF document, otherwise <c>false</c>.  Setting AllowUserFormData true will also enable annotations.
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserPrinting">
            <summary>
            Gets or sets the permissions for users to print the PDF document.
            <para>If print rights are restricted, then the <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.OwnerPassword" /> must be set for the security measure to take effect.</para></summary>
            <value>
            The <see cref="T:IronPdf.PdfDocument.PdfSecuritySettings.PdfPrintSecrity" /> value for user printing.
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfSecuritySettings.AllowUserEdits">
            <summary>
            Gets or sets the permissions for users edit the PDF document.  The features to edit the document depends entirely on the PDF client software used by the end user.
            <para>If editing rights are restricted, then the <see cref="P:IronPdf.PdfDocument.PdfSecuritySettings.OwnerPassword" /> must be set for the security measure to take effect.</para></summary>
            <value>
            The <see cref="T:IronPdf.PdfDocument.PdfSecuritySettings.PdfEditSecurity" /> value for user edit security.
            </value>
        </member>
        <member name="T:IronPdf.PdfDocument.PdfMetaData">
            <summary>
            A class defining PDF file meta-data.
            <para>Allows File meta-data to be read and set including: Authors, File Dates, Keywords, Title and Subject</para><para>Implemented in <see cref="P:IronPdf.PdfDocument.MetaData" />. </para></summary>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfMetaData.Author">
            <summary>
            Gets or sets the Author of the document.
            </summary>
            <value>
            The author name as a string.
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfMetaData.Creator">
            <summary>
            Gets or sets the Creator of the document.
            </summary>
            <value>
            The creator name as a string.
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfMetaData.Producer">
            <summary>
            Gets or sets the Producer of the document.
            </summary>
            <value>
            The producer name as a string.
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfMetaData.CreationDate">
            <summary>
            Gets or sets the PDF file creation DateTime.
            </summary>
            <value>
            DateTime of PDF file creation.
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfMetaData.Keywords">
            <summary>
            Gets or sets the Keywords of the document.  This helps search indexes and operating systems correctly index the PDF.
            </summary>
            <value>
            The Keywords of the document as a string.  It is customary to use comma separation between keywords.
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfMetaData.ModifiedDate">
            <summary>
            Gets or sets the PDF file last-modified DateTime.
            </summary>
            <value>
            DateTime of PDF file modification.
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfMetaData.Subject">
            <summary>
            Gets or sets the Subject of the document.  This helps search indexes and operating systems correctly index the PDF, and may appear in PDF viewer software.
            </summary>
            <value>
            The Subject of the document as a string. 
            </value>
        </member>
        <member name="P:IronPdf.PdfDocument.PdfMetaData.Title">
            <summary>
            Gets or sets the Title of the document.  This helps search indexes and operating systems correctly index the PDF, and may appear in PDF viewer software.
            </summary>
            <value>
            The Title of the document as a string. 
            </value>
        </member>
        <member name="M:IronPdf.PdfDocument.GetPrintDocument">
            <summary>
            Returns a <see cref="T:System.Drawing.Printing.PrintDocument" /> for the PDF allowing developers granular control over sending the PDF to a Printer.
            <para>An assembly reference to System.Drawing is required in your project.</para><para>
            Available in IronPDF for .Net Framework, and .Net Core.
            For Linux and OSX targets please install the PDFium library to your application or bin directory for this functionality to work.
            </para></summary>
            <returns>A <see cref="T:System.Drawing.Printing.PrintDocument" />.</returns>
            <exception cref="T:System.Exception">IronPdf must be licensed to use this feature.</exception>
        </member>
        <member name="M:IronPdf.PdfDocument.Print">
            <summary>
            Prints this PDF by sending it to the computer's default printer.  
            <para>Windows print UI dialogs will be displayed to the user.</para><para>For advanced real-world printing options please see <see cref="M:IronPdf.PdfDocument.GetPrintDocument" />.</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
        </member>
        <member name="M:IronPdf.PdfDocument.ToBitmap(System.Int32)">
            <summary>
            Rasterizes (renders) the PDF into System.Drawing.Bitmap objects.  1 Bitmap for each page.
            <para>Please add an assembly reference to System.Drawing to use this "PDF To Image" method.</para><para>Please Dispose() each Bitmap object after use.</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <returns>An array of System.Drawing.Bitmap image objects which can be saved, manipulated, displayed or edited programmatically.</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToBitmap(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Rasterizes (renders) the PDF into System.Drawing.Bitmap objects.
            <para>Specific pages may be selected using the PageNumbers parameter.</para><para>Please add an assembly reference to System.Drawing to use this "PDF To Image" method</para><para>Please Dispose() each Bitmap object after use.</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="PageNumbers">Specific page numbers may be given to only convert part of the PDF document to images</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>
            An array of System.Drawing.Bitmap image objects which can be saved, manipulated, displayed or edited programmatically.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToBitmap(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Rasterizes (renders) the PDF into System.Drawing.Bitmap objects.
            <para>Specific pages may be selected using the PageNumbers parameter.  The Widths and Height of the output images may be specified.</para><para>Please add an assembly reference to System.Drawing to use this "PDF To Image" method</para><para>Please Dispose() each Bitmap object after use.</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="ImageMaxWidth">The target maximum width of the output images.</param>
            <param name="ImageMaxHeight">The target maximum height of the output images.</param>
            <param name="PageNumbers">Specific page numbers may be given to only convert part of the PDF document to images</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>
            An array of System.Drawing.Bitmap image objects which can be saved, manipulated, displayed or edited programmatically.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.PageToBitmap(System.Int32,System.Int32)">
            <summary>
            Renders a single page of the PDF to a System.Drawing.Bitmap object.
            <para>Please add an assembly reference to System.Drawing to use this "PDF To Image" method</para><para>Please Dispose() each Bitmap object after use.</para></summary>
            <param name="PageNumber">The page number to be converted to an image.</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>A System.Drawing.Bitmap of the rendered PDF page.</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.PageToBitmap(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Int32)">
            <summary>
            Renders a single page of the PDF to a System.Drawing.Bitmap object.
            <para>Please add an assembly reference to System.Drawing to use this "PDF To Image" method</para><para>Please Dispose() each Bitmap object after use.</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="PageNumber">The page number to be converted to an image.</param>
            <param name="ImageMaxWidth">The target maximum width of the output images.</param>
            <param name="ImageMaxHeight">The target maximum height of the output images.</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>A System.Drawing.Bitmap of the rendered PDF page.</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.RasterizeToImageFiles(System.String,IronPdf.ImageType,System.Int32)">
            <summary>
            Renders the PDF and exports image Files in convenient formats.  1 image file is created for each page.<para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_page_*.png</param>
            <param name="ImageFileType">Type of the image file.  If not specified, a best guess will be taken from the FileNamePattern file extension</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>An array of the file paths of the image files created.</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.RasterizeToImageFiles(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},IronPdf.ImageType,System.Int32)">
            <summary>
            Renders the PDF and exports image Files in convenient formats.  Image dimensions may be specified.  1 image file is created for each page.<para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_page_*.png</param>
            <param name="ImageFileType">Type of the image file.  If not specified, a best guess will be taken from the FileNamePattern file extension</param>
            <param name="ImageMaxWidth">The target maximum width of the output images.</param>
            <param name="ImageMaxHeight">The target maximum height of the output images.</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.RasterizeToImageFiles(System.String,System.Collections.Generic.IEnumerable{System.Int32},IronPdf.ImageType,System.Int32)">
            <summary>
            Renders the PDF and exports image Files in convenient formats.  Page Numbers may be specified.  1 image file is created for each page.
            <para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_page_*.png</param>
            <param name="ImageFileType">Type of the image file.  If not specified, a best guess will be taken from the FileNamePattern file extension</param>
            <param name="PageNumbers">A list of the specific page numbers to render as images.</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.RasterizeToImageFiles(System.String,System.Collections.Generic.IEnumerable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},IronPdf.ImageType,System.Int32)">
            <summary>
            Renders the PDF and exports image Files in convenient formats.  Page Numbers may be specified.  1 image file is created for each page.
            <para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_page_*.png</param>
            <param name="ImageFileType">Type of the image file.  If not specified, a best guess will be taken from the FileNamePattern file extension</param>
            <param name="PageNumbers">A list of the specific page numbers to render as images.</param>
            <param name="ImageMaxWidth">The target maximum width of the output images.</param>
            <param name="ImageMaxHeight">The target maximum height of the output images.</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToJpegImages(System.String,System.Int32)">
            <summary>
            Renders the pages of the PDF as JPEG files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_page_*.jpg</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToJpegImages(System.String,System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Renders the pages of the PDF as JPEG files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_page_*.jpg</param>
            <param name="PageNumbers">A list of the specific page numbers to render as images.</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToJpegImages(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Int32)">
            <summary>
            Renders the pages of the PDF as JPEG files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_page_*.jpg</param>
            <param name="ImageMaxWidth">The target maximum width of the output images.</param>
            <param name="ImageMaxHeight">The target maximum height of the output images.</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToJpegImages(System.String,System.Collections.Generic.IEnumerable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Int32)">
            <summary>
            Renders the pages of the PDF as JPEG files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_page_*.jpg</param>
            <param name="PageNumbers">A list of the specific page numbers to render as images.</param>
            <param name="ImageMaxWidth">The target maximum width of the output images.</param>
            <param name="ImageMaxHeight">The target maximum height of the output images.</param>
            <param name="DPI">The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToPngImages(System.String,System.Int32)">
            <summary>
            Renders the pages of the PDF as PNG (Portable Network Graphic) files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_pages_*.png</param>
            <param name="DPI"> The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToPngImages(System.String,System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Renders the pages of the PDF as PNG (Portable Network Graphic) files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_pages_*.png</param>
            <param name="PageNumbers">A list of the specific page numbers to render as images.</param>
            <param name="DPI"> The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToPngImages(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Int32)">
            <summary>
            Renders the pages of the PDF as PNG (Portable Network Graphic) files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_pages_*.png</param>
            <param name="ImageMaxWidth">The target maximum width of the output images.</param>
            <param name="ImageMaxHeight">The target maximum height of the output images.</param>
            <param name="DPI"> The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToPngImages(System.String,System.Collections.Generic.IEnumerable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Int32)">
            <summary>
            Renders the pages of the PDF as PNG (Portable Network Graphic) files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_pages_*.png</param>
            <param name="PageNumbers">A list of the specific page numbers to render as images.</param>
            <param name="ImageMaxWidth">The target maximum width of the output images.</param>
            <param name="ImageMaxHeight">The target maximum height of the output images.</param>
            <param name="DPI"> The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToTiffImages(System.String,System.Int32)">
            <summary>
            Renders the pages of the PDF as TIFF (Tagged Image File Format / Tif) files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_pages_*.tiff</param>
            <param name="DPI"> The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToTiffImages(System.String,System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Renders the pages of the PDF as TIFF (Tagged Image File Format / Tif) files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para><para> Available in IronPDF for .Net Framework, and .Net Core, but only for Windows and Azure machines.</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_pages_*.tiff</param>
            <param name="PageNumbers">A list of the specific page numbers to render as images.</param>
            <param name="DPI"> The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToTiffImages(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Int32)">
            <summary>
            Renders the pages of the PDF as TIFF (Tagged Image File Format / Tif) files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_pages_*.tiff</param>
            <param name="ImageMaxWidth">The target maximum width of the output images.</param>
            <param name="ImageMaxHeight">The target maximum height of the output images.</param>
            <param name="DPI"> The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.ToTiffImages(System.String,System.Collections.Generic.IEnumerable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Int32)">
            <summary>
            Renders the pages of the PDF as TIFF (Tagged Image File Format / Tif) files and saves them to disk.
            <para>Specific image dimensions and page numbers may be given as optional parameters</para><para>FileNamePattern should normally contain an asterisk (*) character which will be substituted for the page numbers</para></summary>
            <param name="FileNamePattern">A full or partial file path for the output files containing an asterisk.  E.g.  C:\images\pdf_pages_*.tiff</param>
            <param name="PageNumbers">A list of the specific page numbers to render as images.</param>
            <param name="ImageMaxWidth">The target maximum width of the output images.</param>
            <param name="ImageMaxHeight">The target maximum height of the output images.</param>
            <param name="DPI"> The desired resolution of the output Images.</param>
            <returns>
            An array of the file paths of the image files created.
            </returns>
        </member>
        <member name="M:IronPdf.PdfDocument.Finalize">
            <exclude />
        </member>
        <member name="M:IronPdf.PdfDocument.VerifyPdfSignatures">
            <summary>
            Verifies all the PDF signatures for this PDF document and returns <c>true</c> if there are no invalid signatures.
            </summary>
            <returns>
                <c>true</c> if all digital signatures for this PDF document are currently valid. Editing a PDF document in any way will invalidate signatures.</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.VerifyPdfSignaturesInFile(System.String)">
            <summary>
            Verifies all the PDF signatures for a PDF file (by file path) and returns <c>true</c> if there are no invalid signatures.
            </summary>
            <param name="PdfFilePath">The full or relative PDF file path.</param>
            <returns>
                <c>true</c> if all digital signatures for the PDF document are currently valid. Editing a PDF document in any way will invalidate signatures.
            </returns>
        </member>
        <member name="T:IronPdf.PdfDocument.WaterMarkLocation">
            <summary>
              Location for a simple watermark to be applied to a PDF page.
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.WaterMarkLocation.TopLeft">
            <summary>
            The top left of the page
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.WaterMarkLocation.TopCenter">
            <summary>
            The top center of the page
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.WaterMarkLocation.TopRight">
            <summary>
            The top right of the page
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.WaterMarkLocation.MiddleLeft">
            <summary>
            The middle left of the page
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.WaterMarkLocation.MiddleCenter">
            <summary>
            The dead center of the page
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.WaterMarkLocation.MiddleRight">
            <summary>
            The middle right of the page
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.WaterMarkLocation.BottomLeft">
            <summary>
            The bottom left of the page
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.WaterMarkLocation.BottomCenter">
            <summary>
            The bottom center of the page
            </summary>
        </member>
        <member name="F:IronPdf.PdfDocument.WaterMarkLocation.BottomRight">
            <summary>
            The bottom right of the page
            </summary>
        </member>
        <member name="M:IronPdf.PdfDocument.WatermarkPage(System.String,System.Int32,IronPdf.PdfDocument.WaterMarkLocation,System.Int32,System.Int32,System.String)">
            <summary>
            Watermarks a single page of this PDF with HTML content.
            <para>Watermarks are restricted to basic positioning and a 100mm by 100mm maximum size.  For more advanced options see <see cref="M:IronPdf.PdfDocument.StampHTML(IronPdf.HtmlStamp,System.Int32)" /></para></summary>
            <param name="Html">The HTML fragment</param>
            <param name="PageIndexToWaterMark">The page index (zero-based page number) of this PDF to watermark.</param>
            <param name="Location">The location of the watermark. <see cref="T:IronPdf.PdfDocument.WaterMarkLocation" /></param>
            <param name="Opacity">The opacity of the watermark from 0-100%. 100 is opaque, 0 is invisible.</param>
            <param name="Rotation">The rotation of the watermark content in clockwise degrees.</param>
            <param name="Hyperlink">An optional hyperlink which the watermark will link to.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.WatermarkAllPages(System.String,IronPdf.PdfDocument.WaterMarkLocation,System.Int32,System.Int32,System.String)">
            <summary>
            Watermarks all pages of this PDF with HTML content.
            <para>Watermarks are restricted to basic positioning and a 100mm by 100mm maximum size.  For more advanced options see <see cref="M:IronPdf.PdfDocument.StampHTML(IronPdf.HtmlStamp)" /></para></summary>
            <param name="Html">The HTML fragment</param>
            <param name="Location">The location of the watermark. <see cref="T:IronPdf.PdfDocument.WaterMarkLocation" /></param>
            <param name="Opacity">The opacity of the watermark from 0-100%. 100 is opaque, 0 is invisible.</param>
            <param name="Rotation">The rotation of the watermark content in clockwise degrees.</param>
            <param name="Hyperlink">An optional hyperlink which the watermark will link to.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="M:IronPdf.PdfDocument.WatermarkPages(System.String,System.Collections.Generic.IEnumerable{System.Int32},IronPdf.PdfDocument.WaterMarkLocation,System.Int32,System.Int32,System.String)">
            <summary>
            Watermarks all pages of this PDF with HTML content.
            <para>Watermarks are restricted to basic positioning and a 100mm by 100mm maximum size.  For more advanced options see <see cref="M:IronPdf.PdfDocument.StampHTML(IronPdf.HtmlStamp,System.Collections.Generic.IEnumerable{System.Int32})" /></para></summary>
            <param name="Html">The HTML fragment</param>
            <param name="PageIndexesToWaterMark">A list of page index (zero-based page number) of this PDF to watermark.</param>
            <param name="Location">The location of the watermark. <see cref="T:IronPdf.PdfDocument.WaterMarkLocation" /></param>
            <param name="Opacity">The opacity of the watermark from 0-100%. 100 is opaque, 0 is invisible.</param>
            <param name="Rotation">The rotation of the watermark content in clockwise degrees.</param>
            <param name="Hyperlink">An optional hyperlink which the watermark will link to.</param>
            <returns>Returns this PdfDocument object, allowing for a 'fluent' (LINQ like) chained in-line code style</returns>
        </member>
        <member name="T:IronPdf.PdfOutline">
            <summary>
            A editable collection of PDF navigational bookmark objects.
            </summary>
        </member>
        <member name="M:IronPdf.PdfOutline.RemoveBookMark(IronPdf.PdfBookMark)">
            <summary>
            Removes a single book mark from the BookMarkList
            </summary>
            <param name="BookMark">The bookmark object to remove.</param>
        </member>
        <member name="M:IronPdf.PdfOutline.RemoveBookMarkAt(System.Int32)">
            <summary>
            Removes a single book mark from the BookMarkList
            </summary>
            <param name="Index">The index of the bookmark to remove.</param>
        </member>
        <member name="M:IronPdf.PdfOutline.AddBookMarkAtEnd(System.String,System.Int32,System.Int32)">
            <summary>
            Adds a bookmark at the end of the document outline.
            </summary>
            <param name="Text">The display text for the link.</param>
            <param name="PageIndex">The zero based page number to link to.  E.g.  Page 1 has a PageIndex of 0</param>
            <param name="IndentLevel">The indent level in the outline.  An IndentLevel of zero is in the root.  An IndentLevel of N  will be nested inside the most recent previous bookmark of IndentLevel N-1. </param>
        </member>
        <member name="M:IronPdf.PdfOutline.AddBookMarkAtStart(System.String,System.Int32,System.Int32)">
            <summary>
            Adds a bookmark at the start of the document outline.
            </summary>
            <param name="Text">The display text for the link.</param>
            <param name="PageIndex">The zero based page number to link to.  E.g.  Page 1 has a PageIndex of 0</param>
            <param name="IndentLevel">The indent level in the outline.  An IndentLevel of zero is in the root.  An IndentLevel of N  will be nested inside the most recent previous bookmark of IndentLevel N-1. </param>
        </member>
        <member name="M:IronPdf.PdfOutline.InsertBookMark(System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Insert a bookmark at the start of the document outline.
            </summary>
            <param name="Position">The position of the bookmark in the BookMark list.</param>
            <param name="Text">The display text for the link.</param>
            <param name="PageIndex">The zero based page number to link to.  E.g.  Page 1 has a PageIndex of 0</param>
            <param name="IndentLevel">The indent level in the outline.  An IndentLevel of zero is in the root.  An IndentLevel of N  will be nested inside the most recent previous bookmark of IndentLevel N-1.</param>
        </member>
        <member name="P:IronPdf.PdfOutline.BookMarkList">
            <summary>
            Gets the full list of current outline book marks.
            </summary>
            <value>
            The PDF documents full collection of bookmarks.
            </value>
        </member>
        <member name="M:IronPdf.PdfOutline.Clean">
            <summary>
            Removes all existing bookmarks from the PDF
            </summary>
        </member>
        <member name="T:IronPdf.PdfBookMark">
            <summary>
            Represents a PDF bookmark as seen in the sidebar of PDF reader software to help user's navigate. 
            </summary>
        </member>
        <member name="F:IronPdf.PdfBookMark.IndentLevel">
            <summary>
            The indent level of the bookmark in the outline.
            <para>An indent level of 0 represents a bookmark in the root.  A bookmark of N will be nested inside the most recent previous bookmark of IndentLevel N-1. </para></summary>
        </member>
        <member name="F:IronPdf.PdfBookMark.Text">
            <summary>
            The display text of the bookmark
            </summary>
        </member>
        <member name="P:IronPdf.PdfBookMark.PageIndex">
            <summary>
            The zero based page number that the bookmark links to.
            </summary>
            <value>
            The index of the page.
            </value>
        </member>
        <member name="F:IronPdf.PdfBookMark.PageID" />
        <member name="T:IronPdf.HtmlStamp">
            <summary>
            Class HtmlStamp.  Used With the <see cref="M:IronPdf.PdfDocument.StampHTML(IronPdf.HtmlStamp)" /> methods to edit PDF documents by 'stamping' additional content into the foreground or background.
            </summary>
        </member>
        <member name="M:IronPdf.HtmlStamp.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:IronPdf.HtmlStamp" /> class.
            </summary>
        </member>
        <member name="M:IronPdf.HtmlStamp.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:IronPdf.HtmlStamp" /> class.
            </summary>
            <param name="Html">The HTML fragment which will be stamped onto your PDF.</param>
        </member>
        <member name="M:IronPdf.HtmlStamp.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:IronPdf.HtmlStamp" /> class.
            </summary>
            <param name="Html">The HTML fragment which will be stamped onto your PDF.</param>
            <param name="WidthInMM">The width of the stamp in mm.</param>
            <param name="HeightInMM">The height  of the stamp in mm.</param>
        </member>
        <member name="F:IronPdf.HtmlStamp.Width">
            <summary>
            The width of the stamp in mm.  Stamps can not automatically detect their own size based on their content.
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.Height">
            <summary>
            The height of the stamp in mm.  Stamps can not automatically detect their own size based on their content.
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.Html">
            <summary>
            The HTML fragment which will be stamped onto your PDF.  All external  references to javascript, CSS and image files will be relative to <see cref="F:IronPdf.HtmlStamp.HtmlBaseUrl" />.
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.Top">
            <summary>
            The position of the stamp from the Top edge of the PDF document in mm.  If Top or Bottom is not set, the stamp will be vertically centered in the document. 
            </summary>f
        </member>
        <member name="F:IronPdf.HtmlStamp.Bottom">
            <summary>
            The position of the stamp from the Bottom edge  of the PDF document in mm.  If Top or Bottom is not set, the stamp will be vertically centered in the document. 
            </summary>f
        </member>
        <member name="F:IronPdf.HtmlStamp.Left">
            <summary>
            The position of the stamp from the Left of the PDF document in mm.  If Left or Right is not set, the stamp will be horizontally centered in the document. 
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.Right">
            <summary>
            The position of the stamp from the Right of the PDF document in mm.  If Left or Right is not set, the stamp will be horizontally centered in the document. 
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.Opacity">
            <summary>
            Allows the stamp to be transparent. 0 is invisible, 100 if fully opaque.
            </summary>
        </member>
        <member name="P:IronPdf.HtmlStamp.Opactity">
            <exclude />
        </member>
        <member name="F:IronPdf.HtmlStamp.Rotation">
            <summary>
            Rotates the stamp clockwise from 0 to 360 degrees as specified.
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.Hyperlink">
            <summary>
            Makes the entire stamp link to a web hyperlink. Note that HTML links created by &lt;a href=''&gt; tags are not reserved by stamping.
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.AutoCenterStampContentOnStampCanvas">
            <summary>
            The automatic centers stamp content within stamp canvas as defined by Width and Height.
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.HtmlBaseUrl">
            <summary>
            The HTML base URL for which references to external CSS, Javascript and Image files will be relative.
            <para>A trick to make references relative to a your project file is <code>HtmlBaseUrl = new Uri(System.Reflection.Assembly.GetEntryAssembly().Location).AbsoluteUri</code></para></summary>
        </member>
        <member name="T:IronPdf.HtmlStamp.StampLayer">
            <summary>
             Defines if a stamp should be placed behind or on-top of existing PDF contents.
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.StampLayer.BehindExistingPDFContent">
            <summary>
            Stamp in the background
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.StampLayer.OnTopOfExistingPDFContent">
            <summary>
            Stamp in the foreground
            </summary>
        </member>
        <member name="F:IronPdf.HtmlStamp.ZIndex">
            <summary>
             Defines if this stamp should be placed behind or on-top of existing PDF contents.
            </summary>
        </member>
        <member name="T:IronPdf.Forms.NamespaceDoc">
            <summary>
            IronPDF namespace for creating, reading and populating user editable forms in PDF documents.
            </summary>
        </member>
        <member name="T:IronPdf.Forms.PdfForm">
            <summary>
            A class represents all user editable form fields in a PDF documents.
            <para>Developers may then pre-populate PDF forms, and also read PDF forms which have been filled in by users.</para></summary>
        </member>
        <member name="F:IronPdf.Forms.PdfForm.Fields">
            <summary>
            The editable fields within this PDF.
            </summary>
            <seealso cref="P:IronPdf.PdfDocument.Form" />
        </member>
        <member name="P:IronPdf.Forms.PdfForm.FieldNames">
            <summary>
             Returns the field name of every editable data field in the PDF.
            </summary>
            <value>
            The field names as an array of strings.
            </value>
        </member>
        <member name="M:IronPdf.Forms.PdfForm.GetFieldByName(System.String)">
            <summary>
            Returns a <see cref="T:IronPdf.Forms.FormField" /> by its name.  This method is fault tolerant and will attempt to match case mistakes and partial field names.
            </summary>
            <param name="FieldName">The name of the field to be edited. This is analogous to the HTML input 'name' attribute when creating a PDF with forms from HTML using IronPDF.</param>
            <returns>A <see cref="T:IronPdf.Forms.FormField" /> object</returns>
        </member>
        <member name="T:IronPdf.Forms.ComboBoxField">
            <summary>
            Represents a combo-box (drop down menu) in a PDF form.
            </summary>
            <seealso cref="T:IronPdf.Forms.FormField" />
        </member>
        <member name="P:IronPdf.Forms.ComboBoxField.SelectedIndex">
            <summary>
            Gets the index of the selected option.
            </summary>
            <value>
            The index of the selected. 0 based.
            </value>
        </member>
        <member name="P:IronPdf.Forms.ComboBoxField.Options">
            <summary>
            Gets the available options for the combo-box in zero based index order.
            </summary>
            <value>
            The option names as strings.
            </value>
        </member>
        <member name="P:IronPdf.Forms.ComboBoxField.Value">
            <summary>
            Gets or sets the text value of the combo-box.
            </summary>
            <value>
            The value as a string.
            </value>
        </member>
        <member name="T:IronPdf.Forms.CheckBoxField">
            <summary>
            Represents a check-box in a PDF form.
            </summary>
            <seealso cref="T:IronPdf.Forms.FormField" />
        </member>
        <member name="P:IronPdf.Forms.CheckBoxField.Value">
            <summary>
            Gets or sets the value of the CheckBoxField as a string.
            </summary>
            <value>
            A typical return value for a checked box is "/Yes", other values mean that the box is not checked.
            </value>
            <seealso cref="P:IronPdf.Forms.CheckBoxField.BooleanValue" />
        </member>
        <member name="P:IronPdf.Forms.CheckBoxField.BooleanValue">
            <summary>
            Gets or sets a value indicating whether the check-box is checked (ticked).
            </summary>
            <value>
                <c>true</c> if checked; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:IronPdf.Forms.TextField">
            <summary>
            Represents an editable text input field in a PDF document.
            </summary>
            <seealso cref="T:IronPdf.Forms.FormField" />
        </member>
        <member name="P:IronPdf.Forms.TextField.Value">
            <summary>
            Gets or sets the text in the text-box.
            </summary>
            <value>
            Text value as a string.
            </value>
        </member>
        <member name="T:IronPdf.Forms.FormField">
            <summary>
            Generic base class from which all PDF Form fields are derived.
            </summary>
        </member>
        <member name="P:IronPdf.Forms.FormField.Name">
            <summary>
            Gets the ID name of this field.
            </summary>
            <value>
            The name as a string.
            </value>
            <seealso cref="M:IronPdf.Forms.PdfForm.GetFieldByName(System.String)" />
        </member>
        <member name="P:IronPdf.Forms.FormField.Value">
            <summary>
            Gets the value of the editable PDF field.
            </summary>
            <value>
            The value.
            </value>
        </member>
        <member name="M:IronPdf.Forms.FormField.ToString">
            <summary>
            Returns the value of this field.
            </summary>
            <returns>
            The value of this field.
            </returns>
        </member>
        <member name="T:IronPdf.PdfPrintOptions">
            <summary>
            PDF output options for IronPdf.  
            Specifies options such as Paper-Size, DPI, Headers and Footers.  
            </summary>
        </member>
        <member name="P:IronPdf.PdfPrintOptions.ViewPortWidth">
            <summary>
            Defines a virtual screen width used to render HTML to PDF in IronPdf. Measured in pixels.
            <para>Viewport size is important in modern responsive HTML5 + CSS3 websites (e.g. Bootstrap framework websites) because the rendering and order of elements on the screen is dependent on viewport size. </para><para>The default viewport is 1280px wide by 1024px high to ensure the desktop version of a website is rendered unless otherwise specified.   Smaller sizes (particularly width) will render responsive versions of many website</para></summary>
        </member>
        <member name="P:IronPdf.PdfPrintOptions.ViewPortHeight">
            <summary>
            Defines a virtual screen height used to render HTML to PDF in IronPdf. Measured in pixels.
            <para>Viewport size is important in modern responsive HTML5 + CSS3 websites (e.g. Bootstrap framework websites) because the rendering and order of elements on the screen is dependent on viewport size. </para><para>The default viewport is 1280px wide by 1024px high to ensure the desktop version of a website is rendered unless otherwise specified.   Smaller sizes (particularly width) will render responsive versions of many websites.</para></summary>
        </member>
        <member name="T:IronPdf.PdfPrintOptions.PdfPaperSize">
            <summary>
            Defines the target paper size the PDF will use of pagination.  Relates to real-world paper-sizes.
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Letter">
            8.5in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Legal">
            8.5in x 14in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A4">
            210mm x 297mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.CSheet">
            17in x 22in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.DSheet">
            22in x 34in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.ESheet">
            34in x 44in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.LetterSmall">
            8.5in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Tabloid">
            11in x 17in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Ledger">
            17in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Statement">
            5.5in x 8.5in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Executive">
            7.25in x 10.5in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A3">
            297mm x 420mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A4Small">
            210mm x 297mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A5">
            148mm x 210mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B4">
            250mm x 353mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B5">
            176mm x 250mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Folio">
            8.5in x 13in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Quarto">
            215mm x 275mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Standard10x14">
            10in x 14in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Standard11x17">
            11in x 17in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Note">
            8.5in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Number9Envelope">
            3.875in x 8.875in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Number10Envelope">
            4.125in x 9.5in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Number11Envelope">
            4.5in x 10.375in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Number12Envelope">
            4.75in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Number14Envelope">
            5in x 11.5in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.DLEnvelope">
            110mm x 220mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.C5Envelope">
            162mm x 229mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.C3Envelope">
            324mm x 458mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.C4Envelope">
            229mm x 324mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.C6Envelope">
            114mm x 162mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.C65Envelope">
            114mm x 229mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B4Envelope">
            250mm x 353mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B5Envelope">
            176mm x 250mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B6Envelope">
            176mm x 125mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.ItalyEnvelope">
            110mm x 230mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.MonarchEnvelope">
            3.875in x 7.5in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PersonalEnvelope">
            3.625in x 6.5in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.USStandardFanfold">
            14.875in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.GermanStandardFanfold">
            8.5in x 12in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.GermanLegalFanfold">
            8.5in x 13in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.IsoB4">
            250mm x 353mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.JapanesePostcard">
            100mm x 148mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Standard9x11">
            9in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Standard10x11">
            10in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Standard15x11">
            15in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.InviteEnvelope">
            220mm x 220mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.LetterExtra">
            9.275in x 12in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.LegalExtra">
            9.275in x 15in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.TabloidExtra">
            11.69in x 18in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A4Extra">
            236mm x 322mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.LetterTransverse">
            8.275in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A4Transverse">
            210mm x 297mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.LetterExtraTransverse">
            9.275in x 12in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.APlus">
            227mm x 356mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.BPlus">
            305mm x 487mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.LetterPlus">
            8.5in x 12.69in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A4Plus">
            210mm x 330mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A5Transverse">
            148mm x 210mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B5Transverse">
            182mm x 257mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A3Extra">
            322mm x 445mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A5Extra">
            174mm x 235mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B5Extra">
            201mm x 276mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A2">
            420mm x 594mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A3Transverse">
            297mm x 420mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A3ExtraTransverse">
            322mm x 445mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.JapaneseDoublePostcard">
            200mm x 148mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A6">
            105mm x 148mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.LetterRotated">
            11in x 8.5in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A3Rotated">
            420mm x 297mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A4Rotated">
            297mm x 210mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A5Rotated">
            210mm x 148mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B4JisRotated">
            364mm x 257mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B5JisRotated">
            257mm x 182mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.JapanesePostcardRotated">
            148mm x 100mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.JapaneseDoublePostcardRotated">
            148mm x 200mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.A6Rotated">
            148mm x 105mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B6Jis">
            128mm x 182mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.B6JisRotated">
            182mm x 128mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Standard12x11">
            12in x 11in
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Prc16K">
            146mm x 215mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Prc32K">
            97mm x 151mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Prc32KBig">
            97mm x 151mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber1">
            102mm x 165mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber2">
            102mm x 176mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber3">
            125mm x 176mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber4">
            110mm x 208mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber5">
            110mm x 220mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber6">
            120mm x 230mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber7">
            160mm x 230mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber8">
            120mm x 309mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber9">
            229mm x 324mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber10">
            324mm x 458mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Prc16KRotated">
            146mm x 215mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Prc32KRotated">
            97mm x 151mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Prc32KBigRotated">
            97mm x 151mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber1Rotated">
            165mm x 102mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber2Rotated">
            176mm x 102mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber3Rotated">
            176mm x 125mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber4Rotated">
            208mm x 110mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber5Rotated">
            220mm x 110mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber6Rotated">
            230mm x 120mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber7Rotated">
            230mm x 160mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber8Rotated">
            309mm x 120mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber9Rotated">
            324mm x 229mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.PrcEnvelopeNumber10Rotated">
            458mm x 324mm
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperSize.Custom">
            Set using PdfPrintOptions.SetCustomPaperSizeInInches or 
        </member>
        <member name="F:IronPdf.PdfPrintOptions.Header">
            <summary>
            Sets the header content for every PDF page as Html or String.  Supports 'mail-merge'.
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.Footer">
            <summary>
            Sets the footer content for every PDF page as Html or String.  Supports 'mail-merge'.
            </summary>
        </member>
        <member name="T:IronPdf.PdfPrintOptions.PdfPaperOrientation">
            <summary>
             Paper Orientation
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperOrientation.Portrait">
            Paper is oriented vertically
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfPaperOrientation.Landscape">
            Paper is oriented horizontally 
        </member>
        <member name="F:IronPdf.PdfPrintOptions.InputEncoding">
            <summary>
            The input character encoding as a string;
            </summary>
        </member>
        <member name="M:IronPdf.PdfPrintOptions.SetCustomPaperSize(System.Double,System.Double)">
            <summary>
            Sets the size of the custom paper. Depreciated.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="M:IronPdf.PdfPrintOptions.SetCustomPaperSizeinMilimeters(System.Double,System.Double)">
            <summary>
            Set an output paper size for PDF pages.  Dimensions are in millimeters. 
             </summary>
            <param name="width">Custom paper width in millimeters.</param>
            <param name="height">&gt;Custom paper height in millimeters.</param>
        </member>
        <member name="M:IronPdf.PdfPrintOptions.SetCustomPaperSizeInInches(System.Double,System.Double)">
            <summary>
            Set an output paper size for PDF pages.  Dimensions are in Inches. 
             </summary>
            <param name="width">Custom paper width in Inches.</param>
            <param name="height">&gt;Custom paper height in Inches.</param>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.Zoom">
            <summary>
            The zoom level in %.  Enlarges the rendering size of Html documents.
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.DPI">
            <summary>
            Printing output DPI.  300 is standard for most print jobs.  Higher resolutions produce clearer images and text, but also larger PDF files.
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.GrayScale">
            <summary>
            Outputs a black-and-white PDF
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.CustomCssUrl">
            <summary>
            Allows a custom CSS style-sheet  to be applied to Html before rendering.  May be a local file path,  or remote url.
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.JpegQuality">
            <summary>
            Quality of any image that must be re-sampled. 0-100
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.MarginLeft">
            <summary>
            Paper margin in millimeters.  Set to zero for border-less and commercial printing applications.
             </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.MarginBottom">
            <summary>
            Paper margin in millimeters.  Set to zero for border-less and commercial printing applications.
             </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.MarginTop">
            <summary>
            Paper margin in millimeters.  Set to zero for border-less and commercial printing applications.  
             </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.MarginRight">
            <summary>
            Paper margin in millimeters.  Set to zero for border-less and commercial printing applications.
             </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PaperSize">
            <summary>
            Set an output paper size for PDF pages.  System.Drawing.Printing.PaperKind. <para>Use SetCustomPaperSize(int width, int height) for custom sizes.</para></summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PaperOrientation">
            <summary>
            The PDF paper orientation.  
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PrintHtmlBackgrounds">
            <summary>
             Prints background-colors and images from Html
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.CssMediaType">
            <summary>
             Enables Media="screen" CSS Styles  and StyleSheets
            <para>Note: By setting AllowScreenCss=false, IronPdf prints using CSS for media="print" only.</para></summary>
        </member>
        <member name="T:IronPdf.PdfPrintOptions.PdfCssMediaType">
            <summary>
            Defines which style-sheet should be rendered.   'Print' or 'Screen'.  This matches the CSS3 Media Queries standard.
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfCssMediaType.Print">
            Renders as expected for a web browser.
        </member>
        <member name="F:IronPdf.PdfPrintOptions.PdfCssMediaType.Screen">
            Ignores 'Print' styles and includes additional 'Screen' styles where available.
        </member>
        <member name="F:IronPdf.PdfPrintOptions.EnableJavaScript">
            <summary>
             Enables JavaScript and Json to be executed  before the page is rendered.  Ideal for printing from Ajax / Angular Applications.
            <para>Also see RenderDelay - <see cref="F:IronPdf.PdfPrintOptions.RenderDelay" /></para></summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.CreatePdfFormsFromHtml">
            <summary>
             Turns all Html forms elements into editable PDF forms.
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.Title">
            <summary>
             PDF Document Name and Title meta-data.  Not required.
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.FitToPaperWidth">
            <summary>
             Where possible, fits the PDF content to 1 page width.
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.RenderDelay">
            <summary>
                Milliseconds to wait after Html is rendered before printing.  This can use useful when
                considering the rendering of JavaScript, Ajax or animations.
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.FirstPageNumber">
            <summary>
             First page number to be used in PDF headers and footers.
            </summary>
        </member>
        <member name="T:IronPdf.PdfPrintOptions.ViewPortSize">
            <summary>
            Defines a virtual screen size used to render HTML to PDF in IronPdf.
            <para>Viewport size is important in modern responsive HTML5 + CSS3 websites (e.g. Bootstrap framework websites) because the rendering and order of elements on the screen is dependent on viewport size. </para><para>The default viewport is 1280px wide by 1024px high to ensure the desktop version of a website is rendered unless otherwise specified.   Smaller sizes (particularly width) will render responsive versions of many websites.</para><para>See http://viewportsizes.com/ to find viewport sizes for common desktop, tablet and mobile devices.</para></summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.ViewPortSize.Width">
            <summary>
                <para>The width of the 'virtual browser window' into which your HTML is rendered.  Measured in pixels. </para>
                <para>The default of 1280px represents a large desktop browser window.</para>
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.ViewPortSize.Height">
            <summary>The height of the 'virtual browser window' into which your HTML is rendered.  Measured in pixels. 
            <para>The default of 1024px represents a large desktop browser window.</para></summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.ViewPortSize.LargeDesktop">
            <summary>
                <para>1280px by 1024px</para>
                <para>A default ViewportSize for large desktop devices.</para>
                <para>Corresponds to the Bootstrap responsive class .col-lg-$</para>
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.ViewPortSize.Desktop">
            <summary>
                <para>1024px by 768px</para>
                <para>A default ViewportSize for smaller desktop and notebook devices. Also renders the same as an iPad in portrait mode.</para>
                <para>Corresponds to the Bootstrap responsive class .col-md-$</para>
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.ViewPortSize.Tablet">
            <summary>
                <para>800px by 1280px</para>
                <para>A default ViewportSize for Tablet devices.</para>
                <para>Corresponds to the Bootstrap responsive class .col-sm-$</para>
            </summary>
        </member>
        <member name="F:IronPdf.PdfPrintOptions.ViewPortSize.Phone">
            <summary>
                <para>480px by 320px</para>
                <para>A default ViewportSize for Phone and small mobile devices</para>
                <para>Corresponds to the Bootstrap responsive class .col-xs-$</para>
            </summary>
        </member>
        <member name="M:IronPdf.PdfPrintOptions.ViewPortSize.ToString">
            <summary>
                <para>String representation of viewport size. </para>
                <para>E.g. "1280x1024"</para>
            </summary>
        </member>
        <member name="T:IronPdf.License">
            <summary>
             Allows IronPdf license keys to be applied globally across an application.
            </summary>
        </member>
        <member name="F:IronPdf.License.LicenseKey">
            <summary>
             Removes watermarks. Get Licensed at http://ironpdf.com/license
             A License key can also be added to Web.Config or App.Config as IronPdf.LicenseKey
            </summary>
        </member>
        <member name="M:IronPdf.License.IsValidLicense(System.String)">
            <summary>
            Determines whether a license key is valid.
            </summary>
            <param name="LicenseKey">IronPDF license key as a string</param>
            <returns>True if the license key given is valid.</returns>
        </member>
        <member name="T:IronPdf.PdfResource">
            <exclude />
        </member>
        <member name="M:IronPdf.PdfResource.#ctor(System.Byte[],System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.PdfResource.#ctor(System.String,System.String)">
            <exclude />
        </member>
        <member name="M:IronPdf.PdfResource.#ctor(System.IO.Stream,System.String)">
            <exclude />
        </member>
        <member name="T:IronPdf.ImageType">
            <summary>
             An Image File Type Enumeration used to select image file formats when converting PDF documents to images.
             Also see: <see cref="M:IronPdf.PdfDocument.RasterizeToImageFiles(System.String,IronPdf.ImageType,System.Int32)" /></summary>
        </member>
        <member name="F:IronPdf.ImageType.Default">
            <summary>
            Default file type.  WIll save images in a Bitmap file type unless a file pattern ends in an image file format such as .png or .jpeg
            </summary>
        </member>
        <member name="F:IronPdf.ImageType.Bitmap">
            <summary>
            PDF pages will be rendered to windows Bitmap image files.
            </summary>
        </member>
        <member name="F:IronPdf.ImageType.Jpeg">
            <summary>
            PDF pages will be rendered to JPEG image files.
            </summary>
        </member>
        <member name="F:IronPdf.ImageType.Png">
            <summary>
            PDF pages will be rendered to PNG (Portable Network Graphics) image files.
            </summary>
        </member>
        <member name="F:IronPdf.ImageType.Gif">
            <summary>
            PDF pages will be rendered to non-animated GIF image files.
            The GIF
            </summary>
        </member>
        <member name="F:IronPdf.ImageType.Tiff">
            <summary>
            PDF pages will be rendered to TIFF image files.
            </summary>
        </member>
        <member name="T:IronPdf.PdfSignature">
            <summary>
            A class that represents a PDF signing certificate (.PFX or .p12) format which can be used to digitally sign a PDF. This protecting it from alteration.
            <para>Not implemented in .Net Core</para></summary>
        </member>
        <member name="M:IronPdf.PdfSignature.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:IronPdf.PdfSignature" /> class using a .pfx or .p12 digital signature file.
            </summary>
            <param name="FilePathToCertificate">The file path to certificate.</param>
            <param name="Password">The certificate's password.</param>
        </member>
        <member name="M:IronPdf.PdfSignature.#ctor(System.Byte[],System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:IronPdf.PdfSignature" /> class.
            </summary>
            <param name="CertificateRawData">The certificate as a binary data (byte array).</param>
            <param name="Password">The certificate's password.</param>
        </member>
        <member name="M:IronPdf.PdfSignature.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Initializes a new instance of the <see cref="T:IronPdf.PdfSignature" /> class.
            </summary>
            <param name="ExportableNativeCertificate">The exportable native certificate as a System.Security.Cryptography.X509Certificates.X509Certificate2.</param>
        </member>
        <member name="F:IronPdf.PdfSignature.SigningReason">
            <summary>
            The reason the PDF was signed (optional).
            </summary>
        </member>
        <member name="F:IronPdf.PdfSignature.SigningLocation">
            <summary>
            The physical location the PDF was signed (optional).
            </summary>
        </member>
        <member name="F:IronPdf.PdfSignature.SigningContact">
            <summary>
            The contact person or email address for signing related inquiries (optional).
            </summary>
        </member>
        <member name="F:IronPdf.PdfSignature.SignatureImage">
            <summary>
            A visual image for the sign, often a PNG of a human signature or company stamp (optional).
            <para>This appends a visual signature in addition to  cryptographic signing.</para><seealso cref="M:IronPdf.PdfSignature.LoadSignatureImageFromFile(System.String)" /><seealso cref="M:IronPdf.PdfSignature.LoadSignatureImageFromStream(System.IO.Stream)" /></summary>
        </member>
        <member name="M:IronPdf.PdfSignature.LoadSignatureImageFromFile(System.String)">
            <summary>
            Loads a signature image from an image file.
            This appends a visual signature in addition to  cryptographic signing.
            </summary>
            <param name="FilePath">The file path.</param>
        </member>
        <member name="M:IronPdf.PdfSignature.LoadSignatureImageFromStream(System.IO.Stream)">
            <summary>
            Loads a signature image from a stream.
            This appends visual signature in addition to  cryptographic signing.
            </summary>
            <param name="Stream">The image file as a stream.</param>
        </member>
        <member name="M:IronPdf.PdfSignature.SignPdfFile(System.String,System.Boolean)">
            <summary>
            Signs an existing PDF file.
            </summary>
            <param name="PdfFilePath">The PDF file path.</param>
            <param name="RemoveOldSignatures">if set to <c>true</c> old digital signatures are removed to ensure signing validity.</param>
            <returns>
                <c>true</c> if successful.
            </returns>
        </member>
        <member name="F:IronPdf.PdfSignature.SignatureDate">
            <summary>
            The date and time of the digital signature. 
            If left null, the signature will be timestamped at the millisecond that the PdfDocument is saved to Disk or Stream.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfArrayExtensions">
            <summary>
            Extension methods for the PdfSharp library PdfArray object
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArrayExtensions.Dump(PdfSharp.Pdf.PdfArray,System.Action{PdfSharp.Pdf.PdfItem})">
            <summary>
            Helper method for inspecting the contents of the dictionary / dumping the contents to the specified output.
            </summary>
            <param name="array">The array to dump.</param>
            <param name="output">The optional output method. If not provided, then the output will be directed to standard output.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArrayExtensions.IsEmpty(PdfSharp.Pdf.PdfArray)">
            <summary>
            Checks to see if the specified PdfArray is empty.
            </summary>
            <param name="array">The array to inspect.</param>
            <returns>True if empty (or null), false if contains 1 or more elements.</returns>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionaryExtensions">
            <summary>
            Extension methods for the PdfSharp library PdfDictionary object for exporting images.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.Dump(PdfSharp.Pdf.PdfDictionary,System.Action{PdfSharp.Pdf.PdfName,PdfSharp.Pdf.PdfItem})">
            <summary>
            Helper method for inspecting the contents of the dictionary / dumping the contents to the specified output.
            </summary>
            <param name="dictionary">The dictionary to dump.</param>
            <param name="output">The optional output method. If not provided, then the output will be directed to standard output.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.IsImage(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Checks to see if the specified dictionary contains an image.
            </summary>
            <param name="dictionary">The dictionary to inspect.</param>
            <returns>True if the dictionary contains an image, false if otherwise.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.ImageFromDCTDecode(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Retrieves the specified dictionary object as an object encoded with DCTDecode filter (JPEG).
            </summary>
            <param name="dictionary">The dictionary to extract the object from.</param>
            <returns>The image retrieve from the dictionary. If not found or an invalid image, then null is returned.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.GetPixelFormat(PdfSharp.Pdf.PdfDictionaryExtensions.PdfColorSpace,System.Int32,System.Boolean)">
            <summary>
            Gets the PixelFormat for the specified bits per pixel (bpp) or color depth.
            </summary>
            <param name="colorSpace">The color-space of the image.</param>
            <param name="bitsPerPixel">The number of bits per pixel.</param>
            <param name="isIndexed">Optional parameters indicating if the bits are indexed. If indexed, then bitsPerPixel must be less than or equal to 8. Defaults to false.</param>
            <returns>The pixel format to read the data from.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.WriteTiffTag(System.IO.Stream,BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.TiffType,System.UInt32,System.UInt32)">
            <summary>
            Writes the specified TIFF tag data to the stream.
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="tag">The <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" /> to write.</param>
            <param name="type">The <see cref="T:BitMiracle.LibTiff.Classic.TiffType" /> being written.</param>
            <param name="count">The number of values being written.</param>
            <param name="value">The actual value to be written.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.GetTiffImageBufferFromCCITTFaxDecode(PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryImageMetaData,System.Byte[])">
            <summary>
            Prepends a proper TIFF image header to the CCITTFaxDecode image data.
            </summary>
            <param name="imageData">The meta-data about the image.</param>
            <param name="image">The original compressed image.</param>
            <returns>A properly formatted TIFF header and the compressed image data.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.ImageFromCCITTFaxDecode(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Retrieves the specified dictionary object as an object encoded with CCITTFaxDecode filter (TIFF).
            </summary>
            <param name="dictionary">The dictionary to extract the object from.</param>
            <returns>The image retrieve from the dictionary. If not found or an invalid image, then null is returned.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.ImageFromFlateDecode(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Retrieves the specified dictionary object as an object encoded with FlateDecode filter.
            </summary>
            <remarks>
            FlateDecode a commonly used filter based on the zlib/deflate algorithm (a.k.a. gzip, but not zip) 
            defined in RFC 1950 and RFC 1951; introduced in PDF 1.2; it can use one of two groups of predictor 
            functions for more compact zlib/deflate compression: Predictor 2 from the TIFF 6.0 specification 
            and predictors (filters) from the PNG specification (RFC 2083)
            </remarks>
            <param name="dictionary">The dictionary to extract the object from.</param>
            <returns>The image retrieve from the dictionary. If not found or an invalid image, then null is returned.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.ConvertRGBStreamToBGR(System.Byte[])">
            <summary>
            Converts an RGB ordered stream to BGR ordering. 
            </summary>
            <remarks>
            A PDF /DeviceRGB stream is stored in RGB ordering, however the .NET Image libraries expect BGR ordering.
            </remarks>
            <param name="stream">The input stream to reorder. The input array will be modified inline by this procedure.</param>
            <returns>Return the modified input stream.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.ToImage(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Retrieves the image from the specified dictionary.
            </summary>
            <param name="dictionary">The dictionary to extract the image from.</param>
            <returns>Returns the image if valid, otherwise if the dictionary does not contain a valid image, then null is returned.</returns>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionaryExtensions.PdfColorSpace">
            <summary>
            Internal class for working with a colorspace.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfColorSpace.IsCMYK">
            <summary>Checks to see if the colorspace supports CYMK colors.</summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfColorSpace.IsRGB">
            <summary>Checks to see if the colorspace supports RGB colors.</summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfColorSpace.IsIndexed">
            <summary>Checks to see if the colorspace is an indexed colorspace.</summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace">
            <summary>
            Internal class for working with an indexed colorspace.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.Colors">
            <summary>The number of colors.</summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.IsIndexed">
            <summary>Checks to see if the colorspace is an indexed colorspace.</summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.#ctor(System.Int32)">
            <param name="colors">The number of colors.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.GetRawPalette(PdfSharp.Pdf.PdfItem)">
            <summary>
            Retrieves the raw data for the colorspace.
            </summary>
            <returns>The raw data from the PdfArray of PdfReference.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.GetRawPalette(PdfSharp.Pdf.PdfArray)">
            <summary>
            Retrieves the raw data for the colorspace.
            </summary>
            <returns>The raw data from the PdfArray of PdfReference.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.GetRawPalette(PdfSharp.Pdf.Advanced.PdfReference)">
            <summary>
            Retrieves the raw data for the colorspace.
            </summary>
            <returns>The raw data from the PdfArray of PdfReference.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.CreateColorPalette(System.Int32)">
            <summary>
            Creates an empty color palette with the required number of colors.
            </summary>
            <param name="colors">The number of colors to create the palette with.</param>
            <returns>An empty <see cref="T:System.Drawing.Imaging.ColorPalette" /> with the required number of colors.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.CreateColorPalette(System.Drawing.Color[])">
            <summary>
            Creates an color palette filled with the specified colors.
            </summary>
            <param name="colors">The colors to fill / create the palette with.</param>
            <returns>An empty <see cref="T:System.Drawing.Imaging.ColorPalette" /> with the required number of colors.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.CreateColorPalette(System.Collections.Generic.IEnumerable{System.Drawing.Color})">
            <summary>
            Creates an color palette filled with the specified colors.
            </summary>
            <param name="colors">The colors to fill / create the palette with.</param>
            <returns>An empty <see cref="T:System.Drawing.Imaging.ColorPalette" /> with the required number of colors.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.CreateColorPalette">
            <summary>
            Creates an empty color palette with the required number of colors.
            </summary>
            <returns>An empty <see cref="T:System.Drawing.Imaging.ColorPalette" /> with the required number of colors.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedColorSpace.ToColorPalette">
            <summary>
            Converts the specified PDF colorspace to a Color space.
            </summary>
            <returns>The ColorPalette representing the raw palette.</returns>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedRGBColorSpace">
            <summary>
            Internal class for working with an indexed RGB colorspace.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedRGBColorSpace.Palette">
            <summary>The color palette for the colorspace.</summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedRGBColorSpace.IsRGB">
            <summary>Checks to see if the colorspace supports RGB colors.</summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedRGBColorSpace.#ctor(PdfSharp.Pdf.PdfItem,System.Int32)">
            <param name="colorSpace">The pdfItem representing the color space.</param>
            <param name="colors">The number of colors.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedRGBColorSpace.GetColorPalette">
            <summary>
            Retrieves the color palette.
            </summary>
            <returns>The color palette for the indexed image.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfIndexedRGBColorSpace.ToColorPalette">
            <summary>
            Converts the specified PDF colorspace to a Color space.
            </summary>
            <returns>The ColorPalette representing the raw palette.</returns>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionaryExtensions.PdfRGBColorSpace">
            <summary>
            Internal class for working with an RGB colorspace.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfRGBColorSpace.IsRGB">
            <summary>Checks to see if the colorspace supports RGB colors.</summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionaryExtensions.PdfGrayColorSpace">
            <summary>
            Internal class for working with a Gray colorspace
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfGrayColorSpace.ToColorPalette(System.Int32)">
            <summary>
            Converts the specified PDF colorspace to a Color space.
            </summary>
            <returns>The ColorPalette representing the raw palette.</returns>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionaryExtensions.PdfCMYKColorSpace">
            <summary>
            Internal class for working with a CMYK colorspace.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfCMYKColorSpace.IsCMYK">
            <summary>Checks to see if the colorspace supports CMYKcolors.</summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryColorSpace">
            <summary>
            Internal class for extracting colorspace information from a dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryColorSpace.GetColorSpaceName(PdfSharp.Pdf.PdfItem)">
            <summary>
            Get's the colorspace name for the specified item.
            </summary>
            <param name="colorSpace">The colorspace to inspect.</param>
            <returns>The PdfName of the specified item.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryColorSpace.Parse(PdfSharp.Pdf.PdfItem)">
            <summary>
            Parse the colorspace information from the specified colorspace item.
            </summary>
            <param name="colorSpace">The external color space object to parse.</param>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryImageMetaData">
            <summary>
            Internal class for extracting meta data from a dictionary.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryImageMetaData.Length">
            <summary>The total length or size of the image data.</summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryImageMetaData.Height">
            <summary>The height of the stored image.</summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryImageMetaData.Width">
            <summary>The width of the stored image.</summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryImageMetaData.BitsPerPixel">
            <summary>The number of bits used to represent 1 pixel in the image. Commonly abbreviated as "bpp".</summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryImageMetaData.ColorSpace">
            <summary>The colorspace information for the image.</summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryImageMetaData.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <param name="dictionary">The dictionary object o parse.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryImageMetaData.Initialize(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Initializes the item based on the specified PdfDictionary.
            </summary>
            <param name="dictionary">The dictionary to use for initialization.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.PdfDictionaryImageMetaData.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.CCITTFaxDecodeParameters.K">
            <summary>
            A code identifying the encoding scheme used: 
            
             less than 0 = Pure two-dimensional encoding (Group 4) 
             0 = Pure one-dimensional encoding (Group 3, 1-D) 
             more than 0 = Mixed one- and two-dimensional encoding (Group 3, 2-D), 
                  in which a line encoded one-dimensionally can be followed 
                  by at most K − 1 lines encoded two-dimensionally 
            
            The filter distinguishes among negative, zero, and positive values of 
            K to determine how to interpret the encoded data; however, it does 
            not distinguish between different positive K values. Default value: 0
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.CCITTFaxDecodeParameters.EndOfLine">
            <summary>
            A flag indicating whether end-of-line bit patterns are required to be 
            present in the encoding. The CCITTFaxDecode filter always accepts 
            end-of-line bit patterns, but requires them only if EndOfLine is true. 
            Default value: false.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.CCITTFaxDecodeParameters.EncodedByteAlign">
            <summary>
            A flag indicating whether the filter expects extra 0 bits before each
            encoded line so that the line begins on a byte boundary. If true, the
            filter skips over encoded bits to begin decoding each line at a byte
            boundary. If false, the filter does not expect extra bits in the 
            encoded representation. Default value: false.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.CCITTFaxDecodeParameters.Columns">
            <summary>
            The width of the image in pixels. If the value is not a multiple of 8,
            the filter adjusts the width of the unencoded image to the next 
            multiple of 8 so that each line starts on a byte boundary. 
            Default value: 1728
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.CCITTFaxDecodeParameters.Rows">
            <summary>
            The height of the image in scan lines. If the value is 0 or absent, the
            image’s height is not predetermined, and the encoded data must be
            terminated by an end-of-block bit pattern or by the end of the filter’s 
            data. Default value: 0.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.CCITTFaxDecodeParameters.EndOfBlock">
            <summary>
            A flag indicating whether the filter expects the encoded data to be 
            terminated by an end-of-block pattern, overriding the Rows parameter.
            If false, the filter stops when it has decoded the number of lines 
            indicated by Rows or when its data has been exhausted, whichever occurs first.
            The end-of-block patter is the CCITT end-of-facsimile-block (EOFB) or
            return-to-control (RTC_ appropriate for the K parameter. 
            Default value: true.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.CCITTFaxDecodeParameters.BlackIs1">
            <summary>
            A flag indicating whether 1 bits are to be interpreted as black pixels 
            and 0 bits as white pixels, the reverse of the normal PDF convention 
            for image data. Default value: false.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionaryExtensions.CCITTFaxDecodeParameters.DamagedRowsBeforeError">
            <summary>
            The number of damaged rows of data to be tolerated before an error
            occurs. This entry applies only if EndOfLine is true and K is 
            non-negative. Tolerating a damaged row means locating its end in the
            encoded data by searching for an EndOfLine pattern and then 
            substituting decoded data from the previous row if the previous row
            was not damaged, or a white scan line if the previous row was also
            damaged. Default value: 0.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionaryExtensions.CCITTFaxDecodeParameters.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <param name="dictionary">The dictionary element to parse / retrieve.</param>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDocumentExtensions">
            <summary>
            Extension methods for the PdfSharp library PdfItem object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocumentExtensions.GetImages(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Get's all of the images from the specified document.
            </summary>
            <param name="document">The document to extract or retrieve images from.</param>
            <returns>An enumeration of images contained on the page.</returns>
        </member>
        <member name="T:PdfSharp.Pdf.PdfItemExtensions">
            <summary>
            Extension methods for the PdfSharp library PdfItem object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.Get(PdfSharp.Pdf.PdfItem)">
            <summary>
            A helper for a PdfItem that will automatically lookup / fetch the corresponding
            PdfReference item if the item is a PdfReference. If the item is not a PdfItem, 
            then the original item is returned.
            </summary>
            <param name="item">The PdfItem to expand or fetch from.</param>
            <returns>The expanded PdfReference item if a PdfReference, otherwise the original item is returned.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsBoolean(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfBoolean
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to a Boolean.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsDate(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfDate
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to a Date.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsLiteral(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfLiteral
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to a Literal.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsName(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfName
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to a Name.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsNull(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfNull
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to Null.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsNumber(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfNumber
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to Number.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsObject(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfObject
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to Object.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsArray(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfArray
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to Array.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsRectangle(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfRectangle
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to Rectangle.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsReference(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfReference
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to Reference.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItemExtensions.IsString(PdfSharp.Pdf.PdfItem)">
            <summary>
            Checks to see if the PdfItem can be represented as a PdfString
            </summary>
            <param name="item">The item to inspect.</param>
            <returns>True if the item can be converted to String.</returns>
        </member>
        <member name="T:PdfSharp.Pdf.PdfPageExtensions">
            <summary>
            Extension methods for the PdfSharp library PdfItem object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPageExtensions.GetImages(PdfSharp.Pdf.PdfPage,System.Func{PdfSharp.Pdf.PdfPage,System.Int32,System.Drawing.Image,System.Drawing.Image})">
            <summary>
            Get's all of the images from the specified page.
            </summary>
            <param name="page">The page to extract or retrieve images from.</param>
            <param name="filter">An optional filter to perform additional modifications or actions on the image.</param>
            <returns>An enumeration of images contained on the page.</returns>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.CleanFaxData">
            <summary>
            Regenerated line info.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.CLEANFAXDATA tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.CleanFaxData.CLEAN">
            <summary>
            No errors detected.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.CleanFaxData.REGENERATED">
            <summary>
            Receiver regenerated lines.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.CleanFaxData.UNCLEAN">
            <summary>
            Uncorrected errors exist.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.ColorResponseUnit">
            <summary>
            Color curve accuracy.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.COLORRESPONSEUNIT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU10S">
            <summary>
            Tenths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU100S">
            <summary>
            Hundredths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU1000S">
            <summary>
            Thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU10000S">
            <summary>
            Ten-thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU100000S">
            <summary>
            Hundred-thousandths.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Compression">
            <summary>
            Compression scheme.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.COMPRESSION tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.NONE">
            <summary>
            Dump mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTRLE">
            <summary>
            CCITT modified Huffman RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTFAX3">
            <summary>
            CCITT Group 3 fax encoding.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITT_T4">
            <summary>
            CCITT T.4 (TIFF 6 name for CCITT Group 3 fax encoding).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTFAX4">
            <summary>
            CCITT Group 4 fax encoding.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITT_T6">
            <summary>
            CCITT T.6 (TIFF 6 name for CCITT Group 4 fax encoding).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.LZW">
            <summary>
            Lempel-Ziv &amp; Welch.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.OJPEG">
            <summary>
            Original JPEG / Old-style JPEG (6.0).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.JPEG">
            <summary>
            JPEG DCT compression. Introduced post TIFF rev 6.0.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.NEXT">
            <summary>
            NeXT 2-bit RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTRLEW">
            <summary>
            CCITT RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.PACKBITS">
            <summary>
            Macintosh RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.THUNDERSCAN">
            <summary>
            ThunderScan RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8CTPAD">
            <summary>
            IT8 CT w/padding. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8LW">
            <summary>
            IT8 Linework RLE. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8MP">
            <summary>
            IT8 Monochrome picture. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8BL">
            <summary>
            IT8 Binary line art. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.PIXARFILM">
            <summary>
            Pixar companded 10bit LZW. Reserved for Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.PIXARLOG">
            <summary>
            Pixar companded 11bit ZIP. Reserved for Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.DEFLATE">
            <summary>
            Deflate compression.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.ADOBE_DEFLATE">
            <summary>
            Deflate compression, as recognized by Adobe.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.DCS">
            <summary>
            Kodak DCS encoding.
            Reserved for Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.JBIG">
            <summary>
            ISO JBIG.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.SGILOG">
            <summary>
            SGI Log Luminance RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.SGILOG24">
            <summary>
            SGI Log 24-bit packed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.JP2000">
            <summary>
            Leadtools JPEG2000.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.ExtraSample">
            <summary>
            Information about extra samples.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.EXTRASAMPLES tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ExtraSample.UNSPECIFIED">
            <summary>
            Unspecified data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ExtraSample.ASSOCALPHA">
            <summary>
            Associated alpha data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ExtraSample.UNASSALPHA">
            <summary>
            Unassociated alpha data.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FaxMode">
            <summary>
            Group 3/4 format control.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.FAXMODE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.CLASSIC">
            <summary>
            Default, include RTC.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.NORTC">
            <summary>
            No RTC at end of data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.NOEOL">
            <summary>
            No EOL code at end of row.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.BYTEALIGN">
            <summary>
            Byte align row.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.WORDALIGN">
            <summary>
            Word align row.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.CLASSF">
            <summary>
            TIFF Class F.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FileType">
            <summary>
            Subfile data descriptor.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.SUBFILETYPE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FileType.REDUCEDIMAGE">
            <summary>
            Reduced resolution version.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FileType.PAGE">
            <summary>
            One page of many.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FileType.MASK">
            <summary>
            Transparency mask.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FillOrder">
            <summary>
            Data order within a byte.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.FILLORDER tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FillOrder.MSB2LSB">
            <summary>
            Most significant -&gt; least.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FillOrder.LSB2MSB">
            <summary>
            Least significant -&gt; most.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.GrayResponseUnit">
            <summary>
            Gray scale curve accuracy.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.GRAYRESPONSEUNIT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU10S">
            <summary>
            Tenths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU100S">
            <summary>
            Hundredths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU1000S">
            <summary>
            Thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU10000S">
            <summary>
            Ten-thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU100000S">
            <summary>
            Hundred-thousandths.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Group3Opt">
            <summary>
            Options for CCITT Group 3/4 fax encoding.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.GROUP3OPTIONS / TiffTag.T4OPTIONS and
            TiffTag.GROUP4OPTIONS / TiffTag.T6OPTIONS tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.UNKNOWN">
            <summary>
            Unknown (uninitialized).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.ENCODING2D">
            <summary>
            2-dimensional coding.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.UNCOMPRESSED">
            <summary>
            Data not compressed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.FILLBITS">
            <summary>
            Fill to byte boundary.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.InkSet">
            <summary>
            Inks in separated image.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.INKSET tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.InkSet.CMYK">
            <summary>
            Cyan-magenta-yellow-black color.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.InkSet.MULTIINK">
            <summary>
            Multi-ink or hi-fi color.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.JpegColorMode">
            <summary>
            Auto RGB&lt;=&gt;YCbCr convert.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.JPEGCOLORMODE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegColorMode.RAW">
            <summary>
            No conversion (default).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegColorMode.RGB">
            <summary>
            Do auto conversion.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.JpegProc">
            <summary>
            JPEG processing algorithm.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.JPEGPROC tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegProc.BASELINE">
            <summary>
            Baseline sequential.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegProc.LOSSLESS">
            <summary>
            Huffman coded lossless.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.JpegTablesMode">
            <summary>
            Jpeg Tables Mode.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.JPEGTABLESMODE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegTablesMode.NONE">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegTablesMode.QUANT">
            <summary>
            Include quantization tables.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegTablesMode.HUFF">
            <summary>
            Include Huffman tables.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.OFileType">
            <summary>
            Kind of data in subfile.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.OSUBFILETYPE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.OFileType.IMAGE">
            <summary>
            Full resolution image data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.OFileType.REDUCEDIMAGE">
            <summary>
            Reduced size image data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.OFileType.PAGE">
            <summary>
            One page of many.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Orientation">
            <summary>
            Image orientation.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.ORIENTATION tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.TOPLEFT">
            <summary>
            Row 0 top, Column 0 lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.TOPRIGHT">
            <summary>
            Row 0 top, Column 0 rhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.BOTRIGHT">
            <summary>
            Row 0 bottom, Column 0 rhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.BOTLEFT">
            <summary>
            Row 0 bottom, Column 0 lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.LEFTTOP">
            <summary>
            Row 0 lhs, Column 0 top.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.RIGHTTOP">
            <summary>
            Row 0 rhs, Column 0 top.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.RIGHTBOT">
            <summary>
            Row 0 rhs, Column 0 bottom.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.LEFTBOT">
            <summary>
            Row 0 lhs, Column 0 bottom.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Photometric">
            <summary>
            Photometric interpretation.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.PHOTOMETRIC tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.MINISWHITE">
            <summary>
            Min value is white.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.MINISBLACK">
            <summary>
            Min value is black.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.RGB">
            <summary>
            RGB color model.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.PALETTE">
            <summary>
            Color map indexed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.MASK">
            <summary>
            [obsoleted by TIFF rev. 6.0] Holdout mask.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.SEPARATED">
            <summary>
            Color separations.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.YCBCR">
            <summary>
            CCIR 601.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.CIELAB">
            <summary>
            1976 CIE L*a*b*.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.ICCLAB">
            <summary>
            ICC L*a*b*. Introduced post TIFF rev 6.0 by Adobe TIFF Technote 4.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.ITULAB">
            <summary>
            ITU L*a*b*.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.LOGL">
            <summary>
            CIE Log2(L).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.LOGLUV">
            <summary>
            CIE Log2(L) (u',v').
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.PlanarConfig">
            <summary>
            Storage organization.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.PLANARCONFIG tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.PlanarConfig.UNKNOWN">
            <summary>
            Unknown (uninitialized).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.PlanarConfig.CONTIG">
            <summary>
            Single image plane.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.PlanarConfig.SEPARATE">
            <summary>
            Separate planes of data.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Predictor">
            <summary>
            Prediction scheme w/ LZW.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.PREDICTOR tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Predictor.NONE">
            <summary>
            No prediction scheme used.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Predictor.HORIZONTAL">
            <summary>
            Horizontal differencing.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Predictor.FLOATINGPOINT">
            <summary>
            Floating point predictor.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.ResUnit">
            <summary>
            Units of resolutions.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.RESOLUTIONUNIT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ResUnit.NONE">
            <summary>
            No meaningful units.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ResUnit.INCH">
            <summary>
            English.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ResUnit.CENTIMETER">
            <summary>
            Metric.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.SampleFormat">
            <summary>
            Data sample format.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.SAMPLEFORMAT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.UINT">
            <summary>
            Unsigned integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.INT">
            <summary>
            Signed integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.IEEEFP">
            <summary>
            IEEE floating point data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.VOID">
            <summary>
            Untyped data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.COMPLEXINT">
            <summary>
            Complex signed int
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.COMPLEXIEEEFP">
            <summary>
            Complex ieee floating
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Threshold">
            <summary>
            Thresholding used on data.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.THRESHHOLDING tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Threshold.BILEVEL">
            <summary>
            B&amp;W art scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Threshold.HALFTONE">
            <summary>
            Dithered scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Threshold.ERRORDIFFUSE">
            <summary>
            Usually Floyd-Steinberg.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffPrintFlags">
            <summary>
            Flags that can be passed to <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.PrintDirectory" />
            method to control printing of data structures that are potentially very large.
            </summary>
            <remarks>More than one flag can be used. Bit-or these flags to enable printing
            multiple items.</remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.NONE">
            <summary>
            no extra info
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.STRIPS">
            <summary>
            strips/tiles info
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.CURVES">
            <summary>
            color/gray response curves
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.COLORMAP">
            <summary>
            colormap
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.JPEGQTABLES">
            <summary>
            JPEG Q matrices
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.JPEGACTABLES">
            <summary>
            JPEG AC tables
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.JPEGDCTABLES">
            <summary>
            JPEG DC tables
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffTag">
            <summary>
            TIFF tag definitions.
            </summary>
            <remarks>
            Joris Van Damme maintains
            <a href="http://www.awaresystems.be/imaging/tiff/tifftags.html" target="_blank">
            TIFF Tag Reference</a>, good source of tag information. It's an overview of known TIFF
            Tags with properties, short description, and other useful information.
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IGNORE">
            <summary>
            Tag placeholder
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SUBFILETYPE">
            <summary>
            Subfile data descriptor.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.FileType" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.OSUBFILETYPE">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Kind of data in subfile. For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.OFileType" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH">
            <summary>
            Image width in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH">
            <summary>
            Image height in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE">
            <summary>
            Bits per channel (sample).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COMPRESSION">
            <summary>
            Data compression technique.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Compression" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PHOTOMETRIC">
            <summary>
            Photometric interpretation.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Photometric" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.THRESHHOLDING">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Thresholding used on data. For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Threshold" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CELLWIDTH">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Dithering matrix width.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CELLLENGTH">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Dithering matrix height.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER">
            <summary>
            Data order within a byte.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.FillOrder" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DOCUMENTNAME">
            <summary>
            Name of document which holds for image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDESCRIPTION">
            <summary>
            Information about image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MAKE">
            <summary>
            Scanner manufacturer name.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MODEL">
            <summary>
            Scanner model name/number.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS">
            <summary>
            Offsets to data strips.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ORIENTATION">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Image orientation. For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Orientation" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLESPERPIXEL">
            <summary>
            Samples per pixel.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP">
            <summary>
            Rows per strip of data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS">
            <summary>
            Bytes counts for strips.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MINSAMPLEVALUE">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Minimum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MAXSAMPLEVALUE">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Maximum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XRESOLUTION">
            <summary>
            Pixels/resolution in x.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YRESOLUTION">
            <summary>
            Pixels/resolution in y.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG">
            <summary>
            Storage organization.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PAGENAME">
            <summary>
            Page name image is from.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XPOSITION">
            <summary>
            X page offset of image lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YPOSITION">
            <summary>
            Y page offset of image lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FREEOFFSETS">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Byte offset to free block.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FREEBYTECOUNTS">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Sizes of free blocks.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GRAYRESPONSEUNIT">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br />
            Gray scale curve accuracy.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.GrayResponseUnit" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GRAYRESPONSECURVE">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br />
            Gray scale response curve.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GROUP3OPTIONS">
            <summary>
            Options for CCITT Group 3 fax encoding. 32 flag bits.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Group3Opt" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.T4OPTIONS">
            <summary>
            TIFF 6.0 proper name alias for GROUP3OPTIONS.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GROUP4OPTIONS">
            <summary>
            Options for CCITT Group 4 fax encoding. 32 flag bits.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Group3Opt" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.T6OPTIONS">
            <summary>
            TIFF 6.0 proper name alias for GROUP4OPTIONS.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.RESOLUTIONUNIT">
            <summary>
            Units of resolutions.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.ResUnit" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PAGENUMBER">
            <summary>
            Page numbers of multi-page.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORRESPONSEUNIT">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br />
            Color curve accuracy.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.ColorResponseUnit" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TRANSFERFUNCTION">
            <summary>
            Colorimetry info.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SOFTWARE">
            <summary>
            Name &amp; release.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DATETIME">
            <summary>
            Creation date and time.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ARTIST">
            <summary>
            Creator of image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.HOSTCOMPUTER">
            <summary>
            Machine where created.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PREDICTOR">
            <summary>
            Prediction scheme w/ LZW.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Predictor" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.WHITEPOINT">
            <summary>
            Image white point.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PRIMARYCHROMATICITIES">
            <summary>
            Primary chromaticities.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORMAP">
            <summary>
            RGB map for pallette image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.HALFTONEHINTS">
            <summary>
            Highlight + shadow info.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEWIDTH">
            <summary>
            Tile width in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILELENGTH">
            <summary>
            Tile height in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEOFFSETS">
            <summary>
            Offsets to data tiles.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEBYTECOUNTS">
            <summary>
            Byte counts for tiles.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BADFAXLINES">
            <summary>
            Lines with wrong pixel count.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CLEANFAXDATA">
            <summary>
            Regenerated line info.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.CleanFaxData" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CONSECUTIVEBADFAXLINES">
            <summary>
            Max consecutive bad lines.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SUBIFD">
            <summary>
            Subimage descriptors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INKSET">
            <summary>
            Inks in separated image.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.InkSet" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INKNAMES">
            <summary>
            ASCII names of inks.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.NUMBEROFINKS">
            <summary>
            Number of inks.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DOTRANGE">
            <summary>
            0% and 100% dot codes.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TARGETPRINTER">
            <summary>
            Separation target.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXTRASAMPLES">
            <summary>
            Information about extra samples.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.ExtraSample" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLEFORMAT">
            <summary>
            Data sample format.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.SampleFormat" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SMINSAMPLEVALUE">
            <summary>
            Variable MinSampleValue.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SMAXSAMPLEVALUE">
            <summary>
            Variable MaxSampleValue.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CLIPPATH">
            <summary>
            ClipPath. Introduced post TIFF rev 6.0 by Adobe TIFF technote 2.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XCLIPPATHUNITS">
            <summary>
            XClipPathUnits. Introduced post TIFF rev 6.0 by Adobe TIFF technote 2.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCLIPPATHUNITS">
            <summary>
            YClipPathUnits. Introduced post TIFF rev 6.0 by Adobe TIFF technote 2.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INDEXED">
            <summary>
            Indexed. Introduced post TIFF rev 6.0 by Adobe TIFF Technote 3.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGTABLES">
            <summary>
            JPEG table stream. Introduced post TIFF rev 6.0.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.OPIPROXY">
            <summary>
            OPI Proxy. Introduced post TIFF rev 6.0 by Adobe TIFF technote.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGPROC">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            JPEG processing algorithm.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.JpegProc" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGIFOFFSET">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            Pointer to SOI marker.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGIFBYTECOUNT">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            JFIF stream length
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGRESTARTINTERVAL">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            Restart interval length.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGLOSSLESSPREDICTORS">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            Lossless proc predictor.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGPOINTTRANSFORM">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            Lossless point transform.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGQTABLES">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            Q matrice offsets.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGDCTABLES">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            DCT table offsets.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGACTABLES">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            AC coefficient offsets.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCBCRCOEFFICIENTS">
            <summary>
            RGB -&gt; YCbCr transform.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCBCRSUBSAMPLING">
            <summary>
            YCbCr subsampling factors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCBCRPOSITIONING">
            <summary>
            Subsample positioning.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.YCbCrPosition" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REFERENCEBLACKWHITE">
            <summary>
            Colorimetry info.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XMLPACKET">
            <summary>
            XML packet. Introduced post TIFF rev 6.0 by Adobe XMP Specification, January 2004.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.OPIIMAGEID">
            <summary>
            OPI ImageID. Introduced post TIFF rev 6.0 by Adobe TIFF technote.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REFPTS">
            <summary>
            Image reference points. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REGIONTACKPOINT">
            <summary>
            Region-xform tack point. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REGIONWARPCORNERS">
            <summary>
            Warp quadrilateral. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REGIONAFFINE">
            <summary>
            Affine transformation matrix. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MATTEING">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br />
            Use EXTRASAMPLE tag. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DATATYPE">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br />
            Use SAMPLEFORMAT tag. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH">
            <summary>
            Z depth of image. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEDEPTH">
            <summary>
            Z depth/data tile. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_IMAGEFULLWIDTH">
            <summary>
            Full image size in X. This tag is set when an image has been cropped out of a larger
            image. It reflect width of the original uncropped image. The XPOSITION tag can be used
            to determine the position of the smaller image in the larger one.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_IMAGEFULLLENGTH">
            <summary>
            Full image size in Y. This tag is set when an image has been cropped out of a larger
            image. It reflect height of the original uncropped image. The YPOSITION can be used
            to determine the position of the smaller image in the larger one.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_TEXTUREFORMAT">
            <summary>
            Texture map format. Used to identify special image modes and data used by Pixar's
            texture formats. Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_WRAPMODES">
            <summary>
            S&amp;T wrap modes. Used to identify special image modes and data used by Pixar's
            texture formats. Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_FOVCOT">
            <summary>
            Cotan(fov) for env. maps. Used to identify special image modes and data used by
            Pixar's texture formats. Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_MATRIX_WORLDTOSCREEN">
            <summary>
            Used to identify special image modes and data used by Pixar's texture formats.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_MATRIX_WORLDTOCAMERA">
            <summary>
            Used to identify special image modes and data used by Pixar's texture formats.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.WRITERSERIALNUMBER">
            <summary>
            Device serial number. Private tag registered to Eastman Kodak.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COPYRIGHT">
            <summary>
            Copyright string. This tag is listed in the TIFF rev. 6.0 w/ unknown ownership.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.RICHTIFFIPTC">
            <summary>
            IPTC TAG from RichTIFF specifications.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8SITE">
            <summary>
            Site name. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8COLORSEQUENCE">
            <summary>
            Color seq. [RGB, CMYK, etc]. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8HEADER">
            <summary>
            DDES Header. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8RASTERPADDING">
            <summary>
            Raster scanline padding. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BITSPERRUNLENGTH">
            <summary>
            The number of bits in short run. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BITSPEREXTENDEDRUNLENGTH">
            <summary>
            The number of bits in long run. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8COLORTABLE">
            <summary>
            LW colortable. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8IMAGECOLORINDICATOR">
            <summary>
            BP/BL image color switch. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BKGCOLORINDICATOR">
            <summary>
            BP/BL bg color switch. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8IMAGECOLORVALUE">
            <summary>
            BP/BL image color value. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BKGCOLORVALUE">
            <summary>
            BP/BL bg color value. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8PIXELINTENSITYRANGE">
            <summary>
            MP pixel intensity value. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8TRANSPARENCYINDICATOR">
            <summary>
            HC transparency switch. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8COLORCHARACTERIZATION">
            <summary>
            Color characterization table. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8HCUSAGE">
            <summary>
            HC usage indicator. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8TRAPINDICATOR">
            <summary>
            Trapping indicator (untrapped = 0, trapped = 1). Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8CMYKEQUIVALENT">
            <summary>
            CMYK color equivalents.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FRAMECOUNT">
            <summary>
            Sequence Frame Count. Private tag registered to Texas Instruments.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PHOTOSHOP">
            <summary>
            Private tag registered to Adobe for PhotoShop.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIFIFD">
            <summary>
            Pointer to EXIF private directory. This tag is documented in EXIF specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ICCPROFILE">
            <summary>
            ICC profile data. ?? Private tag registered to Adobe. ??
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JBIGOPTIONS">
            <summary>
            JBIG options. Private tag registered to Pixel Magic.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GPSIFD">
            <summary>
            Pointer to GPS private directory. This tag is documented in EXIF specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXRECVPARAMS">
            <summary>
            Encoded Class 2 ses. params. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXSUBADDRESS">
            <summary>
            Received SubAddr string. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXRECVTIME">
            <summary>
            Receive time (secs). Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXDCS">
            <summary>
            Encoded fax ses. params, Table 2/T.30. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.STONITS">
            <summary>
            Sample value to Nits. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FEDEX_EDR">
            <summary>
            Private tag registered to FedEx.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INTEROPERABILITYIFD">
            <summary>
            Pointer to Interoperability private directory.
            This tag is documented in EXIF specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DNGVERSION">
            <summary>
            DNG version number. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DNGBACKWARDVERSION">
            <summary>
            DNG compatibility version. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.UNIQUECAMERAMODEL">
            <summary>
            Name for the camera model. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LOCALIZEDCAMERAMODEL">
            <summary>
            Localized camera model name. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CFAPLANECOLOR">
            <summary>
            CFAPattern-&gt;LinearRaw space mapping. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CFALAYOUT">
            <summary>
            Spatial layout of the CFA. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LINEARIZATIONTABLE">
            <summary>
            Lookup table description. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVELREPEATDIM">
            <summary>
            Repeat pattern size for the BlackLevel tag. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVEL">
            <summary>
            Zero light encoding level. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVELDELTAH">
            <summary>
            Zero light encoding level differences (columns). Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVELDELTAV">
            <summary>
            Zero light encoding level differences (rows). Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.WHITELEVEL">
            <summary>
            Fully saturated encoding level. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DEFAULTSCALE">
            <summary>
            Default scale factors. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DEFAULTCROPORIGIN">
            <summary>
            Origin of the final image area. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DEFAULTCROPSIZE">
            <summary>
            Size of the final image area. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORMATRIX1">
            <summary>
            XYZ-&gt;reference color space transformation matrix 1.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORMATRIX2">
            <summary>
            XYZ-&gt;reference color space transformation matrix 2.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CAMERACALIBRATION1">
            <summary>
            Calibration matrix 1. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CAMERACALIBRATION2">
            <summary>
            Calibration matrix 2. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REDUCTIONMATRIX1">
            <summary>
            Dimensionality reduction matrix 1. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REDUCTIONMATRIX2">
            <summary>
            Dimensionality reduction matrix 2. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ANALOGBALANCE">
            <summary>
            Gain applied the stored raw values. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTNEUTRAL">
            <summary>
            Selected white balance in linear reference space.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTWHITEXY">
            <summary>
            Selected white balance in x-y chromaticity coordinates.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BASELINEEXPOSURE">
            <summary>
            How much to move the zero point. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BASELINENOISE">
            <summary>
            Relative noise level. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BASELINESHARPNESS">
            <summary>
            Relative amount of sharpening. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BAYERGREENSPLIT">
            <summary>
            How closely the values of the green pixels in the blue/green rows 
            track the values of the green pixels in the red/green rows.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LINEARRESPONSELIMIT">
            <summary>
            Non-linear encoding range. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CAMERASERIALNUMBER">
            <summary>
            Camera's serial number. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LENSINFO">
            <summary>
            Information about the lens.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CHROMABLURRADIUS">
            <summary>
            Chroma blur radius. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ANTIALIASSTRENGTH">
            <summary>
            Relative strength of the camera's anti-alias filter.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SHADOWSCALE">
            <summary>
            Used by Adobe Camera Raw. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DNGPRIVATEDATA">
            <summary>
            Manufacturer's private data. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MAKERNOTESAFETY">
            <summary>
            Whether the EXIF MakerNote tag is safe to preserve along with the rest of the EXIF data.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CALIBRATIONILLUMINANT1">
            <summary>
            Illuminant 1. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CALIBRATIONILLUMINANT2">
            <summary>
            Illuminant 2. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BESTQUALITYSCALE">
            <summary>
            Best quality multiplier. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.RAWDATAUNIQUEID">
            <summary>
            Unique identifier for the raw image data. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ORIGINALRAWFILENAME">
            <summary>
            File name of the original raw file. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ORIGINALRAWFILEDATA">
            <summary>
            Contents of the original raw file. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ACTIVEAREA">
            <summary>
            Active (non-masked) pixels of the sensor. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MASKEDAREAS">
            <summary>
            List of coordinates of fully masked pixels. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTICCPROFILE">
            <summary>
            Used to map cameras's color space into ICC profile space.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTPREPROFILEMATRIX">
            <summary>
            Used to map cameras's color space into ICC profile space.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CURRENTICCPROFILE">
            <summary>
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CURRENTPREPROFILEMATRIX">
            <summary>
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSHUESHIFTVALUES">
            <summary>
            Undefined tag used by Eastman Kodak, hue shift correction data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXMODE">
            <summary>
            [pseudo tag. not written to file]<br />
            Group 3/4 format control.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.FaxMode" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGQUALITY">
            <summary>
            [pseudo tag. not written to file]<br />
            Compression quality level. Quality level is on the IJG 0-100 scale. Default value is 75.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGCOLORMODE">
            <summary>
            [pseudo tag. not written to file]<br />
            Auto RGB&lt;=&gt;YCbCr convert.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.JpegColorMode" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGTABLESMODE">
            <summary>
            [pseudo tag. not written to file]<br />
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.JpegTablesMode" />.
            Default is <see cref="F:BitMiracle.LibTiff.Classic.JpegTablesMode.QUANT" /> | <see cref="F:BitMiracle.LibTiff.Classic.JpegTablesMode.HUFF" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXFILLFUNC">
            <summary>
            [pseudo tag. not written to file]<br />
            G3/G4 fill function.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXARLOGDATAFMT">
            <summary>
            [pseudo tag. not written to file]<br />
            PixarLogCodec I/O data sz.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSIMAGERTYPE">
            <summary>
            [pseudo tag. not written to file]<br />
            Imager mode &amp; filter.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSINTERPMODE">
            <summary>
            [pseudo tag. not written to file]<br />
            Interpolation mode.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSBALANCEARRAY">
            <summary>
            [pseudo tag. not written to file]<br />
            Color balance values.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSCORRECTMATRIX">
            <summary>
            [pseudo tag. not written to file]<br />
            Color correction values.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSGAMMA">
            <summary>
            [pseudo tag. not written to file]<br />
            Gamma value.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSTOESHOULDERPTS">
            <summary>
            [pseudo tag. not written to file]<br />
            Toe &amp; shoulder points.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSCALIBRATIONFD">
            <summary>
            [pseudo tag. not written to file]<br />
            Calibration file description.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ZIPQUALITY">
            <summary>
            [pseudo tag. not written to file]<br />
            Compression quality level.
            Quality level is on the ZLIB 1-9 scale. Default value is -1.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXARLOGQUALITY">
            <summary>
            [pseudo tag. not written to file]<br />
            PixarLog uses same scale.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSCLIPRECTANGLE">
            <summary>
            [pseudo tag. not written to file]<br />
            Area of image to acquire.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SGILOGDATAFMT">
            <summary>
            [pseudo tag. not written to file]<br />
            SGILog user data format.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SGILOGENCODE">
            <summary>
            [pseudo tag. not written to file]<br />
            SGILog data encoding control.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSURETIME">
            <summary>
            Exposure time.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FNUMBER">
            <summary>
            F number.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREPROGRAM">
            <summary>
            Exposure program.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SPECTRALSENSITIVITY">
            <summary>
            Spectral sensitivity.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_ISOSPEEDRATINGS">
            <summary>
            ISO speed rating.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_OECF">
            <summary>
            Optoelectric conversion factor.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXIFVERSION">
            <summary>
            Exif version.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DATETIMEORIGINAL">
            <summary>
            Date and time of original data generation.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DATETIMEDIGITIZED">
            <summary>
            Date and time of digital data generation.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_COMPONENTSCONFIGURATION">
            <summary>
            Meaning of each component.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_COMPRESSEDBITSPERPIXEL">
            <summary>
            Image compression mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SHUTTERSPEEDVALUE">
            <summary>
            Shutter speed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_APERTUREVALUE">
            <summary>
            Aperture.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_BRIGHTNESSVALUE">
            <summary>
            Brightness.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREBIASVALUE">
            <summary>
            Exposure bias.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_MAXAPERTUREVALUE">
            <summary>
            Maximum lens aperture.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTDISTANCE">
            <summary>
            Subject distance.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_METERINGMODE">
            <summary>
            Metering mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_LIGHTSOURCE">
            <summary>
            Light source.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FLASH">
            <summary>
            Flash.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALLENGTH">
            <summary>
            Lens focal length.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTAREA">
            <summary>
            Subject area.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_MAKERNOTE">
            <summary>
            Manufacturer notes.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_USERCOMMENT">
            <summary>
            User comments.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBSECTIME">
            <summary>
            DateTime subseconds.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBSECTIMEORIGINAL">
            <summary>
            DateTimeOriginal subseconds.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBSECTIMEDIGITIZED">
            <summary>
            DateTimeDigitized subseconds.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FLASHPIXVERSION">
            <summary>
            Supported Flashpix version.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_COLORSPACE">
            <summary>
            Color space information.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_PIXELXDIMENSION">
            <summary>
            Valid image width.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_PIXELYDIMENSION">
            <summary>
            Valid image height.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_RELATEDSOUNDFILE">
            <summary>
            Related audio file.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FLASHENERGY">
            <summary>
            Flash energy.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SPATIALFREQUENCYRESPONSE">
            <summary>
            Spatial frequency response.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALPLANEXRESOLUTION">
            <summary>
            Focal plane X resolution.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALPLANEYRESOLUTION">
            <summary>
            Focal plane Y resolution.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALPLANERESOLUTIONUNIT">
            <summary>
            Focal plane resolution unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTLOCATION">
            <summary>
            Subject location.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREINDEX">
            <summary>
            Exposure index.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SENSINGMETHOD">
            <summary>
            Sensing method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FILESOURCE">
            <summary>
            File source.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SCENETYPE">
            <summary>
            Scene type.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_CFAPATTERN">
            <summary>
            CFA pattern.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_CUSTOMRENDERED">
            <summary>
            Custom image processing.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREMODE">
            <summary>
            Exposure mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_WHITEBALANCE">
            <summary>
            White balance.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DIGITALZOOMRATIO">
            <summary>
            Digital zoom ratio.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALLENGTHIN35MMFILM">
            <summary>
            Focal length in 35 mm film.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SCENECAPTURETYPE">
            <summary>
            Scene capture type.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_GAINCONTROL">
            <summary>
            Gain control.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_CONTRAST">
            <summary>
            Contrast.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SATURATION">
            <summary>
            Saturation.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SHARPNESS">
            <summary>
            Sharpness.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DEVICESETTINGDESCRIPTION">
            <summary>
            Device settings description.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTDISTANCERANGE">
            <summary>
            Subject distance range.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_IMAGEUNIQUEID">
            <summary>
            Unique image ID.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_MODELPIXELSCALETAG">
            <summary>
            This tag is defining exact affine transformations between raster and model space. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_MODELTIEPOINTTAG">
            <summary>
            This tag stores raster-&gt;model tiepoint pairs. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_MODELTRANSFORMATIONTAG">
            <summary>
            This tag is optionally provided for defining exact affine transformations between raster and model space. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffType">
            <summary>
            Tag data type.
            </summary>
            <remarks>Note: RATIONALs are the ratio of two 32-bit integer values.</remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.NOTYPE">
            <summary>
            Placeholder.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.ANY">
            <summary>
            For field descriptor searching.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.BYTE">
            <summary>
            8-bit unsigned integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.ASCII">
            <summary>
            8-bit bytes with last byte <c>null</c>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SHORT">
            <summary>
            16-bit unsigned integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.LONG">
            <summary>
            32-bit unsigned integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.RATIONAL">
            <summary>
            64-bit unsigned fraction.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SBYTE">
            <summary>
            8-bit signed integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.UNDEFINED">
            <summary>
            8-bit untyped data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SSHORT">
            <summary>
            16-bit signed integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SLONG">
            <summary>
            32-bit signed integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SRATIONAL">
            <summary>
            64-bit signed fraction.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.FLOAT">
            <summary>
            32-bit IEEE floating point.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.DOUBLE">
            <summary>
            64-bit IEEE floating point.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.IFD">
            <summary>
            32-bit unsigned integer (offset)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.LONG8">
            <summary>
            BigTIFF 64-bit unsigned long
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SLONG8">
            <summary>
            BigTIFF 64-bit signed long
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.IFD8">
            <summary>
            BigTIFF 64-bit unsigned integer/long (offset)
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.YCbCrPosition">
            <summary>
            Subsample positioning.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.YCBCRPOSITIONING tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.YCbCrPosition.CENTERED">
            <summary>
            As in PostScript Level 2
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.YCbCrPosition.COSITED">
            <summary>
            As in CCIR 601-1
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FieldBit">
            <summary>
            Field bits (flags) for tags.
            </summary>
            <remarks>Field bits used to indicate fields that have been set in a directory, and to
            reference fields when manipulating a directory.</remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Ignore">
            <summary>
            This value is used to signify tags that are to be processed
            but otherwise ignored.<br />
            This permits antiquated tags to be quietly read and discarded. Note that
            a bit <b>is</b> allocated for ignored tags; this is understood by the
            directory reading logic which uses this fact to avoid special-case handling.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Pseudo">
            <summary>
            This value is used to signify pseudo-tags.<br />
            Pseudo-tags don't normally need field bits since they are not
            written to an output file (by definition). The library also has
            express logic to always query a codec for a pseudo-tag so allocating
            a field bit for one is a waste. If codec wants to promote the notion
            of a pseudo-tag being <i>set</i> or <i>unset</i> then it can do using
            internal state flags without polluting the field bit space defined
            for real tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Custom">
            <summary>
            This value is used to signify custom tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Codec">
            <summary>
            This value is used as a base (starting) value for codec-private tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Last">
            <summary>
            Last usable value for field bit. All tags values should be less than this value.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FieldValue">
            <summary>
            Holds a value of a Tiff tag.
            </summary>
            <remarks>
                <para>Simply put, it is a wrapper around System.Object, that helps to deal with
            unboxing and conversion of types a bit easier.
            </para>
                <para>
            Please take a look at:
            http://blogs.msdn.com/ericlippert/archive/2009/03/19/representation-and-identity.aspx
            </para>
            </remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.FieldValue.Value">
            <summary>
            Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToByte">
            <summary>
            Retrieves value converted to byte.
            </summary>
            <returns>The value converted to byte.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToShort">
            <summary>
            Retrieves value converted to short.
            </summary>
            <returns>The value converted to short.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUShort">
            <summary>
            Retrieves value converted to ushort.
            </summary>
            <returns>The value converted to ushort.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToInt">
            <summary>
            Retrieves value converted to int.
            </summary>
            <returns>The value converted to int.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUInt">
            <summary>
            Retrieves value converted to uint.
            </summary>
            <returns>The value converted to uint.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToLong">
            <summary>
            Retrieves value converted to long.
            </summary>
            <returns>The value converted to long.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToFloat">
            <summary>
            Retrieves value converted to float.
            </summary>
            <returns>The value converted to float.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToDouble">
            <summary>
            Retrieves value converted to double.
            </summary>
            <returns>The value converted to double.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToString">
            <summary>
            Retrieves value converted to string.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.        
            </returns>
            <remarks>If value is a byte array, then it gets converted to string using
            Latin1 encoding encoder.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.GetBytes">
            <summary>
            Retrieves value converted to byte array.
            </summary>
            <returns>Value converted to byte array.</returns>
            <remarks>
                <para>If value is byte array then it retrieved unaltered.</para>
                <para>If value is array of short, ushort, int, uint, float or double values then this
            array is converted to byte array</para>
                <para>
            If value is a string then it gets converted to byte array using Latin1 encoding
            encoder.</para>
                <para>
            If value is of any other type then <c>null</c> is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToByteArray">
            <summary>
            Retrieves value converted to array of bytes.
            </summary>
            <returns>Value converted to array of bytes.</returns>
            <remarks>
                <para>If value is array of bytes then it retrieved unaltered.</para>
                <para>If value is array of short, ushort, int or uint values then each element of
            field value gets converted to byte and added to resulting array.</para>
                <para>If value is string then it gets converted to byte[] using Latin1 encoding
            encoder.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToShortArray">
            <summary>
            Retrieves value converted to array of short values.
            </summary>
            <returns>Value converted to array of short values.</returns>
            <remarks>
                <para>If value is array of short values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each pair of bytes is converted to short and
            added to resulting array. If value contains odd amount of bytes, then null is
            returned.</para>
                <para>
            If value is array of ushort, int or uint values then each element of field value gets
            converted to short and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUShortArray">
            <summary>
            Retrieves value converted to array of ushort values.
            </summary>
            <returns>Value converted to array of ushort values.</returns>
            <remarks>
                <para>If value is array of ushort values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each pair of bytes is converted to ushort and
            added to resulting array. If value contains odd amount of bytes, then null is
            returned.</para>
                <para>
            If value is array of short, int or uint values then each element of field value gets
            converted to ushort and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToIntArray">
            <summary>
            Retrieves value converted to array of int values.
            </summary>
            <returns>Value converted to array of int values.</returns>
            <remarks>
                <para>If value is array of int values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each 4 bytes are converted to int and added to
            resulting array. If value contains amount of bytes that can't be divided by 4 without
            remainder, then null is returned.</para>
                <para>If value is array of short, ushort or uint values then each element of
            field value gets converted to int and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUIntArray">
            <summary>
            Retrieves value converted to array of uint values.
            </summary>
            <returns>Value converted to array of uint values.</returns>
            <remarks>
                <para>If value is array of uint values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each 4 bytes are converted to uint and added to
            resulting array. If value contains amount of bytes that can't be divided by 4 without
            remainder, then null is returned.</para>
                <para>If value is array of short, ushort or int values then each element of
            field value gets converted to uint and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.TolongArray">
            <summary>
            Retrieves value converted to array of long values.
            </summary>
            <returns>Value converted to array of long values.</returns>
            <remarks>
                <para>If value is array of long values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each 8 bytes are converted to uint and added to
            resulting array. If value contains amount of bytes that can't be divided by 8 without
            remainder, then null is returned.</para>
                <para>If value is array of short, ushort or int values then each element of
            field value gets converted to long and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToFloatArray">
            <summary>
            Retrieves value converted to array of float values.
            </summary>
            <returns>Value converted to array of float values.</returns>
            <remarks>
                <para>If value is array of float values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each 4 bytes are converted to float and added to
            resulting array. If value contains amount of bytes that can't be divided by 4 without
            remainder, then null is returned.</para>
                <para>If value is array of double values then each element of field value gets
            converted to float and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToDoubleArray">
            <summary>
            Retrieves value converted to array of double values.
            </summary>
            <returns>Value converted to array of double values.</returns>
            <remarks>
                <para>If value is array of double values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each 8 bytes are converted to double and added to
            resulting array. If value contains amount of bytes that can't be divided by 8 without
            remainder, then null is returned.</para>
                <para>If value is array of float values then each element of field value gets
            converted to double and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PreEncode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Close">
            <summary>
            Flushes any internal data buffers and terminates current operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3Decode1D(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of G3 1D-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3Decode2D(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of G3 2D-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encode a buffer of pixels.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3DecodeRLE(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of RLE-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax4Decode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of G4-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax4Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encode the requested amount of data.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor">
            <summary>
            Codecs that want to support the Predictor tag should inherit from 
            this class instead of TiffCodec. 
            
            Such codecs should not override default TiffCodec's methods for 
            decode|encode setup and encoding|decoding of row|tile|strip. 
            Codecs with predictor support should override equivalent methods 
            provided by this class.
            
            If codec wants to provide custom tag get|set|print methods, then
            it should pass pointer to a object derived from TiffTagMethods
            as parameter to TIFFPredictorInit
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_predictor">
            <summary>
            predictor tag value
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_stride">
            <summary>
            sample stride over data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_rowSize">
            <summary>
            tile/strip row size
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_predictorType">
            <summary>
            horizontal differencer/accumulator
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreDecode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreEncode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.fpAcc(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Floating point predictor accumulation routine.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.fpDiff(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Floating point predictor differencing routine.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.PredictorDecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a scanline and apply the predictor routine.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.PredictorDecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a tile/strip and apply the predictor routine. Note that horizontal differencing
            must be done on a row-by-row basis. The width of a "row" has already been calculated
            at pre-decode time according to the strip/tile dimensions.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.ZIPEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.Seek(System.Int32)">
            <summary>
            Seeks the specified row in the strip being processed.
            </summary>
            <param name="row">The row to seek.</param>
            <returns>
                <c>true</c> if specified row was successfully found; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DumpModeEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a hunk of pixels.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DumpModeDecode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a hunk of pixels.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.JpegCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.JpegCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreDecode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreEncode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DefStripSize(System.Int32)">
            <summary>
            Calculates and/or constrains a strip size.
            </summary>
            <param name="size">The proposed strip size (may be zero or negative).</param>
            <returns>A strip size to use.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DefTileSize(System.Int32@,System.Int32@)">
            <summary>
            Calculate and/or constrains a tile size
            </summary>
            <param name="width">The proposed tile width upon the call / tile width to use after the call.</param>
            <param name="height">The proposed tile height upon the call / tile height to use after the call.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGPreEncode(System.Int16)">
            <summary>
            Set encoding state at the start of a strip or tile.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGPostEncode">
            <summary>
            Finish up at the end of a strip or tile.
            </summary>
            <returns />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGDecode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a chunk of pixels.
            "Standard" case: returned data is not downsampled.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGDecodeRaw(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a chunk of pixels. 
            Returned data is downsampled per sampling factors.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            "Standard" case: incoming data is not downsampled.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGEncodeRaw(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            Incoming data is expected to be downsampled per sampling factors.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegErrorManager">
            <summary>
             LibJpeg.Net interface layer.
            
             We handle fatal errors when they are encountered within the JPEG
             library.  We also direct LibJpeg.Net error and warning
             messages through the appropriate LibTiff.Net handlers.
             </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegStdDestination">
            <summary>
            JPEG library destination data manager.
            These routines direct compressed data from LibJpeg.Net into the
            LibTiff.Net output buffer.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegStdSource">
            <summary>
            JPEG library source data manager.
            These routines supply compressed data to LibJpeg.Net
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegTablesDestination">
            <summary>
            Alternate destination manager for outputting to JPEGTables field.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegTablesSource">
            <summary>
            Alternate source manager for reading from JPEGTables.
            We can share all the code except for the init routine.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.LZWCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.LZWCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.LZWEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            </summary>
            <remarks>
            Uses an open addressing double hashing (no chaining) on the prefix code/next character
            combination. We do a variant of Knuth's algorithm D (vol. 3, sec. 6.4) along with
            G. Knott's relatively-prime secondary probe. Here, the modular division first probe is
            gives way to a faster exclusive-or manipulation. Also do block compression with an
            adaptive reset, whereby the code table is cleared when the compression ratio
            decreases, but after the table fills. The variable-length output codes are re-sized at
            this point, and a CODE_CLEAR is generated for the decoder. 
            </remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreDecode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreEncode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.init_source">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.fill_input_buffer">
            <summary>
            Fills input buffer
            </summary>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.skip_input_data(System.Int32)">
            <summary>
            Skip data - used to skip over a potentially large amount of
            uninteresting data (such as an APPn marker).
            </summary>
            <param name="num_bytes">The number of bytes to skip.</param>
            <remarks>Writers of suspendable-input applications must note that skip_input_data
            is not granted the right to give a suspension return.  If the skip extends
            beyond the data currently in the buffer, the buffer can be marked empty so
            that the next read will cause a fill_input_buffer call that can suspend.
            Arranging for additional bytes to be discarded before reloading the input
            buffer is the application writer's problem.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.resync_to_restart(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Int32)">
            <summary>
            This is the default resync_to_restart method for data source
            managers to use if they don't have any better approach.
            </summary>
            <param name="cinfo">An instance of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" /></param>
            <param name="desired">The desired</param>
            <returns>
                <c>false</c> if suspension is required.</returns>
            <remarks>That method assumes that no backtracking is possible.
            Some data source managers may be able to back up, or may have
            additional knowledge about the data which permits a more
            intelligent recovery strategy; such managers would
            presumably supply their own resync method.<br /><br />
            read_restart_marker calls resync_to_restart if it finds a marker other than
            the restart marker it was expecting.  (This code is *not* used unless
            a nonzero restart interval has been declared.)  cinfo.unread_marker is
            the marker code actually found (might be anything, except 0 or FF).
            The desired restart marker number (0..7) is passed as a parameter.<br /><br />
            This routine is supposed to apply whatever error recovery strategy seems
            appropriate in order to position the input stream to the next data segment.
            Note that cinfo.unread_marker is treated as a marker appearing before
            the current data-source input point; usually it should be reset to zero
            before returning.<br /><br />
            This implementation is substantially constrained by wanting to treat the
            input as a data stream; this means we can't back up.  Therefore, we have
            only the following actions to work with:<br />
            1. Simply discard the marker and let the entropy decoder resume at next
            byte of file.<br />
            2. Read forward until we find another marker, discarding intervening
            data.  (In theory we could look ahead within the current bufferload,
            without having to discard data if we don't find the desired marker.
            This idea is not implemented here, in part because it makes behavior
            dependent on buffer size and chance buffer-boundary positions.)<br />
            3. Leave the marker unread (by failing to zero cinfo.unread_marker).
            This will cause the entropy decoder to process an empty data segment,
            inserting dummy zeroes, and then we will reprocess the marker.<br />
            #2 is appropriate if we think the desired marker lies ahead, while #3 is
            appropriate if the found marker is a future restart marker (indicating
            that we have missed the desired restart marker, probably because it got
            corrupted).<br />
            We apply #2 or #3 if the found marker is a restart marker no more than
            two counts behind or ahead of the expected one.  We also apply #2 if the
            found marker is not a legal JPEG marker code (it's certainly bogus data).
            If the found marker is a restart marker more than 2 counts away, we do #1
            (too much risk that the marker is erroneous; with luck we will be able to
            resync at some future point).<br />
            For any valid non-restart JPEG marker, we apply #3.  This keeps us from
            overrunning the end of a scan.  An implementation limited to single-scan
            files might find it better to apply #2 for markers other than EOI, since
            any other marker would have to be bogus data in that case.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.term_source">
            <summary>
            Terminate source - called by jpeg_finish_decompress
            after all data has been read.  Often a no-op.
            </summary>
            <remarks>NB: <b>not</b> called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.</remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.PackBitsEncodeChunk(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a rectangular chunk of pixels. We break it up into row-sized pieces to insure
            that encoded runs do not span rows. Otherwise, there can be problems with the decoder
            if data is read, for example, by scanlines when it was encoded by strips.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB">
            <summary>
            CIE Lab 1976-&gt;RGB support
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.range">
            <summary>
            Size of conversion table
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.Yr2r">
            <summary>
            Conversion of Yr to r
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.Yg2g">
            <summary>
            Conversion of Yg to g
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.Yb2b">
            <summary>
            Conversion of Yb to b
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffDirectory">
            <summary>
            Internal format of a TIFF directory entry.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirectory.td_fieldsset">
            <summary>
            bit vector of fields that are set
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirectory.td_nstrips">
            <summary>
            size of offset and bytecount arrays
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirectory.td_stripbytecountsorted">
            <summary>
            is the bytecount array sorted ascending?
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry">
            <summary>
            TIFF Image File Directories are comprised of a table of field
            descriptors of the form shown below.  The table is sorted in
            ascending order by tag.  The values associated with each entry are
            disjoint and may appear anywhere in the file (so long as they are
            placed on a word boundary).
            
            If the value is 4 bytes or less, then it is placed in the offset
            field to save space.  If the value is less than 4 bytes, it is
            left-justified in the offset field.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry.tdir_count">
            <summary>
            number of items; length in spec
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry.tdir_offset">
            <summary>
            byte offset to field data
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry.SizeInBytes(System.Boolean)">
            <summary>
            size in bytes of the entry depending on the current format
            </summary>
            <param name="isBigTiff">if set to <c>true</c> then the bigtiff size will be returned.</param>
            <returns />
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffDisplay">
            <summary>
            Structure for holding information about a display device.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDisplay.d_mat">
            <summary>
            XYZ -&gt; luminance matrix
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.MSB2LSB">
            <summary>
            Use MSB2LSB (most significant -&gt; least) fill order
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.LSB2MSB">
            <summary>
            Use LSB2MSB (least significant -&gt; most) fill order
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.FILLORDER">
            <summary>
            natural bit fill order for machine
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.DIRTYDIRECT">
            <summary>
            current directory must be written
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.BUFFERSETUP">
            <summary>
            data buffers setup
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.CODERSETUP">
            <summary>
            encoder/decoder setup done
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.BEENWRITING">
            <summary>
            written 1+ scanlines to file
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.SWAB">
            <summary>
            byte swap file information
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.NOBITREV">
            <summary>
            inhibit bit reversal logic
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.MYBUFFER">
            <summary>
            my raw data buffer; free on close
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.ISTILED">
            <summary>
            file is tile, not strip- based
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.POSTENCODE">
            <summary>
            need call to postencode routine
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.INSUBIFD">
            <summary>
            currently writing a subifd
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.UPSAMPLED">
            <summary>
            library is doing data up-sampling
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.STRIPCHOP">
            <summary>
            enable strip chopping support
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.HEADERONLY">
            <summary>
            read header only, do not process the first directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.NOREADRAW">
            <summary>
            skip reading of raw uncompressed image data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.ISBIGTIFF">
            <summary>
            File is written in bigTiff-format.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.NOBIGTIFF">
            <summary>
            File must not be in bigTiff-format.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_magic">
            <summary>
            magic number (defines byte order)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_version">
            <summary>
            TIFF version number
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_diroff">
            <summary>
            byte offset to first directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_offsize">
            <summary>
            reperesents the size in bytes of the offsets
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_fill">
            <summary>
            constant for possibly bigtiff convert
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.TiffHeader.SizeInBytes(System.Boolean)">
            <summary>
            size in bytes of the header depending on the current format
            </summary>
            <param name="isBigTiff">if set to <c>true</c> then the bigtiff size will be returned.</param>
            <returns />
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffYCbCrToRGB">
            <summary>
            Convert color value from the YCbCr space to CIE XYZ.
            The colorspace conversion algorithm comes from the IJG v5a code;
            see below for more information on how it works.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffYCbCrToRGB.clamptab">
            <summary>
            range clamping table
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Tiff">
            <summary>
            Tag Image File Format (TIFF)
            </summary>
            <remarks>
            Based on Rev 6.0 from
            <see href="http://partners.adobe.com/asn/developer/PDFS/TN/TIFF6.pdf" target="_blank" /></remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_extender">
            <summary>
            Client Tag extension support (from Niles Ritter).
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.setupBuiltInCodecs">
            <summary>
            Compression schemes statically built into the library.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.tiffFieldInfo">
            <summary>
            NB:   THIS ARRAY IS ASSUMED TO BE SORTED BY TAG.
                  If a tag can have both LONG and SHORT types then the LONG must
                  be placed before the SHORT for writing to work properly.
                  
            NOTE: The second field (field_readcount) and third field
                  (field_writecount) sometimes use the values
                  TiffFieldInfo.Variable (-1), TiffFieldInfo.Variable2 (-3)
                  and TiffFieldInfo.Spp (-2). These values should be used but
                  would throw off the formatting of the code, so please
                  interpret the -1, -2 and -3  values accordingly.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.checkDirOffset(System.UInt64)">
            <summary>
            Checks the directory offset against the list of already seen directory
            offsets.
            </summary>
            <remarks> This is a trick to prevent IFD looping. The one can
            create TIFF file with looped directory pointers. We will maintain a
            list of already seen directories and check every IFD offset against
            that list.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchDirectory(System.UInt64,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry[]@,System.UInt64@)">
            <summary>
            Reads IFD structure from the specified offset.
            </summary>
            <returns>The number of fields in the directory or 0 if failed.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchData(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Byte[])">
            <summary>
            Fetches a contiguous directory item.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchString(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.String@)">
            <summary>
            Fetches an ASCII item from the file.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchFloat(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry)">
            <summary>
            Fetch a single floating point value from the offset field and
            return it as a native float.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchByteArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Byte[])">
            <summary>
            Fetches an array of BYTE or SBYTE values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchShortArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int16[])">
            <summary>
            Fetch an array of SHORT or SSHORT values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchULongArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.UInt32[])">
            <summary>
            Fetches an array of ULONG values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchLongArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int32[])">
            <summary>
            Fetches an array of LONG or SLONG values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchLong8Array(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int64[])">
            <summary>
            Fetches an array of LONG or SLONG values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchRationalArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Single[])">
            <summary>
            Fetch an array of RATIONAL or SRATIONAL values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchFloatArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Single[])">
            <summary>
            Fetches an array of FLOAT values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchDoubleArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Double[])">
            <summary>
            Fetches an array of DOUBLE values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchAnyArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Double[])">
            <summary>
            Fetches an array of ANY values.
            </summary>
            <remarks>The actual values are returned as doubles which should be
            able hold all the types. Note in particular that we assume that the
            double return value vector is large enough to read in any
            fundamental type. We use that vector as a buffer to read in the base
            type vector and then convert it in place to double (from end to
            front of course).</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchNormalTag(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry)">
            <summary>
            Fetches a tag that is not handled by special case code.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchPerSampleShorts(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int16@)">
            <summary>
            Fetches samples/pixel short values for the specified tag and verify
            that all values are the same.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchPerSampleLongs(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int32@)">
            <summary>
            Fetches samples/pixel long values for the specified tag and verify
            that all values are the same.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchPerSampleAnys(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Double@)">
            <summary>
            Fetches samples/pixel ANY values for the specified tag and verify
            that all values are the same.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchStripThing(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int32,System.Int64[]@)">
            <summary>
            Fetches a set of offsets or lengths.
            </summary>
            <remarks>While this routine says "strips", in fact it's also used
            for tiles.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchRefBlackWhite(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry)">
            <summary>
            Fetches and sets the RefBlackWhite tag.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.chopUpSingleUncompressedStrip">
            <summary>
            Replace a single strip (tile) of uncompressed data with multiple
            strips (tiles), each approximately 8Kbytes.
            </summary>
            <remarks>This is useful for dealing with large images or for
            dealing with machines with a limited amount of memory.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeDirectory(System.Boolean)">
            <summary>
            Writes the contents of the current directory to the specified file.
            </summary>
            <remarks>This routine doesn't handle overwriting a directory with
            auxiliary storage that's been changed.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeNormalTag(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,BitMiracle.LibTiff.Classic.TiffFieldInfo)">
            <summary>
            Writes tags that are not special cased.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.setupShortLong(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32)">
            <summary>
            Setups a directory entry with either a SHORT or LONG type
            according to the value.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.setupShort(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int16)">
            <summary>
            Setups a SHORT directory entry
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeShortTable(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32,System.Int16[][])">
            <summary>
            Setup a directory entry for an NxM table of shorts, where M is
            known to be 2**bitspersample, and write the associated indirect data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeByteArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Byte[])">
            <summary>
            Write/copy data associated with an ASCII or opaque tag value.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeShortArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int16[])">
            <summary>
            Setup a directory entry of an array of SHORT or SSHORT and write
            the associated indirect values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeLongArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32[])">
            <summary>
            Setup a directory entry of an array of LONG or SLONG and write the
            associated indirect values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeRationalArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Single[])">
            <summary>
            Setup a directory entry of an array of RATIONAL or SRATIONAL and
            write the associated indirect values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeAnyArray(BitMiracle.LibTiff.Classic.TiffType,BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32,System.Double[])">
            <summary>
            Writes an array of "type" values for a specified tag (i.e. this is
            a tag which is allowed to have different types, e.g. SMaxSampleType).
            Internally the data values are represented as double since a double
            can hold any of the TIFF tag types (yes, this should really be an abstract
            type tany_t for portability).  The data is converted into the specified
            type in a temporary buffer and then handed off to the appropriate array
            writer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeData(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Byte[],System.Int32)">
            <summary>
            Writes a contiguous directory item.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.linkDirectory">
            <summary>
            Link the current directory into the directory chain for the file.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.STRIPCHOP_DEFAULT">
            <summary>
            Support strip chopping (whether or not to convert single-strip 
            uncompressed images to mutiple strips of ~8Kb to reduce memory usage)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.DEFAULT_EXTRASAMPLE_AS_ALPHA">
            <summary>
            Treat extra sample as alpha (default enabled). The RGBA interface 
            will treat a fourth sample with no EXTRASAMPLE_ value as being 
            ASSOCALPHA. Many packages produce RGBA files but don't mark the 
            alpha properly.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.CHECK_JPEG_YCBCR_SUBSAMPLING">
            <summary>
            Pick up YCbCr subsampling info from the JPEG data stream to support 
            files lacking the tag (default enabled).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_name">
            <summary>
            name of open file
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_mode">
            <summary>
            open mode (O_*)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_diroff">
            <summary>
            file offset of current directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dir">
            <summary>
            internal rep of current directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_row">
            <summary>
            current scanline
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curstrip">
            <summary>
            current strip for read/write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curtile">
            <summary>
            current tile for read/write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_tilesize">
            <summary>
            # of bytes in a tile
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_scanlinesize">
            <summary>
            # of bytes in a scanline
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawdata">
            <summary>
            raw data buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawdatasize">
            <summary>
            # of bytes in raw data buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawcp">
            <summary>
            current spot in raw buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawcc">
            <summary>
            bytes unread from raw buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_clientdata">
            <summary>
            callback parameter
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_postDecodeMethod">
            <summary>
            post decoding method type
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_tagmethods">
            <summary>
            tag get/set/print routines
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_nextdiroff">
            <summary>
            file offset of following directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dirlist">
            <summary>
            list of offsets to already seen directories to prevent IFD looping
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dirlistsize">
            <summary>
            number of entires in offset list
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dirnumber">
            <summary>
            number of already seen directories
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_header">
            <summary>
            file's header block
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_typeshift">
            <summary>
            data type shift counts
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_typemask">
            <summary>
            data type masks
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curdir">
            <summary>
            current directory (index)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curoff">
            <summary>
            current offset for read/write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dataoff">
            <summary>
            current offset for writing dir
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_nsubifd">
            <summary>
            remaining subifds to write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_subifdoff">
            <summary>
            offset for patching SubIFD link
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_col">
            <summary>
            current column (offset by row too)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_fieldinfo">
            <summary>
            sorted table of registered tags
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_nfields">
            <summary>
            # entries in registered tag table
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_foundfield">
            <summary>
            cached pointer to already found tag
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_clientinfo">
            <summary>
            extra client information.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_stream">
            <summary>
            stream used for read|write|etc.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteCustomDirectory(System.Int64@)">
            <summary>
            Writes custom directory. See ticket #51.
            </summary>
            <param name="pdiroff">Output directory offset.</param>
            <returns>
                <c>true</c> if succeeded; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.postDecode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            post decoding routine
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.NOSTRIP">
            <summary>
            undefined state
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.NOTILE">
            <summary>
            undefined state
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.startStrip(System.Int32)">
            <summary>
            Set state to appear as if a strip has just been read in.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fillStrip(System.Int32)">
            <summary>
            Read the specified strip and setup for decoding.
            The data buffer is expanded, as necessary, to hold the strip's data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fillTile(System.Int32)">
            <summary>
            Read the specified tile and setup for decoding. 
            The data buffer is expanded, as necessary, to hold the tile's data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.appendToStrip(System.Int32,System.Byte[],System.Int32,System.Int64)">
            <summary>
            Appends the data to the specified strip.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Tiff.TiffExtendProc">
            <summary>
            Delegate for LibTiff.Net extender method
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <remarks>
                <para>Extender method is usually used for registering custom tags.</para>
                <para>To setup extender method that will be called upon creation of
            each instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> object please use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetTagExtender(BitMiracle.LibTiff.Classic.Tiff.TiffExtendProc)" />
            method.</para>
            </remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Tiff.FaxFillFunc">
            <summary>
            Delegate for a method used to image decoded spans.        
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="runs">The array of black and white run lengths (white then black).</param>
            <param name="thisRunOffset">The zero-based offset in <paramref name="runs" /> array at
            which current row's run begins.</param>
            <param name="nextRunOffset">The zero-based offset in <paramref name="runs" /> array at
            which next row's run begins.</param>
            <param name="width">The width in pixels of the row.</param>
            <remarks>
                <para>
            To override the default method used to image decoded spans please set
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FAXFILLFUNC" /> tag with an instance of this delegate.</para>
                <para>
            Fill methods can assume the <paramref name="runs" /> array has room for at least
            <paramref name="width" /> runs and can overwrite data in the <paramref name="runs" />
            array as needed (e.g. to append zero runs to bring the count up to a nice multiple).
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetVersion">
            <summary>
            Gets the library version string.
            </summary>
            <returns>The library version string.</returns>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Tiff.AssemblyVersion">
            <summary>
            Gets the version of the library's assembly.
            </summary>
            <value>The version of the library's assembly.</value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)">
            <summary>
            Gets the R component from ABGR value returned by 
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The R component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)">
            <summary>
            Gets the G component from ABGR value returned by 
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The G component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)">
            <summary>
            Gets the B component from ABGR value returned by 
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The B component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)">
            <summary>
            Gets the A component from ABGR value returned by 
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The A component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FindCodec(BitMiracle.LibTiff.Classic.Compression)">
            <summary>
            Retrieves the codec registered for the specified compression scheme.
            </summary>
            <param name="scheme">The compression scheme.</param>
            <returns>The codec registered for the specified compression scheme or <c>null</c>
            if there is no codec registered for the given scheme.</returns>
            <remarks>
                <para>
            LibTiff.Net supports a variety of compression schemes implemented by software codecs.
            Each codec adheres to a modular interface that provides for the decoding and encoding
            of image data; as well as some other methods for initialization, setup, cleanup, and
            the control of default strip and tile sizes. Codecs are identified by the associated
            value of the <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.COMPRESSION tag.
            </para>
                <para>
            Other compression schemes may be registered. Registered schemes can also override the
            built-in versions provided by the library.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RegisterCodec(BitMiracle.LibTiff.Classic.TiffCodec)">
            <summary>
            Adds specified codec to a list of registered codec.
            </summary>
            <param name="codec">The codec to register.</param>
            <remarks>
            This method can be used to augment or override the set of codecs available to an
            application. If the <paramref name="codec" /> is for a scheme that already has a
            registered codec then it is overridden and any images with data encoded with this
            compression scheme will be decoded using the supplied codec.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.UnRegisterCodec(BitMiracle.LibTiff.Classic.TiffCodec)">
            <summary>
            Removes specified codec from a list of registered codecs.
            </summary>
            <param name="codec">The codec to remove from a list of registered codecs.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsCodecConfigured(BitMiracle.LibTiff.Classic.Compression)">
            <summary>
            Checks whether library has working codec for the specific compression scheme.
            </summary>
            <param name="scheme">The scheme to check.</param>
            <returns>
                <c>true</c> if the codec is configured and working; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetConfiguredCodecs">
            <summary>
            Retrieves an array of configured codecs, both built-in and registered by user.
            </summary>
            <returns>An array of configured codecs.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Realloc(System.Byte[],System.Int32)">
            <summary>
            Allocates new byte array of specified size and copies data from the existing to
            the new array.
            </summary>
            <param name="array">The existing array.</param>
            <param name="size">The number of elements in new array.</param>
            <returns>
            The new byte array of specified size with data from the existing array.
            </returns>
            <overloads>Allocates new array of specified size and copies data from the existing to
            the new array.</overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Realloc(System.Int32[],System.Int32)">
            <summary>
            Allocates new integer array of specified size and copies data from the existing to
            the new array.
            </summary>
            <param name="array">The existing array.</param>
            <param name="size">The number of elements in new array.</param>
            <returns>
            The new integer array of specified size with data from the existing array.
            </returns>
            <remarks>Size of the array is in elements, not bytes.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Compare(System.Int16[],System.Int16[],System.Int32)">
            <summary>
            Compares specified number of elements in two arrays.
            </summary>
            <param name="first">The first array to compare.</param>
            <param name="second">The second array to compare.</param>
            <param name="elementCount">The number of elements to compare.</param>
            <returns>
            The difference between compared elements or 0 if all elements are equal.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)">
            <summary>
            Initializes new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class and opens a TIFF file for
            reading or writing.
            </summary>
            <param name="fileName">The name of the file to open.</param>
            <param name="mode">The open mode. Specifies if the file is to be opened for
            reading ("r"), writing ("w"), or appending ("a") and, optionally, whether to override
            certain default aspects of library operation (see remarks).</param>
            <returns>The new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class if specified file is
            successfully opened; otherwise, <c>null</c>.</returns>
            <remarks>
                <para>
                    <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> opens a TIFF file whose name is <paramref name="fileName" />. When
            a file is opened for appending, existing data will not be touched; instead new data
            will be written as additional subfiles. If an existing file is opened for writing,
            all previous data is overwritten.
            </para>
                <para>
            If a file is opened for reading, the first TIFF directory in the file is automatically
            read (see <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)" /> for reading directories other than the first). If
            a file is opened for writing or appending, a default directory is automatically
            created for writing subsequent data. This directory has all the default values
            specified in TIFF Revision 6.0: BitsPerSample = 1, ThreshHolding = Threshold.BILEVEL
            (bilevel art scan), FillOrder = MSB2LSB (most significant bit of each data byte is
            filled first), Orientation = TOPLEFT (the 0th row represents the visual top of the
            image, and the 0th column represents the visual left hand side), SamplesPerPixel = 1,
            RowsPerStrip = infinity, ResolutionUnit = INCH, and Compression = NONE. To alter
            these values, or to define values for additional fields, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])" /> must
            be used.
            </para>
                <para>
            The <paramref name="mode" /> parameter can include the following flags in addition to
            the "r", "w", and "a" flags. Note however that option flags must follow the
            read-write-append specification.
            </para>
                <list type="table">
                    <listheader>
                        <term>Flag</term>
                        <description>Description</description>
                    </listheader>
                    <item>
                        <term>l</term>
                        <description>When creating a new file force information be written with Little-Endian
            byte order (but see below).</description>
                    </item>
                    <item>
                        <term>b</term>
                        <description>When creating a new file force information be written with Big-Endian
            byte order (but see below).</description>
                    </item>
                    <item>
                        <term>L</term>
                        <description>Force image data that is read or written to be treated with bits filled
            from Least Significant Bit (LSB) to Most Significant Bit (MSB). Note that this is the
            opposite to the way the library has worked from its inception.</description>
                    </item>
                    <item>
                        <term>B</term>
                        <description>Force image data that is read or written to be treated with bits filled
            from Most Significant Bit (MSB) to Least Significant Bit (LSB); this is the
            default.</description>
                    </item>
                    <item>
                        <term>H</term>
                        <description>Force image data that is read or written to be treated with bits filled
            in the same order as the native CPU.</description>
                    </item>
                    <item>
                        <term>C</term>
                        <description>Enable the use of "strip chopping" when reading images that are comprised
            of a single strip or tile of uncompressed data. Strip chopping is a mechanism by which
            the library will automatically convert the single-strip image to multiple strips, each
            of which has about 8 Kilobytes of data. This facility can be useful in reducing the
            amount of memory used to read an image because the library normally reads each strip
            in its entirety. Strip chopping does however alter the apparent contents of the image
            because when an image is divided into multiple strips it looks as though the
            underlying file contains multiple separate strips. The default behaviour is to enable 
            strip chopping.</description>
                    </item>
                    <item>
                        <term>c</term>
                        <description>Disable the use of strip chopping when reading images.</description>
                    </item>
                    <item>
                        <term>h</term>
                        <description>Read TIFF header only, do not load the first image directory. That could
            be useful in case of the broken first directory. We can open the file and proceed to
            the other directories.</description>
                    </item>
                    <item>
                        <term>4</term>
                        <description>Create classic TIFF file</description>
                    </item>
                    <item>
                        <term>8</term>
                        <description>Create BigTIFF file</description>
                    </item>
                </list>
                <para>
            By default the library will create new files with the native byte-order of the CPU on
            which the application is run. This ensures optimal performance and is portable to any
            application that conforms to the TIFF specification. To force the library to use a
            specific byte-order when creating a new file the "b" and "l" option flags may be
            included in the <paramref name="mode" /> parameter; for example, "wb" or "wl".</para>
                <para>The use of the "l" and "b" flags is strongly discouraged. These flags are
            provided solely because numerous vendors do not correctly support TIFF; they only
            support one of the two byte orders. It is strongly recommended that you not use this
            feature except to deal with busted apps that write invalid TIFF.</para>
                <para>The "L", "B", and "H" flags are intended for applications that can optimize
            operations on data by using a particular bit order.  By default the library returns
            data in MSB2LSB bit order. Returning data in the bit order of the native CPU makes the
            most sense but also requires applications to check the value of the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag; something they probably do not do right now.</para>
                <para>The "c" option permits applications that only want to look at the tags, for
            example, to get the unadulterated TIFF tag information.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)">
            <summary>
            Initializes new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class and opens a stream with TIFF data
            for reading or writing.
            </summary>
            <param name="name">The name for the new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <param name="mode">The open mode. Specifies if the file is to be opened for
            reading ("r"), writing ("w"), or appending ("a") and, optionally, whether to override
            certain default aspects of library operation (see remarks for <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" />
            method for the list of the mode flags).</param>
            <param name="clientData">Some client data. This data is passed as parameter to every
            method of the <see cref="T:BitMiracle.LibTiff.Classic.TiffStream" /> object specified by the
            <paramref name="stream" /> parameter.</param>
            <param name="stream">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffStream" /> class to use for
            reading, writing and seeking of TIFF data.</param>
            <returns>The new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class if stream is successfully
            opened; otherwise, <c>null</c>.</returns>
            <remarks>
                <para>
            This method can be used to read TIFF data from sources other than file. When custom
            stream class derived from <see cref="T:BitMiracle.LibTiff.Classic.TiffStream" /> is used it is possible to read (or
            write) TIFF data that reside in memory, database, etc.
            </para>
                <para>Please note, that <paramref name="name" /> is an arbitrary string used as
            ID for the created <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />. It's not required to be a file name or anything
            meaningful at all.</para>
                <para>
            Please read remarks for <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> method for the list of option flags that
            can be specified in <paramref name="mode" /> parameter.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Close">
            <summary>
            Closes a previously opened TIFF file.
            </summary>
            <remarks>
            This method closes a file or stream that was previously opened with <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" />
            or <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)" />.
            Any buffered data are flushed to the file/stream,
            including the contents of the current directory (if modified); and all resources
            are reclaimed.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Dispose">
            <summary>
            Frees and releases all resources allocated by this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetTagListCount">
            <summary>
            Gets the number of elements in the custom tag list.
            </summary>
            <returns>The number of elements in the custom tag list.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetTagListEntry(System.Int32)">
            <summary>
            Retrieves the custom tag with specified index.
            </summary>
            <param name="index">The zero-based index of a custom tag to retrieve.</param>
            <returns>The custom tag with specified index.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.MergeFieldInfo(BitMiracle.LibTiff.Classic.TiffFieldInfo[],System.Int32)">
            <summary>
            Merges given field information to existing one.
            </summary>
            <param name="info">The array of <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo" /> objects.</param>
            <param name="count">The number of items to use from the <paramref name="info" /> array.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FindFieldInfo(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.TiffType)">
            <summary>
            Retrieves field information for the specified tag.
            </summary>
            <param name="tag">The tag to retrieve field information for.</param>
            <param name="type">The tiff data type to use us additional filter.</param>
            <returns>The field information for specified tag with specified type or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FindFieldInfoByName(System.String,BitMiracle.LibTiff.Classic.TiffType)">
            <summary>
            Retrieves field information for the tag with specified name.
            </summary>
            <param name="name">The name of the tag to retrieve field information for.</param>
            <param name="type">The tiff data type to use us additional filter.</param>
            <returns>The field information for specified tag with specified type or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FieldWithTag(BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Retrieves field information for the specified tag.
            </summary>
            <param name="tag">The tag to retrieve field information for.</param>
            <returns>The field information for specified tag or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FieldWithName(System.String)">
            <summary>
            Retrieves field information for the tag with specified name.
            </summary>
            <param name="name">The name of the tag to retrieve field information for.</param>
            <returns>The field information for specified tag or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetTagMethods">
            <summary>
            Gets the currently used tag methods.
            </summary>
            <returns>The currently used tag methods.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetTagMethods(BitMiracle.LibTiff.Classic.TiffTagMethods)">
            <summary>
            Sets the new tag methods to use.
            </summary>
            <param name="methods">Tag methods.</param>
            <returns>The previously used tag methods.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetClientInfo(System.String)">
            <summary>
            Gets the extra information with specified name associated with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <param name="name">Name of the extra information to retrieve.</param>
            <returns>The extra information with specified name associated with
            this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> or <c>null</c> if extra information with specified
            name was not found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetClientInfo(System.Object,System.String)">
            <summary>
            Associates extra information with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <param name="data">The information to associate with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.</param>
            <param name="name">The name (label) of the information.</param>
            <remarks>If there is already an extra information with the name specified by
            <paramref name="name" /> it will be replaced by the information specified by
            <paramref name="data" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Flush">
            <summary>
            Flushes pending writes to an open TIFF file.
            </summary>
            <returns>
                <c>true</c> if succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush" /> causes any pending writes for the specified file
            (including writes for the current directory) to be done. In normal operation this call
            is never needed − the library automatically does any flushing required.
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.FlushData" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FlushData">
            <summary>
            Flushes any pending image data for the specified file to be written out.
            </summary>
            <returns>
                <c>true</c> if succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <see cref="M:BitMiracle.LibTiff.Classic.Tiff.FlushData" /> flushes any pending image data for the specified file
            to be written out; directory-related data are not flushed. In normal operation this
            call is never needed − the library automatically does any flushing required.
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Gets the value(s) of a tag in an open TIFF file.
            </summary>
            <param name="tag">The tag.</param>
            <returns>The value(s) of a tag in an open TIFF file as array of
            <see cref="T:BitMiracle.LibTiff.Classic.FieldValue" /> objects or <c>null</c> if there is no such tag set.</returns>
            <remarks>
                <para>
                    <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)" /> returns the value(s) of a tag or pseudo-tag associated with the
            current directory of the opened TIFF file. The tag is identified by
            <paramref name="tag" />. The type and number of values returned is dependent on the
            tag being requested. You may want to consult
            <a href="../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> to become familiar with exact data types and calling
            conventions required for each tag supported by the library.
            </para>
                <para>
            A pseudo-tag is a parameter that is used to control the operation of the library but
            whose value is not read or written to the underlying file.
            </para>
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.GetFieldDefaulted(BitMiracle.LibTiff.Classic.TiffTag)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetFieldDefaulted(BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Gets the value(s) of a tag in an open TIFF file or default value(s) of a tag if a tag
            is not defined in the current directory and it has a default value(s).
            </summary>
            <param name="tag">The tag.</param>
            <returns>
            The value(s) of a tag in an open TIFF file as array of
            <see cref="T:BitMiracle.LibTiff.Classic.FieldValue" /> objects or <c>null</c> if there is no such tag set and
            tag has no default value.
            </returns>
            <remarks>
                <para>
                    <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetFieldDefaulted(BitMiracle.LibTiff.Classic.TiffTag)" /> returns the value(s) of a tag or pseudo-tag associated
            with the current directory of the opened TIFF file or default value(s) of a tag if a
            tag is not defined in the current directory and it has a default value(s). The tag is
            identified by <paramref name="tag" />. The type and number of values returned is
            dependent on the tag being requested. You may want to consult
            <a href="../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> to become familiar with exact data types and calling
            conventions required for each tag supported by the library.
            </para>
                <para>
            A pseudo-tag is a parameter that is used to control the operation of the library but
            whose value is not read or written to the underlying file.
            </para>
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadDirectory">
            <summary>
            Reads the contents of the next TIFF directory in an open TIFF file/stream and makes
            it the current directory.
            </summary>
            <returns>
                <c>true</c> if directory was successfully read; otherwise, <c>false</c> if an
            error was encountered, or if there are no more directories to be read.</returns>
            <remarks>
                <para>Directories are read sequentially.</para>
                <para>Applications only need to call <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadDirectory" /> to read multiple
            subfiles in a single TIFF file/stream - the first directory in a file/stream is
            automatically read when <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)" /> is called.
            </para>
                <para>
            The images that have a single uncompressed strip or tile of data are automatically
            treated as if they were made up of multiple strips or tiles of approximately 8
            kilobytes each. This operation is done only in-memory; it does not alter the contents
            of the file/stream. However, the construction of the "chopped strips" is visible to
            the application through the number of strips returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfStrips" />
            or the number of tiles returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfTiles" />.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadCustomDirectory(System.Int64,BitMiracle.LibTiff.Classic.TiffFieldInfo[],System.Int32)">
            <summary>
            Reads a custom directory from the arbitrary offset within file/stream.
            </summary>
            <param name="offset">The directory offset.</param>
            <param name="info">The array of <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo" /> objects to read from
            custom directory. Standard <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo" /> objects are ignored.</param>
            <param name="count">The number of items to use from
            the <paramref name="info" /> array.</param>
            <returns>
                <c>true</c> if a custom directory was read successfully;
            otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadEXIFDirectory(System.Int64)">
            <summary>
            Reads an EXIF directory from the given offset within file/stream.
            </summary>
            <param name="offset">The directory offset.</param>
            <returns>
                <c>true</c> if an EXIF directory was read successfully; 
            otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize">
            <summary>
            Calculates the size in bytes of a row of data as it would be returned in a call to
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadScanline" />, or as it would be
            expected in a call to <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" />.
            </summary>
            <returns>The size in bytes of a row of data.</returns>
            <remarks>
                <b>ScanlineSize</b> calculates size for one sample plane only. Please use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RasterScanlineSize" /> if you want to get size in bytes of a complete
            decoded and packed raster scanline.</remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RasterScanlineSize" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RasterScanlineSize">
            <summary>
            Calculates the size in bytes of a complete decoded and packed raster scanline.
            </summary>
            <returns>The size in bytes of a complete decoded and packed raster scanline.</returns>
            <remarks>The value returned by <b>RasterScanlineSize</b> may be different from the
            value returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize" /> if data is stored as separate
            planes (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.DefaultStripSize(System.Int32)">
            <summary>
            Computes the number of rows for a reasonable-sized strip according to the current
            settings of the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH" />, <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" />
            and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLESPERPIXEL" /> tags and any compression-specific requirements.
            </summary>
            <param name="estimate">The esimated value (may be zero).</param>
            <returns>The number of rows for a reasonable-sized strip according to the current
            tag settings and compression-specific requirements.</returns>
            <remarks>If the <paramref name="estimate" /> parameter is non-zero, then it is taken
            as an estimate of the desired strip size and adjusted according to any
            compression-specific requirements. The value returned by <b>DefaultStripSize</b> is
            typically used to define the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP" /> tag. If there is no
            any unusual requirements <b>DefaultStripSize</b> tries to create strips that have
            approximately 8 kilobytes of uncompressed data.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.StripSize">
            <summary>
            Computes the number of bytes in a row-aligned strip.
            </summary>
            <returns>The number of bytes in a row-aligned strip</returns>
            <remarks>
                <para>
                    <b>StripSize</b> returns the equivalent size for a strip of data as it would be
            returned in a call to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)" /> or as it would be expected in a
            call to <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedStrip" />.
            </para>
                <para>
            If the value of the field corresponding to <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP" /> is
            larger than the recorded <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />, then the strip size is
            truncated to reflect the actual space required to hold the strip.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.VStripSize(System.Int32)">
            <summary>
            Computes the number of bytes in a row-aligned strip with specified number of rows.
            </summary>
            <param name="rowCount">The number of rows in a strip.</param>
            <returns>
            The number of bytes in a row-aligned strip with specified number of rows.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RawStripSize(System.Int32)">
            <summary>
            Computes the number of bytes in a raw (i.e. not decoded) strip.
            </summary>
            <param name="strip">The zero-based index of a strip.</param>
            <returns>The number of bytes in a raw strip.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)">
            <summary>
            Computes which strip contains the specified coordinates (row, plane).
            </summary>
            <param name="row">The row.</param>
            <param name="plane">The sample plane.</param>
            <returns>The number of the strip that contains the specified coordinates.</returns>
            <remarks>
            A valid strip number is always returned; out-of-range coordinate values are clamped to
            the bounds of the image. The <paramref name="row" /> parameter is always used in
            calculating a strip. The <paramref name="plane" /> parameter is used only if data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfStrips">
            <summary>
            Retrives the number of strips in the image.
            </summary>
            <returns>The number of strips in the image.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.DefaultTileSize(System.Int32@,System.Int32@)">
            <summary>
            Computes the pixel width and height of a reasonable-sized tile suitable for setting
            up the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILEWIDTH" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILELENGTH" /> tags.
            </summary>
            <param name="width">The proposed tile width upon the call / tile width to use
            after the call.</param>
            <param name="height">The proposed tile height upon the call / tile height to use
            after the call.</param>
            <remarks>If the <paramref name="width" /> and <paramref name="height" /> values passed
            in are non-zero, then they are adjusted to reflect any compression-specific
            requirements. The returned width and height are constrained to be a multiple of
            16 pixels to conform with the TIFF specification.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.TileSize">
            <summary>
            Compute the number of bytes in a row-aligned tile.
            </summary>
            <returns>The number of bytes in a row-aligned tile.</returns>
            <remarks>
                <b>TileSize</b> returns the equivalent size for a tile of data as it would be
            returned in a call to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)" /> or as it would be expected in a
            call to <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteTile" />.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.VTileSize(System.Int32)">
            <summary>
            Computes the number of bytes in a row-aligned tile with specified number of rows.
            </summary>
            <param name="rowCount">The number of rows in a tile.</param>
            <returns>
            The number of bytes in a row-aligned tile with specified number of rows.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RawTileSize(System.Int32)">
            <summary>
            Computes the number of bytes in a raw (i.e. not decoded) tile.
            </summary>
            <param name="tile">The zero-based index of a tile.</param>
            <returns>The number of bytes in a raw tile.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.TileRowSize">
            <summary>
            Compute the number of bytes in each row of a tile.
            </summary>
            <returns>The number of bytes in each row of a tile.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Computes which tile contains the specified coordinates (x, y, z, plane).
            </summary>
            <param name="x">The x-coordinate.</param>
            <param name="y">The y-coordinate.</param>
            <param name="z">The z-coordinate.</param>
            <param name="plane">The sample plane.</param>
            <returns>The number of the tile that contains the specified coordinates.</returns>
            <remarks>
            A valid tile number is always returned; out-of-range coordinate values are
            clamped to the bounds of the image. The <paramref name="x" /> and <paramref name="y" />
            parameters are always used in calculating a tile. The <paramref name="z" /> parameter
            is used if the image is deeper than 1 slice (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH" /> &gt; 1).
            The <paramref name="plane" /> parameter is used only if data are organized in separate
            planes (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CheckTile(System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Checks whether the specified (x, y, z, plane) coordinates are within the bounds of
            the image.
            </summary>
            <param name="x">The x-coordinate.</param>
            <param name="y">The y-coordinate.</param>
            <param name="z">The z-coordinate.</param>
            <param name="plane">The sample plane.</param>
            <returns>
                <c>true</c> if the specified coordinates are within the bounds of the image;
            otherwise, <c>false</c>.</returns>
            <remarks>The <paramref name="x" /> parameter is checked against the value of the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH" /> tag. The <paramref name="y" /> parameter is checked
            against the value of the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag. The <paramref name="z" />
            parameter is checked against the value of the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH" /> tag
            (if defined). The <paramref name="plane" /> parameter is checked against the value of
            the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLESPERPIXEL" /> tag if the data are organized in separate
            planes.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfTiles">
            <summary>
            Retrives the number of tiles in the image.
            </summary>
            <returns>The number of tiles in the image.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Clientdata">
            <summary>
            Returns the custom client data associated with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <returns>The custom client data associated with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetClientdata(System.Object)">
            <summary>
            Asscociates a custom data with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <param name="data">The data to associate.</param>
            <returns>The previously associated data.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetMode">
            <summary>
            Gets the mode with which the underlying file or stream was opened.
            </summary>
            <returns>The mode with which the underlying file or stream was opened.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetMode(System.Int32)">
            <summary>
            Sets the new mode for the underlying file or stream.
            </summary>
            <param name="mode">The new mode for the underlying file or stream.</param>
            <returns>The previous mode with which the underlying file or stream was opened.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled">
            <summary>
            Gets the value indicating whether the image data of this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> has a
            tiled organization.
            </summary>
            <returns>
                <c>true</c> if the image data of this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> has a tiled organization or
            <c>false</c> if the image data of this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> is organized in strips.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsByteSwapped">
            <summary>
            Gets the value indicating whether the image data was in a different byte-order than
            the host computer.
            </summary>
            <returns>
                <c>true</c> if the image data was in a different byte-order than the host
            computer or <c>false</c> if the TIFF file/stream and local host byte-orders are the
            same.</returns>
            <remarks>
                <para>
            Note that <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedTile(System.Int32,System.Byte[],System.Int32,System.Int32)" />,
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)" /> and
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadScanline" /> methods already
            normally perform byte swapping to local host order if needed.
            </para>
                <para>
            Also note that <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawTile(System.Int32,System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawStrip(System.Int32,System.Byte[],System.Int32,System.Int32)" /> do not
            perform byte swapping to local host order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsUpSampled">
            <summary>
            Gets the value indicating whether the image data returned through the read interface
            methods is being up-sampled.
            </summary>
            <returns>
                <c>true</c> if the data is returned up-sampled; otherwise, <c>false</c>.
            </returns>
            <remarks>The value returned by this method can be useful to applications that want to
            calculate I/O buffer sizes to reflect this usage (though the usual strip and tile size
            routines already do this).</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsMSB2LSB">
            <summary>
            Gets the value indicating whether the image data is being returned in MSB-to-LSB
            bit order.
            </summary>
            <returns>
                <c>true</c> if the data is being returned in MSB-to-LSB bit order (i.e with bit 0 as
            the most significant bit); otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsBigEndian">
            <summary>
            Gets the value indicating whether given image data was written in big-endian order.
            </summary>
            <returns>
                <c>true</c> if given image data was written in big-endian order; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetStream">
            <summary>
            Gets the tiff stream.
            </summary>
            <returns>The tiff stream.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentRow">
            <summary>
            Gets the current row that is being read or written.
            </summary>
            <returns>The current row that is being read or written.</returns>
            <remarks>The current row is updated each time a read or write is done.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentDirectory">
            <summary>
            Gets the zero-based index of the current directory.
            </summary>
            <returns>The zero-based index of the current directory.</returns>
            <remarks>The zero-based index returned by this method is suitable for use with
            the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)" /> method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfDirectories">
            <summary>
            Gets the number of directories in a file.
            </summary>
            <returns>The number of directories in a file.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentDirOffset">
            <summary>
            Retrieves the file/stream offset of the current directory.
            </summary>
            <returns>The file/stream offset of the current directory.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentStrip">
            <summary>
            Gets the current strip that is being read or written.
            </summary>
            <returns>The current strip that is being read or written.</returns>
            <remarks>The current strip is updated each time a read or write is done.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentTile">
            <summary>
            Gets the current tile that is being read or written.
            </summary>
            <returns>The current tile that is being read or written.</returns>
            <remarks>The current tile is updated each time a read or write is done.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadBufferSetup(System.Byte[],System.Int32)">
            <summary>
            Sets up the data buffer used to read raw (encoded) data from a file.
            </summary>
            <param name="buffer">The data buffer.</param>
            <param name="size">The buffer size.</param>
            <remarks>
                <para>
            This method is provided for client-control of the I/O buffers used by the library.
            Applications need never use this method; it's provided only for "intelligent clients"
            that wish to optimize memory usage and/or eliminate potential copy operations that can
            occur when working with images that have data stored without compression.
            </para>
                <para>
            If the <paramref name="buffer" /> is <c>null</c>, then a buffer of appropriate size is
            allocated by the library. Otherwise, the caller must guarantee that the buffer is
            large enough to hold any individual strip of raw data.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteBufferSetup(System.Byte[],System.Int32)">
            <summary>
            Sets up the data buffer used to write raw (encoded) data to a file.
            </summary>
            <param name="buffer">The data buffer.</param>
            <param name="size">The buffer size.</param>
            <remarks>
                <para>
            This method is provided for client-control of the I/O buffers used by the library.
            Applications need never use this method; it's provided only for "intelligent clients"
            that wish to optimize memory usage and/or eliminate potential copy operations that can
            occur when working with images that have data stored without compression.
            </para>
                <para>
            If the <paramref name="size" /> is -1 then the buffer size is selected to hold a
            complete tile or strip, or at least 8 kilobytes, whichever is greater. If the
            <paramref name="buffer" /> is <c>null</c>, then a buffer of appropriate size is
            allocated by the library.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetupStrips">
            <summary>
            Setups the strips.
            </summary>
            <returns>
                <c>true</c> if setup successfully; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteCheck(System.Boolean,System.String)">
            <summary>
            Verifies that file/stream is writable and that the directory information is
            setup properly.
            </summary>
            <param name="tiles">If set to <c>true</c> then ability to write tiles will be verified;
            otherwise, ability to write strips will be verified.</param>
            <param name="method">The name of the calling method.</param>
            <returns>
                <c>true</c> if file/stream is writeable and the directory information is
            setup properly; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FreeDirectory">
            <summary>
            Releases storage associated with current directory.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CreateDirectory">
            <summary>
            Creates a new directory within file/stream.
            </summary>
            <remarks>The newly created directory will not exist on the file/stream till
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.CheckpointDirectory" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush" />
            or <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Close" /> is called.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.LastDirectory">
            <summary>
            Returns an indication of whether the current directory is the last directory
            in the file.
            </summary>
            <returns>
                <c>true</c> if current directory is the last directory in the file;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)">
            <summary>
            Sets the directory with specified number as the current directory.
            </summary>
            <param name="number">The zero-based number of the directory to set as the
            current directory.</param>
            <returns>
                <c>true</c> if the specified directory was set as current successfully;
            otherwise, <c>false</c></returns>
            <remarks>
                <b>SetDirectory</b> changes the current directory and reads its contents with
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadDirectory" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetSubDirectory(System.Int64)">
            <summary>
            Sets the directory at specified file/stream offset as the current directory.
            </summary>
            <param name="offset">The offset from the beginnig of the file/stream to the directory
            to set as the current directory.</param>
            <returns>
                <c>true</c> if the directory at specified file offset was set as current
            successfully; otherwise, <c>false</c></returns>
            <remarks>
                <b>SetSubDirectory</b> acts like <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)" />, except the
            directory is specified as a file offset instead of an index; this is required for
            accessing subdirectories linked through a SubIFD tag (e.g. thumbnail images).</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.UnlinkDirectory(System.Int16)">
            <summary>
            Unlinks the specified directory from the directory chain.
            </summary>
            <param name="number">The zero-based number of the directory to unlink.</param>
            <returns>
                <c>true</c> if directory was unlinked successfully; otherwise, <c>false</c>.</returns>
            <remarks>
                <b>UnlinkDirectory</b> does not removes directory bytes from the file/stream.
            It only makes them unused.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])">
            <summary>
            Sets the value(s) of a tag in a TIFF file/stream open for writing.
            </summary>
            <param name="tag">The tag.</param>
            <param name="value">The tag value(s).</param>
            <returns>
                <c>true</c> if tag value(s) were set successfully; otherwise, <c>false</c>.</returns>
            <remarks>
                <para>
                    <b>SetField</b> sets the value of a tag or pseudo-tag in the current directory
            associated with the open TIFF file/stream. To set the value of a field the file/stream
            must have been previously opened for writing with <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)" />;
            pseudo-tags can be set whether the file was opened for
            reading or writing. The tag is identified by <paramref name="tag" />.
            The type and number of values in <paramref name="value" /> is dependent on the tag
            being set. You may want to consult
            <a href="../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> to become familiar with exact data types and calling
            conventions required for each tag supported by the library.
            </para>
                <para>
            A pseudo-tag is a parameter that is used to control the operation of the library but
            whose value is not read or written to the underlying file.
            </para>
                <para>
            The field will be written to the file when/if the directory structure is updated.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory">
            <summary>
            Writes the contents of the current directory to the file and setup to create a new
            subfile (page) in the same file.
            </summary>
            <returns>
                <c>true</c> if the current directory was written successfully;
            otherwise, <c>false</c></returns>
            <remarks>Applications only need to call <b>WriteDirectory</b> when writing multiple
            subfiles (pages) to a single TIFF file. <b>WriteDirectory</b> is automatically called
            by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Close" /> and <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush" /> to write a modified directory if the
            file is open for writing.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CheckpointDirectory">
            <summary>
            Writes the current state of the TIFF directory into the file to make what is currently
            in the file/stream readable.
            </summary>
            <returns>
                <c>true</c> if the current directory was rewritten successfully;
            otherwise, <c>false</c></returns>
            <remarks>Unlike <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory" />, <b>CheckpointDirectory</b> does not free
            up the directory data structures in memory, so they can be updated (as strips/tiles
            are written) and written again. Reading such a partial file you will at worst get a
            TIFF read error for the first strip/tile encountered that is incomplete, but you will
            at least get all the valid data in the file before that. When the file is complete,
            just use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory" /> as usual to finish it off cleanly.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RewriteDirectory">
            <summary>
            Rewrites the contents of the current directory to the file and setup to create a new
            subfile (page) in the same file.
            </summary>
            <returns>
                <c>true</c> if the current directory was rewritten successfully;
            otherwise, <c>false</c></returns>
            <remarks>The <b>RewriteDirectory</b> operates similarly to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory" />,
            but can be called with directories previously read or written that already have an
            established location in the file. It will rewrite the directory, but instead of place
            it at it's old location (as <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory" /> would) it will place them at
            the end of the file, correcting the pointer from the preceeding directory or file
            header to point to it's new location. This is particularly important in cases where
            the size of the directory and pointed to data has grown, so it won’t fit in the space
            available at the old location. Note that this will result in the loss of the 
            previously used directory space.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.PrintDirectory(System.IO.Stream)">
            <summary>
            Prints formatted description of the contents of the current directory to the
            specified stream.
            </summary>
            <overloads>
            Prints formatted description of the contents of the current directory to the
            specified stream possibly using specified print options.
            </overloads>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.PrintDirectory(System.IO.Stream,BitMiracle.LibTiff.Classic.TiffPrintFlags)">
            <summary>
            Prints formatted description of the contents of the current directory to the
            specified stream using specified print (formatting) options.
            </summary>
            <param name="stream">The stream.</param>
            <param name="flags">The print (formatting) options.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32)">
            <summary>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </summary>
            <overloads>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </overloads>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="row">The zero-based index of scanline (row) to read.</param>
            <returns>
                <c>true</c> if image data were read and decoded successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>ReadScanline</b> reads the data for the specified <paramref name="row" /> into the
            user supplied data buffer <paramref name="buffer" />. The data are returned
            decompressed and, in the native byte- and bit-ordering, but are otherwise packed
            (see further below). The <paramref name="buffer" /> must be large enough to hold an
            entire scanline of data. Applications should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize" />
            to find out the size (in bytes) of a scanline buffer. Applications should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int16)" /> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int32,System.Int16)" /> and specify correct sample plane if
            image data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            </para>
                <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="row">The zero-based index of scanline (row) to read.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
                <c>true</c> if image data were read and decoded successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>ReadScanline</b> reads the data for the specified <paramref name="row" /> and
            specified sample plane <paramref name="plane" /> into the user supplied data buffer
            <paramref name="buffer" />. The data are returned decompressed and, in the native
            byte- and bit-ordering, but are otherwise packed (see further below). The
            <paramref name="buffer" /> must be large enough to hold an entire scanline of data.
            Applications should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize" /> to find out the size (in
            bytes) of a scanline buffer. Applications may use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32)" /> or specify 0 for <paramref name="plane" />
            parameter if image data is contiguous (i.e not organized in separate planes, 
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG).
            </para>
                <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin storing read and decoded bytes.</param>
            <param name="row">The zero-based index of scanline (row) to read.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
                <c>true</c> if image data were read and decoded successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>ReadScanline</b> reads the data for the specified <paramref name="row" /> and
            specified sample plane <paramref name="plane" /> into the user supplied data buffer
            <paramref name="buffer" />. The data are returned decompressed and, in the native
            byte- and bit-ordering, but are otherwise packed (see further below). The
            <paramref name="buffer" /> must be large enough to hold an entire scanline of data.
            Applications should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize" /> to find out the size (in
            bytes) of a scanline buffer. Applications may use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32)" /> or specify 0 for <paramref name="plane" />
            parameter if image data is contiguous (i.e not organized in separate planes,
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG).
            </para>
                <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32)">
            <summary>
            Encodes and writes a scanline of data to an open TIFF file/stream.
            </summary>
            <overloads>Encodes and writes a scanline of data to an open TIFF file/stream.</overloads>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="row">The zero-based index of scanline (row) to place encoded data at.</param>
            <returns>
                <c>true</c> if image data were encoded and written successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>WriteScanline</b> encodes and writes to a file at the specified
            <paramref name="row" />. Applications should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int16)" /> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int32,System.Int16)" /> and specify correct sample plane
            parameter if image data in a file/stream is organized in separate planes (i.e
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            </para>
                <para>
            The data are assumed to be uncompressed and in the native bit- and byte-order of the
            host machine. The data written to the file is compressed according to the compression
            scheme of the current TIFF directory (see further below). If the current scanline is
            past the end of the current subfile, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the scanline (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8. The library attempts to hide bit-ordering differences between the image and
            the native machine by converting data from the native machine order.
            </para>
                <para>
            Once data are written to a file/stream for the current directory, the values of
            certain tags may not be altered; see
            <a href="../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> for more information.
            </para>
                <para>
            It is not possible to write scanlines to a file/stream that uses a tiled organization.
            The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled" /> can be used to determine if the file/stream is organized as
            tiles or strips.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Encodes and writes a scanline of data to an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="row">The zero-based index of scanline (row) to place encoded data at.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
                <c>true</c> if image data were encoded and written successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>WriteScanline</b> encodes and writes to a file at the specified
            <paramref name="row" /> and specified sample plane <paramref name="plane" />.
            Applications may use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32)" /> or specify 0 for
            <paramref name="plane" /> parameter if image data in a file/stream is contiguous (i.e
            not organized in separate planes,
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG).
            </para>
                <para>
            The data are assumed to be uncompressed and in the native bit- and byte-order of the
            host machine. The data written to the file is compressed according to the compression
            scheme of the current TIFF directory (see further below). If the current scanline is
            past the end of the current subfile, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the scanline (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8. The library attempts to hide bit-ordering differences between the image and
            the native machine by converting data from the native machine order.
            </para>
                <para>
            Once data are written to a file/stream for the current directory, the values of
            certain tags may not be altered; see
            <a href="../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> for more information.
            </para>
                <para>
            It is not possible to write scanlines to a file/stream that uses a tiled organization.
            The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled" /> can be used to determine if the file/stream is organized as
            tiles or strips.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes and writes a scanline of data to an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes.</param>
            <param name="row">The zero-based index of scanline (row) to place encoded data at.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
                <c>true</c> if image data were encoded and written successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>WriteScanline</b> encodes and writes to a file at the specified
            <paramref name="row" /> and specified sample plane <paramref name="plane" />.
            Applications may use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32)" /> or specify 0 for
            <paramref name="plane" /> parameter if image data in a file/stream is contiguous (i.e
            not organized in separate planes,
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG).
            </para>
                <para>
            The data are assumed to be uncompressed and in the native bit- and byte-order of the
            host machine. The data written to the file is compressed according to the compression
            scheme of the current TIFF directory (see further below). If the current scanline is
            past the end of the current subfile, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the scanline (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8. The library attempts to hide bit-ordering differences between the image and
            the native machine by converting data from the native machine order.
            </para>
                <para>
            Once data are written to a file/stream for the current directory, the values of
            certain tags may not be altered; see 
            <a href="../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> for more information.
            </para>
                <para>
            It is not possible to write scanlines to a file/stream that uses a tiled organization.
            The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled" /> can be used to determine if the file/stream is organized as
            tiles or strips.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Reads the image and decodes it into RGBA format raster.
            </summary>
            <overloads>
            Reads the image and decodes it into RGBA format raster.
            </overloads>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <returns>
                <c>true</c> if the image was successfully read and converted; otherwise,
            <c>false</c> is returned if an error was encountered.</returns>
            <remarks>
                <para>
                    <b>ReadRGBAImage</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster" />. The raster is assumed to
            be an array of <paramref name="width" /> times <paramref name="height" /> 32-bit entries,
            where <paramref name="width" /> must be less than or equal to the width of the image
            (<paramref name="height" /> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data are placed in the lower
            part of the raster. Note that the raster is assumed to be organized such that the
            pixel at location (x, y) is <paramref name="raster" />[y * width + x]; with the raster
            origin in the lower-left hand corner. Please use
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" /> if you
            want to specify another raster origin.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
                    <b>ReadRGBAImage</b> converts non-8-bit images by scaling sample values. Palette,
            grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently. Raster
            pixels are returned uncorrected by any colorimetry information present in the directory.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBAImage</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage(System.Int32,System.Int32,System.Int32[],System.Boolean)">
            <summary>
            Reads the image and decodes it into RGBA format raster.
            </summary>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="stopOnError">if set to <c>true</c> then an error will terminate the
            operation; otherwise method will continue processing data until all the possible data
            in the image have been requested.</param>
            <returns>
                <c>true</c> if the image was successfully read and converted; otherwise, <c>false</c>
            is returned if an error was encountered and stopOnError is <c>false</c>.
            </returns>
            <remarks>
                <para>
                    <b>ReadRGBAImage</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster" />. The raster is assumed to
            be an array of <paramref name="width" /> times <paramref name="height" /> 32-bit entries,
            where <paramref name="width" /> must be less than or equal to the width of the image
            (<paramref name="height" /> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data are placed in the lower
            part of the raster. Note that the raster is assumed to be organized such that the
            pixel at location (x, y) is <paramref name="raster" />[y * width + x]; with the raster
            origin in the lower-left hand corner. Please use
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" /> if you
            want to specify another raster origin.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
                    <b>ReadRGBAImage</b> converts non-8-bit images by scaling sample values. Palette,
            grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently. Raster
            pixels are returned uncorrected by any colorimetry information present in the directory.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBAImage</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented(System.Int32,System.Int32,System.Int32[],BitMiracle.LibTiff.Classic.Orientation)">
            <summary>
            Reads the image and decodes it into RGBA format raster using specified raster origin.
            </summary>
            <overloads>
            Reads the image and decodes it into RGBA format raster using specified raster origin.
            </overloads>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="orientation">The raster origin position.</param>
            <returns>
                <c>true</c> if the image was successfully read and converted; otherwise, <c>false</c>
            is returned if an error was encountered.
            </returns>
            <remarks>
                <para>
                    <b>ReadRGBAImageOriented</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster" />. The raster is assumed to
            be an array of <paramref name="width" /> times <paramref name="height" /> 32-bit entries,
            where <paramref name="width" /> must be less than or equal to the width of the image
            (<paramref name="height" /> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data placement depends on
            <paramref name="orientation" />. Note that the raster is assumed to be organized such
            that the pixel at location (x, y) is <paramref name="raster" />[y * width + x]; with
            the raster origin specified by <paramref name="orientation" /> parameter.
            </para>
                <para>
            When <b>ReadRGBAImageOriented</b> is used with <see cref="T:BitMiracle.LibTiff.Classic.Orientation" />.BOTLEFT for
            the <paramref name="orientation" /> the produced result is the same as retuned by
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
                    <b>ReadRGBAImageOriented</b> converts non-8-bit images by scaling sample values.
            Palette, grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently.
            Raster pixels are returned uncorrected by any colorimetry information present in
            the directory.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBAImageOriented</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented(System.Int32,System.Int32,System.Int32[],BitMiracle.LibTiff.Classic.Orientation,System.Boolean)">
            <summary>
            Reads the image and decodes it into RGBA format raster using specified raster origin.
            </summary>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="orientation">The raster origin position.</param>
            <param name="stopOnError">if set to <c>true</c> then an error will terminate the
            operation; otherwise method will continue processing data until all the possible data
            in the image have been requested.</param>
            <returns>
                <c>true</c> if the image was successfully read and converted; otherwise, <c>false</c>
            is returned if an error was encountered and stopOnError is <c>false</c>.
            </returns>
            <remarks>
                <para>
                    <b>ReadRGBAImageOriented</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster" />. The raster is assumed to
            be an array of <paramref name="width" /> times <paramref name="height" /> 32-bit entries,
            where <paramref name="width" /> must be less than or equal to the width of the image
            (<paramref name="height" /> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data placement depends on
            <paramref name="orientation" />. Note that the raster is assumed to be organized such
            that the pixel at location (x, y) is <paramref name="raster" />[y * width + x]; with
            the raster origin specified by <paramref name="orientation" /> parameter.
            </para>
                <para>
            When <b>ReadRGBAImageOriented</b> is used with <see cref="T:BitMiracle.LibTiff.Classic.Orientation" />.BOTLEFT for
            the <paramref name="orientation" /> the produced result is the same as retuned by
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
                    <b>ReadRGBAImageOriented</b> converts non-8-bit images by scaling sample values.
            Palette, grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently.
            Raster pixels are returned uncorrected by any colorimetry information present in
            the directory.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBAImageOriented</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])">
            <summary>
            Reads a whole strip of a strip-based image, decodes it and converts it to RGBA format.
            </summary>
            <param name="row">The row.</param>
            <param name="raster">The RGBA raster.</param>
            <returns>
                <c>true</c> if the strip was successfully read and converted; otherwise,
            <c>false</c></returns>
            <remarks>
                <para>
                    <b>ReadRGBAStrip</b> reads a single strip of a strip-based image into memory, storing
            the result in the user supplied RGBA <paramref name="raster" />. If specified strip is
            the last strip, then it will only contain the portion of the strip that is actually
            within the image space. The raster is assumed to be an array of width times
            rowsperstrip 32-bit entries, where width is the width of the image
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH" />) and rowsperstrip is the maximum lines in a strip
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP" />).
            </para>
                <para>
            The <paramref name="row" /> value should be the row of the first row in the strip
            (strip * rowsperstrip, zero based).
            </para>
                <para>
            Note that the raster is assumed to be organized such that the pixel at location (x, y)
            is <paramref name="raster" />[y * width + x]; with the raster origin in the lower-left
            hand corner of the strip. That is bottom to top organization. When reading a partial
            last strip in the file the last line of the image will begin at the beginning of
            the buffer.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
            See <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> for more details on how various image types are
            converted to RGBA values.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBAStrip</b>'s main advantage over the similar
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" /> function is that for
            large images a single buffer capable of holding the whole image doesn't need to be
            allocated, only enough for one strip. The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" /> function does a
            similar operation for tiled images.
            </para>
                <para>
                    <b>ReadRGBAStrip</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Reads a whole tile of a tile-based image, decodes it and converts it to RGBA format.
            </summary>
            <param name="col">The column.</param>
            <param name="row">The row.</param>
            <param name="raster">The RGBA raster.</param>
            <returns>
                <c>true</c> if the strip was successfully read and converted; otherwise,
            <c>false</c></returns>
            <remarks>
                <para>
                    <b>ReadRGBATile</b> reads a single tile of a tile-based image into memory,
            storing the result in the user supplied RGBA <paramref name="raster" />. The raster is
            assumed to be an array of width times length 32-bit entries, where width is the width
            of the tile (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILEWIDTH" />) and length is the height of a tile
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILELENGTH" />).
            </para>
                <para>
            The <paramref name="col" /> and <paramref name="row" /> values are the offsets from the
            top left corner of the image to the top left corner of the tile to be read. They must
            be an exact multiple of the tile width and length.
            </para>
                <para>
            Note that the raster is assumed to be organized such that the pixel at location (x, y)
            is <paramref name="raster" />[y * width + x]; with the raster origin in the lower-left
            hand corner of the tile. That is bottom to top organization. Edge tiles which partly
            fall off the image will be filled out with appropriate zeroed areas.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
            See <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> for more details on how various image types are
            converted to RGBA values.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBATile</b>'s main advantage over the similar
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" /> function is that for
            large images a single buffer capable of holding the whole image doesn't need to be
            allocated, only enough for one tile. The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" /> function does a
            similar operation for stripped images.
            </para>
                <para>
                    <b>ReadRGBATile</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)">
            <summary>
            Check the image to see if it can be converted to RGBA format.
            </summary>
            <param name="errorMsg">The error message (if any) gets placed here.</param>
            <returns>
                <c>true</c> if the image can be converted to RGBA format; otherwise,
            <c>false</c> is returned and <paramref name="errorMsg" /> contains the reason why it
            is being rejected.</returns>
            <remarks>
                <para>
            To convert the image to RGBA format please use
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />,
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />,
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" /> or <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" /></para>
                <para>
            Convertible images should follow this rules: samples must be either 1, 2, 4, 8, or
            16 bits; colorimetric samples/pixel must be either 1, 3, or 4 (i.e. SamplesPerPixel
            minus ExtraSamples).</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FileName">
            <summary>
            Gets the name of the file or ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <returns>The name of the file or ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.</returns>
            <remarks>If this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> was created using <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> method then
            value of fileName parameter of <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> method is returned. If this
            <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> was created using
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)" />
            then value of name parameter of
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)" />
            method is returned.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetFileName(System.String)">
            <summary>
            Sets the new ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <param name="name">The ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.</param>
            <returns>The previous file name or ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.</returns>
            <remarks>Please note, that <paramref name="name" /> is an arbitrary string used as
            ID for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />. It's not required to be a file name or anything
            meaningful at all.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Error(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
                <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" />.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Error(System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
                <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ErrorExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="clientData">The client data to be passed to error handler.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything you want. It will be passed
            unchanged to the error handler. Default error handler does not use it. Only custom
            error handlers may make use of it.
            </para>
                <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" /> and passes client data to the error handler.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ErrorExt(System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="clientData">The client data to be passed to error handler.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything you want. It will be passed
            unchanged to the error handler. Default error handler does not use it. Only custom
            error handlers may make use of it.
            </para>
                <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Warning(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter,
            if not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
                <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" />.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Warning(System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter,
            if not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
                <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WarningExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" /> and passes client data to the warning handler.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="clientData">The client data to be passed to warning handler.</param>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything you want. It will be passed
            unchanged to the warning handler. Default warning handler does not use it. Only custom
            warning handlers may make use of it.
            </para>
                <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" /> and passes client data to the warning handler.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WarningExt(System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" /> and passes client data to the warning handler.
            </summary>
            <param name="clientData">The client data to be passed to warning handler.</param>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything you want. It will be passed
            unchanged to the warning handler. Default warning handler does not use it. Only custom
            warning handlers may make use of it.
            </para>
                <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)">
            <summary>
            Sets an instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffErrorHandler" /> class as custom library-wide
            error and warning handler.
            </summary>
            <param name="errorHandler">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffErrorHandler" /> class
            to set as custom library-wide error and warning handler.</param>
            <returns>
            Previous error handler or <c>null</c> if there was no error handler set.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetTagExtender(BitMiracle.LibTiff.Classic.Tiff.TiffExtendProc)">
            <summary>
            Sets the tag extender method.
            </summary>
            <param name="extender">The tag extender method.</param>
            <returns>Previous tag extender method.</returns>
            <remarks>
            Extender method is called upon creation of each instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> object.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Reads and decodes a tile of data from an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin storing read and decoded bytes.</param>
            <param name="x">The x-coordinate of the pixel within a tile to be read and decoded.</param>
            <param name="y">The y-coordinate of the pixel within a tile to be read and decoded.</param>
            <param name="z">The z-coordinate of the pixel within a tile to be read and decoded.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>The number of bytes in the decoded tile or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
            The tile to read and decode is selected by the (x, y, z, plane) coordinates (i.e.
            <b>ReadTile</b> returns the data for the tile containing the specified coordinates.
            The data placed in <paramref name="buffer" /> are returned decompressed and, typically,
            in the native byte- and bit-ordering, but are otherwise packed (see further below).
            The buffer must be large enough to hold an entire tile of data. Applications should
            call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize" /> to find out the size (in bytes) of a tile buffer.
            The <paramref name="x" /> and <paramref name="y" /> parameters are always used by
            <b>ReadTile</b>. The <paramref name="z" /> parameter is used if the image is deeper
            than 1 slice (a value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH" /> &gt; 1). In other cases the
            value of <paramref name="z" /> is ignored. The <paramref name="plane" /> parameter is
            used only if data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE). In other
            cases the value of <paramref name="plane" /> is ignored.
            </para>
                <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a tile of data from an open TIFF file/stream, decompresses it and places
            specified amount of decompressed bytes into the user supplied buffer.
            </summary>
            <param name="tile">The zero-based index of the tile to read.</param>
            <param name="buffer">The buffer to place decompressed tile bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            decompressed tile bytes.</param>
            <param name="count">The maximum number of decompressed tile bytes to be stored
            to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
                <para>
            The value of <paramref name="tile" /> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.</para>
                <para>To read a full tile of data the data buffer should typically be at least as
            large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize" />. If the -1 passed in
            <paramref name="count" /> parameter, the whole tile will be read. You should be sure
            you have enough space allocated for the buffer.</para>
                <para>The library attempts to hide bit- and byte-ordering differences between the
            image and the native machine by converting data to the native machine order. Bit
            reversal is done if the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the undecoded contents of a tile of data from an open TIFF file/stream and places
            specified amount of read bytes into the user supplied buffer.
            </summary>
            <param name="tile">The zero-based index of the tile to read.</param>
            <param name="buffer">The buffer to place read tile bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            read tile bytes.</param>
            <param name="count">The maximum number of read tile bytes to be stored to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
                <para>
            The value of <paramref name="tile" /> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.</para>
                <para>To read a full tile of data the data buffer should typically be at least as
            large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RawTileSize(System.Int32)" />. If the -1 passed in
            <paramref name="count" /> parameter, the whole tile will be read. You should be sure
            you have enough space allocated for the buffer.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <overloads>Encodes and writes a tile of data to an open TIFF file/stream.</overloads>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="x">The x-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="y">The y-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="z">The z-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
            The number of encoded and written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
                <para>
            The tile to place encoded data is selected by the (x, y, z, plane) coordinates (i.e.
            <b>WriteTile</b> writes data to the tile containing the specified coordinates.
            <b>WriteTile</b> (potentially) encodes the data <paramref name="buffer" /> and writes
            it to open file/stream. The buffer must contain an entire tile of data. Applications
            should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize" /> to find out the size (in bytes) of a tile buffer.
            The <paramref name="x" /> and <paramref name="y" /> parameters are always used by
            <b>WriteTile</b>. The <paramref name="z" /> parameter is used if the image is deeper
            than 1 slice (a value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH" /> &gt; 1). In other cases the
            value of <paramref name="z" /> is ignored. The <paramref name="plane" /> parameter is
            used only if data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE). In other
            cases the value of <paramref name="plane" /> is ignored.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes to be encoded and written.</param>
            <param name="x">The x-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="y">The y-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="z">The z-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>The number of encoded and written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
            The tile to place encoded data is selected by the (x, y, z, plane) coordinates (i.e.
            <b>WriteTile</b> writes data to the tile containing the specified coordinates.
            <b>WriteTile</b> (potentially) encodes the data <paramref name="buffer" /> and writes
            it to open file/stream. The buffer must contain an entire tile of data. Applications
            should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize" /> to find out the size (in bytes) of a tile buffer.
            The <paramref name="x" /> and <paramref name="y" /> parameters are always used by
            <b>WriteTile</b>. The <paramref name="z" /> parameter is used if the image is deeper
            than 1 slice (a value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH" /> &gt; 1). In other cases the
            value of <paramref name="z" /> is ignored. The <paramref name="plane" /> parameter is
            used only if data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE). In other
            cases the value of <paramref name="plane" /> is ignored.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a strip of data from an open TIFF file/stream, decompresses it and places
            specified amount of decompressed bytes into the user supplied buffer.
            </summary>
            <param name="strip">The zero-based index of the strip to read.</param>
            <param name="buffer">The buffer to place decompressed strip bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            decompressed strip bytes.</param>
            <param name="count">The maximum number of decompressed strip bytes to be stored
            to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
                <para>
            The value of <paramref name="strip" /> is a "raw strip number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to a
            strip index.</para>
                <para>To read a full strip of data the data buffer should typically be at least
            as large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.StripSize" />. If the -1 passed in
            <paramref name="count" /> parameter, the whole strip will be read. You should be sure
            you have enough space allocated for the buffer.</para>
                <para>The library attempts to hide bit- and byte-ordering differences between the
            image and the native machine by converting data to the native machine order. Bit
            reversal is done if the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the undecoded contents of a strip of data from an open TIFF file/stream and
            places specified amount of read bytes into the user supplied buffer.
            </summary>
            <param name="strip">The zero-based index of the strip to read.</param>
            <param name="buffer">The buffer to place read bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            read bytes.</param>
            <param name="count">The maximum number of read bytes to be stored to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
                <para>
            The value of <paramref name="strip" /> is a "raw strip number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to a
            strip index.</para>
                <para>To read a full strip of data the data buffer should typically be at least
            as large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RawStripSize(System.Int32)" />. If the -1 passed in
            <paramref name="count" /> parameter, the whole strip will be read. You should be sure
            you have enough space allocated for the buffer.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedStrip(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encodes and writes a strip of data to an open TIFF file/stream.
            </summary>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>
            The number of encoded and written bytes or <c>-1</c> if an error occurred.
            </returns>
            <overloads>Encodes and writes a strip of data to an open TIFF file/stream.</overloads>
            <remarks>
                <para>
                    <b>WriteEncodedStrip</b> encodes <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> and append the result to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip" /> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to
            a strip index.
            </para>
                <para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes and writes a strip of data to an open TIFF file/stream.
            </summary>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes to be encoded and written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>The number of encoded and written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
                    <b>WriteEncodedStrip</b> encodes <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> and append the result to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip" /> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to
            a strip index.
            </para>
                <para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawStrip(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes a strip of raw data to an open TIFF file/stream.
            </summary>
            <overloads>Writes a strip of raw data to an open TIFF file/stream.</overloads>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>
            The number of written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
                <para>
                    <b>WriteRawStrip</b> appends <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip" /> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to
            a strip index.
            </para>
                <para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a strip of raw data to an open TIFF file/stream.
            </summary>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes to be written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>The number of written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
                    <b>WriteRawStrip</b> appends <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip" /> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to
            a strip index.
            </para>
                <para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedTile(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <overloads>Encodes and writes a tile of data to an open TIFF file/stream.</overloads>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>
            The number of encoded and written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
                <para>
                    <b>WriteEncodedTile</b> encodes <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> and append the result to the end of the specified tile. Note
            that the value of <paramref name="tile" /> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para>
                <para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteEncodedTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes to be encoded and written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>The number of encoded and written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
                    <b>WriteEncodedTile</b> encodes <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> and append the result to the end of the specified tile. Note
            that the value of <paramref name="tile" /> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para>
                <para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteEncodedTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawTile(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes a tile of raw data to an open TIFF file/stream.
            </summary>
            <overloads>Writes a tile of raw data to an open TIFF file/stream.</overloads>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>
            The number of written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
                <para>
                    <b>WriteRawTile</b> appends <paramref name="count" /> bytes of raw data to the end of
            the specified tile. Note that the value of <paramref name="tile" /> is a "raw tile
            number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para>
                <para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteRawTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a tile of raw data to an open TIFF file/stream.
            </summary>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes to be written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>The number of written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
                    <b>WriteRawTile</b> appends <paramref name="count" /> bytes of raw data to the end of
            the specified tile. Note that the value of <paramref name="tile" /> is a "raw tile
            number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para>
                <para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteRawTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetWriteOffset(System.Int64)">
            <summary>
            Sets the current write offset.
            </summary>
            <param name="offset">The write offset.</param>
            <remarks>This should only be used to set the offset to a known previous location
            (very carefully), or to 0 so that the next write gets appended to the end of the file.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.DataWidth(BitMiracle.LibTiff.Classic.TiffType)">
            <summary>
            Gets the number of bytes occupied by the item of given type.
            </summary>
            <param name="type">The type.</param>
            <returns>The number of bytes occupied by the <paramref name="type" /> or 0 if unknown
            data type is supplied.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabShort(System.Int16@)">
            <summary>
            Swaps the bytes in a single 16-bit item.
            </summary>
            <param name="value">The value to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabLong(System.Int32@)">
            <summary>
            Swaps the bytes in a single 32-bit item.
            </summary>
            <param name="value">The value to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabDouble(System.Double@)">
            <summary>
            Swaps the bytes in a single double-precision floating-point number.
            </summary>
            <param name="value">The value to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfShort(System.Int16[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 16-bit items.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of 16-bit items.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfShort(System.Int16[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 16-bit items starting at
            specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array" /> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfTriples(System.Byte[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of triples (24-bit items).
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of triples (24-bit items).
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfTriples(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of triples (24-bit items)
            starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array" /> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong(System.Int32[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 32-bit items.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of 32-bit items.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong8(System.Int64[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 64-bit items.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of 64-bit items.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 32-bit items
            starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array" /> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong8(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 64-bit items
            starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array" /> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfDouble(System.Double[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of double-precision
            floating-point numbers.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of double-precision
            floating-point numbers.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfDouble(System.Double[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of double-precision
            floating-point numbers starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array" /> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReverseBits(System.Byte[],System.Int32)">
            <summary>
            Replaces specified number of bytes in <paramref name="buffer" /> with the
            equivalent bit-reversed bytes.
            </summary>
            <overloads>
            Replaces specified number of bytes in <paramref name="buffer" /> with the
            equivalent bit-reversed bytes.
            </overloads>
            <param name="buffer">The buffer to replace bytes in.</param>
            <param name="count">The number of bytes to process.</param>
            <remarks>
            This operation is performed with a lookup table, which can be retrieved using the
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetBitRevTable(System.Boolean)" /> method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReverseBits(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Replaces specified number of bytes in <paramref name="buffer" /> with the
            equivalent bit-reversed bytes starting at specified offset.
            </summary>
            <param name="buffer">The buffer to replace bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer" /> at
            which to begin processing bytes.</param>
            <param name="count">The number of bytes to process.</param>
            <remarks>
            This operation is performed with a lookup table, which can be retrieved using the
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetBitRevTable(System.Boolean)" /> method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetBitRevTable(System.Boolean)">
            <summary>
            Retrieves a bit reversal table.
            </summary>
            <param name="reversed">if set to <c>true</c> then bit reversal table will be
            retrieved; otherwise, the table that do not reverse bit values will be retrieved.</param>
            <returns>The bit reversal table.</returns>
            <remarks>If <paramref name="reversed" /> is <c>false</c> then the table that do not
            reverse bit values will be retrieved. It is a lookup table that can be used as an
            identity function; i.e. NoBitRevTable[n] == n.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ByteArrayToInts(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts a byte buffer into array of 32-bit values.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer" /> at
            which to begin converting bytes.</param>
            <param name="count">The number of bytes to convert.</param>
            <returns>The array of 32-bit values.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ByteArrayToLong8(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts a byte buffer into array of 64-bit values.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer" /> at
            which to begin converting bytes.</param>
            <param name="count">The number of bytes to convert.</param>
            <returns>The array of 64-bit values.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Long8ToByteArray(System.Int64[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Converts array of 64-bit values into array of bytes.
            </summary>
            <param name="source">The array of 64-bit values.</param>
            <param name="srcOffset">The zero-based offset in <paramref name="source" /> at
            which to begin converting bytes.</param>
            <param name="srcCount">The number of 64-bit values to convert.</param>
            <param name="bytes">The byte array to store converted values at.</param>
            <param name="offset">The zero-based offset in <paramref name="bytes" /> at
            which to begin storing converted values.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IntsToByteArray(System.Int32[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Converts array of 32-bit values into array of bytes.
            </summary>
            <param name="source">The array of 32-bit values.</param>
            <param name="srcOffset">The zero-based offset in <paramref name="source" /> at
            which to begin converting bytes.</param>
            <param name="srcCount">The number of 32-bit values to convert.</param>
            <param name="bytes">The byte array to store converted values at.</param>
            <param name="offset">The zero-based offset in <paramref name="bytes" /> at
            which to begin storing converted values.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ByteArrayToShorts(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts a byte buffer into array of 16-bit values.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer" /> at
            which to begin converting bytes.</param>
            <param name="count">The number of bytes to convert.</param>
            <returns>The array of 16-bit values.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ShortsToByteArray(System.Int16[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Converts array of 16-bit values into array of bytes.
            </summary>
            <param name="source">The array of 16-bit values.</param>
            <param name="srcOffset">The zero-based offset in <paramref name="source" /> at
            which to begin converting bytes.</param>
            <param name="srcCount">The number of 16-bit values to convert.</param>
            <param name="bytes">The byte array to store converted values at.</param>
            <param name="offset">The zero-based offset in <paramref name="bytes" /> at
            which to begin storing converted values.</param>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffCodec">
            <summary>
            Base class for all codecs within the library.
            </summary>
            <remarks>
                <para>
            A codec is a class that implements decoding, encoding, or decoding and encoding of a
            compression algorithm.
            </para>
                <para>
            The library provides a collection of builtin codecs. More codecs may be registered
            through calls to the library and/or the builtin implementations may be overridden.
            </para>
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffCodec.m_tif">
            <summary>
            An instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffCodec.m_scheme">
            <summary>
            Compression scheme this codec impelements.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffCodec.m_name">
            <summary>
            Codec name.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.#ctor(BitMiracle.LibTiff.Classic.Tiff,BitMiracle.LibTiff.Classic.Compression,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffCodec" /> class.
            </summary>
            <param name="tif">An instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <param name="scheme">The compression scheme for the codec.</param>
            <param name="name">The name of the codec.</param>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Init">
            <summary>
            Initializes this instance.
            </summary>
            <returns>
                <c>true</c> if initialized successfully</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreDecode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.</returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreEncode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.</returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external 
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Close">
            <summary>
            Flushes any internal data buffers and terminates current operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Seek(System.Int32)">
            <summary>
            Seeks the specified row in the strip being processed.
            </summary>
            <param name="row">The row to seek.</param>
            <returns>
                <c>true</c> if specified row was successfully found; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DefStripSize(System.Int32)">
            <summary>
            Calculates and/or constrains a strip size.
            </summary>
            <param name="size">The proposed strip size (may be zero or negative).</param>
            <returns>A strip size to use.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DefTileSize(System.Int32@,System.Int32@)">
            <summary>
            Calculate and/or constrains a tile size
            </summary>
            <param name="width">The proposed tile width upon the call / tile width to use after the call.</param>
            <param name="height">The proposed tile height upon the call / tile height to use after the call.</param>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffErrorHandler">
            <summary>
            Default error handler implementation.
            </summary>
            <remarks>
                <para>
                    <b>TiffErrorHandler</b> provides error and warning handling methods that write an
            error or a warning messages to the <see cref="P:System.Console.Error" />.
            </para>
                <para>
            Applications that desire to capture control in the event of an error or a warning should
            set their custom error and warning handler using <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> method.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.ErrorHandler(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Handles an error by writing it text to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.ErrorHandlerExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Handles an error by writing it text to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="clientData">A client data.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything. Its value and meaning is
            defined by an application and not the library.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.WarningHandler(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Handles a warning by writing it text to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="method">The method where a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.WarningHandlerExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Handles a warning by writing it text to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="clientData">A client data.</param>
            <param name="method">The method where a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything. Its value and meaning is
            defined by an application and not the library.
            </para>
            </remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffFieldInfo">
            <summary>
            Represents a TIFF field information.
            </summary>
            <remarks>
                <b>TiffFieldInfo</b> describes a field. It provides information about field name, type,
            number of values etc.
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable">
            <summary>
            marker for variable length tags
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp">
            <summary>
            marker for SamplesPerPixel-bound tags
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2">
            <summary>
            marker for integer variable length tags
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffFieldInfo.#ctor(BitMiracle.LibTiff.Classic.TiffTag,System.Int16,System.Int16,BitMiracle.LibTiff.Classic.TiffType,System.Int16,System.Boolean,System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo" /> class.
            </summary>
            <param name="tag">The tag to describe.</param>
            <param name="readCount">The number of values to read when reading field information or
            one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable" />, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2" />.</param>
            <param name="writeCount">The number of values to write when writing field information
            or one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable" />, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2" />.</param>
            <param name="type">The type of the field value.</param>
            <param name="bit">Index of the bit to use in "Set Fields Vector" when this instance
            is merged into field info collection. Take a look at <see cref="T:BitMiracle.LibTiff.Classic.FieldBit" /> class.</param>
            <param name="okToChange">If true, then it is permissible to set the tag's value even
            after writing has commenced.</param>
            <param name="passCount">If true, then number of value elements should be passed to
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])" /> method as second parameter (right after tag type AND
            before value itself).</param>
            <param name="name">The name (description) of the tag this instance describes.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffFieldInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Tag">
            <summary>
            The tag described by this instance.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.ReadCount">
            <summary>
            Number of values to read when reading field information or
            one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable" />, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2" />.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.WriteCount">
            <summary>
            Number of values to write when writing field information or
            one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable" />, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2" />.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Type">
            <summary>
            Type of the field values.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Bit">
            <summary>
            Index of the bit to use in "Set Fields Vector" when this instance
            is merged into field info collection. Take a look at <see cref="T:BitMiracle.LibTiff.Classic.FieldBit" /> class.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.OkToChange">
            <summary>
            If true, then it is permissible to set the tag's value even after writing has commenced.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.PassCount">
            <summary>
            If true, then number of value elements should be passed to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])" />
            method as second parameter (right after tag type AND before values itself).
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Name">
            <summary>
            The name (or description) of the tag this instance describes.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage">
            <summary>
            RGBA-style image support. Provides methods for decoding images into RGBA (or other) format.
            </summary>
            <remarks>
                <para>
                    <b>TiffRgbaImage</b> provide a high-level interface through which TIFF images may be read
            into memory. Images may be strip- or tile-based and have a variety of different
            characteristics: bits/sample, samples/pixel, photometric, etc. The target raster format
            can be customized to a particular application's needs by installing custom methods that
            manipulate image data according to application requirements.
            </para>
                <para>
            The default usage for this class: check if an image can be processed using
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />, construct an instance of
            <b>TiffRgbaImage</b> using <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.Create(BitMiracle.LibTiff.Classic.Tiff,System.Boolean,System.String@)" /> and then read and decode an image into a
            target raster using <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)" />. <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)" /> can be called
            multiple times to decode an image using different state parameters. If multiple images
            are to be displayed and there is not enough space for each of the decoded rasters,
            multiple instances of <b>TiffRgbaImage</b> can be managed and then calls can be made to
            <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)" /> as needed to display an image.</para>
                <para>
            To use the core support for reading and processing TIFF images, but write the resulting
            raster data in a different format one need only override the "put methods" used to store
            raster data. These methods are initially setup by <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.Create(BitMiracle.LibTiff.Classic.Tiff,System.Boolean,System.String@)" /> to point to methods
            that pack raster data in the default ABGR pixel format. Two different methods are used
            according to the physical organization of the image data in the file: one for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG (packed samples),
            and another for <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE
            (separated samples). Note that this mechanism can be used to transform the data before 
            storing it in the raster. For example one can convert data to colormap indices for display
            on a colormap display.</para>
                <para>
            To setup custom "put" method please use <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig" /> property for contiguously
            packed samples and/or <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate" /> property for separated samples.</para>
                <para>
            The methods of <b>TiffRgbaImage</b> support the most commonly encountered flavors of TIFF.
            It is possible to extend this support by overriding the "get method" invoked by
            <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)" /> to read TIFF image data. Details of doing this are a bit involved,
            it is best to make a copy of an existing get method and modify it to suit the needs of an
            application. To setup custom "get" method please use <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get" /> property.</para>
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.tif">
            <summary>
            image handle
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.stoponerr">
            <summary>
            stop on read error
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.isContig">
            <summary>
            data is packed/separate
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.alpha">
            <summary>
            type of alpha data present
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.width">
            <summary>
            image width
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.height">
            <summary>
            image height
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.bitspersample">
            <summary>
            image bits/sample
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.samplesperpixel">
            <summary>
            image samples/pixel
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.orientation">
            <summary>
            image orientation
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.req_orientation">
            <summary>
            requested orientation
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.photometric">
            <summary>
            image photometric interp
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.redcmap">
            <summary>
            colormap pallete
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.Map">
            <summary>
            sample mapping array
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.BWmap">
            <summary>
            black and white map
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.PALmap">
            <summary>
            palette image map
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.ycbcr">
            <summary>
            YCbCr conversion state
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.cielab">
            <summary>
            CIE L*a*b conversion state
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContigDelegate">
            <summary>
            Delegate for "put" method (the method that is called to pack pixel data in the raster)
            used when converting contiguously packed samples.
            </summary>
            <param name="img">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> class.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="rasterOffset">The zero-based byte offset in <paramref name="raster" /> at
            which to begin storing decoded bytes.</param>
            <param name="rasterShift">The value that should be added to
            <paramref name="rasterOffset" /> after each row processed.</param>
            <param name="x">The x-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="y">The y-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="width">The block width.</param>
            <param name="height">The block height.</param>
            <param name="buffer">The buffer with image data.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin reading image bytes.</param>
            <param name="bufferShift">The value that should be added to <paramref name="offset" />
            after each row processed.</param>
            <remarks>
                <para>
            The image reading and conversion methods invoke "put" methods to copy/image/whatever
            tiles of raw image data. A default set of methods is provided to convert/copy raw
            image data to 8-bit packed ABGR format rasters. Applications can supply alternate
            methods that unpack the data into a different format or, for example, unpack the data
            and draw the unpacked raster on the display.
            </para>
                <para>
            To setup custom "put" method for contiguously packed samples please use
            <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig" /> property.</para>
                <para>
            The <paramref name="bufferShift" /> is usually 0. It is greater than 0 if width of strip
            being converted is greater than image width or part of the tile being converted is
            outside the image (may be true for tiles on the right and bottom edge of the image).
            In other words, <paramref name="bufferShift" /> is used to make up for any padding on
            the end of each line of the buffer with image data.
            </para>
                <para>
            The <paramref name="rasterShift" /> is 0 if width of tile being converted is equal to
            image width and image data should not be flipped vertically. In other circumstances
            <paramref name="rasterShift" /> is used to make up for any padding on the end of each
            line of the raster and/or for flipping purposes.
            </para>
            </remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparateDelegate">
            <summary>
            Delegate for "put" method (the method that is called to pack pixel data in the raster)
            used when converting separated samples.
            </summary>
            <param name="img">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> class.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="rasterOffset">The zero-based byte offset in <paramref name="raster" /> at
            which to begin storing decoded bytes.</param>
            <param name="rasterShift">The value that should be added to
            <paramref name="rasterOffset" /> after each row processed.</param>
            <param name="x">The x-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="y">The y-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="width">The block width.</param>
            <param name="height">The block height.</param>
            <param name="buffer">The buffer with image data.</param>
            <param name="offset1">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin reading image bytes that constitute first sample plane.</param>
            <param name="offset2">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin reading image bytes that constitute second sample plane.</param>
            <param name="offset3">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin reading image bytes that constitute third sample plane.</param>
            <param name="offset4">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin reading image bytes that constitute fourth sample plane.</param>
            <param name="bufferShift">The value that should be added to <paramref name="offset1" />,
            <paramref name="offset2" />, <paramref name="offset3" /> and <paramref name="offset4" />
            after each row processed.</param>
            <remarks>
                <para>
            The image reading and conversion methods invoke "put" methods to copy/image/whatever
            tiles of raw image data. A default set of methods is provided to convert/copy raw
            image data to 8-bit packed ABGR format rasters. Applications can supply alternate
            methods that unpack the data into a different format or, for example, unpack the data
            and draw the unpacked raster on the display.
            </para>
                <para>
            To setup custom "put" method for separated samples please use
            <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate" /> property.</para>
                <para>
            The <paramref name="bufferShift" /> is usually 0. It is greater than 0 if width of strip
            being converted is greater than image width or part of the tile being converted is
            outside the image (may be true for tiles on the right and bottom edge of the image).
            In other words, <paramref name="bufferShift" /> is used to make up for any padding on
            the end of each line of the buffer with image data.
            </para>
                <para>
            The <paramref name="rasterShift" /> is 0 if width of tile being converted is equal to
            image width and image data should not be flipped vertically. In other circumstances
            <paramref name="rasterShift" /> is used to make up for any padding on the end of each
            line of the raster and/or for flipping purposes.
            </para>
            </remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetDelegate">
            <summary>
            Delegate for "get" method (the method that is called to produce RGBA raster).
            </summary>
            <param name="img">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> class.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="offset">The zero-based byte offset in <paramref name="raster" /> at which
            to begin storing decoded bytes.</param>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <returns>
                <c>true</c> if the image was successfully read and decoded; otherwise,
            <c>false</c>.</returns>
            <remarks>
                <para>
            A default set of methods is provided to read and convert/copy raw image data to 8-bit
            packed ABGR format rasters. Applications can supply alternate method for this.
            </para>
                <para>
            To setup custom "get" method please use <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get" /> property.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.Create(BitMiracle.LibTiff.Classic.Tiff,System.Boolean,System.String@)">
            <summary>
            Creates new instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> class.
            </summary>
            <param name="tif">
            The instance of the <see cref="N:BitMiracle.LibTiff.Classic" /> class used to retrieve
            image data.
            </param>
            <param name="stopOnError">
            if set to <c>true</c> then an error will terminate the conversion; otherwise "get"
            methods will continue processing data until all the possible data in the image have
            been requested.
            </param>
            <param name="errorMsg">The error message (if any) gets placed here.</param>
            <returns>
            New instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> class if the image specified
            by <paramref name="tif" /> can be converted to RGBA format; otherwise, <c>null</c> is
            returned and <paramref name="errorMsg" /> contains the reason why it is being
            rejected.
            </returns>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.IsContig">
            <summary>
            Gets a value indicating whether image data has contiguous (packed) or separated samples.
            </summary>
            <value>
                <c>true</c> if this image data has contiguous (packed) samples; otherwise,
            <c>false</c>.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Alpha">
            <summary>
            Gets the type of alpha data present.
            </summary>
            <value>The type of alpha data present.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Width">
            <summary>
            Gets the image width.
            </summary>
            <value>The image width.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Height">
            <summary>
            Gets the image height.
            </summary>
            <value>The image height.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.BitsPerSample">
            <summary>
            Gets the image bits per sample count.
            </summary>
            <value>The image bits per sample count.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.SamplesPerPixel">
            <summary>
            Gets the image samples per pixel count.
            </summary>
            <value>The image samples per pixel count.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Orientation">
            <summary>
            Gets the image orientation.
            </summary>
            <value>The image orientation.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.ReqOrientation">
            <summary>
            Gets or sets the requested orientation.
            </summary>
            <value>The requested orientation.</value>
            <remarks>The <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)" /> method uses this value when placing converted
            image data into raster buffer.</remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Photometric">
            <summary>
            Gets the photometric interpretation of the image data.
            </summary>
            <value>The photometric interpretation of the image data.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get">
            <summary>
            Gets or sets the "get" method (the method that is called to produce RGBA raster).
            </summary>
            <value>The "get" method.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig">
            <summary>
            Gets or sets the "put" method (the method that is called to pack pixel data in the
            raster) used when converting contiguously packed samples.
            </summary>
            <value>The "put" method used when converting contiguously packed samples.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate">
            <summary>
            Gets or sets the "put" method (the method that is called to pack pixel data in the
            raster) used when converting separated samples.
            </summary>
            <value>The "put" method used when converting separated samples.</value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Reads the underlaying TIFF image and decodes it into RGBA format raster.
            </summary>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="offset">The zero-based byte offset in <paramref name="raster" /> at which
            to begin storing decoded bytes.</param>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <returns>
                <c>true</c> if the image was successfully read and decoded; otherwise,
            <c>false</c>.</returns>
            <remarks>
                <para>
                    <b>GetRaster</b> reads image into memory using current "get" (<see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get" />) method,
            storing the result in the user supplied RGBA <paramref name="raster" /> using one of
            the "put" (<see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig" /> or <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate" />) methods. The raster
            is assumed to be an array of <paramref name="width" /> times <paramref name="height" />
            32-bit entries, where <paramref name="width" /> must be less than or equal to the width
            of the image (<paramref name="height" /> may be any non-zero size). If the raster
            dimensions are smaller than the image, the image data is cropped to the raster bounds.
            If the raster height is greater than that of the image, then the image data placement
            depends on the value of <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.ReqOrientation" /> property. Note that the raster is
            assumed to be organized such that the pixel at location (x, y) is
            <paramref name="raster" />[y * width + x]; with the raster origin specified by the
            value of <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.ReqOrientation" /> property.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The 
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
                    <b>GetRaster</b> converts non-8-bit images by scaling sample values. Palette,
            grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently.
            Raster pixels are returned uncorrected by any colorimetry information present in
            the directory.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.CMAP(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Palette images with &lt;= 8 bits/sample are handled with a table to avoid lots of shifts
            and masks. The table is setup so that put*cmaptile (below) can retrieve 8 / bitspersample
            pixel values simply by indexing into the table with one number.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GREY(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Greyscale images with less than 8 bits/sample are handled with a table to avoid lots
            of shifts and masks. The table is setup so that put*bwtile (below) can retrieve
            8 / bitspersample pixel values simply by indexing into the table with one number.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtTileContig(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get an tile-organized image that has
            PlanarConfiguration contiguous if SamplesPerPixel &gt; 1
             or
            SamplesPerPixel == 1
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtTileSeparate(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get an tile-organized image that has
            SamplesPerPixel &gt; 1
            PlanarConfiguration separated
            We assume that all such images are RGB.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtStripContig(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get a strip-organized image that has 
            PlanarConfiguration contiguous if SamplesPerPixel &gt; 1
             or
            SamplesPerPixel == 1
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtStripSeparate(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get a strip-organized image with
             SamplesPerPixel &gt; 1
             PlanarConfiguration separated
            We assume that all such images are RGB.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.pickContigCase">
            <summary>
            Select the appropriate conversion routine for packed data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.pickSeparateCase">
            <summary>
            Select the appropriate conversion routine for unpacked data.
            NB: we assume that unpacked single channel data is directed to the "packed routines.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.buildMap">
            <summary>
            Construct any mapping table used by the associated put method.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.setupMap">
            <summary>
            Construct a mapping table to convert from the range of the data samples to [0, 255] -
            for display. This process also handles inverting B&amp;W images when needed.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.YCbCrtoRGB(System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            YCbCr -&gt; RGB conversion and packing routines.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put8bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit palette =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put4bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            4-bit palette =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put2bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            2-bit palette =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put1bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            1-bit palette =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putgreytile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit greyscale =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putgreywithalphatile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit greyscale with alpha =&gt; colormap/RGBA
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put16bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit greyscale =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put1bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            1-bit bilevel =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put2bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            2-bit greyscale =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put4bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            4-bit greyscale =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed samples, no Map =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAcontig8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed samples =&gt; RGBA w/ associated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAcontig8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed samples =&gt; RGBA w/ unassociated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit packed samples =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAcontig16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit packed samples =&gt; RGBA w/ associated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAcontig16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit packed samples =&gt; RGBA w/ unassociated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAcontig8bitCMYKAtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CMYKA samples w/o Map =&gt; RGBA.
            NB: The conversion of CMYKA-&gt;RGBA is *very* crude.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig8bitCMYKtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CMYK samples w/o Map =&gt; RGB.
            NB: The conversion of CMYK-&gt;RGB is *very* crude.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitCIELab(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CIE L*a*b 1976 samples =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr22tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 2,2 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr21tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 2,1 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr44tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 4,4 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr42tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 4,2 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr41tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 4,1 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr11tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ no subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr12tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 1,2 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBseparate8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit unpacked samples =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAseparate8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit unpacked samples =&gt; RGBA w/ associated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAseparate8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit unpacked samples =&gt; RGBA w/ unassociated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBseparate16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            16-bit unpacked samples =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAseparate16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            16-bit unpacked samples =&gt; RGBA w/ associated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAseparate16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            16-bit unpacked samples =&gt; RGBA w/ unassociated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putseparate8bitYCbCr11tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ no subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig8bitCMYKMaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CMYK samples w/Map =&gt; RGB
            NB: The conversion of CMYK-&gt;RGB is *very* crude.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffStream">
            <summary>
            A stream used by the library for TIFF reading and writing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Read(System.Object,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the stream and advances the position within the stream
            by the number of bytes read.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <param name="buffer">An array of bytes. When this method returns, the
            <paramref name="buffer" /> contains the specified byte array with the values between
            <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1)
            replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>The total number of bytes read into the <paramref name="buffer" />. This can
            be less than the number of bytes requested if that many bytes are not currently
            available, or zero (0) if the end of the stream has been reached.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Write(System.Object,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position
            within this stream by the number of bytes written.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <param name="buffer">An array of bytes. This method copies <paramref name="count" />
            bytes from <paramref name="buffer" /> to the current stream.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Seek(System.Object,System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <param name="offset">A byte offset relative to the <paramref name="origin" /> parameter.</param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the
            reference point used to obtain the new position.</param>
            <returns>The new position within the current stream.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Close(System.Object)">
            <summary>
            Closes the current stream.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Size(System.Object)">
            <summary>
            Gets the length in bytes of the stream.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <returns>The length of the stream in bytes.</returns>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffTagMethods">
            <summary>
            Tiff tag methods.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_VOID">
            <summary>
            untyped data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_INT">
            <summary>
            signed integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_UINT">
            <summary>
            unsigned integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_IEEEFP">
            <summary>
            IEEE floating point data
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.SetField(BitMiracle.LibTiff.Classic.Tiff,BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.FieldValue[])">
            <summary>
            Sets the value(s) of a tag in a TIFF file/stream open for writing.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <param name="tag">The tag.</param>
            <param name="value">The tag value(s).</param>
            <returns>
                <c>true</c> if tag value(s) were set successfully; otherwise, <c>false</c>.
            </returns>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.GetField(BitMiracle.LibTiff.Classic.Tiff,BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Gets the value(s) of a tag in an open TIFF file.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <param name="tag">The tag.</param>
            <returns>The value(s) of a tag in an open TIFF file/stream as array of
            <see cref="T:BitMiracle.LibTiff.Classic.FieldValue" /> objects or <c>null</c> if there is no such tag set.</returns>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.PrintDir(BitMiracle.LibTiff.Classic.Tiff,System.IO.Stream,BitMiracle.LibTiff.Classic.TiffPrintFlags)">
            <summary>
            Prints formatted description of the contents of the current directory to the
            specified stream using specified print (formatting) options.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <param name="stream">The stream to print to.</param>
            <param name="flags">The print (formatting) options.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.setExtraSamples(BitMiracle.LibTiff.Classic.Internal.TiffDirectory,System.Int32@,BitMiracle.LibTiff.Classic.FieldValue[])">
            <summary>
            Install extra samples information.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.DensityUnit">
            <summary>
            The unit of density.
            </summary>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown">
            <summary>
            Unknown density
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.DotsInch">
            <summary>
            Dots/inch
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.DotsCm">
            <summary>
            Dots/cm
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.bitread_perm_state">
            <summary>
            Bitreading state saved across MCUs
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.bitread_working_state">
            <summary>
            Bitreading working state within an MCU
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer">
            <summary>
            Encapsulates buffer of image samples for one color component
            When provided with funny indices (see jpeg_d_main_controller for 
            explanation of what it is) uses them for non-linear row access.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl">
            <summary>
            Derived data constructed for each Huffman table
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder">
            <summary>
            Expanded entropy decoder object for Huffman decoding.
            
            The savable_state subrecord contains fields that change within an MCU,
            but must not be updated permanently until we complete the MCU.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.start_pass">
            <summary>
            Initialize for a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_full(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            Decode one MCU's worth of Huffman-compressed coefficients, full-size blocks.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_sub(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            Decode one MCU's worth of Huffman-compressed coefficients, partial blocks.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_DC_first(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for DC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_AC_first(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for AC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_DC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for DC successive approximation refinement scan.
            Note: we assume such scans can be multi-component,
            although the spec is not very clear on the point.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.undo_decode_mcu_AC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[],System.Int32[],System.Int32)">
            <summary>
            MCU decoding for AC successive approximation refinement scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.process_restart">
            <summary>
            Check for a restart marker and resynchronize decoder.
            Returns false if must suspend.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.jpeg_make_d_derived_tbl(System.Boolean,System.Int32,BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl@)">
            <summary>
            Expand a Huffman table definition into the derived format
            This routine also performs some validation checks on the table.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder">
            <summary>
            Expanded entropy encoder object for Huffman encoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.start_pass(System.Boolean)">
            <summary>
            Initialize for a Huffman-compressed scan.
            If gather_statistics is true, we do not output anything during the scan,
            just count the Huffman symbols used and generate Huffman code tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_huff(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            Encode and output one MCU's worth of Huffman-compressed coefficients.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.finish_pass_huff">
            <summary>
            Finish up at the end of a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_gather(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            Trial-encode one MCU's worth of Huffman-compressed coefficients.
            No data is actually output, so no suspension return is possible.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.finish_pass_gather">
            <summary>
            Finish up a statistics-gathering pass and create the new Huffman tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_one_block(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int16[],System.Int32,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl)">
            <summary>
            Encode a single block's worth of coefficients
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.htest_one_block(System.Int16[],System.Int32,System.Int64[],System.Int64[])">
            <summary>
            Huffman coding optimization.
            
            We first scan the supplied data and count the number of uses of each symbol
            that is to be Huffman-coded. (This process MUST agree with the code above.)
            Then we build a Huffman coding tree for the observed counts.
            Symbols which are not needed at all for the particular image are not
            assigned any code, which saves space in the DHT marker as well as in
            the compressed data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_bits_s(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int32,System.Int32)">
            <summary>
            Only the right 24 bits of put_buffer are used; the valid bits are
            left-justified in this part.  At most 16 bits can be passed to emit_bits
            in one call, and we never retain more than 7 bits in put_buffer
            between calls, so 24 bits are sufficient.
            </summary>
            Emit some bits; return true if successful, false if must suspend
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_bits_e(System.Int32,System.Int32)">
            <summary>
            Outputting bits to the file
            
            Only the right 24 bits of put_buffer are used; the valid bits are
            left-justified in this part.  At most 16 bits can be passed to emit_bits
            in one call, and we never retain more than 7 bits in put_buffer
            between calls, so 24 bits are sufficient.
            </summary>
            Emit some bits, unless we are in gather mode
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_restart_s(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int32)">
            <summary>
            Emit a restart marker and resynchronize predictions.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.IRIGHT_SHIFT(System.Int32,System.Int32)">
            <summary>
            IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than int.
            We assume that int right shift is unsigned if int right shift is,
            which should be safe.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_DC_first(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for DC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_AC_first(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for AC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_DC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for DC successive approximation refinement scan.
            Note: we assume such scans can be multi-component, although the spec
            is not very clear on the point.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_AC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for AC successive approximation refinement scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.jpeg_make_c_derived_tbl(System.Boolean,System.Int32,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl@)">
            <summary>
            Expand a Huffman table definition into the derived format
            Compute the derived values for a Huffman table.
            This routine also performs some validation checks on the table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.jpeg_gen_optimal_table(BitMiracle.LibJpeg.Classic.JHUFF_TBL,System.Int64[])">
            <summary>
            Generate the best Huffman code table for the given counts, fill htbl.
            
            The JPEG standard requires that no symbol be assigned a codeword of all
            one bits (so that padding bits added at the end of a compressed segment
            can't look like a valid code).  Because of the canonical ordering of
            codewords, this just means that there must be an unused slot in the
            longest codeword length category.  Section K.2 of the JPEG spec suggests
            reserving such a slot by pretending that symbol 256 is a valid symbol
            with count 1.  In theory that's not optimal; giving it count zero but
            including it in the symbol set anyway should give a better Huffman code.
            But the theoretically better code actually seems to come out worse in
            practice, because it produces more all-ones bytes (which incur stuffed
            zero bytes in the final file).  In any case the difference is tiny.
            
            The JPEG standard requires Huffman codes to be no more than 16 bits long.
            If some symbols have a very small but nonzero probability, the Huffman tree
            must be adjusted to meet the code length restriction.  We currently use
            the adjustment method suggested in JPEG section K.2.  This method is *not*
            optimal; it may not choose the best possible limited-length code.  But
            typically only very-low-frequency symbols will be given less-than-optimal
            lengths, so the code is almost optimal.  Experimental comparisons against
            an optimal limited-length-code algorithm indicate that the difference is
            microscopic --- usually less than a hundredth of a percent of total size.
            So the extra complexity of an optimal algorithm doesn't seem worthwhile.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order7">
            zz to natural order for 7x7 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order6">
            zz to natural order for 6x6 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order5">
            zz to natural order for 5x5 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order4">
            zz to natural order for 4x4 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order3">
            zz to natural order for 3x3 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order2">
            zz to natural order for 2x2 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_aritab">
            Arithmetic coding probability estimation tables
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jdiv_round_up(System.Int64,System.Int64)">
            <summary>
            Compute a/b rounded up to next integer, ie, ceil(a/b)
            Assumes a &gt;= 0, b &gt; 0
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jround_up(System.Int32,System.Int32)">
            <summary>
            Compute a rounded up to next multiple of b, ie, ceil(a/b)*b
            Assumes a &gt;= 0, b &gt; 0
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jcopy_sample_rows(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer,System.Int32,System.Byte[][],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy some rows of samples from one place to another.
            num_rows rows are copied from input_array[source_row++]
            to output_array[dest_row++]; these areas may overlap for duplication.
            The source and destination arrays must be at least as wide as num_cols.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter">
            <summary>
            Colorspace conversion
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.color_convert">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            
            Note that we change from the application's interleaved-pixel format
            to our internal noninterleaved, one-plane-per-component format.
            The input buffer is therefore three times as wide as the output buffer.
            
            A starting row offset is provided only for the output buffer.  The caller
            can easily adjust the passed input_buf value to accommodate any row
            offset required on that side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_ycc_start">
            <summary>
            Initialize for RGB-&gt;YCC colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_ycc_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            RGB -&gt; YCbCr conversion: most common case
            YCbCr is defined per CCIR 601-1, except that Cb and Cr are
            normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
            The conversion equations to be implemented are therefore
            Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
            Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE
            Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE
            (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
            To avoid floating-point arithmetic, we represent the fractional constants
            as integers scaled up by 2^16 (about 4 digits precision); we have to divide
            the products by 2^16, with appropriate rounding, to get the correct answer.
            For even more speed, we avoid doing any multiplications in the inner loop
            by precalculating the constants times R,G,B for all possible values.
            For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
            for 12-bit samples it is still acceptable.  It's not very reasonable for
            16-bit samples, but if you want lossless storage you shouldn't be changing
            colorspace anyway.
            The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included
            in the tables to save adding them separately in the inner loop.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_gray_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles RGB-&gt;grayscale conversion, which is the same
            as the RGB-&gt;Y portion of RGB-&gt;YCbCr.
            We assume rgb_ycc_start has been called (we only use the Y tables).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.cmyk_ycck_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles Adobe-style CMYK-&gt;YCCK conversion,
            where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
            conversion as above, while passing K (black) unchanged.
            We assume rgb_ycc_start has been called.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.grayscale_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles grayscale output with no conversion.
            The source can be either plain grayscale or YCC (since Y == gray).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.null_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles multi-component colorspaces without conversion.
            We assume input_components == num_components.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter">
            <summary>
            Colorspace conversion
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for output colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.color_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the output colorspace.
            
            Note that we change from noninterleaved, one-plane-per-component format
            to interleaved-pixel format.  The output buffer is therefore three times
            as wide as the input buffer.
            A starting row offset is provided only for the input buffer.  The caller
            can easily adjust the passed output_buf value to accommodate any row
            offset required on that side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.build_ycc_rgb_table">
            <summary>
            Initialize tables for YCbCr-&gt;RGB colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.build_bg_ycc_rgb_table">
            <summary>
            Initialize tables for BG_YCC-&gt;RGB colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.ycck_cmyk_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Adobe-style YCCK-&gt;CMYK conversion.
            We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
            conversion as above, while passing K (black) unchanged.
            We assume build_ycc_rgb_table has been called.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.gray_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Convert grayscale to RGB: just duplicate the graylevel three times.
            This is provided to support applications that don't want to cope
            with grayscale as a separate case.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.grayscale_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for grayscale: just copy the data.
            This also works for YCC -&gt; grayscale conversion, in which
            we just copy the Y (luminance) component and ignore chrominance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.cmyk_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for CMYK -&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.ycck_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for YCCK -&gt; RGB
            it's just a gybrid of YCCK -&gt; CMYK and CMYK -&gt; RGB conversions
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.null_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for no colorspace change: just copy the data,
            converting from separate-planes to interleaved representation.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_quantizer">
            <summary>
            Color quantization or color precision reduction
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master">
            <summary>
            Master control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.prepare_for_pass">
            <summary>
            Per-pass setup.
            
            This is called at the beginning of each pass.  We determine which 
            modules will be active during this pass and give them appropriate 
            start_pass calls. 
            We also set is_last_pass to indicate whether any more passes will 
            be required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.pass_startup">
            <summary>
            Special start-of-pass hook.
            
            This is called by jpeg_write_scanlines if call_pass_startup is true.
            In single-pass processing, we need this hook because we don't want to
            write frame/scan headers during jpeg_start_compress; we want to let the
            application write COM markers etc. between jpeg_start_compress and the
            jpeg_write_scanlines loop.
            In multi-pass processing, this routine is not used.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.finish_pass">
            <summary>
            Finish up at end of pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.per_scan_setup">
            <summary>
            Do computations that are needed before processing a JPEG scan
            cinfo.comps_in_scan and cinfo.cur_comp_info[] are already set
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_coef_controller">
            <summary>
            Coefficient buffer control
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller">
            <summary>
            Main buffer control (downsampled-data buffer)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller.process_data(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This routine handles the simple pass-through mode,
            where we have only a strip buffer.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller">
            <summary>
            Compression preprocessing (downsampling input buffer control).
            
            For the simple (no-context-row) case, we just need to buffer one
            row group's worth of pixels for the downsampling step.  At the bottom of
            the image, we pad to a full row group by replicating the last pixel row.
            The downsampler's last output row is then replicated if needed to pad
            out to a full iMCU row.
            
            When providing context rows, we must buffer three row groups' worth of
            pixels.  Three row groups are physically allocated, but the row pointer
            arrays are made five row groups high, with the extra pointers above and
            below "wrapping around" to point to the last and first real row groups.
            This allows the downsampler to access the proper context rows.
            At the top and bottom of the image, we create dummy context rows by
            copying the first or last real pixel row.  This copying could be avoided
            by pointer hacking as is done in jdmainct.c, but it doesn't seem worth the
            trouble on the compression side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.create_context_buffer">
            <summary>
            Create the wrapped-around downsampling input buffer needed for context mode.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.pre_process_WithoutContext(System.Byte[][],System.Int32@,System.Int32,System.Byte[][][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the simple no-context case.
            
            Preprocessor output data is counted in "row groups".  A row group
            is defined to be v_samp_factor sample rows of each component.
            Downsampling will produce this much data from each max_v_samp_factor
            input rows.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.pre_process_context(System.Byte[][],System.Int32@,System.Int32,System.Byte[][][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the context case.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.expand_bottom_edge(System.Byte[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expand an image vertically from height input_rows to height output_rows,
            by duplicating the bottom row.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master">
            <summary>
            Master control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.prepare_for_output_pass">
            <summary>
            Per-pass setup.
            This is called at the beginning of each output pass.  We determine which
            modules will be active during this pass and give them appropriate
            start_pass calls.  We also set is_dummy_pass to indicate whether this
            is a "real" output pass or a dummy pass for color quantization.
            (In the latter case, we will crank the pass to completion.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.finish_output_pass">
            <summary>
            Finish up at end of an output pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.master_selection">
            <summary>
            Master selection of decompression modules.
            This is done once at jpeg_start_decompress time.  We determine
            which modules will be used and give them appropriate initialization calls.
            We also initialize the decompressor input side to begin consuming data.
            
            Since jpeg_read_header has finished, we know what is in the SOF
            and (first) SOS markers.  We also have all the application parameter
            settings.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.prepare_range_limit_table">
            <summary>
            Allocate and fill in the sample_range_limit table.
            
            Several decompression processes need to range-limit values to the range
            0..MAXJSAMPLE; the input value may fall somewhat outside this range
            due to noise introduced by quantization, roundoff error, etc. These
            processes are inner loops and need to be as fast as possible. On most
            machines, particularly CPUs with pipelines or instruction prefetch,
            a (subscript-check-less) C table lookup
                x = sample_range_limit[x];
            is faster than explicit tests
            <c>
                if (x &amp; 0)
                   x = 0;
                else if (x &gt; MAXJSAMPLE)
                   x = MAXJSAMPLE;
            </c>
            These processes all use a common table prepared by the routine below.
            
            For most steps we can mathematically guarantee that the initial value
            of x is within 2*(MAXJSAMPLE+1) of the legal range, so a table running
            from -2*(MAXJSAMPLE+1) to 3*MAXJSAMPLE+2 is sufficient.But for the
            initial limiting step(just after the IDCT), a wildly out-of-range value
            is possible if the input data is corrupt.To avoid any chance of indexing
            off the end of memory and getting a bad-pointer trap, we perform the
            post-IDCT limiting thus:
                <c>x = (sample_range_limit - SUBSET)[(x + CENTER) &amp; MASK];</c>
            where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit
            samples.  Under normal circumstances this is more than enough range and
            a correct output will be generated; with bogus input data the mask will
            cause wraparound, and we will safely generate a bogus-but-in-range output.
            For the post-IDCT step, we want to convert the data from signed to unsigned
            representation by adding CENTERJSAMPLE at the same time that we limit it.
            This is accomplished with SUBSET = CENTER - CENTERJSAMPLE.
            
            Note that the table is allocated in near data space on PCs; it's small
            enough and used often enough to justify this.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler">
            <summary>
            Downsampling
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.downsample(System.Byte[][][],System.Int32,System.Byte[][][],System.Int32)">
            <summary>
            Do downsampling for a whole row group (all components).
            
            In this version we simply downsample each component independently.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.int_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            One row group is processed per call.
            This version handles arbitrary integral sampling ratios, without smoothing.
            Note that this version is not actually used for customary sampling ratios.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.fullsize_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the special case of a full-size component,
            without smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v1_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the common case of 2:1 horizontal and 1:1 vertical,
            without smoothing.
            
            A note about the "bias" calculations: when rounding fractional values to
            integer, we do not want to always round 0.5 up to the next integer.
            If we did that, we'd introduce a noticeable bias towards larger values.
            Instead, this code is arranged so that 0.5 will be rounded up or down at
            alternate pixel locations (a simple ordered dither pattern).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v2_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the standard case of 2:1 horizontal and 2:1 vertical,
            without smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v2_smooth_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the standard case of 2:1 horizontal and 2:1 vertical,
            with smoothing.  One row of context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.fullsize_smooth_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the special case of a full-size component,
            with smoothing.  One row of context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.expand_right_edge(System.Byte[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expand a component horizontally from width input_cols to width output_cols,
            by duplicating the rightmost samples.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller">
            <summary>
            Coefficient buffer control
            
            This code applies interblock smoothing as described by section K.8
            of the JPEG standard: the first 5 AC coefficients are estimated from
            the DC values of a DCT block and its 8 neighboring blocks.
            We apply smoothing only for progressive JPEG decoding, and only if
            the coefficients it can estimate are not yet known to full precision.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_input_pass">
            <summary>
            Initialize for an input processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.consume_data">
            <summary>
            Consume input data and store it in the full-image coefficient buffer.
            We read as much as one fully interleaved MCU row ("iMCU" row) per call,
            ie, v_samp_factor block rows for each component in the scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_output_pass">
            <summary>
            Initialize for an output processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_onepass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Decompress and return some data in the single-pass case.
            Always attempts to emit one fully interleaved MCU row ("iMCU" row).
            Input and output must run in lockstep since we have only a one-MCU buffer.
            Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
            
            NB: output_buf contains a plane for each component in image,
            which we index according to the component's SOF position.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_data_ordinary(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Decompress and return some data in the multi-pass case.
            Always attempts to emit one fully interleaved MCU row ("iMCU" row).
            Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
            
            NB: output_buf contains a plane for each component in image.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_smooth_data(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Variant of decompress_data for use when doing block smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.smoothing_ok">
            <summary>
            Determine whether block smoothing is applicable and safe.
            We also latch the current states of the coef_bits[] entries for the
            AC coefficients; otherwise, if the input side of the decompressor
            advances into a new scan, we might think the coefficients are known
            more accurately than they really are.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_iMCU_row">
            <summary>
            Reset within-iMCU-row counters for a new row (input side)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller">
            <summary>
            Main buffer control (downsampled-data buffer)
            
            In the current system design, the main buffer need never be a full-image
            buffer; any full-height buffers will be found inside the coefficient or
            postprocessing controllers.  Nonetheless, the main controller is not
            trivial.  Its responsibility is to provide context rows for upsampling/
            rescaling, and doing this in an efficient fashion is a bit tricky.
            
            Postprocessor input data is counted in "row groups".  A row group
            is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
            sample rows of each component.  (We require DCT_scaled_size values to be
            chosen such that these numbers are integers.  In practice DCT_scaled_size
            values will likely be powers of two, so we actually have the stronger
            condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)
            Upsampling will typically produce max_v_samp_factor pixel rows from each
            row group (times any additional scale factor that the upsampler is
            applying).
            
            The coefficient controller will deliver data to us one iMCU row at a time;
            each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or
            exactly min_DCT_scaled_size row groups.  (This amount of data corresponds
            to one row of MCUs when the image is fully interleaved.)  Note that the
            number of sample rows varies across components, but the number of row
            groups does not.  Some garbage sample rows may be included in the last iMCU
            row at the bottom of the image.
            
            Depending on the vertical scaling algorithm used, the upsampler may need
            access to the sample row(s) above and below its current input row group.
            The upsampler is required to set need_context_rows true at global selection
            time if so.  When need_context_rows is false, this controller can simply
            obtain one iMCU row at a time from the coefficient controller and dole it
            out as row groups to the postprocessor.
            
            When need_context_rows is true, this controller guarantees that the buffer
            passed to postprocessing contains at least one row group's worth of samples
            above and below the row group(s) being processed.  Note that the context
            rows "above" the first passed row group appear at negative row offsets in
            the passed buffer.  At the top and bottom of the image, the required
            context rows are manufactured by duplicating the first or last real sample
            row; this avoids having special cases in the upsampling inner loops.
            
            The amount of context is fixed at one row group just because that's a
            convenient number for this controller to work with.  The existing
            upsamplers really only need one sample row of context.  An upsampler
            supporting arbitrary output rescaling might wish for more than one row
            group of context when shrinking the image; tough, we don't handle that.
            (This is justified by the assumption that downsizing will be handled mostly
            by adjusting the DCT_scaled_size values, so that the actual scale factor at
            the upsample step needn't be much less than one.)
            
            To provide the desired context, we have to retain the last two row groups
            of one iMCU row while reading in the next iMCU row.  (The last row group
            can't be processed until we have another row group for its below-context,
            and so we have to save the next-to-last group too for its above-context.)
            We could do this most simply by copying data around in our buffer, but
            that'd be very slow.  We can avoid copying any data by creating a rather
            strange pointer structure.  Here's how it works.  We allocate a workspace
            consisting of M+2 row groups (where M = min_DCT_scaled_size is the number
            of row groups per iMCU row).  We create two sets of redundant pointers to
            the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
            pointer lists look like this:
                              M+1                          M-1
                              master pointer --&gt; 0         master pointer --&gt; 0
                              1                            1
                              ...                          ...
                              M-3                          M-3
                              M-2                           M
                              M-1                          M+1
                               M                           M-2
                              M+1                          M-1
                               0                            0
            We read alternate iMCU rows using each master pointer; thus the last two
            row groups of the previous iMCU row remain un-overwritten in the workspace.
            The pointer lists are set up so that the required context rows appear to
            be adjacent to the proper places when we pass the pointer lists to the
            upsampler.
            
            The above pictures describe the normal state of the pointer lists.
            At top and bottom of the image, we diddle the pointer lists to duplicate
            the first or last sample row as necessary (this is cheaper than copying
            sample rows around).
            
            This scheme breaks down if M less than 2, ie, min_DCT_scaled_size is 1.  In that
            situation each iMCU row provides only one row group so the buffering logic
            must be different (eg, we must read two iMCU rows before we can emit the
            first row group).  For now, we simply do not support providing context
            rows when min_DCT_scaled_size is 1.  That combination seems unlikely to
            be worth providing --- if someone wants a 1/8th-size preview, they probably
            want it quick and dirty, so a context-free upsampler is sufficient.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_simple_main(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This handles the simple case where no context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_context_main(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This handles the case where context rows must be provided.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_crank_post(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            Final pass of two-pass quantization: just call the postprocessor.
            Source data will be the postprocessor controller's internal buffer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.alloc_funny_pointers">
            <summary>
            Allocate space for the funny pointer lists.
            This is done only once, not once per pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.make_funny_pointers">
            <summary>
            Create the funny pointer lists discussed in the comments above.
            The actual workspace is already allocated (in main.buffer),
            and the space for the pointer lists is allocated too.
            This routine just fills in the curiously ordered lists.
            This will be repeated at the beginning of each pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.set_wraparound_pointers">
            <summary>
            Set up the "wraparound" pointers at top and bottom of the pointer lists.
            This changes the pointer list state from top-of-image to the normal state.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.set_bottom_pointers">
            <summary>
            Change the pointer lists to duplicate the last sample row at the bottom
            of the image.  m_whichFunny indicates which m_funnyIndices holds the final iMCU row.
            Also sets rowgroups_avail to indicate number of nondummy row groups in row.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller">
            <summary>
            Decompression postprocessing (color quantization buffer control)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Boolean)">
            <summary>
            Initialize postprocessing controller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_1pass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the one-pass (strip buffer) case.
            This is used for color precision reduction as well as one-pass quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_prepass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Int32@)">
            <summary>
            Process some data in the first pass of 2-pass quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_2pass(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the second pass of 2-pass quantization.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_decoder">
            <summary>
            Entropy decoding
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder">
            <summary>
            Entropy encoding
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct">
            <summary>
            Forward DCT (also controls coefficient quantization)
            
            A forward DCT routine is given a pointer to an input sample array and
            a pointer to a work area of type DCTELEM[]; the DCT is to be performed
            in-place in that buffer.  Type DCTELEM is int for 8-bit samples, INT32
            for 12-bit samples.  (NOTE: Floating-point DCT implementations use an
            array of type FAST_FLOAT, instead.)
            The input data is to be fetched from the sample array starting at a
            specified column.  (Any row offset needed will be applied to the array
            pointer before it is passed to the FDCT code.)
            Note that the number of samples fetched by the FDCT routine is
            DCT_h_scaled_size * DCT_v_scaled_size.
            The DCT outputs are returned scaled up by a factor of 8; they therefore
            have a range of +-8K for 8-bit data, +-128K for 12-bit data.  This
            convention improves accuracy in integer implementations and saves some
            work in floating-point ones.
            
            Each IDCT routine has its own ideas about the best dct_table element type.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.forward_DCT_ptr">
            <summary>
            Perform forward DCT on one or more blocks of a component.
            
            The input samples are taken from the sample_data[] array starting at
            position start_row/start_col, and moving to the right for any additional
            blocks. The quantized coefficients are returned in coef_blocks[].
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.start_pass">
            <summary>
            Initialize for a processing pass.
            Verify that all referenced Q-tables are present, and set up
            the divisor table for each one.
            In the current implementation, DCT of all components is done during
            the first pass, even if only some components will be output in the
            first scan.  Hence all components should be examined here.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_float(System.Single[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            
            A floating-point implementation of the 
            forward DCT (Discrete Cosine Transform).
            
            This implementation should be more accurate than either of the integer
            DCT implementations.  However, it may not give the same results on all
            machines because of differences in roundoff behavior.  Speed will depend
            on the hardware's floating point capacity.
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with a fixed-point
            implementation, accuracy is lost due to imprecise representation of the
            scaled quantization values.  However, that problem does not arise if
            we use floating point arithmetic.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_ifast(System.Int32[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            This file contains a fast, not so accurate integer implementation of the
            forward DCT (Discrete Cosine Transform).
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with fixed-point math,
            accuracy is lost due to imprecise representation of the scaled
            quantization values.  The smaller the quantization table entry, the less
            precise the scaled value, so this implementation does worse with high-
            quality-setting files than with low-quality ones.
            
            Scaling decisions are generally the same as in the LL&amp;M algorithm;
            see jpeg_fdct_islow for more details.  However, we choose to descale
            (right shift) multiplication products as soon as they are formed,
            rather than carrying additional fractional bits into subsequent additions.
            This compromises accuracy slightly, but it lets us save a few shifts.
            More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
            everywhere except in the multiplications proper; this saves a good deal
            of work on 16-bit-int machines.
            
            Again to save a few shifts, the intermediate results between pass 1 and
            pass 2 are not upscaled, but are represented only to integral precision.
            
            A final compromise is to represent the multiplicative constants to only
            8 fractional bits, rather than 13.  This saves some shifting work on some
            machines, and may also reduce the cost of multiplication (since there
            are fewer one-bits in the constants).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_islow(System.Int32[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            
            A slow-but-accurate integer implementation of the
            forward DCT (Discrete Cosine Transform).
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on an algorithm described in
            C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
            Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
            Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
            The primary algorithm described there uses 11 multiplies and 29 adds.
            We use their alternate method with 12 multiplies and 32 adds.
            The advantage of this method is that no data path contains more than one
            multiplication; this allows a very simple and accurate implementation in
            scaled fixed-point arithmetic, with a minimal number of shifts.
            
            The poop on this scaling stuff is as follows:
            
            Each 1-D DCT step produces outputs which are a factor of sqrt(N)
            larger than the true DCT outputs.  The final outputs are therefore
            a factor of N larger than desired; since N=8 this can be cured by
            a simple right shift at the end of the algorithm.  The advantage of
            this arrangement is that we save two multiplications per 1-D DCT,
            because the y0 and y4 outputs need not be divided by sqrt(N).
            In the IJG code, this factor of 8 is removed by the quantization 
            step, NOT here.
            
            We have to do addition and subtraction of the integer inputs, which
            is no problem, and multiplication by fractional constants, which is
            a problem to do in integer arithmetic.  We multiply all the constants
            by CONST_SCALE and convert them to integer constants (thus retaining
            SLOW_INTEGER_CONST_BITS bits of precision in the constants).  After doing a
            multiplication we have to divide the product by CONST_SCALE, with proper
            rounding, to produce the correct output.  This division can be done
            cheaply as a right shift of SLOW_INTEGER_CONST_BITS bits.  We postpone shifting
            as long as possible so that partial sums can be added together with
            full fractional precision.
            
            The outputs of the first pass are scaled up by SLOW_INTEGER_PASS1_BITS bits so that
            they are represented to better-than-integral precision.  These outputs
            require BITS_IN_JSAMPLE + SLOW_INTEGER_PASS1_BITS + 3 bits; this fits in a 16-bit word
            with the recommended scaling.  (For 12-bit sample data, the intermediate
            array is int anyway.)
            
            To avoid overflow of the 32-bit intermediate results in pass 2, we must
            have BITS_IN_JSAMPLE + SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS &lt;= 26.  Error analysis
            shows that the values given below are the most effective.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.FAST_INTEGER_MULTIPLY(System.Int32,System.Int32)">
            <summary>
            Multiply a DCTELEM variable by an int constant, and immediately
            descale to yield a DCTELEM result.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller">
            <summary>
            Input control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize the input controller module.
            This is called only once, when the decompression object is created.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.reset_input_controller">
            <summary>
            Reset state to begin a fresh datastream.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.start_input_pass">
            <summary>
            Initialize the input modules to read a scan of compressed data.
            The first call to this is done after initializing
            the entire decompressor (during jpeg_start_decompress).
            Subsequent calls come from consume_markers, below.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.finish_input_pass">
            <summary>
            Finish up after inputting a compressed-data scan.
            This is called by the coefficient controller after it's read all
            the expected data of the scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.consume_markers">
            <summary>
            Read JPEG markers before, between, or after compressed-data scans.
            Change state as necessary when a new scan is reached.
            Return value is JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
            
            The consume_input method pointer points either here or to the
            coefficient controller's consume_data routine, depending on whether
            we are reading a compressed data segment or inter-segment markers.
            
            Note: This function should NOT return a pseudo SOS marker(with zero
            component number) to the caller.A pseudo marker received by
            read_markers is processed and then skipped for other markers.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.initial_setup">
            <summary>
            Routines to calculate various quantities related to the size of the image.
            Called once, when first SOS marker is reached
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.latch_quant_tables">
            <summary>
            Save away a copy of the Q-table referenced by each component present
            in the current scan, unless already saved during a prior scan.
            
            In a multiple-scan JPEG file, the encoder could assign different components
            the same Q-table slot number, but change table definitions between scans
            so that each component uses a different Q-table.  (The IJG encoder is not
            currently capable of doing this, but other encoders might.)  Since we want
            to be able to dequantize all the components at the end of the file, this
            means that we have to save away the table actually used for each component.
            We do this by copying the table at the start of the first scan containing
            the component.
            The JPEG spec prohibits the encoder from changing the contents of a Q-table
            slot between scans of a component using that slot.  If the encoder does so
            anyway, this decoder will simply use the Q-table values that were current
            at the start of the first scan for the component.
            
            The decompressor output side looks only at the saved quant tables,
            not at the current Q-table slots.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.per_scan_setup">
            <summary>
            Do computations that are needed before processing a JPEG scan
            cinfo.comps_in_scan and cinfo.cur_comp_info[] were set from SOS marker
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct">
            <summary>
            An inverse DCT routine is given a pointer to the input JBLOCK and a pointer
            to an output sample array.  The routine must dequantize the input data as
            well as perform the IDCT; for dequantization, it uses the multiplier table
            pointed to by componentInfo.dct_table.  The output data is to be placed into the
            sample array starting at a specified column. (Any row offset needed will
            be applied to the array pointer before it is passed to the IDCT code)
            Note that the number of samples emitted by the IDCT routine is
            DCT_h_scaled_size * DCT_v_scaled_size.
            
            Each IDCT routine has its own ideas about the best dct_table element type.
            
            The decompressor input side saves away the appropriate
            quantization table for each component at the start of the first scan
            involving that component.  (This is necessary in order to correctly
            decode files that reuse Q-table slots.)
            When we are ready to make an output pass, the saved Q-table is converted
            to a multiplier table that will actually be used by the IDCT routine.
            The multiplier table contents are IDCT-method-dependent.  To support
            application changes in IDCT method between scans, we can remake the
            multiplier tables if necessary.
            In buffered-image mode, the first output pass may occur before any data
            has been seen for some components, and thus before their Q-tables have
            been saved away.  To handle this case, multiplier tables are preset
            to zeroes; the result of the IDCT will be a neutral gray level.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.start_pass">
            <summary>
            Prepare for an output pass.
            Here we select the proper IDCT routine for each component and build
            a matching multiplier table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_islow(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            A slow-but-accurate integer implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on an algorithm described in
            C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
            Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
            Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
            The primary algorithm described there uses 11 multiplies and 29 adds.
            We use their alternate method with 12 multiplies and 32 adds.
            The advantage of this method is that no data path contains more than one
            multiplication; this allows a very simple and accurate implementation in
            scaled fixed-point arithmetic, with a minimal number of shifts.
            
            The poop on this scaling stuff is as follows:
            
            Each 1-D IDCT step produces outputs which are a factor of sqrt(N)
            larger than the true IDCT outputs.  The final outputs are therefore
            a factor of N larger than desired; since N=8 this can be cured by
            a simple right shift at the end of the algorithm.  The advantage of
            this arrangement is that we save two multiplications per 1-D IDCT,
            because the y0 and y4 inputs need not be divided by sqrt(N).
            
            We have to do addition and subtraction of the integer inputs, which
            is no problem, and multiplication by fractional constants, which is
            a problem to do in integer arithmetic.  We multiply all the constants
            by CONST_SCALE and convert them to integer constants (thus retaining
            SLOW_INTEGER_CONST_BITS bits of precision in the constants).  After doing a
            multiplication we have to divide the product by CONST_SCALE, with proper
            rounding, to produce the correct output.  This division can be done
            cheaply as a right shift of SLOW_INTEGER_CONST_BITS bits.  We postpone shifting
            as long as possible so that partial sums can be added together with
            full fractional precision.
            
            The outputs of the first pass are scaled up by SLOW_INTEGER_PASS1_BITS bits so that
            they are represented to better-than-integral precision.  These outputs
            require BITS_IN_JSAMPLE + SLOW_INTEGER_PASS1_BITS + 3 bits; this fits in a 16-bit word
            with the recommended scaling.  (To scale up 12-bit sample data further, an
            intermediate int array would be needed.)
            
            To avoid overflow of the 32-bit intermediate results in pass 2, we must
            have BITS_IN_JSAMPLE + SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS &lt;= 26.  Error analysis
            shows that the values given below are the most effective.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.SLOW_INTEGER_DEQUANTIZE(System.Int32,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce an int result.  In this module, both inputs and result
            are 16 bits or less, so either int or short multiply will work.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_ifast(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            
            A fast, not so accurate integer implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with fixed-point math,
            accuracy is lost due to imprecise representation of the scaled
            quantization values.  The smaller the quantization table entry, the less
            precise the scaled value, so this implementation does worse with high-
            quality-setting files than with low-quality ones.
            
            Scaling decisions are generally the same as in the LL&amp;M algorithm;
            However, we choose to descale
            (right shift) multiplication products as soon as they are formed,
            rather than carrying additional fractional bits into subsequent additions.
            This compromises accuracy slightly, but it lets us save a few shifts.
            More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
            everywhere except in the multiplications proper; this saves a good deal
            of work on 16-bit-int machines.
            
            The dequantized coefficients are not integers because the AA&amp;N scaling
            factors have been incorporated.  We represent them scaled up by FAST_INTEGER_PASS1_BITS,
            so that the first and second IDCT rounds have the same input scaling.
            For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = FAST_INTEGER_PASS1_BITS so as to
            avoid a descaling shift; this compromises accuracy rather drastically
            for small quantization table entries, but it saves a lot of shifts.
            For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
            so we use a much larger scaling factor to preserve accuracy.
            
            A final compromise is to represent the multiplicative constants to only
            8 fractional bits, rather than 13.  This saves some shifting work on some
            machines, and may also reduce the cost of multiplication (since there
            are fewer one-bits in the constants).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_MULTIPLY(System.Int32,System.Int32)">
            <summary>
            Multiply a DCTELEM variable by an int constant, and immediately
            descale to yield a DCTELEM result.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_DEQUANTIZE(System.Int16,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce a DCTELEM result.  For 8-bit data a 16x16-&gt;16
            multiplication will do.  For 12-bit data, the multiplier table is
            declared int, so a 32-bit multiply will be used.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_IRIGHT_SHIFT(System.Int32,System.Int32)">
            <summary>
            Like DESCALE, but applies to a DCTELEM and produces an int.
            We assume that int right shift is unsigned if int right shift is.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_float(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            
            A floating-point implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            This implementation should be more accurate than either of the integer
            IDCT implementations.  However, it may not give the same results on all
            machines because of differences in roundoff behavior.  Speed will depend
            on the hardware's floating point capacity.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with a fixed-point
            implementation, accuracy is lost due to imprecise representation of the
            scaled quantization values.  However, that problem does not arise if
            we use floating point arithmetic.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FLOAT_DEQUANTIZE(System.Int16,System.Single)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce a float result.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_4x4(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Inverse-DCT routines that produce reduced-size output:
            either 4x4, 2x2, or 1x1 pixels from an 8x8 DCT block.
            
            NOTE: this code only copes with 8x8 DCTs.
            
            The implementation is based on the Loeffler, Ligtenberg and Moschytz (LL&amp;M)
            algorithm. We simply replace each 8-to-8 1-D IDCT step
            with an 8-to-4 step that produces the four averages of two adjacent outputs
            (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).
            These steps were derived by computing the corresponding values at the end
            of the normal LL&amp;M code, then simplifying as much as possible.
            
            1x1 is trivial: just take the DC coefficient divided by 8.
            
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 4x4 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_2x2(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 2x2 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_1x1(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 1x1 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.REDUCED_DEQUANTIZE(System.Int16,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce an int result.  In this module, both inputs and result
            are 16 bits or less, so either int or short multiply will work.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader">
            <summary>
            Marker reading and parsing
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize the marker reader module.
            This is called only once, when the decompression object is created.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.reset_marker_reader">
            <summary>
            Reset marker processing state to begin a fresh datastream.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.read_markers">
            <summary>
            Read markers until SOS or EOI.
            
            Returns same codes as are defined for jpeg_consume_input:
            JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
            
            Note: This function may return a pseudo SOS marker(with zero
            component number) for treat by input controller's consume_input.
            consume_input itself should filter out (skip) the pseudo marker
            after processing for the caller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.read_restart_marker">
            <summary>
            Read a restart marker, which is expected to appear next in the datastream;
            if the marker is not there, take appropriate recovery action.
            Returns false if suspension is required.
            
            Made public for use by entropy decoder only
            
            This is called by the entropy decoder after it has read an appropriate
            number of MCUs.  cinfo.unread_marker may be nonzero if the entropy decoder
            has already read a marker from the data source.  Under normal conditions
            cinfo.unread_marker will be reset to 0 before returning; if not reset,
            it holds a marker which the decoder will be unable to read past.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.next_marker">
            <summary>
            Find the next JPEG marker, save it in cinfo.unread_marker.
            Returns false if had to suspend before reaching a marker;
            in that case cinfo.unread_marker is unchanged.
            
            Note that the result might not be a valid marker code,
            but it will never be 0 or FF.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)">
            <summary>
            Install a special processing method for COM or APPn markers.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.save_marker(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Save an APPn or COM marker into the marker list
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.skip_variable(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Skip over an unknown or uninteresting variable-length marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_interesting_appn(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Process an APP0 or APP14 marker without saving it
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.examine_app0(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Examine first few bytes from an APP0.
            Take appropriate action if it is a JFIF marker.
            datalen is # of bytes at data[], remaining is length of rest of marker data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.examine_app14(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Examine first few bytes from an APP14.
            Take appropriate action if it is an Adobe marker.
            datalen is # of bytes at data[], remaining is length of rest of marker data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_soi">
            <summary>
            Process an SOI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_sof(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Process a SOFn marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_sos">
            <summary>
            Process a SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dac">
            <summary>
            Process a DAC marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dht">
            <summary>
            Process a DHT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dqt">
            <summary>
            Process a DQT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dri">
            <summary>
            Process a DRI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_lse">
            <summary>
            Process an LSE marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.first_marker">
            <summary>
            Like next_marker, but used to obtain the initial SOI marker.
            For this marker, we do not allow preceding garbage or fill; otherwise,
            we might well scan an entire input file before realizing it ain't JPEG.
            If an application wants to process non-JFIF files, it must seek to the
            SOI before calling the JPEG library.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer">
            <summary>
            Marker writing
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_file_header">
            <summary>
            Write datastream header.
            This consists of an SOI and optional APPn markers.
            We recommend use of the JFIF marker, but not the Adobe marker,
            when using YCbCr or grayscale data. The JFIF marker is also used
            for other standard JPEG colorspaces. The Adobe marker is helpful
            to distinguish RGB, CMYK, and YCCK colorspaces.
            Note that an application can write additional header markers after
            jpeg_start_compress returns.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_frame_header">
            <summary>
            Write frame header.
            This consists of DQT and SOFn markers,
            a conditional LSE marker and a conditional pseudo SOS marker.
            Note that we do not emit the SOF until we have emitted the DQT(s).
            This avoids compatibility problems with incorrect implementations that
            try to error-check the quant table numbers as soon as they see the SOF.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_scan_header">
            <summary>
            Write scan header.
            This consists of DHT or DAC markers, optional DRI, and SOS.
            Compressed data will be written following the SOS.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_file_trailer">
            <summary>
            Write datastream trailer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_tables_only">
            <summary>
            Write an abbreviated table-specification datastream.
            This consists of SOI, DQT and DHT tables, and EOI.
            Any table that is defined and not marked sent_table = true will be
            emitted.  Note that all tables will be marked sent_table = true at exit.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_marker_header(System.Int32,System.Int32)">
            <summary>
            Emit an arbitrary marker header
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_marker_byte(System.Byte)">
            <summary>
            Emit one byte of marker parameters following write_marker_header
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_sos">
            <summary>
            Emit a SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_lse_ict">
            <summary>
            Emit an LSE inverse color transform specification marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_sof(BitMiracle.LibJpeg.Classic.JPEG_MARKER)">
            <summary>
            Emit a SOF marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_adobe_app14">
            <summary>
            Emit an Adobe APP14 marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dri">
            <summary>
            Emit a DRI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dht(System.Int32,System.Boolean)">
            <summary>
            Emit a DHT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dqt(System.Int32)">
            <summary>
            Emit a DQT marker
            </summary>
            <param name="index">The index.</param>
            <returns>the precision used (0 = 8bits, 1 = 16bits) for baseline checking</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_pseudo_sos">
            <summary>
            Emit a pseudo SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_jfif_app0">
            <summary>
            Emit a JFIF-compliant APP0 marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_marker(BitMiracle.LibJpeg.Classic.JPEG_MARKER)">
            <summary>
            Emit a marker code
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_2bytes(System.Int32)">
            <summary>
            Emit a 2-byte integer; these are always MSB first in JPEG files
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_byte(System.Int32)">
            <summary>
            Emit a byte
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_scan_info">
            <summary>
            The script for encoding a multiple-scan file is an array of these:
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_upsampler">
            <summary>
            Upsampling (note that upsampler must also call color converter)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE">
            <summary>
            Operating modes for buffer controllers
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer">
            <summary>
            The main purpose of 1-pass quantization is to provide a fast, if not very
            high quality, colormapped output capability.  A 2-pass quantizer usually
            gives better visual quality; however, for quantized grayscale output this
            quantizer is perfectly adequate.  Dithering is highly recommended with this
            quantizer, though you can turn it off if you really want to.
            
            In 1-pass quantization the colormap must be chosen in advance of seeing the
            image.  We use a map consisting of all combinations of Ncolors[i] color
            values for the i'th component.  The Ncolors[] values are chosen so that
            their product, the total number of colors, is no more than that requested.
            (In most cases, the product will be somewhat less.)
            
            Since the colormap is orthogonal, the representative value for each color
            component can be determined without considering the other components;
            then these indexes can be combined into a colormap index by a standard
            N-dimensional-array-subscript calculation.  Most of the arithmetic involved
            can be precalculated and stored in the lookup table colorindex[].
            colorindex[i][j] maps pixel value j in component i to the nearest
            representative value (grid plane) for that component; this index is
            multiplied by the array stride for component i, so that the
            index of the colormap entry closest to a given pixel value is just
                sum( colorindex[component-number][pixel-component-value] )
            Aside from being fast, this scheme allows for variable spacing between
            representative values with no additional lookup cost.
            
            If gamma correction has been applied in color conversion, it might be wise
            to adjust the color grid spacing so that the representative colors are
            equidistant in linear space.  At this writing, gamma correction is not
            implemented, so nothing is done here.
            
            
            Declarations for Floyd-Steinberg dithering.
            
            Errors are accumulated into the array fserrors[], at a resolution of
            1/16th of a pixel count.  The error at a given pixel is propagated
            to its not-yet-processed neighbors using the standard F-S fractions,
                ...	(here)	7/16
               3/16	5/16	1/16
            We work left-to-right on even rows, right-to-left on odd rows.
            
            We can get away with a single array (holding one row's worth of errors)
            by using it to store the current row's errors at pixel columns not yet
            processed, but the next row's errors at columns already processed.  We
            need only a few extra variables to hold the errors immediately around the
            current column.  (If we are lucky, those variables are in registers, but
            even if not, they're probably cheaper to access than array elements are.)
            
            The fserrors[] array is indexed [component#][position].
            We provide (#columns + 2) entries per component; the extra entry at each
            end saves us from special-casing the first and last pixels.
            
            
            Declarations for ordered dithering.
            
            We use a standard 16x16 ordered dither array.  The basic concept of ordered
            dithering is described in many references, for instance Dale Schumacher's
            chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).
            In place of Schumacher's comparisons against a "threshold" value, we add a
            "dither" value to the input pixel and then round the result to the nearest
            output value.  The dither value is equivalent to (0.5 - threshold) times
            the distance between output values.  For ordered dithering, we assume that
            the output colors are equally spaced; if not, results will probably be
            worse, since the dither may be too much or too little at a given point.
            
            The normal calculation would be to form pixel value + dither, range-limit
            this to 0..MAXJSAMPLE, and then index into the colorindex table as usual.
            We can skip the separate range-limiting step by extending the colorindex
            table in both directions.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for 1-pass color quantization.
            </summary>
            <param name="cinfo">The cinfo.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.start_pass(System.Boolean)">
            <summary>
            Initialize for one-pass color quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.finish_pass">
            <summary>
            Finish up at the end of the pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.new_color_map">
            <summary>
            Switch to a new external colormap between output passes.
            Shouldn't get to this!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, no dithering.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize3(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            Fast path for out_color_components==3, no dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize_ord_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, with ordered dithering.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize3_ord_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            Fast path for out_color_components==3, with ordered dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize_fs_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, with Floyd-Steinberg dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_colormap">
            <summary>
            Create the colormap.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_colorindex">
            <summary>
            Create the color index table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_odither_tables">
            <summary>
            Create the ordered-dither tables.
            Components having the same number of representative colors may 
            share a dither table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.alloc_fs_workspace">
            <summary>
            Allocate workspace for Floyd-Steinberg errors.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.largest_input_value(System.Int32,System.Int32)">
            <summary>
            Return largest input value that should map to j'th output value
            Must have largest(j=0) &gt;= 0, and largest(j=maxj) &gt;= MAXJSAMPLE
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.output_value(System.Int32,System.Int32)">
            <summary>
            Return j'th output value, where j will range from 0 to maxj
            The output values must fall in 0..MAXJSAMPLE in increasing order
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.select_ncolors(System.Int32[])">
            <summary>
            Determine allocation of desired colors to components,
            and fill in Ncolors[] array to indicate choice.
            Return value is total number of colors (product of Ncolors[] values).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.make_odither_array(System.Int32)">
            <summary>
            Create an ordered-dither array for a component having ncolors
            distinct output values.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer">
            <summary>
            This module implements the well-known Heckbert paradigm for color
            quantization.  Most of the ideas used here can be traced back to
            Heckbert's seminal paper
            Heckbert, Paul.  "Color Image Quantization for Frame Buffer Display",
            Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
            
            In the first pass over the image, we accumulate a histogram showing the
            usage count of each possible color.  To keep the histogram to a reasonable
            size, we reduce the precision of the input; typical practice is to retain
            5 or 6 bits per color, so that 8 or 4 different input values are counted
            in the same histogram cell.
            
            Next, the color-selection step begins with a box representing the whole
            color space, and repeatedly splits the "largest" remaining box until we
            have as many boxes as desired colors.  Then the mean color in each
            remaining box becomes one of the possible output colors.
            
            The second pass over the image maps each input pixel to the closest output
            color (optionally after applying a Floyd-Steinberg dithering correction).
            This mapping is logically trivial, but making it go fast enough requires
            considerable care.
            
            Heckbert-style quantizers vary a good deal in their policies for choosing
            the "largest" box and deciding where to cut it.  The particular policies
            used here have proved out well in experimental comparisons, but better ones
            may yet be found.
            
            In earlier versions of the IJG code, this module quantized in YCbCr color
            space, processing the raw upsampled data without a color conversion step.
            This allowed the color conversion math to be done only once per colormap
            entry, not once per pixel.  However, that optimization precluded other
            useful optimizations (such as merging color conversion with upsampling)
            and it also interfered with desired capabilities such as quantizing to an
            externally-supplied colormap.  We have therefore abandoned that approach.
            The present code works in the post-conversion color space, typically RGB.
            
            To improve the visual quality of the results, we actually work in scaled
            RGB space, giving G distances more weight than R, and R in turn more than
            B.  To do everything in integer math, we must use integer scale factors.
            The 2/3/1 scale factors used here correspond loosely to the relative
            weights of the colors in the NTSC grayscale equation.
            If you want to use this code to quantize a non-RGB color space, you'll
            probably need to change these scale factors.
            
            First we have the histogram data structure and routines for creating it.
            
            The number of bits of precision can be adjusted by changing these symbols.
            We recommend keeping 6 bits for G and 5 each for R and B.
            If you have plenty of memory and cycles, 6 bits all around gives marginally
            better results; if you are short of memory, 5 bits all around will save
            some space but degrade the results.
            To maintain a fully accurate histogram, we'd need to allocate a "long"
            (preferably unsigned long) for each cell.  In practice this is overkill;
            we can get by with 16 bits per cell.  Few of the cell counts will overflow,
            and clamping those that do overflow to the maximum value will give close-
            enough results.  This reduces the recommended histogram size from 256Kb
            to 128Kb, which is a useful savings on PC-class machines.
            (In the second pass the histogram space is re-used for pixel mapping data;
            in that capacity, each cell must be able to store zero to the number of
            desired colors.  16 bits/cell is plenty for that too.)
            Since the JPEG code is intended to run in small memory model on 80x86
            machines, we can't just allocate the histogram in one chunk.  Instead
            of a true 3-D array, we use a row of pointers to 2-D arrays.  Each
            pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and
            each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that
            on 80x86 machines, the pointer row is in near memory but the actual
            arrays are in far memory (same arrangement as we use for image arrays).
            
            
            Declarations for Floyd-Steinberg dithering.
            
            Errors are accumulated into the array fserrors[], at a resolution of
            1/16th of a pixel count.  The error at a given pixel is propagated
            to its not-yet-processed neighbors using the standard F-S fractions,
                ... (here)  7/16
            3/16    5/16    1/16
            We work left-to-right on even rows, right-to-left on odd rows.
            
            We can get away with a single array (holding one row's worth of errors)
            by using it to store the current row's errors at pixel columns not yet
            processed, but the next row's errors at columns already processed.  We
            need only a few extra variables to hold the errors immediately around the
            current column.  (If we are lucky, those variables are in registers, but
            even if not, they're probably cheaper to access than array elements are.)
            
            The fserrors[] array has (#columns + 2) entries; the extra entry at
            each end saves us from special-casing the first and last pixels.
            Each entry is three values long, one value for each color component.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for 2-pass color quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.start_pass(System.Boolean)">
            <summary>
            Initialize for each processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.new_color_map">
            <summary>
            Switch to a new external colormap between output passes.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.prescan_quantize(System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Prescan some rows of pixels.
            In this module the prescan simply updates the histogram, which has been
            initialized to zeroes by start_pass.
            An output_buf parameter is required by the method signature, but no data
            is actually output (in fact the buffer controller is probably passing a
            null pointer).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.pass2_fs_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            This version performs Floyd-Steinberg dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.pass2_no_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            This version performs no dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.finish_pass1">
            <summary>
            Finish up at the end of each pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.compute_color(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32,System.Int32)">
            <summary>
            Compute representative color for a box, put it in colormap[icolor]
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.select_colors(System.Int32)">
            <summary>
            Master routine for color selection
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.median_cut(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32,System.Int32)">
            <summary>
            Repeatedly select and split the largest box until we have enough boxes
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_biggest_color_pop(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Find the splittable box with the largest color population
            Returns null if no splittable boxes remain
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_biggest_volume(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Find the splittable box with the largest (scaled) volume
            Returns null if no splittable boxes remain
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.update_box(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Shrink the min/max bounds of a box to enclose only nonzero elements,
            and recompute its volume and population
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.init_error_limit">
            <summary>
            Initialize the error-limiting transfer function (lookup table).
            The raw F-S error computation can potentially compute error values of up to
            +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
            much less, otherwise obviously wrong pixels will be created.  (Typical
            effects include weird fringes at color-area boundaries, isolated bright
            pixels in a dark area, etc.)  The standard advice for avoiding this problem
            is to ensure that the "corners" of the color cube are allocated as output
            colors; then repeated errors in the same direction cannot cause cascading
            error buildup.  However, that only prevents the error from getting
            completely out of hand; Aaron Giles reports that error limiting improves
            the results even with corner colors allocated.
            A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
            well, but the smoother transfer function used below is even better.  Thanks
            to Aaron Giles for this idea.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_nearby_colors(System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>
            Locate the colormap entries close enough to an update box to be candidates
            for the nearest entry to some cell(s) in the update box.  The update box
            is specified by the center coordinates of its first cell.  The number of
            candidate colormap entries is returned, and their colormap indexes are
            placed in colorlist[].
            This routine uses Heckbert's "locally sorted search" criterion to select
            the colors that need further consideration.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_best_colors(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Find the closest colormap entry for each cell in the update box,
            given the list of candidate colors prepared by find_nearby_colors.
            Return the indexes of the closest entries in the bestcolor[] array.
            This routine uses Thomas' incremental distance calculation method to
            find the distance from a colormap entry to successive cells in the box.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.fill_inverse_cmap(System.Int32,System.Int32,System.Int32)">
            <summary>
            Fill the inverse-colormap entries in the update box that contains
            histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but
            we can fill as many others as we wish.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressDataImpl(System.Byte[][][])">
            <summary>
            Process some data in the single-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the image.
            Returns true if the iMCU row is completed, false if suspended.
            
            NB: input_buf contains a plane for each component in image,
            which we index according to the component's SOF position.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressFirstPass(System.Byte[][][])">
            <summary>
            Process some data in the first pass of a multi-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the image.
            This amount of data is read from the source buffer, DCT'd and quantized,
            and saved into the virtual arrays.  We also generate suitable dummy blocks
            as needed at the right and lower edges.  (The dummy blocks are constructed
            in the virtual arrays, which have been padded appropriately.)  This makes
            it possible for subsequent passes not to worry about real vs. dummy blocks.
            
            We must also emit the data to the entropy encoder.  This is conveniently
            done by calling compress_output() after we've loaded the current strip
            of the virtual arrays.
            
            NB: input_buf contains a plane for each component in image.  All
            components are DCT'd and loaded into the virtual arrays in this pass.
            However, it may be that only a subset of the components are emitted to
            the entropy encoder during this first pass; be careful about looking
            at the scan-dependent variables (MCU dimensions, etc).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressOutput">
            <summary>
            Process some data in subsequent passes of a multi-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the scan.
            The data is obtained from the virtual arrays and fed to the entropy coder.
            Returns true if the iMCU row is completed, false if suspended.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr">
            <summary>
            Expanded data destination object for output to Stream
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.init_destination">
            <summary>
            Initialize destination --- called by jpeg_start_compress
            before any data is actually written.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.empty_output_buffer">
            <summary>
            Empty the output buffer --- called whenever buffer fills up.
            
            In typical applications, this should write the entire output buffer
            (ignoring the current state of next_output_byte and free_in_buffer),
            reset the pointer and count to the start of the buffer, and return true
            indicating that the buffer has been dumped.
            
            In applications that need to be able to suspend compression due to output
            overrun, a false return indicates that the buffer cannot be emptied now.
            In this situation, the compressor will return to its caller (possibly with
            an indication that it has not accepted all the supplied scanlines).  The
            application should resume compression after it has made more room in the
            output buffer.  Note that there are substantial restrictions on the use of
            suspension --- see the documentation.
            
            When suspending, the compressor will back up to a convenient restart point
            (typically the start of the current MCU). next_output_byte and free_in_buffer
            indicate where the restart point will be if the current call returns false.
            Data beyond this point will be regenerated after resumption, so do not
            write it out when emptying the buffer externally.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.term_destination">
            <summary>
            Terminate destination --- called by jpeg_finish_compress
            after all data has been written.  Usually needs to flush buffer.
            
            NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.start_pass">
            <summary>
            Initialize for an upsampling pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.merged_1v_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Byte[][],System.Int32@)">
            <summary>
            Control routine to do upsampling (and color conversion).
            The control routine just handles the row buffering considerations.
            1:1 vertical sampling case: much easier, never need a spare row.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.merged_2v_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Control routine to do upsampling (and color conversion).
            The control routine just handles the row buffering considerations.
            2:1 vertical sampling case: may need a spare row.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.h2v1_merged_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.h2v2_merged_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][])">
            <summary>
            Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.build_ycc_rgb_table">
            <summary>
            Initialize tables for YCbCr-&gt;RGB colorspace conversion.
            This is taken directly from jpeg_color_deconverter; see that file for more info.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.build_bg_ycc_rgb_table">
            <summary>
            Initialize tables for BG_YCC-&gt;RGB colorspace conversion.
            This is taken directly from jpeg_color_deconverter; see that file for more info.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr">
            <summary>
            Expanded data source object for stdio input
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize source - called by jpeg_read_header
            before any data is actually read.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr.fill_input_buffer">
            <summary>
            Fill the input buffer - called whenever buffer is emptied.
            
            In typical applications, this should read fresh data into the buffer
            (ignoring the current state of next_input_byte and bytes_in_buffer),
            reset the pointer and count to the start of the buffer, and return true
            indicating that the buffer has been reloaded.  It is not necessary to
            fill the buffer entirely, only to obtain at least one more byte.
            
            There is no such thing as an EOF return.  If the end of the file has been
            reached, the routine has a choice of ERREXIT() or inserting fake data into
            the buffer.  In most cases, generating a warning message and inserting a
            fake EOI marker is the best course of action --- this will allow the
            decompressor to output however much of the image is there.  However,
            the resulting error message is misleading if the real problem is an empty
            input file, so we handle that case specially.
            
            In applications that need to be able to suspend compression due to input
            not being available yet, a false return indicates that no more data can be
            obtained right now, but more may be forthcoming later.  In this situation,
            the decompressor will return to its caller (with an indication of the
            number of scanlines it has read, if any).  The application should resume
            decompression after it has loaded more data into the input buffer.  Note
            that there are substantial restrictions on the use of suspension --- see
            the documentation.
            
            When suspending, the decompressor will back up to a convenient restart point
            (typically the start of the current MCU). next_input_byte and bytes_in_buffer
            indicate where the restart point will be if the current call returns false.
            Data beyond this point must be rescanned after resumption, so move it to
            the front of the buffer rather than discarding it.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller">
            <summary>
            This is a special implementation of the coefficient
            buffer controller.  This is similar to jccoefct.c, but it handles only
            output from presupplied virtual arrays.  Furthermore, we generate any
            dummy padding blocks on-the-fly rather than expecting them to be present
            in the arrays.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_compress_struct,BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Initialize coefficient buffer controller.
            
            Each passed coefficient array must be the right size for that
            coefficient: width_in_blocks wide and height_in_blocks high,
            with unit height at least v_samp_factor.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.compress_data(System.Byte[][][])">
            <summary>
            Process some data.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the scan.
            The data is obtained from the virtual arrays and fed to the entropy coder.
            Returns true if the iMCU row is completed, false if suspended.
            
            NB: input_buf is ignored; it is likely to be a null pointer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.start_iMCU_row">
            <summary>
            Reset within-iMCU-row counters for a new row
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.start_pass">
            <summary>
            Initialize for an upsampling pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Control routine to do upsampling (and color conversion).
            
            In this version we upsample each component independently.
            We upsample one row group into the conversion buffer, then apply
            color conversion a row at a time.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.noop_upsample">
            <summary>
            This is a no-op version used for "uninteresting" components.
            These components will not be referenced by color conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.fullsize_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            For full-size components, we just make color_buf[ci] point at the
            input buffer, and thus avoid copying any data.  Note that this is
            safe only because sep_upsample doesn't declare the input row group
            "consumed" until we are done color converting and emitting it.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v1_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
            It's still a box filter.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v2_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
            It's still a box filter.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.int_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            This version handles any integral sampling ratios.
            This is not used for typical JPEG files, so it need not be fast.
            Nor, for that matter, is it particularly accurate: the algorithm is
            simple replication of the input pixel onto the corresponding output
            pixels.  The hi-falutin sampling literature refers to this as a
            "box filter".  A box filter tends to introduce visible artifacts,
            so if you are actually going to use 3:1 or 4:1 sampling ratios
            you would be well advised to improve this code.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JBLOCK">
            <summary>
            One block of coefficients.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JBLOCK.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The index of required element.</param>
            <value>The required element.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JHUFF_TBL">
            <summary>
            Huffman coding table.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JHUFF_TBL.Sent_table">
            <summary>
            Gets or sets a value indicating whether the table has been output to file.
            </summary>
            <value>It's initialized <c>false</c> when the table is created, and set 
            <c>true</c> when it's been output to the file. You could suppress output 
            of a table by setting this to <c>true</c>.
            </value>
            <remarks>This property is used only during compression. It's initialized
            <c>false</c> when the table is created, and set <c>true</c> when it's been
            output to the file. You could suppress output of a table by setting this to
            <c>true</c>. (See jpeg_suppress_tables for an example.)</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)" />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JpegConstants">
            <summary>
            Defines some JPEG constants.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.DCTSIZE">
            <summary>
            The basic DCT block is 8x8 coefficients
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.DCTSIZE2">
            <summary>
            DCTSIZE squared; the number of elements in a block. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_QUANT_TBLS">
            <summary>
            Quantization tables are numbered 0..3 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_HUFF_TBLS">
            <summary>
            Huffman tables are numbered 0..3
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_ARITH_TBLS">
            <summary>
            Arith-coding tables are numbered 0..15
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_COMPS_IN_SCAN">
            <summary>
            JPEG limit on the number of components in one scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.C_MAX_BLOCKS_IN_MCU">
            <summary>
            Compressor's limit on blocks per MCU.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.D_MAX_BLOCKS_IN_MCU">
            <summary>
            Decompressor's limit on blocks per MCU.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_SAMP_FACTOR">
            <summary>
            JPEG limit on sampling factors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_COMPONENTS">
            <summary>
            Maximum number of color channels allowed in JPEG image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.BITS_IN_JSAMPLE">
            <summary>
            The size of sample.
            </summary>
            <remarks>Are either:
            8 - for 8-bit sample values (the usual setting)<br />
            9 - for 9-bit sample values
            10 - for 10-bit sample values
            11 - for 11-bit sample values
            12 - for 12-bit sample values (not supported by this version)<br />
            Only 8, 9, 10, 11, and 12 bits sample data precision are supported for
            full-feature DCT processing.Further depths up to 16-bit may be added
            later for the lossless modes of operation.
            Run-time selection and conversion of data precision will be added later
            and are currently not supported, sorry.
            Exception:  The transcoding part(jpegtran) supports all settings in a
            single instance, since it operates on the level of DCT coefficients and
            not sample values.The DCT coefficients are of the same type(16 bits)
            in all cases(see below).
            </remarks>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JDCT_DEFAULT">
            <summary>
            DCT method used by default.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JDCT_FASTEST">
            <summary>
            Fastest DCT method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JPEG_MAX_DIMENSION">
            <summary>
            A tad under 64K to prevent overflows. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAXJSAMPLE">
            <summary>
            The maximum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.CENTERJSAMPLE">
            <summary>
            The medium sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_RED">
            <summary>
            Offset of Red in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_GREEN">
            <summary>
            Offset of Green in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_BLUE">
            <summary>
            Offset of Blue in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_PIXELSIZE">
            <summary>
            Bytes per RGB scanline element.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.HUFF_LOOKAHEAD">
            <summary>
            The number of bits of lookahead.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_common_struct">
            <summary>Base class for both JPEG compressor and decompresor.</summary>
            <remarks>
            Routines that are to be used by both halves of the library are declared
            to receive an instance of this class. There are no actual instances of 
            <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_common_struct" />, only of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" /> 
            and <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" /></remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.#ctor">
            <summary>
            Base constructor.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Base constructor.
            </summary>
            <param name="errorManager">The error manager.</param>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.IsDecompressor">
            <summary>
            Gets a value indicating whether this instance is Jpeg decompressor.
            </summary>
            <value>
                <c>true</c> if this is Jpeg decompressor; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Progress">
            <summary>
            Progress monitor.
            </summary>
            <value>The progress manager.</value>
            <remarks>Default value: <c>null</c>.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Err">
            <summary>
            Error handler module.
            </summary>
            <value>The error manager.</value>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Version">
            <summary>
            Gets the version of LibJpeg.
            </summary>
            <value>The version of LibJpeg.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Copyright">
            <summary>
            Gets the LibJpeg's copyright.
            </summary>
            <value>The copyright.</value>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateSamplesArray(System.Int32,System.Int32)">
            <summary>
            Creates the array of samples.
            </summary>
            <param name="samplesPerRow">The number of samples in row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateBlocksArray(System.Int32,System.Int32)">
            <summary>
            Creates the array of blocks.
            </summary>
            <param name="blocksPerRow">The number of blocks in row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of blocks.</returns>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.JBLOCK" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.AllocJpegSamples(System.Int32,System.Int32)">
            <summary>
            Creates 2-D sample array.
            </summary>
            <param name="samplesPerRow">The number of samples per row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort">
            <summary>
            Abort processing of a JPEG compression or decompression operation,
            but don't destroy the object itself.
            
            Closing a data source or destination, if necessary, is the 
            application's responsibility.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_destroy">
            <summary>
            Destruction of a JPEG object. 
            
            Closing a data source or destination, if necessary, is the 
            application's responsibility.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(System.Int32,System.Object[])">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(System.Int32,System.Object[])">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" /> for description.</param>
            <param name="code">The message code.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" /> for description.</param>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,System.Int32,System.Object[])">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" /> for description.</param>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_component_info">
            <summary>
            Basic info about one component (color channel).
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Component_id">
            <summary>
            Identifier for this component (0..255)
            </summary>
            <value>The component ID.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Component_index">
            <summary>
            Its index in SOF or <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Comp_info" />.
            </summary>
            <value>The component index.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.H_samp_factor">
            <summary>
            Horizontal sampling factor (1..4)
            </summary>
            <value>The horizontal sampling factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.V_samp_factor">
            <summary>
            Vertical sampling factor (1..4)
            </summary>
            <value>The vertical sampling factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Quant_tbl_no">
            <summary>
            Quantization table selector (0..3)
            </summary>
            <value>The quantization table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Dc_tbl_no">
            <summary>
            DC entropy table selector (0..3)
            </summary>
            <value>The DC entropy table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Ac_tbl_no">
            <summary>
            AC entropy table selector (0..3)
            </summary>
            <value>The AC entropy table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Width_in_blocks">
            <summary>
            Gets or sets the width in blocks.
            </summary>
            <value>The width in blocks.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Downsampled_width">
            <summary>
            Gets the downsampled width.
            </summary>
            <value>The downsampled width.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct">
            <summary>
            JPEG compression routine.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.scale_num">
            <summary>
            The scale numerator
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.scale_denom">
            <summary>
            The scale denomenator
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.q_scale_factor">
            <summary>
            corresponding scale factors (percentage, initialized 100).
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.do_fancy_downsampling">
            <summary>
            TRUE=apply fancy downsampling
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.color_transform">
            <summary>
            Color transform identifier, writes LSE marker if nonzero
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.block_size">
            <summary>
            the basic DCT block size: 1..16
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" /> class.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" /> class.
            </summary>
            <param name="errorManager">The error manager.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.IsDecompressor">
            <summary>
            Retrieves <c>false</c> because this is not decompressor.
            </summary>
            <value>
                <c>false</c>
            </value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dest">
            <summary>
            Gets or sets the destination for compressed data
            </summary>
            <value>The destination for compressed data.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Image_width">
            <summary>
            Gets or sets the width of image, in pixels.
            </summary>
            <value>The width of image.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Image_height">
            <summary>
            Gets or sets the height of image, in pixels.
            </summary>
            <value>The height of image.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Input_components">
            <summary>
            Gets or sets the number of color channels (components per pixel)
            </summary>
            <value>The number of color channels.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space">
            <summary>
            Gets or sets the color space of source image.
            </summary>
            <value>The color space.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
            <seealso href="../articles/KB/special-color-spaces.html">Special color spaces</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Data_precision">
            <summary>
            Gets or sets the number of bits of precision in image data.
            </summary>
            <remarks>Default value: 8<br />
            The number of bits.
            </remarks>
            <value>The data precision.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Num_components">
            <summary>
            Gets or sets the number of color components for JPEG color space.
            </summary>
            <value>The number of color components for JPEG color space.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Jpeg_color_space">
            <summary>
            Gets or sets the JPEG color space.
            </summary>
            <remarks>We recommend to use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)" /> if you want to change this.</remarks>
            <value>The JPEG color space.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Raw_data_in">
            <summary>
            Gets or sets a value indicating whether you will be supplying raw data.
            </summary>
            <remarks>Default value: <c>false</c></remarks>
            <value>
                <c>true</c> if you will be supplying raw data; otherwise, <c>false</c>.</value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Optimize_coding">
            <summary>
            Gets or sets a value indicating a way of using Huffman coding tables.
            </summary>
            <remarks>When this is <c>true</c>, you need not supply Huffman tables at all, and any you do supply will be overwritten.</remarks>
            <value>
                <c>true</c> causes the compressor to compute optimal Huffman coding tables 
            for the image. This requires an extra pass over the data and therefore costs a good 
            deal of space and time. The default is <c>false</c>, which tells the compressor to use the 
            supplied or default Huffman tables. In most cases optimal tables save only a few 
            percent of file size compared to the default tables.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.CCIR601_sampling">
            <summary>
            Gets or sets a value indicating whether first samples are cosited.
            </summary>
            <value>
                <c>true</c> if first samples are cosited; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Smoothing_factor">
            <summary>
            Gets or sets the coefficient of image smoothing.
            </summary>
            <remarks>Default value: 0<br />
            If non-zero, the input image is smoothed; the value should be 1 for minimal smoothing 
            to 100 for maximum smoothing.</remarks>
            <value>The coefficient of image smoothing.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dct_method">
            <summary>
            Gets or sets the algorithm used for the DCT step.
            </summary>
            <value>The DCT algorithm.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval">
            <summary>
            Gets or sets the exact interval in MCU blocks.
            </summary>
            <remarks>Default value: 0<br />
            One restart marker per MCU row is often a good choice. The overhead of restart markers 
            is higher in grayscale JPEG files than in color files, and MUCH higher in progressive JPEGs. 
            If you use restarts, you may want to use larger intervals in those cases.</remarks>
            <value>The restart interval.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_in_rows" />
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_in_rows">
            <summary>
            Gets or sets the interval in MCU rows.
            </summary>
            <remarks>Default value: 0<br />
            If Restart_in_rows is not 0, then <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval" /> is set 
            after the image width in MCUs is computed.<br />
            One restart marker per MCU row is often a good choice. 
            The overhead of restart markers is higher in grayscale JPEG files than in color files, and MUCH higher in progressive JPEGs. If you use restarts, you may want to use larger intervals in those cases.
            </remarks>
            <value>The restart interval in MCU rows.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval" />
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header">
            <summary>
            Gets or sets a value indicating whether the JFIF APP0 marker is emitted.
            </summary>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults" /> and 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)" /> set this <c>true</c> 
            if a JFIF-legal JPEG color space (i.e., YCbCr or grayscale) is selected, otherwise <c>false</c>.</remarks>
            <value>
                <c>true</c> if JFIF APP0 marker is emitted; otherwise, <c>false</c>.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version" />
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version">
            <summary>
            Gets or sets the version number to be written into the JFIF marker.
            </summary>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults" /> initializes the version to 
            1.01 (major=minor=1). You should set it to 1.02 (major=1, minor=2) if you plan to write any 
            JFIF 1.02 extension markers.</remarks>
            <value>The version number to be written into the JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_minor_version" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_minor_version">
            <summary>
            Gets or sets the version number to be written into the JFIF marker.
            </summary>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults" /> initializes the version to 
            1.01 (major=minor=1). You should set it to 1.02 (major=1, minor=2) if you plan to write any 
            JFIF 1.02 extension markers.</remarks>
            <value>The version number to be written into the JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit">
            <summary>
            Gets or sets the resolution information to be written into the JFIF marker; not used otherwise.
            </summary>
            <remarks>Default value: <see cref="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown" /><br />
            The pixel aspect ratio is defined by 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density" />/<see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density" /> 
            even when Density_unit is <see cref="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown">Unknown</see>.</remarks>
            <value>The density unit.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density" />
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density">
            <summary>
            Gets or sets the horizontal component of pixel ratio.
            </summary>
            <remarks>Default value: 1</remarks>
            <value>The horizontal density.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density">
            <summary>
            Gets or sets the vertical component of pixel ratio.
            </summary>
            <remarks>Default value: 1</remarks>
            <value>The vertical density.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_Adobe_marker">
            <summary>
            Gets or sets a value indicating whether to emit Adobe APP14 marker.
            </summary>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults" /> and <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)" /> 
            set this <c>true</c> if JPEG color space RGB, CMYK, or YCCK is selected, otherwise <c>false</c>. 
            It is generally a bad idea to set both <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header" /> and 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_Adobe_marker" />. 
            In fact, you probably shouldn't change the default settings at all - the default behavior ensures that the JPEG file's 
            color space can be recognized by the decoder.</remarks>
            <value>If <c>true</c> an Adobe APP14 marker is emitted; <c>false</c>, otherwise.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Max_v_samp_factor">
            <summary>
            Gets the largest vertical sample factor.
            </summary>
            <value>The largest vertical sample factor.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Component_info">
            <summary>
            Gets the components that appears in SOF.
            </summary>
            <value>The component info array.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Quant_tbl_ptrs">
            <summary>
            Gets the coefficient quantization tables.
            </summary>
            <value>The coefficient quantization tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dc_huff_tbl_ptrs">
            <summary>
            Gets the Huffman coding tables.
            </summary>
            <value>The Huffman coding tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Ac_huff_tbl_ptrs">
            <summary>
            Gets the Huffman coding tables.
            </summary>
            <value>The Huffman coding tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Next_scanline">
            <summary>
            Gets the index of next scanline to be written to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)" />.
            </summary>
            <remarks>Application may use this to control its processing loop, 
            e.g., "while (Next_scanline &lt; Image_height)"</remarks>
            <value>Range: from 0 to (Image_height - 1)</value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_abort_compress">
            <summary>
            Abort processing of a JPEG compression operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)">
            <summary>
            Forcibly suppress or un-suppress all quantization and Huffman tables.
            </summary>
            <remarks>Marks all currently defined tables as already written (if suppress)
            or not written (if !suppress). This will control whether they get 
            emitted by a subsequent <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)" /> call.<br />
            
            This routine is exported for use by applications that want to produce
            abbreviated JPEG datastreams.</remarks>
            <param name="suppress">if set to <c>true</c> then suppress tables; 
            otherwise unsuppress.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress">
            <summary>
            Finishes JPEG compression.
            </summary>
            <remarks>If a multipass operating mode was selected, this may do a great 
            deal of work including most of the actual output.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_marker(System.Int32,System.Byte[])">
            <summary>
            Write a special marker.
            </summary>
            <remarks>This is only recommended for writing COM or APPn markers. 
            Must be called after <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)" /> and before first call to 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)" /> or <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)" />.
            </remarks>
            <param name="marker">Specify the marker type parameter as <see cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER" />.COM for COM or 
            <see cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER" />.APP0 + n for APPn. (Actually, jpeg_write_marker will let you write any marker type, 
            but we don't recommend writing any other kinds of marker)</param>
            <param name="data">The data associated with the marker.</param>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_header(System.Int32,System.Int32)">
            <summary>
            Writes special marker's header.
            </summary>
            <param name="marker">Special marker.</param>
            <param name="datalen">Length of data associated with the marker.</param>
            <remarks>After calling this method you need to call <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)" />
            exactly the number of times given in the length parameter.<br />
            This method lets you empty the output buffer partway through a marker, which might be important when 
            using a suspending data destination module. In any case, if you are using a suspending destination, 
            you should flush its buffer after inserting any special markers.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)" />
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_marker(System.Int32,System.Byte[])" />
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)">
            <summary>
            Writes a byte of special marker's data.
            </summary>
            <param name="val">The byte of data.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_header(System.Int32,System.Int32)" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables">
            <summary>
            Alternate compression function: just write an abbreviated table file.
            </summary>
            <remarks>Before calling this, all parameters and a data destination must be set up.<br />
            
            To produce a pair of files containing abbreviated tables and abbreviated
            image data, one would proceed as follows:<br /><c>Initialize JPEG object<br />
            Set JPEG parameters<br />
            Set destination to table file<br /><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables">jpeg_write_tables();</see><br />
            Set destination to image file<br /><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">jpeg_start_compress(false);</see><br />
            Write data...<br /><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress">jpeg_finish_compress();</see><br /></c><br />
            
            jpeg_write_tables has the side effect of marking all tables written
            (same as <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)">jpeg_suppress_tables(true)</see>).
            Thus a subsequent <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">jpeg_start_compress</see> 
            will not re-emit the tables unless it is passed <c>write_all_tables=true</c>.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_stdio_dest(System.IO.Stream)">
            <summary>
            Sets output stream.
            </summary>
            <param name="outfile">The output stream.</param>
            <remarks>The caller must have already opened the stream, and is responsible
            for closing it after finishing compression.</remarks>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults">
            <summary>
            Jpeg_set_defaultses this instance.
            </summary>
            <remarks>Uses only the input image's color space (property <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space" />, 
            which must already be set in <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />). Many applications will only need 
            to use this routine and perhaps <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)" />.
            </remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)">
            <summary>
            Set the JPEG colorspace (property <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Jpeg_color_space" />,
            and choose colorspace-dependent parameters appropriately.
            </summary>
            <param name="colorspace">The required colorspace.</param>
            <remarks>See <see href="../articles/KB/special-color-spaces.html">Special color spaces</see>, 
            below, before using this. A large number of parameters, including all per-component parameters, 
            are set by this routine; if you want to twiddle individual parameters you should call 
            <c>jpeg_set_colorspace</c> before rather than after.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
            <seealso href="../articles/KB/special-color-spaces.html">Special color spaces</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_default_colorspace">
            <summary>
            Select an appropriate JPEG colorspace based on <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space" />,
            and calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)" /></summary>
            <remarks>This is actually a subroutine of <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults" />. 
            It's broken out in case you want to change just the colorspace-dependent JPEG parameters.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)">
            <summary>
            Constructs JPEG quantization tables appropriate for the indicated quality setting.
            </summary>
            <param name="quality">The quality value is expressed on the 0..100 scale recommended by IJG.</param>
            <param name="force_baseline">If <c>true</c>, then the quantization table entries are constrained 
            to the range 1..255 for full JPEG baseline compatibility. In the current implementation, 
            this only makes a difference for quality settings below 25, and it effectively prevents 
            very small/low quality files from being generated. The IJG decoder is capable of reading 
            the non-baseline files generated at low quality settings when <c>force_baseline</c> is <c>false</c>,
            but other decoders may not be.</param>
            <remarks>Note that the exact mapping from quality values to tables may change in future IJG releases 
            as more is learned about DCT quantization.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_default_qtables(System.Boolean)">
            <summary>
            Set or change the 'quality' (quantization) setting, using default tables
            and straight percentage-scaling quality scales.
            This entry point allows different scalings for luminance and chrominance.
            </summary>
            <param name="force_baseline">if set to <c>true</c> then baseline version is forced.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_linear_quality(System.Int32,System.Boolean)">
            <summary>
            Same as <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)" /> except that the generated tables are the 
            sample tables given in the JPEG specification section K.1, multiplied by 
            the specified scale factor.
            </summary>
            <param name="scale_factor">The scale_factor.</param>
            <param name="force_baseline">If <c>true</c>, then the quantization table entries are 
            constrained to the range 1..255 for full JPEG baseline compatibility. In the current 
            implementation, this only makes a difference for quality settings below 25, and it 
            effectively prevents very small/low quality files from being generated. The IJG decoder 
            is capable of reading the non-baseline files generated at low quality settings when 
            <c>force_baseline</c> is <c>false</c>, but other decoders may not be.</param>
            <remarks>Note that larger scale factors give lower quality. This entry point is 
            useful for conforming to the Adobe PostScript DCT conventions, but we do not 
            recommend linear scaling as a user-visible quality scale otherwise.
            </remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_add_quant_table(System.Int32,System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Allows an arbitrary quantization table to be created.
            </summary>
            <param name="which_tbl">Indicates which table slot to fill.</param>
            <param name="basic_table">An array of 64 unsigned integers given in normal array order.
            These values are multiplied by <c>scale_factor/100</c> and then clamped to the range 1..65535 
            (or to 1..255 if <c>force_baseline</c> is <c>true</c>).<br />
            The basic table should be given in JPEG zigzag order.
            </param>
            <param name="scale_factor">Multiplier for values in <c>basic_table</c>.</param>
            <param name="force_baseline">Defines range of values in <c>basic_table</c>. 
            If <c>true</c> - 1..255, otherwise - 1..65535.</param>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_quality_scaling(System.Int32)">
            <summary>
            Converts a value on the IJG-recommended quality scale to a linear scaling percentage.
            </summary>
            <param name="quality">The IJG-recommended quality scale. Should be 0 (terrible) to 100 (very good).</param>
            <returns>The linear scaling percentage.</returns>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_simple_progression">
            <summary>
            Generates a default scan script for writing a progressive-JPEG file.
            </summary>
            <remarks>This is the recommended method of creating a progressive file, unless you want 
            to make a custom scan sequence. You must ensure that the JPEG color space is 
            set correctly before calling this routine.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">
            <summary>
            Starts JPEG compression.
            </summary>
            <param name="write_all_tables">Write or not write all quantization and Huffman tables.</param>
            <remarks>Before calling this, all parameters and a data destination must be set up.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)" />
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables" />
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)">
            <summary>
            Write some scanlines of data to the JPEG compressor.
            </summary>
            <param name="scanlines">The array of scanlines.</param>
            <param name="num_lines">The number of scanlines for writing.</param>
            <returns>The return value will be the number of lines actually written.<br />
            This should be less than the supplied <c>num_lines</c> only in case that 
            the data destination module has requested suspension of the compressor, 
            or if more than image_height scanlines are passed in.
            </returns>
            <remarks>We warn about excess calls to <c>jpeg_write_scanlines()</c> since this likely 
            signals an application programmer error. However, excess scanlines passed in the last 
            valid call are "silently" ignored, so that the application need not adjust <c>num_lines</c>
            for end-of-image when using a multiple-scanline buffer.</remarks>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)">
            <summary>
            Alternate entry point to write raw data.
            </summary>
            <param name="data">The raw data.</param>
            <param name="num_lines">The number of scanlines for writing.</param>
            <returns>The number of lines actually written.</returns>
            <remarks>Processes exactly one iMCU row per call, unless suspended.
            Replaces <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)" /> when writing raw downsampled data.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_coefficients(BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Compression initialization for writing raw-coefficient data. Useful for lossless transcoding.
            </summary>
            <param name="coef_arrays">The virtual arrays need not be filled or even realized at the time 
            <c>jpeg_write_coefficients</c> is called; indeed, the virtual arrays typically will be realized 
            during this routine and filled afterwards.
            </param>
            <remarks>Before calling this, all parameters and a data destination must be set up.
            Call <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress" /> to actually write the data.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.initialize">
            <summary>
            Initialization of a JPEG compression object
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_compress_master">
            <summary>
            Master selection of compression modules.
            This is done once at the start of processing an image.  We determine
            which modules will be used and give them appropriate initialization calls.
            This routine is in charge of selecting the modules to be executed and
            making an initialization call to each one.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_c_master_control(System.Boolean)">
            <summary>
            Initialize master compression control.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_c_main_controller(System.Boolean)">
            <summary>
            Initialize main buffer controller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.transencode_master_selection(BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Master selection of compression modules for transcoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.initial_setup(System.Boolean)">
            <summary>
            Do computations that are needed before master selection phase
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.validate_script">
            <summary>
            Verify that the scan script in scan_info[] is valid; 
            also determine whether it uses progressive JPEG, and set progressive_mode.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.std_huff_tables">
            <summary>
            Set up the standard Huffman tables (cf. JPEG standard section K.3)
            
            IMPORTANT: these are only valid for 8-bit data precision!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.add_huff_table(BitMiracle.LibJpeg.Classic.JHUFF_TBL@,System.Byte[],System.Byte[])">
            <summary>
            Define a Huffman table
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_a_scan(System.Int32@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate one scan for specified component
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_dc_scans(System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate interleaved DC scan if possible, else N scans
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_scans(System.Int32@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate one scan for each component
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct">
            <summary>
            JPEG decompression routine.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method">
            <summary>
            The delegate for application-supplied marker processing methods.
            </summary>
            <param name="cinfo">Decompressor.</param>
            <returns>Return <c>true</c> to indicate success. <c>false</c> should be returned only 
            if you are using a suspending data source and it tells you to suspend.
            </returns>
            <remarks>Although the marker code is not explicitly passed, the routine can find it 
            in the <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Unread_marker" />. At the time of call, 
            the marker proper has been read from the data source module. The processor routine 
            is responsible for reading the marker length word and the remaining parameter bytes, if any.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" /> class.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" /> class.
            </summary>
            <param name="errorManager">The error manager.</param>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.IsDecompressor">
            <summary>
            Retrieves <c>true</c> because this is a decompressor.
            </summary>
            <value>
                <c>true</c>
            </value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Src">
            <summary>
            Gets or sets the source for decompression.
            </summary>
            <value>The source for decompression.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Image_width">
            <summary>
            Gets the width of image, set by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)" /></summary>
            <value>The width of image.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Image_height">
            <summary>
            Gets the height of image, set by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)" /></summary>
            <value>The height of image.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Num_components">
            <summary>
            Gets the number of color components in JPEG image.
            </summary>
            <value>The number of color components.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Jpeg_color_space">
            <summary>
            Gets or sets the colorspace of JPEG image.
            </summary>
            <value>The colorspace of JPEG image.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">
            <summary>
            Gets the list of loaded special markers.
            </summary>
            <remarks>All the special markers in the file appear in this list, in order of 
            their occurrence in the file (but omitting any markers of types you didn't ask for)
            </remarks>
            <value>The list of loaded special markers.</value>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space">
            <summary>
            Gets or sets the output color space.
            </summary>
            <value>The output color space.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num">
            <summary>
            Gets or sets the numerator of the fraction of image scaling.
            </summary>
            <value>Scale the image by the fraction Scale_num/<see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom">Scale_denom</see>. 
            Default is 1/1, or no scaling. Currently, the only supported scaling ratios are 1/1, 1/2, 1/4, and 1/8.
            (The library design allows for arbitrary scaling ratios but this is not likely to be implemented any time soon.)
            </value>
            <remarks>Smaller scaling ratios permit significantly faster decoding since fewer pixels 
            need to be processed and a simpler <see cref="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">DCT method</see> can be used.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom" />
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom">
            <summary>
            Gets or sets the denominator of the fraction of image scaling.
            </summary>
            <value>Scale the image by the fraction <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num">Scale_num</see>/Scale_denom. 
            Default is 1/1, or no scaling. Currently, the only supported scaling ratios are 1/1, 1/2, 1/4, and 1/8.
            (The library design allows for arbitrary scaling ratios but this is not likely to be implemented any time soon.)
            </value>
            <remarks>Smaller scaling ratios permit significantly faster decoding since fewer pixels 
            need to be processed and a simpler <see cref="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">DCT method</see> can be used.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num" />
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Buffered_image">
            <summary>
            Gets or sets a value indicating whether to use buffered-image mode.
            </summary>
            <value>
                <c>true</c> if buffered-image mode is turned on; otherwise, <c>false</c>.</value>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Raw_data_out">
            <summary>
            Enable or disable raw data output.
            </summary>
            <value>
                <c>true</c> if raw data output is enabled; otherwise, <c>false</c>.</value>
            <remarks>Default value: <c>false</c><br />
            Set this to true before <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" /> 
            if you need to obtain raw data output.
            </remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_raw_data(System.Byte[][][],System.Int32)" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dct_method">
            <summary>
            Gets or sets the algorithm used for the DCT step.
            </summary>
            <value>The algorithm used for the DCT step.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Do_fancy_upsampling">
            <summary>
            Enable or disable upsampling of chroma components.
            </summary>
            <value>If <c>true</c>, do careful upsampling of chroma components. 
            If <c>false</c>, a faster but sloppier method is used. 
            The visual impact of the sloppier method is often very small.
            </value>
            <remarks>Default value: <c>true</c></remarks>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Do_block_smoothing">
            <summary>
            Apply interblock smoothing in early stages of decoding progressive JPEG files.
            </summary>
            <value>If <c>true</c>, interblock smoothing is applied in early stages of decoding progressive JPEG files; 
            if <c>false</c>, not. Early progression stages look "fuzzy" with smoothing, "blocky" without.</value>
            <remarks>Default value: <c>true</c><br />
            In any case, block smoothing ceases to be applied after the first few AC coefficients are 
            known to full accuracy, so it is relevant only when using 
            <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see> for progressive images.
            </remarks>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors">
            <summary>
            Colors quantization.
            </summary>
            <value>If set <c>true</c>, colormapped output will be delivered.<br />
            Default value: <c>false</c>, meaning that full-color output will be delivered.
            </value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dither_mode">
            <summary>
            Selects color dithering method.
            </summary>
            <value>Default value: <see cref="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_FS" />.</value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" /> is <c>false</c>.<br />
            At present, ordered dither is implemented only in the single-pass, standard-colormap case. 
            If you ask for ordered dither when <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Two_pass_quantize" /> is <c>true</c>
            or when you supply an external color map, you'll get F-S dithering.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" />
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Two_pass_quantize">
            <summary>
            Gets or sets a value indicating whether to use two-pass color quantization.
            </summary>
            <value>If <c>true</c>, an extra pass over the image is made to select a custom color map for the image.
            This usually looks a lot better than the one-size-fits-all colormap that is used otherwise.
            Ignored when the application supplies its own color map.<br />
            
            Default value: <c>true</c></value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" /> is <c>false</c>.<br /></remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" />
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Desired_number_of_colors">
            <summary>
            Maximum number of colors to use in generating a library-supplied color map.
            </summary>
            <value>Default value: 256.</value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" /> is <c>false</c>.<br />
            The actual number of colors is returned in a <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors" />.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" />
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_1pass_quant">
            <summary>
            Enable future use of 1-pass quantizer.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_external_quant">
            <summary>
            Enable future use of external colormap.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_2pass_quant">
            <summary>
            Enable future use of 2-pass quantizer.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_width">
            <summary>
            Gets the actual width of output image.
            </summary>
            <value>The width of output image.</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions" /> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_height" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_height">
            <summary>
            Gets the actual height of output image.
            </summary>
            <value>The height of output image.</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions" /> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_width" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components">
            <summary>
            Gets the number of color components in <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space" />.
            </summary>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions" /> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.</remarks>
            <value>The number of color components.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space" />
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_components">
            <summary>
            Gets the number of color components returned.
            </summary>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions" /> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.</remarks>
            <value>When <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors">quantizing colors</see>, 
            <c>Output_components</c> is 1, indicating a single color map index per pixel. 
            Otherwise it equals to <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components" />.
            </value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space" />
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Rec_outbuf_height">
            <summary>
            Gets the recommended height of scanline buffer.
            </summary>
            <value>In high-quality modes, <c>Rec_outbuf_height</c> is always 1, but some faster, 
            lower-quality modes set it to larger values (typically 2 to 4).</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions" /> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.<br /><c>Rec_outbuf_height</c> is the recommended minimum height (in scanlines) 
            of the buffer passed to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)" />.
            If the buffer is smaller, the library will still work, but time will be wasted due 
            to unnecessary data copying. If you are going to ask for a high-speed processing mode, 
            you may as well go to the trouble of honoring <c>Rec_outbuf_height</c> so as to avoid data copying.
            (An output buffer larger than <c>Rec_outbuf_height</c> lines is OK, but won't provide 
            any material speed improvement over that height.)
            </remarks>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors">
            <summary>
            The number of colors in the color map.
            </summary>
            <value>The number of colors in the color map.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Colormap" />
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Colormap">
            <summary>
            The color map, represented as a 2-D pixel array of <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components" /> rows 
            and <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors" /> columns.
            </summary>
            <value>Colormap is set to <c>null</c> by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)" />.
            The application can supply a color map by setting <c>Colormap</c> non-null and setting 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors" /> to the map size.
            </value>
            <remarks>Ignored if not quantizing.<br />
            Implementation restriction: at present, an externally supplied <c>Colormap</c>
            is only accepted for 3-component output color spaces.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" />
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_scanline">
            <summary>
            Gets the number of scanlines returned so far.
            </summary>
            <value>The output_scanline.</value>
            <remarks>Usually you can just use this variable as the loop counter, 
            so that the loop test looks like 
            <c>while (cinfo.Output_scanline &lt; cinfo.Output_height)</c></remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Input_scan_number">
            <summary>
            Gets the number of SOS markers seen so far.
            </summary>
            <value>The number of SOS markers seen so far.</value>
            <remarks>Indicates the progress of the decompressor input side.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Input_iMCU_row">
            <summary>
            Gets the number of iMCU rows completed.
            </summary>
            <value>The number of iMCU rows completed.</value>
            <remarks>Indicates the progress of the decompressor input side.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_scan_number">
            <summary>
            Gets the nominal scan number being displayed.
            </summary>
            <value>The nominal scan number being displayed.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_iMCU_row">
            <summary>
            Gets the number of iMCU rows read.
            </summary>
            <value>The number of iMCU rows read.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Coef_bits">
            <summary>
            Gets the current progression status..
            </summary>
            <value>
                <c>Coef_bits[c][i]</c> indicates the precision with 
            which component c's DCT coefficient i (in zigzag order) is known. 
            It is <c>-1</c> when no data has yet been received, otherwise 
            it is the point transform (shift) value for the most recent scan of the coefficient 
            (thus, 0 at completion of the progression). This is null when reading a non-progressive file.
            </value>
            <seealso href="../articles/KB/progressive-jpeg.html">Progressive JPEG support</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit">
            <summary>
            Gets the resolution information from JFIF marker.
            </summary>
            <value>The information from JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density" />
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density">
            <summary>
            Gets the horizontal component of pixel ratio.
            </summary>
            <value>The horizontal component of pixel ratio.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density">
            <summary>
            Gets the vertical component of pixel ratio.
            </summary>
            <value>The vertical component of pixel ratio.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Data_precision">
            <summary>
            Gets the data precision.
            </summary>
            <value>The data precision.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Max_v_samp_factor">
            <summary>
            Gets the largest vertical sample factor.
            </summary>
            <value>The largest vertical sample factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Unread_marker">
            <summary>
            Gets the last read and unprocessed JPEG marker.
            </summary>
            <value>It is either zero or the code of a JPEG marker that has been
            read from the data source, but has not yet been processed.
            </value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)" />
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Comp_info">
            <summary>
            Comp_info[i] describes component that appears i'th in SOF
            </summary>
            <value>The components in SOF.</value>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_component_info" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_stdio_src(System.IO.Stream)">
            <summary>
            Sets input stream.
            </summary>
            <param name="infile">The input stream.</param>
            <remarks>
            The caller must have already opened the stream, and is responsible
            for closing it after finishing decompression.
            </remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">
            <summary>
            Decompression startup: this will read the source datastream header markers, up to the beginning of the compressed data proper.
            </summary>
            <param name="require_image">Read a description of <b>Return Value</b>.</param>
            <returns>
            If you pass <c>require_image=true</c> (normal case), you need not check for a
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY" /> return code; an abbreviated file will cause
            an error exit. <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED" /> is only possible if you use a data source
            module that can give a suspension return.<br /><br />
            
            This method will read as far as the first SOS marker (ie, actual start of compressed data),
            and will save all tables and parameters in the JPEG object. It will also initialize the
            decompression parameters to default values, and finally return <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK" />.
            On return, the application may adjust the decompression parameters and then call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />. (Or, if the application only wanted to
            determine the image parameters, the data need not be decompressed. In that case, call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort" /> to release any temporary space.)<br /><br />
            
            If an abbreviated (tables only) datastream is presented, the routine will return
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY" /> upon reaching EOI. The application may then re-use
            the JPEG object to read the abbreviated image datastream(s). It is unnecessary (but OK) to call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort">jpeg_abort</see> in this case.
            The <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED" /> return code only occurs if the data source module
            requests suspension of the decompressor. In this case the application should load more source
            data and then re-call <c>jpeg_read_header</c> to resume processing.<br /><br />
            
            If a non-suspending data source is used and <c>require_image</c> is <c>true</c>,
            then the return code need not be inspected since only <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK" /> is possible.
            </returns>
            <remarks>Need only initialize JPEG object and supply a data source before calling.<br />
            On return, the image dimensions and other info have been stored in the JPEG object.
            The application may wish to consult this information before selecting decompression parameters.<br />
            This routine is now just a front end to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input" />, with some extra error checking.
            </remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress">
            <summary>
            Decompression initialization.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected 
            only if a suspending data source is used.
            </returns>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">jpeg_read_header</see> must be completed before calling this.<br />
            
            If a multipass operating mode was selected, this will do all but the last pass, and thus may take a great deal of time.
            </remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress" />
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)">
            <summary>
            Read some scanlines of data from the JPEG decompressor.
            </summary>
            <param name="scanlines">Buffer for filling.</param>
            <param name="max_lines">Required number of lines.</param>
            <returns>The return value will be the number of lines actually read. 
            This may be less than the number requested in several cases, including 
            bottom of image, data source suspension, and operating modes that emit multiple scanlines at a time.
            </returns>
            <remarks>We warn about excess calls to <c>jpeg_read_scanlines</c> since this likely signals an 
            application programmer error. However, an oversize buffer <c>(max_lines &gt; scanlines remaining)</c> 
            is not an error.
            </remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress">
            <summary>
            Finish JPEG decompression.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected 
            only if a suspending data source is used.
            </returns>
            <remarks>This will normally just verify the file trailer and release temp storage.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_raw_data(System.Byte[][][],System.Int32)">
            <summary>
            Alternate entry point to read raw data.
            </summary>
            <param name="data">The raw data.</param>
            <param name="max_lines">The number of scanlines for reading.</param>
            <returns>The number of lines actually read.</returns>
            <remarks>Replaces <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)">jpeg_read_scanlines</see> 
            when reading raw downsampled data. Processes exactly one iMCU row per call, unless suspended.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_has_multiple_scans">
            <summary>
            Is there more than one scan?
            </summary>
            <returns>
                <c>true</c> if image has more than one scan; otherwise, <c>false</c></returns>
            <remarks>If you are concerned about maximum performance on baseline JPEG files,
            you should use <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see> only
            when the incoming file actually has multiple scans. This can be tested by calling this method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_output(System.Int32)">
            <summary>
            Initialize for an output pass in <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see>.
            </summary>
            <param name="scan_number">Indicates which scan of the input file is to be displayed; 
            the scans are numbered starting at 1 for this purpose.</param>
            <returns>
                <c>true</c> if done; <c>false</c> if suspended</returns>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output" />
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output">
            <summary>
            Finish up after an output pass in <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see>.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected only if a suspending data source is used.</returns>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_output(System.Int32)" />
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_input_complete">
            <summary>
            Indicates if we have finished reading the input file.
            </summary>
            <returns>
                <c>true</c> if we have finished reading the input file.</returns>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input">
            <summary>
            Consume data in advance of what the decompressor requires.
            </summary>
            <returns>The result of data consumption.</returns>
            <remarks>This routine can be called at any time after initializing the JPEG object.
            It reads some additional data and returns when one of the indicated significant events
            occurs. If called after the EOI marker is reached, it will immediately return
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_EOI" /> without attempting to read more data.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions">
            <summary>
            Pre-calculate output image dimensions and related values for current decompression parameters.
            </summary>
            <remarks>This is allowed for possible use by application. Hence it mustn't do anything 
            that can't be done twice. Also note that it may be called before the master module is initialized!
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_coefficients">
            <summary>
            Read or write the raw DCT coefficient arrays from a JPEG file (useful for lossless transcoding).
            </summary>
            <returns>Returns <c>null</c> if suspended. This case need be checked only 
            if a suspending data source is used.
            </returns>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">jpeg_read_header</see> must be completed before calling this.<br />
            
            The entire image is read into a set of virtual coefficient-block arrays, one per component.
            The return value is an array of virtual-array descriptors.<br />
            
            An alternative usage is to simply obtain access to the coefficient arrays during a 
            <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see> decompression operation. This is allowed after any 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output">jpeg_finish_output</see> call. The arrays can be accessed 
            until <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress">jpeg_finish_decompress</see> is called. 
            Note that any call to the library may reposition the arrays, 
            so don't rely on <see cref="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.Access(System.Int32,System.Int32)" /> results to stay valid across library calls.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_copy_critical_parameters(BitMiracle.LibJpeg.Classic.jpeg_compress_struct)">
            <summary>
            Initializes the compression object with default parameters, then copy from the source object 
            all parameters needed for lossless transcoding.
            </summary>
            <param name="dstinfo">Target JPEG compression object.</param>
            <remarks>Parameters that can be varied without loss (such as scan script and 
            Huffman optimization) are left in their default states.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_abort_decompress">
            <summary>
            Aborts processing of a JPEG decompression operation.
            </summary>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)">
            <summary>
            Sets processor for special marker.
            </summary>
            <param name="marker_code">The marker code.</param>
            <param name="routine">The processor.</param>
            <remarks>Allows you to supply your own routine to process 
            COM and/or APPn markers on-the-fly as they are read.
            </remarks>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_save_markers(System.Int32,System.Int32)">
            <summary>
            Control saving of COM and APPn markers into <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">Marker_list</see>.
            </summary>
            <param name="marker_code">The marker type to save (see JPEG_MARKER enumeration).<br />
            To arrange to save all the special marker types, you need to call this 
            routine 17 times, for COM and APP0-APP15 markers.</param>
            <param name="length_limit">If the incoming marker is longer than <c>length_limit</c> data bytes, 
            only <c>length_limit</c> bytes will be saved; this parameter allows you to avoid chewing up memory 
            when you only need to see the first few bytes of a potentially large marker. If you want to save 
            all the data, set <c>length_limit</c> to 0xFFFF; that is enough since marker lengths are only 16 bits. 
            As a special case, setting <c>length_limit</c> to 0 prevents that marker type from being saved at all. 
            (That is the default behavior, in fact.)
            </param>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list" />
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.use_merged_upsample">
            <summary>
            Determine whether merged upsample/color conversion should be used.
            CRUCIAL: this must match the actual capabilities of merged upsampler!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.initialize">
            <summary>
            Initialization of JPEG compression objects.
            The error manager must already be set up (in case memory manager fails).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.transdecode_master_selection">
            <summary>
            Master selection of decompression modules for transcoding (that is, reading 
            raw DCT coefficient arrays from an input JPEG file.)
            This substitutes for initialization of the full decompressor.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.output_pass_setup">
            <summary>
            Set up for an output pass, and perform any dummy pass(es) needed.
            Common subroutine for jpeg_start_decompress and jpeg_start_output.
            Entry: global_state = DSTATE_PRESCAN only if previously suspended.
            Exit: If done, returns true and sets global_state for proper output mode.
                  If suspended, returns false and sets global_state = DSTATE_PRESCAN.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.default_decompress_parms">
            <summary>
            Set default decompression parameters.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr">
            <summary>
            Data destination object for compression.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.init_destination">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.empty_output_buffer">
            <summary>
            Empties output buffer.
            </summary>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.term_destination">
            <summary>
            Term_destinations this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.emit_byte(System.Int32)">
            <summary>
            Emits a byte.
            </summary>
            <param name="val">The byte value.</param>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.initInternalBuffer(System.Byte[],System.Int32)">
            <summary>
            Initializes the internal buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.freeInBuffer">
            <summary>
            Gets the number of free bytes in buffer.
            </summary>
            <value>The number of free bytes in buffer.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr">
            <summary>
            Contains simple error-reporting and trace-message routines.
            </summary>
            <remarks>This class is used by both the compression and decompression code.</remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr" /> class.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.Trace_level">
            <summary>
            Gets or sets the maximum message level that will be displayed.
            </summary>
            <value>Values are:
            -1: recoverable corrupt-data warning, may want to abort.<br />
            0: important advisory messages (always display to user).<br />
            1: first level of tracing detail.<br />
            2, 3, ...: successively more detailed tracing messages.
            </value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.Num_warnings">
            <summary>
            Gets the number of corrupt-data warnings.
            </summary>
            <value>The num_warnings.</value>
            <remarks>For recoverable corrupt-data errors, we emit a warning message, but keep going 
            unless <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)">emit_message</see> chooses to abort. 
            <c>emit_message</c> should count warnings in <c>Num_warnings</c>. The surrounding application 
            can check for bad data by seeing if <c>Num_warnings</c> is nonzero at the end of processing.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.error_exit">
            <summary>
            Receives control for a fatal error.
            </summary>
            <remarks>This method calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see> 
            and then throws an exception.</remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)">
            <summary>
            Conditionally emit a trace or warning message.
            </summary>
            <param name="msg_level">The message severity level.<br />
            Values are:<br />
            -1: recoverable corrupt-data warning, may want to abort.<br />
            0: important advisory messages (always display to user).<br />
            1: first level of tracing detail.<br />
            2, 3, ...: successively more detailed tracing messages.
            </param>
            <remarks>The main reason for overriding this method would be to abort on warnings.
            This method calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see> for message showing.<br />
            
            An application might override this method if it wanted to abort on 
            warnings or change the policy about which messages to display.
            </remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">
            <summary>
            Actual output of any JPEG message.
            </summary>
            <remarks>Override this to send messages somewhere other than Console. 
            Note that this method does not know how to generate a message, only where to send it.
            For extending a generation of messages see <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.format_message">format_message</see>.
            </remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.format_message">
            <summary>
            Constructs a readable error message string.
            </summary>
            <remarks>This method is called by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see>.
            Few applications should need to override this method. One possible reason for doing so is to 
            implement dynamic switching of error message language.</remarks>
            <returns>The formatted message</returns>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.reset_error_mgr">
            <summary>
            Resets error manager to initial state.
            </summary>
            <remarks>This is called during compression startup to reset trace/error
            processing to default state. An application might possibly want to
            override this method if it has additional error processing state.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.GetMessageText(System.Int32)">
            <summary>
            Gets the actual message texts.
            </summary>
            <param name="code">The message code. See <see cref="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE" /> for details.</param>
            <returns>The message text associated with <c>code</c>.</returns>
            <remarks>It may be useful for an application to add its own message texts that are handled 
            by the same mechanism. You can override <c>GetMessageText</c> for this purpose. If you number 
            the addon messages beginning at 1000 or so, you won't have to worry about conflicts 
            with the library's built-in messages.
            </remarks>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE" />
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER">
            <summary>
            JPEG marker codes.
            </summary>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF0">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF1">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF2">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF3">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF5">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF6">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF7">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF9">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF10">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF11">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF13">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF14">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF15">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DHT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DAC">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST0">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST1">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST2">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST3">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST4">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST5">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST6">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST7">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.EOI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DQT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DNL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DRI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DHP">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.EXP">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP0">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP1">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP2">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP3">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP4">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP5">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP6">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP7">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP8">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP9">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP10">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP11">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP12">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP13">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP14">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP15">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG0">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG8">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG13">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.COM">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.TEM">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.ERROR">
            <summary />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_marker_struct">
            <summary>
            Representation of special JPEG marker.
            </summary>
            <remarks>You can't create instance of this class manually.
            Concrete objects are instantiated by library and you can get them
            through <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">Marker_list</see> property.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list" />
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.Marker">
            <summary>
            Gets the special marker.
            </summary>
            <value>The marker value.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.OriginalLength">
            <summary>
            Gets the full length of original data associated with the marker.
            </summary>
            <value>The length of original data associated with the marker.</value>
            <remarks>This length excludes the marker length word, whereas the stored representation 
            within the JPEG file includes it. (Hence the maximum data length is really only 65533.)
            </remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.Data">
            <summary>
            Gets the data associated with the marker.
            </summary>
            <value>The data associated with the marker.</value>
            <remarks>The length of this array doesn't exceed <c>length_limit</c> for the particular marker type.
            Note that this length excludes the marker length word, whereas the stored representation 
            within the JPEG file includes it. (Hence the maximum data length is really only 65533.)
            </remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr">
            <summary>
            The progress monitor object.
            </summary>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="E:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.OnProgress">
            <summary>
            Occurs when progress is changed.
            </summary>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Pass_counter">
            <summary>
            Gets or sets the number of work units completed in this pass.
            </summary>
            <value>The number of work units completed in this pass.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Pass_limit">
            <summary>
            Gets or sets the total number of work units in this pass.
            </summary>
            <value>The total number of work units in this pass.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Completed_passes">
            <summary>
            Gets or sets the number of passes completed so far.
            </summary>
            <value>The number of passes completed so far.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Total_passes">
            <summary>
            Gets or sets the total number of passes expected.
            </summary>
            <value>The total number of passes expected.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Updated">
            <summary>
            Indicates that progress was changed.
            </summary>
            <remarks>Call this method if you change some progress parameters manually.
            This method ensures happening of the <see cref="E:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.OnProgress">OnProgress</see> event.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_source_mgr">
            <summary>
            Data source object for decompression.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.init_source">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.fill_input_buffer">
            <summary>
            Fills input buffer
            </summary>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.initInternalBuffer(System.Byte[],System.Int32)">
            <summary>
            Initializes the internal buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.skip_input_data(System.Int32)">
            <summary>
            Skip data - used to skip over a potentially large amount of
            uninteresting data (such as an APPn marker).
            </summary>
            <param name="num_bytes">The number of bytes to skip.</param>
            <remarks>Writers of suspendable-input applications must note that skip_input_data
            is not granted the right to give a suspension return.  If the skip extends
            beyond the data currently in the buffer, the buffer can be marked empty so
            that the next read will cause a fill_input_buffer call that can suspend.
            Arranging for additional bytes to be discarded before reloading the input
            buffer is the application writer's problem.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.resync_to_restart(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Int32)">
            <summary>
            This is the default resync_to_restart method for data source 
            managers to use if they don't have any better approach.
            </summary>
            <param name="cinfo">An instance of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" /></param>
            <param name="desired">The desired</param>
            <returns>
                <c>false</c> if suspension is required.</returns>
            <remarks>That method assumes that no backtracking is possible. 
            Some data source managers may be able to back up, or may have 
            additional knowledge about the data which permits a more 
            intelligent recovery strategy; such managers would
            presumably supply their own resync method.<br /><br />
            
            read_restart_marker calls resync_to_restart if it finds a marker other than
            the restart marker it was expecting.  (This code is *not* used unless
            a nonzero restart interval has been declared.)  cinfo.unread_marker is
            the marker code actually found (might be anything, except 0 or FF).
            The desired restart marker number (0..7) is passed as a parameter.<br /><br />
            
            This routine is supposed to apply whatever error recovery strategy seems
            appropriate in order to position the input stream to the next data segment.
            Note that cinfo.unread_marker is treated as a marker appearing before
            the current data-source input point; usually it should be reset to zero
            before returning.<br /><br />
            
            This implementation is substantially constrained by wanting to treat the
            input as a data stream; this means we can't back up.  Therefore, we have
            only the following actions to work with:<br />
            1. Simply discard the marker and let the entropy decoder resume at next
            byte of file.<br />
            2. Read forward until we find another marker, discarding intervening
            data.  (In theory we could look ahead within the current bufferload,
            without having to discard data if we don't find the desired marker.
            This idea is not implemented here, in part because it makes behavior
            dependent on buffer size and chance buffer-boundary positions.)<br />
            3. Leave the marker unread (by failing to zero cinfo.unread_marker).
            This will cause the entropy decoder to process an empty data segment,
            inserting dummy zeroes, and then we will reprocess the marker.<br />
            
            #2 is appropriate if we think the desired marker lies ahead, while #3 is
            appropriate if the found marker is a future restart marker (indicating
            that we have missed the desired restart marker, probably because it got
            corrupted).<br />
            We apply #2 or #3 if the found marker is a restart marker no more than
            two counts behind or ahead of the expected one.  We also apply #2 if the
            found marker is not a legal JPEG marker code (it's certainly bogus data).
            If the found marker is a restart marker more than 2 counts away, we do #1
            (too much risk that the marker is erroneous; with luck we will be able to
            resync at some future point).<br />
            For any valid non-restart JPEG marker, we apply #3.  This keeps us from
            overrunning the end of a scan.  An implementation limited to single-scan
            files might find it better to apply #2 for markers other than EOI, since
            any other marker would have to be bogus data in that case.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.term_source">
            <summary>
            Terminate source - called by jpeg_finish_decompress
            after all data has been read.  Often a no-op.
            </summary>
            <remarks>NB: <b>not</b> called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetTwoBytes(System.Int32@)">
            <summary>
            Reads two bytes interpreted as an unsigned 16-bit integer.
            </summary>
            <param name="V">The result.</param>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetByte(System.Int32@)">
            <summary>
            Read a byte into variable V.
            If must suspend, take the specified action (typically "return false").
            </summary>
            <param name="V">The result.</param>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetBytes(System.Byte[],System.Int32)">
            <summary>
            Gets the bytes.
            </summary>
            <param name="dest">The destination.</param>
            <param name="amount">The amount.</param>
            <returns>The number of available bytes.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.MakeByteAvailable">
            <summary>
            Functions for fetching data from the data source module.
            </summary>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
            <remarks>At all times, cinfo.src.next_input_byte and .bytes_in_buffer reflect
            the current restart point; we update them only when we have reached a
            suitable place to restart if a suspension occurs.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JQUANT_TBL">
            <summary>
            DCT coefficient quantization tables.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JQUANT_TBL.Sent_table">
            <summary>
            Gets or sets a value indicating whether the table has been output to file.
            </summary>
            <value>It's initialized <c>false</c> when the table is created, and set 
            <c>true</c> when it's been output to the file. You could suppress output of a table by setting this to <c>true</c>.
            </value>
            <remarks>This property is used only during compression.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)" />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jvirt_array`1">
            <summary>
            JPEG virtual array.
            </summary>
            <typeparam name="T">The type of array's elements.</typeparam>
            <remarks>You can't create virtual array manually. For creation use methods
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateSamplesArray(System.Int32,System.Int32)" /> and
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateBlocksArray(System.Int32,System.Int32)" />.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.#ctor(System.Int32,System.Int32,BitMiracle.LibJpeg.Classic.jvirt_array{`0}.Allocator)">
            <summary>
            Request a virtual 2-D array
            </summary>
            <param name="width">Width of array</param>
            <param name="height">Total virtual array height</param>
            <param name="allocator">The allocator.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jvirt_array`1.ErrorProcessor">
            <summary>
            Gets or sets the error processor.
            </summary>
            <value>The error processor.<br />
            Default value: <c>null</c></value>
            <remarks>Uses only for calling 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">jpeg_common_struct.ERREXIT</see>
            on error.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.Access(System.Int32,System.Int32)">
            <summary>
            Access the part of a virtual array.
            </summary>
            <param name="startRow">The first row in required block.</param>
            <param name="numberOfRows">The number of required rows.</param>
            <returns>The required part of virtual array.</returns>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE">
            <summary>
            Known color spaces.
            </summary>
            <seealso href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</seealso>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_UNKNOWN">
            <summary>
            Unspecified color space.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_GRAYSCALE">
            <summary>
            Monochrome
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_RGB">
            <summary>
            Red/Green/Blue, standard RGB (sRGB)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_YCbCr">
            <summary>
            Y/Cb/Cr (also known as YUV), standard YCC
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_CMYK">
            <summary>
            C/M/Y/K
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_YCCK">
            <summary>
             Y/Cb/Cr/K
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_BG_RGB">
            <summary>
            big gamut red/green/blue, bg-sRGB
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_BG_YCC">
            <summary>
            big gamut Y/Cb/Cr, bg-sYCC
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_NCHANNEL">
            <summary>
            N channels
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM">
            <summary>
            Supported color transforms.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM.JCT_NONE">
            <summary>
            No transform
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN">
            <summary>
            Substract green
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">
            <summary>
            Algorithm used for the DCT step.
            </summary>
            <remarks>The <c>FLOAT</c> method is very slightly more accurate than the <c>ISLOW</c> method,
            but may give different results on different machines due to varying roundoff behavior.
            The integer methods should give the same results on all machines. On machines with
            sufficiently fast hardware, the floating-point method may also be the fastest.
            The <c>IFAST</c> method is considerably less accurate than the other two; its use is not recommended
            if high quality is a concern.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dct_method" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dct_method" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_ISLOW">
            <summary>
            Slow but accurate integer algorithm.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_IFAST">
            <summary>
            Faster, less accurate integer method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_FLOAT">
            <summary>
            Floating-point method.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_DITHER_MODE">
            <summary>
            Dithering options for decompression.
            </summary>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dither_mode" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_NONE">
            <summary>
            No dithering: fast, very low quality
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_ORDERED">
            <summary>
            Ordered dither: moderate speed and quality
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_FS">
            <summary>
            Floyd-Steinberg dither: slow, high quality
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE">
            <summary>
            Message codes used in code to signal errors, warning and trace messages.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_NOMESSAGE">
            <summary>
            Must be first entry!
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_BUFFER_MODE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_COMPONENT_ID">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_CROP_SPEC">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DCT_COEF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DCTSIZE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DROP_SAMPLING">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_LENGTH">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_MCU_SIZE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PRECISION">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PROGRESSION">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_SAMPLING">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_SCAN_SCRIPT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_STATE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_VIRTUAL_ACCESS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BUFFER_SIZE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CANT_SUSPEND">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CCIR601_NOTIMPL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_COMPONENT_COUNT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DAC_INDEX">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DAC_VALUE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DHT_INDEX">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DQT_INDEX">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_EMPTY_IMAGE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_EOI_EXPECTED">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_FILE_WRITE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_HUFF_CLEN_OVERFLOW">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_HUFF_MISSING_CODE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_IMAGE_TOO_BIG">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_INPUT_EMPTY">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_INPUT_EOF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MISMATCHED_QUANT_TABLE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MISSING_DATA">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MODE_CHANGE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NOTIMPL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NOT_COMPILED">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_ARITH_TABLE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_HUFF_TABLE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_IMAGE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_QUANT_TABLE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_SOI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_OUT_OF_MEMORY">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_COMPONENTS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_BEFORE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_DUPLICATE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_NO_SOS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_UNSUPPORTED">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOI_DUPLICATE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOS_NO_SOF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_TOO_LITTLE_DATA">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_UNKNOWN_MARKER">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_WIDTH_OVERFLOW">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_16BIT_TABLES">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_ADOBE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_APP0">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_APP14">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DAC">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DHT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DQT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DRI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_EOI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_HUFFBITS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_EXTENSION">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_MISC_MARKER">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_PARMLESS_MARKER">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANTVALS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_3_NCOLORS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_NCOLORS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_SELECTED">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_RECOVERY_ACTION">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_RST">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SMOOTH_NOTIMPL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOF_COMPONENT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS_COMPONENT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS_PARAMS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_JPEG">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_PALETTE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_RGB">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_UNKNOWN_IDS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_ADOBE_XFORM">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_ARITH_BAD_CODE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_BOGUS_PROGRESSION">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_EXTRANEOUS_DATA">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_HIT_MARKER">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_JFIF_MAJOR">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_JPEG_EOF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_MUST_RESYNC">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_NOT_SEQUENTIAL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_TOO_MUCH_DATA">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_UNKNOWNMSGCODE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_LASTMSGCODE">
            <summary />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.ReadResult">
            <summary>
            Describes a result of read operation.
            </summary>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED">
            <summary>
            Suspended due to lack of input data. Can occur only if a suspending data source is used.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK">
            <summary>
            Found valid image datastream.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY">
            <summary>
            Found valid table-specs-only datastream.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_SOS">
            <summary>
            Reached a SOS marker (the start of a new scan)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_EOI">
            <summary>
            Reached the EOI marker (end of image)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_ROW_COMPLETED">
            <summary>
            Completed reading one MCU row of compressed data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SCAN_COMPLETED">
            <summary>
            Completed reading last MCU row of current scan.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.Int64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.UInt64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.Single)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.Double)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int32,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int64,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ReadInput(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source Stream and writes the data to the target array at the specified index.</summary>
            <param name="sourceStream">The source Stream to read from.</param>
            <param name="target">Contains the array of characteres read from the source Stream.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to read from the source Stream.</param>
            <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source Stream. Returns -1 if the end of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source TextReader and writes the data to the target array at the specified index.</summary>
            <param name="sourceTextReader">The source TextReader to read from</param>
            <param name="target">Contains the array of characteres read from the source TextReader.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to read from the source TextReader.</param>
            <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source TextReader. Returns -1 if the end of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ToByteArray(System.String)">
            <summary>
            Converts a string to an array of bytes
            </summary>
            <param name="sourceString">The string to be converted</param>
            <returns>The new array of bytes</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ToCharArray(System.Byte[])">
            <summary>
            Converts an array of bytes to an array of chars
            </summary>
            <param name="byteArray">The array of bytes to convert</param>
            <returns>The new array of chars</returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZInputStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZInputStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZOutputStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZOutputStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.CleanFaxData">
            <summary>
            Regenerated line info.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.CLEANFAXDATA tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.CleanFaxData.CLEAN">
            <summary>
            No errors detected.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.CleanFaxData.REGENERATED">
            <summary>
            Receiver regenerated lines.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.CleanFaxData.UNCLEAN">
            <summary>
            Uncorrected errors exist.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.ColorResponseUnit">
            <summary>
            Color curve accuracy.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.COLORRESPONSEUNIT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU10S">
            <summary>
            Tenths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU100S">
            <summary>
            Hundredths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU1000S">
            <summary>
            Thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU10000S">
            <summary>
            Ten-thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU100000S">
            <summary>
            Hundred-thousandths.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Compression">
            <summary>
            Compression scheme.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.COMPRESSION tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.NONE">
            <summary>
            Dump mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTRLE">
            <summary>
            CCITT modified Huffman RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTFAX3">
            <summary>
            CCITT Group 3 fax encoding.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITT_T4">
            <summary>
            CCITT T.4 (TIFF 6 name for CCITT Group 3 fax encoding).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTFAX4">
            <summary>
            CCITT Group 4 fax encoding.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITT_T6">
            <summary>
            CCITT T.6 (TIFF 6 name for CCITT Group 4 fax encoding).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.LZW">
            <summary>
            Lempel-Ziv &amp; Welch.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.OJPEG">
            <summary>
            Original JPEG / Old-style JPEG (6.0).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.JPEG">
            <summary>
            JPEG DCT compression. Introduced post TIFF rev 6.0.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.NEXT">
            <summary>
            NeXT 2-bit RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTRLEW">
            <summary>
            CCITT RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.PACKBITS">
            <summary>
            Macintosh RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.THUNDERSCAN">
            <summary>
            ThunderScan RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8CTPAD">
            <summary>
            IT8 CT w/padding. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8LW">
            <summary>
            IT8 Linework RLE. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8MP">
            <summary>
            IT8 Monochrome picture. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8BL">
            <summary>
            IT8 Binary line art. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.PIXARFILM">
            <summary>
            Pixar companded 10bit LZW. Reserved for Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.PIXARLOG">
            <summary>
            Pixar companded 11bit ZIP. Reserved for Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.DEFLATE">
            <summary>
            Deflate compression.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.ADOBE_DEFLATE">
            <summary>
            Deflate compression, as recognized by Adobe.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.DCS">
            <summary>
            Kodak DCS encoding.
            Reserved for Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.JBIG">
            <summary>
            ISO JBIG.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.SGILOG">
            <summary>
            SGI Log Luminance RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.SGILOG24">
            <summary>
            SGI Log 24-bit packed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.JP2000">
            <summary>
            Leadtools JPEG2000.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.ExtraSample">
            <summary>
            Information about extra samples.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.EXTRASAMPLES tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ExtraSample.UNSPECIFIED">
            <summary>
            Unspecified data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ExtraSample.ASSOCALPHA">
            <summary>
            Associated alpha data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ExtraSample.UNASSALPHA">
            <summary>
            Unassociated alpha data.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FaxMode">
            <summary>
            Group 3/4 format control.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.FAXMODE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.CLASSIC">
            <summary>
            Default, include RTC.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.NORTC">
            <summary>
            No RTC at end of data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.NOEOL">
            <summary>
            No EOL code at end of row.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.BYTEALIGN">
            <summary>
            Byte align row.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.WORDALIGN">
            <summary>
            Word align row.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.CLASSF">
            <summary>
            TIFF Class F.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FileType">
            <summary>
            Subfile data descriptor.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.SUBFILETYPE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FileType.REDUCEDIMAGE">
            <summary>
            Reduced resolution version.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FileType.PAGE">
            <summary>
            One page of many.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FileType.MASK">
            <summary>
            Transparency mask.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FillOrder">
            <summary>
            Data order within a byte.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.FILLORDER tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FillOrder.MSB2LSB">
            <summary>
            Most significant -&gt; least.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FillOrder.LSB2MSB">
            <summary>
            Least significant -&gt; most.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.GrayResponseUnit">
            <summary>
            Gray scale curve accuracy.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.GRAYRESPONSEUNIT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU10S">
            <summary>
            Tenths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU100S">
            <summary>
            Hundredths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU1000S">
            <summary>
            Thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU10000S">
            <summary>
            Ten-thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU100000S">
            <summary>
            Hundred-thousandths.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Group3Opt">
            <summary>
            Options for CCITT Group 3/4 fax encoding.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.GROUP3OPTIONS / TiffTag.T4OPTIONS and
            TiffTag.GROUP4OPTIONS / TiffTag.T6OPTIONS tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.UNKNOWN">
            <summary>
            Unknown (uninitialized).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.ENCODING2D">
            <summary>
            2-dimensional coding.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.UNCOMPRESSED">
            <summary>
            Data not compressed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.FILLBITS">
            <summary>
            Fill to byte boundary.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.InkSet">
            <summary>
            Inks in separated image.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.INKSET tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.InkSet.CMYK">
            <summary>
            Cyan-magenta-yellow-black color.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.InkSet.MULTIINK">
            <summary>
            Multi-ink or hi-fi color.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.JpegColorMode">
            <summary>
            Auto RGB&lt;=&gt;YCbCr convert.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.JPEGCOLORMODE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegColorMode.RAW">
            <summary>
            No conversion (default).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegColorMode.RGB">
            <summary>
            Do auto conversion.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.JpegProc">
            <summary>
            JPEG processing algorithm.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.JPEGPROC tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegProc.BASELINE">
            <summary>
            Baseline sequential.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegProc.LOSSLESS">
            <summary>
            Huffman coded lossless.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.JpegTablesMode">
            <summary>
            Jpeg Tables Mode.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.JPEGTABLESMODE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegTablesMode.NONE">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegTablesMode.QUANT">
            <summary>
            Include quantization tables.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegTablesMode.HUFF">
            <summary>
            Include Huffman tables.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.OFileType">
            <summary>
            Kind of data in subfile.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.OSUBFILETYPE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.OFileType.IMAGE">
            <summary>
            Full resolution image data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.OFileType.REDUCEDIMAGE">
            <summary>
            Reduced size image data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.OFileType.PAGE">
            <summary>
            One page of many.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Orientation">
            <summary>
            Image orientation.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.ORIENTATION tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.TOPLEFT">
            <summary>
            Row 0 top, Column 0 lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.TOPRIGHT">
            <summary>
            Row 0 top, Column 0 rhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.BOTRIGHT">
            <summary>
            Row 0 bottom, Column 0 rhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.BOTLEFT">
            <summary>
            Row 0 bottom, Column 0 lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.LEFTTOP">
            <summary>
            Row 0 lhs, Column 0 top.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.RIGHTTOP">
            <summary>
            Row 0 rhs, Column 0 top.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.RIGHTBOT">
            <summary>
            Row 0 rhs, Column 0 bottom.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.LEFTBOT">
            <summary>
            Row 0 lhs, Column 0 bottom.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Photometric">
            <summary>
            Photometric interpretation.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.PHOTOMETRIC tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.MINISWHITE">
            <summary>
            Min value is white.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.MINISBLACK">
            <summary>
            Min value is black.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.RGB">
            <summary>
            RGB color model.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.PALETTE">
            <summary>
            Color map indexed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.MASK">
            <summary>
            [obsoleted by TIFF rev. 6.0] Holdout mask.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.SEPARATED">
            <summary>
            Color separations.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.YCBCR">
            <summary>
            CCIR 601.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.CIELAB">
            <summary>
            1976 CIE L*a*b*.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.ICCLAB">
            <summary>
            ICC L*a*b*. Introduced post TIFF rev 6.0 by Adobe TIFF Technote 4.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.ITULAB">
            <summary>
            ITU L*a*b*.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.LOGL">
            <summary>
            CIE Log2(L).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.LOGLUV">
            <summary>
            CIE Log2(L) (u',v').
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.PlanarConfig">
            <summary>
            Storage organization.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.PLANARCONFIG tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.PlanarConfig.UNKNOWN">
            <summary>
            Unknown (uninitialized).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.PlanarConfig.CONTIG">
            <summary>
            Single image plane.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.PlanarConfig.SEPARATE">
            <summary>
            Separate planes of data.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Predictor">
            <summary>
            Prediction scheme w/ LZW.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.PREDICTOR tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Predictor.NONE">
            <summary>
            No prediction scheme used.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Predictor.HORIZONTAL">
            <summary>
            Horizontal differencing.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Predictor.FLOATINGPOINT">
            <summary>
            Floating point predictor.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.ResUnit">
            <summary>
            Units of resolutions.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.RESOLUTIONUNIT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ResUnit.NONE">
            <summary>
            No meaningful units.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ResUnit.INCH">
            <summary>
            English.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ResUnit.CENTIMETER">
            <summary>
            Metric.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.SampleFormat">
            <summary>
            Data sample format.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.SAMPLEFORMAT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.UINT">
            <summary>
            Unsigned integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.INT">
            <summary>
            Signed integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.IEEEFP">
            <summary>
            IEEE floating point data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.VOID">
            <summary>
            Untyped data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.COMPLEXINT">
            <summary>
            Complex signed int
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.COMPLEXIEEEFP">
            <summary>
            Complex ieee floating
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Threshold">
            <summary>
            Thresholding used on data.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.THRESHHOLDING tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Threshold.BILEVEL">
            <summary>
            B&amp;W art scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Threshold.HALFTONE">
            <summary>
            Dithered scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Threshold.ERRORDIFFUSE">
            <summary>
            Usually Floyd-Steinberg.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffPrintFlags">
            <summary>
            Flags that can be passed to <see cref="O:BitMiracle.LibTiff.Classic.Tiff.PrintDirectory" />
            method to control printing of data structures that are potentially very large. 
            </summary>
            <remarks>More than one flag can be used. Bit-or these flags to enable printing
            multiple items.</remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.NONE">
            <summary>
            no extra info
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.STRIPS">
            <summary>
            strips/tiles info
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.CURVES">
            <summary>
            color/gray response curves
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.COLORMAP">
            <summary>
            colormap
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.JPEGQTABLES">
            <summary>
            JPEG Q matrices
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.JPEGACTABLES">
            <summary>
            JPEG AC tables
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.JPEGDCTABLES">
            <summary>
            JPEG DC tables
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffTag">
            <summary>
            TIFF tag definitions.
            </summary>
            <remarks>
            Joris Van Damme maintains
            <a href="http://www.awaresystems.be/imaging/tiff/tifftags.html" target="_blank">
            TIFF Tag Reference</a>, good source of tag information. It's an overview of known TIFF
            Tags with properties, short description, and other useful information.
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IGNORE">
            <summary>
            Tag placeholder
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SUBFILETYPE">
            <summary>
            Subfile data descriptor.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.FileType" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.OSUBFILETYPE">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Kind of data in subfile. For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.OFileType" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH">
            <summary>
            Image width in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH">
            <summary>
            Image height in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE">
            <summary>
            Bits per channel (sample).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COMPRESSION">
            <summary>
            Data compression technique.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Compression" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PHOTOMETRIC">
            <summary>
            Photometric interpretation.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Photometric" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.THRESHHOLDING">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Thresholding used on data. For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Threshold" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CELLWIDTH">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Dithering matrix width.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CELLLENGTH">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Dithering matrix height.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER">
            <summary>
            Data order within a byte.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.FillOrder" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DOCUMENTNAME">
            <summary>
            Name of document which holds for image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDESCRIPTION">
            <summary>
            Information about image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MAKE">
            <summary>
            Scanner manufacturer name.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MODEL">
            <summary>
            Scanner model name/number.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS">
            <summary>
            Offsets to data strips.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ORIENTATION">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Image orientation. For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Orientation" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLESPERPIXEL">
            <summary>
            Samples per pixel.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP">
            <summary>
            Rows per strip of data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS">
            <summary>
            Bytes counts for strips.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MINSAMPLEVALUE">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Minimum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MAXSAMPLEVALUE">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Maximum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XRESOLUTION">
            <summary>
            Pixels/resolution in x.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YRESOLUTION">
            <summary>
            Pixels/resolution in y.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG">
            <summary>
            Storage organization.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PAGENAME">
            <summary>
            Page name image is from.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XPOSITION">
            <summary>
            X page offset of image lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YPOSITION">
            <summary>
            Y page offset of image lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FREEOFFSETS">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Byte offset to free block.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FREEBYTECOUNTS">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br />
            Sizes of free blocks.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GRAYRESPONSEUNIT">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br />
            Gray scale curve accuracy.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.GrayResponseUnit" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GRAYRESPONSECURVE">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br />
            Gray scale response curve.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GROUP3OPTIONS">
            <summary>
            Options for CCITT Group 3 fax encoding. 32 flag bits.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Group3Opt" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.T4OPTIONS">
            <summary>
            TIFF 6.0 proper name alias for GROUP3OPTIONS.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GROUP4OPTIONS">
            <summary>
            Options for CCITT Group 4 fax encoding. 32 flag bits.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Group3Opt" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.T6OPTIONS">
            <summary>
            TIFF 6.0 proper name alias for GROUP4OPTIONS.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.RESOLUTIONUNIT">
            <summary>
            Units of resolutions.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.ResUnit" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PAGENUMBER">
            <summary>
            Page numbers of multi-page.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORRESPONSEUNIT">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br />
            Color curve accuracy.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.ColorResponseUnit" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TRANSFERFUNCTION">
            <summary>
            Colorimetry info.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SOFTWARE">
            <summary>
            Name &amp; release.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DATETIME">
            <summary>
            Creation date and time.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ARTIST">
            <summary>
            Creator of image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.HOSTCOMPUTER">
            <summary>
            Machine where created.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PREDICTOR">
            <summary>
            Prediction scheme w/ LZW.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Predictor" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.WHITEPOINT">
            <summary>
            Image white point.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PRIMARYCHROMATICITIES">
            <summary>
            Primary chromaticities.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORMAP">
            <summary>
            RGB map for pallette image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.HALFTONEHINTS">
            <summary>
            Highlight + shadow info.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEWIDTH">
            <summary>
            Tile width in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILELENGTH">
            <summary>
            Tile height in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEOFFSETS">
            <summary>
            Offsets to data tiles.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEBYTECOUNTS">
            <summary>
            Byte counts for tiles.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BADFAXLINES">
            <summary>
            Lines with wrong pixel count.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CLEANFAXDATA">
            <summary>
            Regenerated line info.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.CleanFaxData" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CONSECUTIVEBADFAXLINES">
            <summary>
            Max consecutive bad lines.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SUBIFD">
            <summary>
            Subimage descriptors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INKSET">
            <summary>
            Inks in separated image.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.InkSet" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INKNAMES">
            <summary>
            ASCII names of inks.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.NUMBEROFINKS">
            <summary>
            Number of inks.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DOTRANGE">
            <summary>
            0% and 100% dot codes.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TARGETPRINTER">
            <summary>
            Separation target.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXTRASAMPLES">
            <summary>
            Information about extra samples.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.ExtraSample" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLEFORMAT">
            <summary>
            Data sample format.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.SampleFormat" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SMINSAMPLEVALUE">
            <summary>
            Variable MinSampleValue.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SMAXSAMPLEVALUE">
            <summary>
            Variable MaxSampleValue.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CLIPPATH">
            <summary>
            ClipPath. Introduced post TIFF rev 6.0 by Adobe TIFF technote 2.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XCLIPPATHUNITS">
            <summary>
            XClipPathUnits. Introduced post TIFF rev 6.0 by Adobe TIFF technote 2.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCLIPPATHUNITS">
            <summary>
            YClipPathUnits. Introduced post TIFF rev 6.0 by Adobe TIFF technote 2.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INDEXED">
            <summary>
            Indexed. Introduced post TIFF rev 6.0 by Adobe TIFF Technote 3.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGTABLES">
            <summary>
            JPEG table stream. Introduced post TIFF rev 6.0.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.OPIPROXY">
            <summary>
            OPI Proxy. Introduced post TIFF rev 6.0 by Adobe TIFF technote.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGPROC">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            JPEG processing algorithm.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.JpegProc" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGIFOFFSET">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            Pointer to SOI marker.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGIFBYTECOUNT">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            JFIF stream length
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGRESTARTINTERVAL">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            Restart interval length.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGLOSSLESSPREDICTORS">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            Lossless proc predictor.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGPOINTTRANSFORM">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            Lossless point transform.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGQTABLES">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            Q matrice offsets.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGDCTABLES">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            DCT table offsets.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGACTABLES">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br />
            AC coefficient offsets.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCBCRCOEFFICIENTS">
            <summary>
            RGB -&gt; YCbCr transform.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCBCRSUBSAMPLING">
            <summary>
            YCbCr subsampling factors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCBCRPOSITIONING">
            <summary>
            Subsample positioning.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.YCbCrPosition" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REFERENCEBLACKWHITE">
            <summary>
            Colorimetry info.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XMLPACKET">
            <summary>
            XML packet. Introduced post TIFF rev 6.0 by Adobe XMP Specification, January 2004.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.OPIIMAGEID">
            <summary>
            OPI ImageID. Introduced post TIFF rev 6.0 by Adobe TIFF technote.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REFPTS">
            <summary>
            Image reference points. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REGIONTACKPOINT">
            <summary>
            Region-xform tack point. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REGIONWARPCORNERS">
            <summary>
            Warp quadrilateral. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REGIONAFFINE">
            <summary>
            Affine transformation matrix. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MATTEING">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br />
            Use EXTRASAMPLE tag. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DATATYPE">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br />
            Use SAMPLEFORMAT tag. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH">
            <summary>
            Z depth of image. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEDEPTH">
            <summary>
            Z depth/data tile. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_IMAGEFULLWIDTH">
            <summary>
            Full image size in X. This tag is set when an image has been cropped out of a larger
            image. It reflect width of the original uncropped image. The XPOSITION tag can be used
            to determine the position of the smaller image in the larger one.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_IMAGEFULLLENGTH">
            <summary>
            Full image size in Y. This tag is set when an image has been cropped out of a larger
            image. It reflect height of the original uncropped image. The YPOSITION can be used
            to determine the position of the smaller image in the larger one.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_TEXTUREFORMAT">
            <summary>
            Texture map format. Used to identify special image modes and data used by Pixar's
            texture formats. Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_WRAPMODES">
            <summary>
            S&amp;T wrap modes. Used to identify special image modes and data used by Pixar's
            texture formats. Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_FOVCOT">
            <summary>
            Cotan(fov) for env. maps. Used to identify special image modes and data used by
            Pixar's texture formats. Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_MATRIX_WORLDTOSCREEN">
            <summary>
            Used to identify special image modes and data used by Pixar's texture formats.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_MATRIX_WORLDTOCAMERA">
            <summary>
            Used to identify special image modes and data used by Pixar's texture formats.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.WRITERSERIALNUMBER">
            <summary>
            Device serial number. Private tag registered to Eastman Kodak.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COPYRIGHT">
            <summary>
            Copyright string. This tag is listed in the TIFF rev. 6.0 w/ unknown ownership.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.RICHTIFFIPTC">
            <summary>
            IPTC TAG from RichTIFF specifications.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8SITE">
            <summary>
            Site name. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8COLORSEQUENCE">
            <summary>
            Color seq. [RGB, CMYK, etc]. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8HEADER">
            <summary>
            DDES Header. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8RASTERPADDING">
            <summary>
            Raster scanline padding. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BITSPERRUNLENGTH">
            <summary>
            The number of bits in short run. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BITSPEREXTENDEDRUNLENGTH">
            <summary>
            The number of bits in long run. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8COLORTABLE">
            <summary>
            LW colortable. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8IMAGECOLORINDICATOR">
            <summary>
            BP/BL image color switch. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BKGCOLORINDICATOR">
            <summary>
            BP/BL bg color switch. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8IMAGECOLORVALUE">
            <summary>
            BP/BL image color value. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BKGCOLORVALUE">
            <summary>
            BP/BL bg color value. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8PIXELINTENSITYRANGE">
            <summary>
            MP pixel intensity value. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8TRANSPARENCYINDICATOR">
            <summary>
            HC transparency switch. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8COLORCHARACTERIZATION">
            <summary>
            Color characterization table. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8HCUSAGE">
            <summary>
            HC usage indicator. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8TRAPINDICATOR">
            <summary>
            Trapping indicator (untrapped = 0, trapped = 1). Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8CMYKEQUIVALENT">
            <summary>
            CMYK color equivalents.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FRAMECOUNT">
            <summary>
            Sequence Frame Count. Private tag registered to Texas Instruments.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PHOTOSHOP">
            <summary>
            Private tag registered to Adobe for PhotoShop.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIFIFD">
            <summary>
            Pointer to EXIF private directory. This tag is documented in EXIF specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ICCPROFILE">
            <summary>
            ICC profile data. ?? Private tag registered to Adobe. ??
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JBIGOPTIONS">
            <summary>
            JBIG options. Private tag registered to Pixel Magic.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GPSIFD">
            <summary>
            Pointer to GPS private directory. This tag is documented in EXIF specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXRECVPARAMS">
            <summary>
            Encoded Class 2 ses. params. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXSUBADDRESS">
            <summary>
            Received SubAddr string. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXRECVTIME">
            <summary>
            Receive time (secs). Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXDCS">
            <summary>
            Encoded fax ses. params, Table 2/T.30. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.STONITS">
            <summary>
            Sample value to Nits. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FEDEX_EDR">
            <summary>
            Private tag registered to FedEx.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INTEROPERABILITYIFD">
            <summary>
            Pointer to Interoperability private directory.
            This tag is documented in EXIF specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DNGVERSION">
            <summary>
            DNG version number. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DNGBACKWARDVERSION">
            <summary>
            DNG compatibility version. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.UNIQUECAMERAMODEL">
            <summary>
            Name for the camera model. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LOCALIZEDCAMERAMODEL">
            <summary>
            Localized camera model name. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CFAPLANECOLOR">
            <summary>
            CFAPattern-&gt;LinearRaw space mapping. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CFALAYOUT">
            <summary>
            Spatial layout of the CFA. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LINEARIZATIONTABLE">
            <summary>
            Lookup table description. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVELREPEATDIM">
            <summary>
            Repeat pattern size for the BlackLevel tag. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVEL">
            <summary>
            Zero light encoding level. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVELDELTAH">
            <summary>
            Zero light encoding level differences (columns). Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVELDELTAV">
            <summary>
            Zero light encoding level differences (rows). Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.WHITELEVEL">
            <summary>
            Fully saturated encoding level. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DEFAULTSCALE">
            <summary>
            Default scale factors. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DEFAULTCROPORIGIN">
            <summary>
            Origin of the final image area. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DEFAULTCROPSIZE">
            <summary>
            Size of the final image area. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORMATRIX1">
            <summary>
            XYZ-&gt;reference color space transformation matrix 1.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORMATRIX2">
            <summary>
            XYZ-&gt;reference color space transformation matrix 2.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CAMERACALIBRATION1">
            <summary>
            Calibration matrix 1. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CAMERACALIBRATION2">
            <summary>
            Calibration matrix 2. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REDUCTIONMATRIX1">
            <summary>
            Dimensionality reduction matrix 1. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REDUCTIONMATRIX2">
            <summary>
            Dimensionality reduction matrix 2. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ANALOGBALANCE">
            <summary>
            Gain applied the stored raw values. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTNEUTRAL">
            <summary>
            Selected white balance in linear reference space.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTWHITEXY">
            <summary>
            Selected white balance in x-y chromaticity coordinates.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BASELINEEXPOSURE">
            <summary>
            How much to move the zero point. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BASELINENOISE">
            <summary>
            Relative noise level. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BASELINESHARPNESS">
            <summary>
            Relative amount of sharpening. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BAYERGREENSPLIT">
            <summary>
            How closely the values of the green pixels in the blue/green rows 
            track the values of the green pixels in the red/green rows.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LINEARRESPONSELIMIT">
            <summary>
            Non-linear encoding range. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CAMERASERIALNUMBER">
            <summary>
            Camera's serial number. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LENSINFO">
            <summary>
            Information about the lens.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CHROMABLURRADIUS">
            <summary>
            Chroma blur radius. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ANTIALIASSTRENGTH">
            <summary>
            Relative strength of the camera's anti-alias filter.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SHADOWSCALE">
            <summary>
            Used by Adobe Camera Raw. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DNGPRIVATEDATA">
            <summary>
            Manufacturer's private data. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MAKERNOTESAFETY">
            <summary>
            Whether the EXIF MakerNote tag is safe to preserve along with the rest of the EXIF data.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CALIBRATIONILLUMINANT1">
            <summary>
            Illuminant 1. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CALIBRATIONILLUMINANT2">
            <summary>
            Illuminant 2. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BESTQUALITYSCALE">
            <summary>
            Best quality multiplier. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.RAWDATAUNIQUEID">
            <summary>
            Unique identifier for the raw image data. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ORIGINALRAWFILENAME">
            <summary>
            File name of the original raw file. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ORIGINALRAWFILEDATA">
            <summary>
            Contents of the original raw file. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ACTIVEAREA">
            <summary>
            Active (non-masked) pixels of the sensor. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MASKEDAREAS">
            <summary>
            List of coordinates of fully masked pixels. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTICCPROFILE">
            <summary>
            Used to map cameras's color space into ICC profile space.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTPREPROFILEMATRIX">
            <summary>
            Used to map cameras's color space into ICC profile space.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CURRENTICCPROFILE">
            <summary>
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CURRENTPREPROFILEMATRIX">
            <summary>
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSHUESHIFTVALUES">
            <summary>
            Undefined tag used by Eastman Kodak, hue shift correction data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXMODE">
            <summary>
            [pseudo tag. not written to file]<br />
            Group 3/4 format control.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.FaxMode" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGQUALITY">
            <summary>
            [pseudo tag. not written to file]<br />
            Compression quality level. Quality level is on the IJG 0-100 scale. Default value is 75.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGCOLORMODE">
            <summary>
            [pseudo tag. not written to file]<br />
            Auto RGB&lt;=&gt;YCbCr convert.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.JpegColorMode" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGTABLESMODE">
            <summary>
            [pseudo tag. not written to file]<br />
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.JpegTablesMode" />.
            Default is <see cref="F:BitMiracle.LibTiff.Classic.JpegTablesMode.QUANT" /> | <see cref="F:BitMiracle.LibTiff.Classic.JpegTablesMode.HUFF" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXFILLFUNC">
            <summary>
            [pseudo tag. not written to file]<br />
            G3/G4 fill function.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXARLOGDATAFMT">
            <summary>
            [pseudo tag. not written to file]<br />
            PixarLogCodec I/O data sz.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSIMAGERTYPE">
            <summary>
            [pseudo tag. not written to file]<br />
            Imager mode &amp; filter.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSINTERPMODE">
            <summary>
            [pseudo tag. not written to file]<br />
            Interpolation mode.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSBALANCEARRAY">
            <summary>
            [pseudo tag. not written to file]<br />
            Color balance values.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSCORRECTMATRIX">
            <summary>
            [pseudo tag. not written to file]<br />
            Color correction values.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSGAMMA">
            <summary>
            [pseudo tag. not written to file]<br />
            Gamma value.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSTOESHOULDERPTS">
            <summary>
            [pseudo tag. not written to file]<br />
            Toe &amp; shoulder points.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSCALIBRATIONFD">
            <summary>
            [pseudo tag. not written to file]<br />
            Calibration file description.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ZIPQUALITY">
            <summary>
            [pseudo tag. not written to file]<br />
            Compression quality level.
            Quality level is on the ZLIB 1-9 scale. Default value is -1.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXARLOGQUALITY">
            <summary>
            [pseudo tag. not written to file]<br />
            PixarLog uses same scale.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSCLIPRECTANGLE">
            <summary>
            [pseudo tag. not written to file]<br />
            Area of image to acquire.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SGILOGDATAFMT">
            <summary>
            [pseudo tag. not written to file]<br />
            SGILog user data format.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SGILOGENCODE">
            <summary>
            [pseudo tag. not written to file]<br />
            SGILog data encoding control.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSURETIME">
            <summary>
            Exposure time.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FNUMBER">
            <summary>
            F number.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREPROGRAM">
            <summary>
            Exposure program.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SPECTRALSENSITIVITY">
            <summary>
            Spectral sensitivity.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_ISOSPEEDRATINGS">
            <summary>
            ISO speed rating.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_OECF">
            <summary>
            Optoelectric conversion factor.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXIFVERSION">
            <summary>
            Exif version.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DATETIMEORIGINAL">
            <summary>
            Date and time of original data generation.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DATETIMEDIGITIZED">
            <summary>
            Date and time of digital data generation.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_COMPONENTSCONFIGURATION">
            <summary>
            Meaning of each component.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_COMPRESSEDBITSPERPIXEL">
            <summary>
            Image compression mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SHUTTERSPEEDVALUE">
            <summary>
            Shutter speed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_APERTUREVALUE">
            <summary>
            Aperture.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_BRIGHTNESSVALUE">
            <summary>
            Brightness.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREBIASVALUE">
            <summary>
            Exposure bias.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_MAXAPERTUREVALUE">
            <summary>
            Maximum lens aperture.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTDISTANCE">
            <summary>
            Subject distance.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_METERINGMODE">
            <summary>
            Metering mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_LIGHTSOURCE">
            <summary>
            Light source.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FLASH">
            <summary>
            Flash.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALLENGTH">
            <summary>
            Lens focal length.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTAREA">
            <summary>
            Subject area.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_MAKERNOTE">
            <summary>
            Manufacturer notes.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_USERCOMMENT">
            <summary>
            User comments.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBSECTIME">
            <summary>
            DateTime subseconds.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBSECTIMEORIGINAL">
            <summary>
            DateTimeOriginal subseconds.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBSECTIMEDIGITIZED">
            <summary>
            DateTimeDigitized subseconds.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FLASHPIXVERSION">
            <summary>
            Supported Flashpix version.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_COLORSPACE">
            <summary>
            Color space information.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_PIXELXDIMENSION">
            <summary>
            Valid image width.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_PIXELYDIMENSION">
            <summary>
            Valid image height.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_RELATEDSOUNDFILE">
            <summary>
            Related audio file.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FLASHENERGY">
            <summary>
            Flash energy.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SPATIALFREQUENCYRESPONSE">
            <summary>
            Spatial frequency response.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALPLANEXRESOLUTION">
            <summary>
            Focal plane X resolution.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALPLANEYRESOLUTION">
            <summary>
            Focal plane Y resolution.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALPLANERESOLUTIONUNIT">
            <summary>
            Focal plane resolution unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTLOCATION">
            <summary>
            Subject location.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREINDEX">
            <summary>
            Exposure index.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SENSINGMETHOD">
            <summary>
            Sensing method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FILESOURCE">
            <summary>
            File source.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SCENETYPE">
            <summary>
            Scene type.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_CFAPATTERN">
            <summary>
            CFA pattern.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_CUSTOMRENDERED">
            <summary>
            Custom image processing.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREMODE">
            <summary>
            Exposure mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_WHITEBALANCE">
            <summary>
            White balance.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DIGITALZOOMRATIO">
            <summary>
            Digital zoom ratio.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALLENGTHIN35MMFILM">
            <summary>
            Focal length in 35 mm film.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SCENECAPTURETYPE">
            <summary>
            Scene capture type.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_GAINCONTROL">
            <summary>
            Gain control.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_CONTRAST">
            <summary>
            Contrast.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SATURATION">
            <summary>
            Saturation.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SHARPNESS">
            <summary>
            Sharpness.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DEVICESETTINGDESCRIPTION">
            <summary>
            Device settings description.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTDISTANCERANGE">
            <summary>
            Subject distance range.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_IMAGEUNIQUEID">
            <summary>
            Unique image ID.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_MODELPIXELSCALETAG">
            <summary>
            This tag is defining exact affine transformations between raster and model space. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_MODELTIEPOINTTAG">
            <summary>
            This tag stores raster-&gt;model tiepoint pairs. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_MODELTRANSFORMATIONTAG">
            <summary>
            This tag is optionally provided for defining exact affine transformations between raster and model space. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffType">
            <summary>
            Tag data type.
            </summary>
            <remarks>Note: RATIONALs are the ratio of two 32-bit integer values.</remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.NOTYPE">
            <summary>
            Placeholder.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.ANY">
            <summary>
            For field descriptor searching.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.BYTE">
            <summary>
            8-bit unsigned integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.ASCII">
            <summary>
            8-bit bytes with last byte <c>null</c>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SHORT">
            <summary>
            16-bit unsigned integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.LONG">
            <summary>
            32-bit unsigned integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.RATIONAL">
            <summary>
            64-bit unsigned fraction.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SBYTE">
            <summary>
            8-bit signed integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.UNDEFINED">
            <summary>
            8-bit untyped data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SSHORT">
            <summary>
            16-bit signed integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SLONG">
            <summary>
            32-bit signed integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SRATIONAL">
            <summary>
            64-bit signed fraction.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.FLOAT">
            <summary>
            32-bit IEEE floating point.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.DOUBLE">
            <summary>
            64-bit IEEE floating point.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.IFD">
            <summary>
            32-bit unsigned integer (offset)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.LONG8">
            <summary>
            BigTIFF 64-bit unsigned long
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SLONG8">
            <summary>
            BigTIFF 64-bit signed long
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.IFD8">
            <summary>
            BigTIFF 64-bit unsigned integer/long (offset)
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.YCbCrPosition">
            <summary>
            Subsample positioning.<br />
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.YCBCRPOSITIONING tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.YCbCrPosition.CENTERED">
            <summary>
            As in PostScript Level 2
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.YCbCrPosition.COSITED">
            <summary>
            As in CCIR 601-1
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FieldBit">
            <summary>
            Field bits (flags) for tags.
            </summary>
            <remarks>Field bits used to indicate fields that have been set in a directory, and to
            reference fields when manipulating a directory.</remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Ignore">
            <summary>
            This value is used to signify tags that are to be processed
            but otherwise ignored.<br />
            This permits antiquated tags to be quietly read and discarded. Note that
            a bit <b>is</b> allocated for ignored tags; this is understood by the
            directory reading logic which uses this fact to avoid special-case handling.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Pseudo">
            <summary>
            This value is used to signify pseudo-tags.<br />
            Pseudo-tags don't normally need field bits since they are not
            written to an output file (by definition). The library also has
            express logic to always query a codec for a pseudo-tag so allocating
            a field bit for one is a waste. If codec wants to promote the notion
            of a pseudo-tag being <i>set</i> or <i>unset</i> then it can do using
            internal state flags without polluting the field bit space defined
            for real tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Custom">
            <summary>
            This value is used to signify custom tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Codec">
            <summary>
            This value is used as a base (starting) value for codec-private tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Last">
            <summary>
            Last usable value for field bit. All tags values should be less than this value.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FieldValue">
            <summary>
            Holds a value of a Tiff tag.
            </summary>
            <remarks>
                <para>Simply put, it is a wrapper around System.Object, that helps to deal with
            unboxing and conversion of types a bit easier.
            </para>
                <para>
            Please take a look at:
            http://blogs.msdn.com/ericlippert/archive/2009/03/19/representation-and-identity.aspx
            </para>
            </remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.FieldValue.Value">
            <summary>
            Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToByte">
            <summary>
            Retrieves value converted to byte.
            </summary>
            <returns>The value converted to byte.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToShort">
            <summary>
            Retrieves value converted to short.
            </summary>
            <returns>The value converted to short.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUShort">
            <summary>
            Retrieves value converted to ushort.
            </summary>
            <returns>The value converted to ushort.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToInt">
            <summary>
            Retrieves value converted to int.
            </summary>
            <returns>The value converted to int.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUInt">
            <summary>
            Retrieves value converted to uint.
            </summary>
            <returns>The value converted to uint.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToLong">
            <summary>
            Retrieves value converted to long.
            </summary>
            <returns>The value converted to long.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToFloat">
            <summary>
            Retrieves value converted to float.
            </summary>
            <returns>The value converted to float.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToDouble">
            <summary>
            Retrieves value converted to double.
            </summary>
            <returns>The value converted to double.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToString">
            <summary>
            Retrieves value converted to string.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.        
            </returns>
            <remarks>If value is a byte array, then it gets converted to string using
            Latin1 encoding encoder.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.GetBytes">
            <summary>
            Retrieves value converted to byte array.
            </summary>
            <returns>Value converted to byte array.</returns>
            <remarks>
                <para>If value is byte array then it retrieved unaltered.</para>
                <para>If value is array of short, ushort, int, uint, float or double values then this
            array is converted to byte array</para>
                <para>
            If value is a string then it gets converted to byte array using Latin1 encoding
            encoder.</para>
                <para>
            If value is of any other type then <c>null</c> is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToByteArray">
            <summary>
            Retrieves value converted to array of bytes.
            </summary>
            <returns>Value converted to array of bytes.</returns>
            <remarks>
                <para>If value is array of bytes then it retrieved unaltered.</para>
                <para>If value is array of short, ushort, int or uint values then each element of
            field value gets converted to byte and added to resulting array.</para>
                <para>If value is string then it gets converted to byte[] using Latin1 encoding
            encoder.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToShortArray">
            <summary>
            Retrieves value converted to array of short values.
            </summary>
            <returns>Value converted to array of short values.</returns>
            <remarks>
                <para>If value is array of short values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each pair of bytes is converted to short and
            added to resulting array. If value contains odd amount of bytes, then null is
            returned.</para>
                <para>
            If value is array of ushort, int or uint values then each element of field value gets
            converted to short and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUShortArray">
            <summary>
            Retrieves value converted to array of ushort values.
            </summary>
            <returns>Value converted to array of ushort values.</returns>
            <remarks>
                <para>If value is array of ushort values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each pair of bytes is converted to ushort and
            added to resulting array. If value contains odd amount of bytes, then null is
            returned.</para>
                <para>
            If value is array of short, int or uint values then each element of field value gets
            converted to ushort and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToIntArray">
            <summary>
            Retrieves value converted to array of int values.
            </summary>
            <returns>Value converted to array of int values.</returns>
            <remarks>
                <para>If value is array of int values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each 4 bytes are converted to int and added to
            resulting array. If value contains amount of bytes that can't be divided by 4 without
            remainder, then null is returned.</para>
                <para>If value is array of short, ushort or uint values then each element of
            field value gets converted to int and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUIntArray">
            <summary>
            Retrieves value converted to array of uint values.
            </summary>
            <returns>Value converted to array of uint values.</returns>
            <remarks>
                <para>If value is array of uint values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each 4 bytes are converted to uint and added to
            resulting array. If value contains amount of bytes that can't be divided by 4 without
            remainder, then null is returned.</para>
                <para>If value is array of short, ushort or int values then each element of
            field value gets converted to uint and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.TolongArray">
            <summary>
            Retrieves value converted to array of long values.
            </summary>
            <returns>Value converted to array of long values.</returns>
            <remarks>
                <para>If value is array of long values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each 8 bytes are converted to uint and added to
            resulting array. If value contains amount of bytes that can't be divided by 8 without
            remainder, then null is returned.</para>
                <para>If value is array of short, ushort or int values then each element of
            field value gets converted to long and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToFloatArray">
            <summary>
            Retrieves value converted to array of float values.
            </summary>
            <returns>Value converted to array of float values.</returns>
            <remarks>
                <para>If value is array of float values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each 4 bytes are converted to float and added to
            resulting array. If value contains amount of bytes that can't be divided by 4 without
            remainder, then null is returned.</para>
                <para>If value is array of double values then each element of field value gets
            converted to float and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToDoubleArray">
            <summary>
            Retrieves value converted to array of double values.
            </summary>
            <returns>Value converted to array of double values.</returns>
            <remarks>
                <para>If value is array of double values then it retrieved unaltered.</para>
                <para>If value is array of bytes then each 8 bytes are converted to double and added to
            resulting array. If value contains amount of bytes that can't be divided by 8 without
            remainder, then null is returned.</para>
                <para>If value is array of float values then each element of field value gets
            converted to double and added to resulting array.</para>
                <para>
            If value is of any other type then null is returned.</para>
            </remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PreEncode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Close">
            <summary>
            Flushes any internal data buffers and terminates current operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3Decode1D(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of G3 1D-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3Decode2D(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of G3 2D-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encode a buffer of pixels.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3DecodeRLE(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of RLE-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax4Decode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of G4-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax4Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encode the requested amount of data.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor">
            <summary>
            Codecs that want to support the Predictor tag should inherit from 
            this class instead of TiffCodec. 
            
            Such codecs should not override default TiffCodec's methods for 
            decode|encode setup and encoding|decoding of row|tile|strip. 
            Codecs with predictor support should override equivalent methods 
            provided by this class.
            
            If codec wants to provide custom tag get|set|print methods, then
            it should pass pointer to a object derived from TiffTagMethods
            as parameter to TIFFPredictorInit
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_predictor">
            <summary>
            predictor tag value
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_stride">
            <summary>
            sample stride over data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_rowSize">
            <summary>
            tile/strip row size
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_predictorType">
            <summary>
            horizontal differencer/accumulator
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreDecode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreEncode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.fpAcc(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Floating point predictor accumulation routine.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.fpDiff(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Floating point predictor differencing routine.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.PredictorDecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a scanline and apply the predictor routine.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.PredictorDecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a tile/strip and apply the predictor routine. Note that horizontal differencing
            must be done on a row-by-row basis. The width of a "row" has already been calculated
            at pre-decode time according to the strip/tile dimensions.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.ZIPEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.Seek(System.Int32)">
            <summary>
            Seeks the specified row in the strip being processed.
            </summary>
            <param name="row">The row to seek.</param>
            <returns>
                <c>true</c> if specified row was successfully found; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DumpModeEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a hunk of pixels.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DumpModeDecode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a hunk of pixels.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.JpegCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.JpegCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreDecode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreEncode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DefStripSize(System.Int32)">
            <summary>
            Calculates and/or constrains a strip size.
            </summary>
            <param name="size">The proposed strip size (may be zero or negative).</param>
            <returns>A strip size to use.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DefTileSize(System.Int32@,System.Int32@)">
            <summary>
            Calculate and/or constrains a tile size
            </summary>
            <param name="width">The proposed tile width upon the call / tile width to use after the call.</param>
            <param name="height">The proposed tile height upon the call / tile height to use after the call.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGPreEncode(System.Int16)">
            <summary>
            Set encoding state at the start of a strip or tile.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGPostEncode">
            <summary>
            Finish up at the end of a strip or tile.
            </summary>
            <returns />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGDecode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a chunk of pixels.
            "Standard" case: returned data is not downsampled.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGDecodeRaw(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a chunk of pixels. 
            Returned data is downsampled per sampling factors.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            "Standard" case: incoming data is not downsampled.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGEncodeRaw(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            Incoming data is expected to be downsampled per sampling factors.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegErrorManager">
            <summary>
            LibJpeg.Net interface layer.
            
            We handle fatal errors when they are encountered within the JPEG
            library.  We also direct LibJpeg.Net error and warning
            messages through the appropriate LibTiff.Net handlers.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegStdDestination">
            <summary>
            JPEG library destination data manager.
            These routines direct compressed data from LibJpeg.Net into the
            LibTiff.Net output buffer.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegStdSource">
            <summary>
            JPEG library source data manager.
            These routines supply compressed data to LibJpeg.Net
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegTablesDestination">
            <summary>
            Alternate destination manager for outputting to JPEGTables field.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegTablesSource">
            <summary>
            Alternate source manager for reading from JPEGTables.
            We can share all the code except for the init routine.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.LZWCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.LZWCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.LZWEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            </summary>
            <remarks>
            Uses an open addressing double hashing (no chaining) on the prefix code/next character
            combination. We do a variant of Knuth's algorithm D (vol. 3, sec. 6.4) along with
            G. Knott's relatively-prime secondary probe. Here, the modular division first probe is
            gives way to a faster exclusive-or manipulation. Also do block compression with an
            adaptive reset, whereby the code table is cleared when the compression ratio
            decreases, but after the table fills. The variable-length output codes are re-sized at
            this point, and a CODE_CLEAR is generated for the decoder. 
            </remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreDecode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreEncode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.init_source">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.fill_input_buffer">
            <summary>
            Fills input buffer
            </summary>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.skip_input_data(System.Int32)">
            <summary>
            Skip data - used to skip over a potentially large amount of
            uninteresting data (such as an APPn marker).
            </summary>
            <param name="num_bytes">The number of bytes to skip.</param>
            <remarks>Writers of suspendable-input applications must note that skip_input_data
            is not granted the right to give a suspension return.  If the skip extends
            beyond the data currently in the buffer, the buffer can be marked empty so
            that the next read will cause a fill_input_buffer call that can suspend.
            Arranging for additional bytes to be discarded before reloading the input
            buffer is the application writer's problem.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.resync_to_restart(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Int32)">
            <summary>
            This is the default resync_to_restart method for data source
            managers to use if they don't have any better approach.
            </summary>
            <param name="cinfo">An instance of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" /></param>
            <param name="desired">The desired</param>
            <returns>
                <c>false</c> if suspension is required.</returns>
            <remarks>That method assumes that no backtracking is possible.
            Some data source managers may be able to back up, or may have
            additional knowledge about the data which permits a more
            intelligent recovery strategy; such managers would
            presumably supply their own resync method.<br /><br />
            read_restart_marker calls resync_to_restart if it finds a marker other than
            the restart marker it was expecting.  (This code is *not* used unless
            a nonzero restart interval has been declared.)  cinfo.unread_marker is
            the marker code actually found (might be anything, except 0 or FF).
            The desired restart marker number (0..7) is passed as a parameter.<br /><br />
            This routine is supposed to apply whatever error recovery strategy seems
            appropriate in order to position the input stream to the next data segment.
            Note that cinfo.unread_marker is treated as a marker appearing before
            the current data-source input point; usually it should be reset to zero
            before returning.<br /><br />
            This implementation is substantially constrained by wanting to treat the
            input as a data stream; this means we can't back up.  Therefore, we have
            only the following actions to work with:<br />
            1. Simply discard the marker and let the entropy decoder resume at next
            byte of file.<br />
            2. Read forward until we find another marker, discarding intervening
            data.  (In theory we could look ahead within the current bufferload,
            without having to discard data if we don't find the desired marker.
            This idea is not implemented here, in part because it makes behavior
            dependent on buffer size and chance buffer-boundary positions.)<br />
            3. Leave the marker unread (by failing to zero cinfo.unread_marker).
            This will cause the entropy decoder to process an empty data segment,
            inserting dummy zeroes, and then we will reprocess the marker.<br />
            #2 is appropriate if we think the desired marker lies ahead, while #3 is
            appropriate if the found marker is a future restart marker (indicating
            that we have missed the desired restart marker, probably because it got
            corrupted).<br />
            We apply #2 or #3 if the found marker is a restart marker no more than
            two counts behind or ahead of the expected one.  We also apply #2 if the
            found marker is not a legal JPEG marker code (it's certainly bogus data).
            If the found marker is a restart marker more than 2 counts away, we do #1
            (too much risk that the marker is erroneous; with luck we will be able to
            resync at some future point).<br />
            For any valid non-restart JPEG marker, we apply #3.  This keeps us from
            overrunning the end of a scan.  An implementation limited to single-scan
            files might find it better to apply #2 for markers other than EOI, since
            any other marker would have to be bogus data in that case.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.term_source">
            <summary>
            Terminate source - called by jpeg_finish_decompress
            after all data has been read.  Often a no-op.
            </summary>
            <remarks>NB: <b>not</b> called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.</remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" /></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.PackBitsEncodeChunk(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a rectangular chunk of pixels. We break it up into row-sized pieces to insure
            that encoded runs do not span rows. Otherwise, there can be problems with the decoder
            if data is read, for example, by scanlines when it was encoded by strips.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB">
            <summary>
            CIE Lab 1976-&gt;RGB support
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.range">
            <summary>
            Size of conversion table
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.Yr2r">
            <summary>
            Conversion of Yr to r
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.Yg2g">
            <summary>
            Conversion of Yg to g
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.Yb2b">
            <summary>
            Conversion of Yb to b
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffDirectory">
            <summary>
            Internal format of a TIFF directory entry.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirectory.td_fieldsset">
            <summary>
            bit vector of fields that are set
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirectory.td_nstrips">
            <summary>
            size of offset and bytecount arrays
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirectory.td_stripbytecountsorted">
            <summary>
            is the bytecount array sorted ascending?
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry">
            <summary>
            TIFF Image File Directories are comprised of a table of field
            descriptors of the form shown below.  The table is sorted in
            ascending order by tag.  The values associated with each entry are
            disjoint and may appear anywhere in the file (so long as they are
            placed on a word boundary).
            
            If the value is 4 bytes or less, then it is placed in the offset
            field to save space.  If the value is less than 4 bytes, it is
            left-justified in the offset field.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry.tdir_count">
            <summary>
            number of items; length in spec
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry.tdir_offset">
            <summary>
            byte offset to field data
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry.SizeInBytes(System.Boolean)">
            <summary>
            size in bytes of the entry depending on the current format
            </summary>
            <param name="isBigTiff">if set to <c>true</c> then the bigtiff size will be returned.</param>
            <returns />
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffDisplay">
            <summary>
            Structure for holding information about a display device.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDisplay.d_mat">
            <summary>
            XYZ -&gt; luminance matrix
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.MSB2LSB">
            <summary>
            Use MSB2LSB (most significant -&gt; least) fill order
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.LSB2MSB">
            <summary>
            Use LSB2MSB (least significant -&gt; most) fill order
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.FILLORDER">
            <summary>
            natural bit fill order for machine
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.DIRTYDIRECT">
            <summary>
            current directory must be written
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.BUFFERSETUP">
            <summary>
            data buffers setup
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.CODERSETUP">
            <summary>
            encoder/decoder setup done
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.BEENWRITING">
            <summary>
            written 1+ scanlines to file
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.SWAB">
            <summary>
            byte swap file information
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.NOBITREV">
            <summary>
            inhibit bit reversal logic
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.MYBUFFER">
            <summary>
            my raw data buffer; free on close
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.ISTILED">
            <summary>
            file is tile, not strip- based
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.POSTENCODE">
            <summary>
            need call to postencode routine
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.INSUBIFD">
            <summary>
            currently writing a subifd
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.UPSAMPLED">
            <summary>
            library is doing data up-sampling
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.STRIPCHOP">
            <summary>
            enable strip chopping support
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.HEADERONLY">
            <summary>
            read header only, do not process the first directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.NOREADRAW">
            <summary>
            skip reading of raw uncompressed image data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.ISBIGTIFF">
            <summary>
            File is written in bigTiff-format.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.NOBIGTIFF">
            <summary>
            File must not be in bigTiff-format.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_magic">
            <summary>
            magic number (defines byte order)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_version">
            <summary>
            TIFF version number
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_diroff">
            <summary>
            byte offset to first directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_offsize">
            <summary>
            reperesents the size in bytes of the offsets
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_fill">
            <summary>
            constant for possibly bigtiff convert
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.TiffHeader.SizeInBytes(System.Boolean)">
            <summary>
            size in bytes of the header depending on the current format
            </summary>
            <param name="isBigTiff">if set to <c>true</c> then the bigtiff size will be returned.</param>
            <returns />
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffYCbCrToRGB">
            <summary>
            Convert color value from the YCbCr space to CIE XYZ.
            The colorspace conversion algorithm comes from the IJG v5a code;
            see below for more information on how it works.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffYCbCrToRGB.clamptab">
            <summary>
            range clamping table
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Tiff">
            <summary>
            Tag Image File Format (TIFF)
            </summary>
            <remarks>
            Based on Rev 6.0 from
            <see href="http://partners.adobe.com/asn/developer/PDFS/TN/TIFF6.pdf" target="_blank" /></remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_extender">
            <summary>
            Client Tag extension support (from Niles Ritter).
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.setupBuiltInCodecs">
            <summary>
            Compression schemes statically built into the library.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.tiffFieldInfo">
            <summary>
            NB:   THIS ARRAY IS ASSUMED TO BE SORTED BY TAG.
                  If a tag can have both LONG and SHORT types then the LONG must
                  be placed before the SHORT for writing to work properly.
                  
            NOTE: The second field (field_readcount) and third field
                  (field_writecount) sometimes use the values
                  TiffFieldInfo.Variable (-1), TiffFieldInfo.Variable2 (-3)
                  and TiffFieldInfo.Spp (-2). These values should be used but
                  would throw off the formatting of the code, so please
                  interpret the -1, -2 and -3  values accordingly.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.checkDirOffset(System.UInt64)">
            <summary>
            Checks the directory offset against the list of already seen directory
            offsets.
            </summary>
            <remarks> This is a trick to prevent IFD looping. The one can
            create TIFF file with looped directory pointers. We will maintain a
            list of already seen directories and check every IFD offset against
            that list.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchDirectory(System.UInt64,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry[]@,System.UInt64@)">
            <summary>
            Reads IFD structure from the specified offset.
            </summary>
            <returns>The number of fields in the directory or 0 if failed.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchData(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Byte[])">
            <summary>
            Fetches a contiguous directory item.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchString(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.String@)">
            <summary>
            Fetches an ASCII item from the file.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchFloat(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry)">
            <summary>
            Fetch a single floating point value from the offset field and
            return it as a native float.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchByteArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Byte[])">
            <summary>
            Fetches an array of BYTE or SBYTE values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchShortArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int16[])">
            <summary>
            Fetch an array of SHORT or SSHORT values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchLongArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int32[])">
            <summary>
            Fetches an array of LONG or SLONG values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchLong8Array(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int64[])">
            <summary>
            Fetches an array of LONG or SLONG values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchRationalArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Single[])">
            <summary>
            Fetch an array of RATIONAL or SRATIONAL values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchFloatArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Single[])">
            <summary>
            Fetches an array of FLOAT values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchDoubleArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Double[])">
            <summary>
            Fetches an array of DOUBLE values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchAnyArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Double[])">
            <summary>
            Fetches an array of ANY values.
            </summary>
            <remarks>The actual values are returned as doubles which should be
            able hold all the types. Note in particular that we assume that the
            double return value vector is large enough to read in any
            fundamental type. We use that vector as a buffer to read in the base
            type vector and then convert it in place to double (from end to
            front of course).</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchNormalTag(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry)">
            <summary>
            Fetches a tag that is not handled by special case code.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchPerSampleShorts(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int16@)">
            <summary>
            Fetches samples/pixel short values for the specified tag and verify
            that all values are the same.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchPerSampleLongs(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int32@)">
            <summary>
            Fetches samples/pixel long values for the specified tag and verify
            that all values are the same.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchPerSampleAnys(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Double@)">
            <summary>
            Fetches samples/pixel ANY values for the specified tag and verify
            that all values are the same.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchStripThing(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int32,System.Int64[]@)">
            <summary>
            Fetches a set of offsets or lengths.
            </summary>
            <remarks>While this routine says "strips", in fact it's also used
            for tiles.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchRefBlackWhite(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry)">
            <summary>
            Fetches and sets the RefBlackWhite tag.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.chopUpSingleUncompressedStrip">
            <summary>
            Replace a single strip (tile) of uncompressed data with multiple
            strips (tiles), each approximately 8Kbytes.
            </summary>
            <remarks>This is useful for dealing with large images or for
            dealing with machines with a limited amount of memory.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeDirectory(System.Boolean)">
            <summary>
            Writes the contents of the current directory to the specified file.
            </summary>
            <remarks>This routine doesn't handle overwriting a directory with
            auxiliary storage that's been changed.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeNormalTag(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,BitMiracle.LibTiff.Classic.TiffFieldInfo)">
            <summary>
            Writes tags that are not special cased.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.setupShortLong(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32)">
            <summary>
            Setups a directory entry with either a SHORT or LONG type
            according to the value.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.setupShort(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int16)">
            <summary>
            Setups a SHORT directory entry
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeShortTable(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32,System.Int16[][])">
            <summary>
            Setup a directory entry for an NxM table of shorts, where M is
            known to be 2**bitspersample, and write the associated indirect data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeByteArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Byte[])">
            <summary>
            Write/copy data associated with an ASCII or opaque tag value.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeShortArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int16[])">
            <summary>
            Setup a directory entry of an array of SHORT or SSHORT and write
            the associated indirect values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeLongArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32[])">
            <summary>
            Setup a directory entry of an array of LONG or SLONG and write the
            associated indirect values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeRationalArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Single[])">
            <summary>
            Setup a directory entry of an array of RATIONAL or SRATIONAL and
            write the associated indirect values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeAnyArray(BitMiracle.LibTiff.Classic.TiffType,BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32,System.Double[])">
            <summary>
            Writes an array of "type" values for a specified tag (i.e. this is
            a tag which is allowed to have different types, e.g. SMaxSampleType).
            Internally the data values are represented as double since a double
            can hold any of the TIFF tag types (yes, this should really be an abstract
            type tany_t for portability).  The data is converted into the specified
            type in a temporary buffer and then handed off to the appropriate array
            writer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeData(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Byte[],System.Int32)">
            <summary>
            Writes a contiguous directory item.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.linkDirectory">
            <summary>
            Link the current directory into the directory chain for the file.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.STRIPCHOP_DEFAULT">
            <summary>
            Support strip chopping (whether or not to convert single-strip 
            uncompressed images to mutiple strips of ~8Kb to reduce memory usage)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.DEFAULT_EXTRASAMPLE_AS_ALPHA">
            <summary>
            Treat extra sample as alpha (default enabled). The RGBA interface 
            will treat a fourth sample with no EXTRASAMPLE_ value as being 
            ASSOCALPHA. Many packages produce RGBA files but don't mark the 
            alpha properly.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.CHECK_JPEG_YCBCR_SUBSAMPLING">
            <summary>
            Pick up YCbCr subsampling info from the JPEG data stream to support 
            files lacking the tag (default enabled).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_name">
            <summary>
            name of open file
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_mode">
            <summary>
            open mode (O_*)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_diroff">
            <summary>
            file offset of current directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dir">
            <summary>
            internal rep of current directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_row">
            <summary>
            current scanline
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curstrip">
            <summary>
            current strip for read/write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curtile">
            <summary>
            current tile for read/write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_tilesize">
            <summary>
            # of bytes in a tile
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_scanlinesize">
            <summary>
            # of bytes in a scanline
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawdata">
            <summary>
            raw data buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawdatasize">
            <summary>
            # of bytes in raw data buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawcp">
            <summary>
            current spot in raw buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawcc">
            <summary>
            bytes unread from raw buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_clientdata">
            <summary>
            callback parameter
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_postDecodeMethod">
            <summary>
            post decoding method type
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_tagmethods">
            <summary>
            tag get/set/print routines
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_nextdiroff">
            <summary>
            file offset of following directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dirlist">
            <summary>
            list of offsets to already seen directories to prevent IFD looping
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dirlistsize">
            <summary>
            number of entires in offset list
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dirnumber">
            <summary>
            number of already seen directories
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_header">
            <summary>
            file's header block
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_typeshift">
            <summary>
            data type shift counts
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_typemask">
            <summary>
            data type masks
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curdir">
            <summary>
            current directory (index)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curoff">
            <summary>
            current offset for read/write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dataoff">
            <summary>
            current offset for writing dir
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_nsubifd">
            <summary>
            remaining subifds to write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_subifdoff">
            <summary>
            offset for patching SubIFD link
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_col">
            <summary>
            current column (offset by row too)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_fieldinfo">
            <summary>
            sorted table of registered tags
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_nfields">
            <summary>
            # entries in registered tag table
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_foundfield">
            <summary>
            cached pointer to already found tag
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_clientinfo">
            <summary>
            extra client information.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_stream">
            <summary>
            stream used for read|write|etc.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteCustomDirectory(System.Int64@)">
            <summary>
            Writes custom directory. See ticket #51.
            </summary>
            <param name="pdiroff">Output directory offset.</param>
            <returns>
                <c>true</c> if succeeded; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.postDecode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            post decoding routine
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.NOSTRIP">
            <summary>
            undefined state
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.NOTILE">
            <summary>
            undefined state
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.startStrip(System.Int32)">
            <summary>
            Set state to appear as if a strip has just been read in.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fillStrip(System.Int32)">
            <summary>
            Read the specified strip and setup for decoding.
            The data buffer is expanded, as necessary, to hold the strip's data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fillTile(System.Int32)">
            <summary>
            Read the specified tile and setup for decoding. 
            The data buffer is expanded, as necessary, to hold the tile's data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.appendToStrip(System.Int32,System.Byte[],System.Int32,System.Int64)">
            <summary>
            Appends the data to the specified strip.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Tiff.TiffExtendProc">
            <summary>
            Delegate for LibTiff.Net extender method
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <remarks>
                <para>Extender method is usually used for registering custom tags.</para>
                <para>To setup extender method that will be called upon creation of
            each instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> object please use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetTagExtender(BitMiracle.LibTiff.Classic.Tiff.TiffExtendProc)" />
            method.</para>
            </remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Tiff.FaxFillFunc">
            <summary>
            Delegate for a method used to image decoded spans.        
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="runs">The array of black and white run lengths (white then black).</param>
            <param name="thisRunOffset">The zero-based offset in <paramref name="runs" /> array at
            which current row's run begins.</param>
            <param name="nextRunOffset">The zero-based offset in <paramref name="runs" /> array at
            which next row's run begins.</param>
            <param name="width">The width in pixels of the row.</param>
            <remarks>
                <para>
            To override the default method used to image decoded spans please set
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FAXFILLFUNC" /> tag with an instance of this delegate.</para>
                <para>
            Fill methods can assume the <paramref name="runs" /> array has room for at least
            <paramref name="width" /> runs and can overwrite data in the <paramref name="runs" />
            array as needed (e.g. to append zero runs to bring the count up to a nice multiple).
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetVersion">
            <summary>
            Gets the library version string.
            </summary>
            <returns>The library version string.</returns>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Tiff.AssemblyVersion">
            <summary>
            Gets the version of the library's assembly.
            </summary>
            <value>The version of the library's assembly.</value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)">
            <summary>
            Gets the R component from ABGR value returned by 
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The R component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)">
            <summary>
            Gets the G component from ABGR value returned by 
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The G component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)">
            <summary>
            Gets the B component from ABGR value returned by 
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The B component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)">
            <summary>
            Gets the A component from ABGR value returned by 
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The A component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FindCodec(BitMiracle.LibTiff.Classic.Compression)">
            <summary>
            Retrieves the codec registered for the specified compression scheme.
            </summary>
            <param name="scheme">The compression scheme.</param>
            <returns>The codec registered for the specified compression scheme or <c>null</c>
            if there is no codec registered for the given scheme.</returns>
            <remarks>
                <para>
            LibTiff.Net supports a variety of compression schemes implemented by software codecs.
            Each codec adheres to a modular interface that provides for the decoding and encoding
            of image data; as well as some other methods for initialization, setup, cleanup, and
            the control of default strip and tile sizes. Codecs are identified by the associated
            value of the <see cref="T:BitMiracle.LibTiff.Classic.TiffTag" />.COMPRESSION tag.
            </para>
                <para>
            Other compression schemes may be registered. Registered schemes can also override the
            built-in versions provided by the library.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RegisterCodec(BitMiracle.LibTiff.Classic.TiffCodec)">
            <summary>
            Adds specified codec to a list of registered codec.
            </summary>
            <param name="codec">The codec to register.</param>
            <remarks>
            This method can be used to augment or override the set of codecs available to an
            application. If the <paramref name="codec" /> is for a scheme that already has a
            registered codec then it is overridden and any images with data encoded with this
            compression scheme will be decoded using the supplied codec.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.UnRegisterCodec(BitMiracle.LibTiff.Classic.TiffCodec)">
            <summary>
            Removes specified codec from a list of registered codecs.
            </summary>
            <param name="codec">The codec to remove from a list of registered codecs.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsCodecConfigured(BitMiracle.LibTiff.Classic.Compression)">
            <summary>
            Checks whether library has working codec for the specific compression scheme.
            </summary>
            <param name="scheme">The scheme to check.</param>
            <returns>
                <c>true</c> if the codec is configured and working; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetConfiguredCodecs">
            <summary>
            Retrieves an array of configured codecs, both built-in and registered by user.
            </summary>
            <returns>An array of configured codecs.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Realloc(System.Byte[],System.Int32)">
            <summary>
            Allocates new byte array of specified size and copies data from the existing to
            the new array.
            </summary>
            <param name="array">The existing array.</param>
            <param name="size">The number of elements in new array.</param>
            <returns>
            The new byte array of specified size with data from the existing array.
            </returns>
            <overloads>Allocates new array of specified size and copies data from the existing to
            the new array.</overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Realloc(System.Int32[],System.Int32)">
            <summary>
            Allocates new integer array of specified size and copies data from the existing to
            the new array.
            </summary>
            <param name="array">The existing array.</param>
            <param name="size">The number of elements in new array.</param>
            <returns>
            The new integer array of specified size with data from the existing array.
            </returns>
            <remarks>Size of the array is in elements, not bytes.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Compare(System.Int16[],System.Int16[],System.Int32)">
            <summary>
            Compares specified number of elements in two arrays.
            </summary>
            <param name="first">The first array to compare.</param>
            <param name="second">The second array to compare.</param>
            <param name="elementCount">The number of elements to compare.</param>
            <returns>
            The difference between compared elements or 0 if all elements are equal.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)">
            <summary>
            Initializes new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class and opens a TIFF file for
            reading or writing.
            </summary>
            <param name="fileName">The name of the file to open.</param>
            <param name="mode">The open mode. Specifies if the file is to be opened for
            reading ("r"), writing ("w"), or appending ("a") and, optionally, whether to override
            certain default aspects of library operation (see remarks).</param>
            <returns>The new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class if specified file is
            successfully opened; otherwise, <c>null</c>.</returns>
            <remarks>
                <para>
                    <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> opens a TIFF file whose name is <paramref name="fileName" />. When
            a file is opened for appending, existing data will not be touched; instead new data
            will be written as additional subfiles. If an existing file is opened for writing,
            all previous data is overwritten.
            </para>
                <para>
            If a file is opened for reading, the first TIFF directory in the file is automatically
            read (see <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)" /> for reading directories other than the first). If
            a file is opened for writing or appending, a default directory is automatically
            created for writing subsequent data. This directory has all the default values
            specified in TIFF Revision 6.0: BitsPerSample = 1, ThreshHolding = Threshold.BILEVEL
            (bilevel art scan), FillOrder = MSB2LSB (most significant bit of each data byte is
            filled first), Orientation = TOPLEFT (the 0th row represents the visual top of the
            image, and the 0th column represents the visual left hand side), SamplesPerPixel = 1,
            RowsPerStrip = infinity, ResolutionUnit = INCH, and Compression = NONE. To alter
            these values, or to define values for additional fields, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])" /> must
            be used.
            </para>
                <para>
            The <paramref name="mode" /> parameter can include the following flags in addition to
            the "r", "w", and "a" flags. Note however that option flags must follow the
            read-write-append specification.
            </para>
                <list type="table">
                    <listheader>
                        <term>Flag</term>
                        <description>Description</description>
                    </listheader>
                    <item>
                        <term>l</term>
                        <description>When creating a new file force information be written with Little-Endian
            byte order (but see below).</description>
                    </item>
                    <item>
                        <term>b</term>
                        <description>When creating a new file force information be written with Big-Endian
            byte order (but see below).</description>
                    </item>
                    <item>
                        <term>L</term>
                        <description>Force image data that is read or written to be treated with bits filled
            from Least Significant Bit (LSB) to Most Significant Bit (MSB). Note that this is the
            opposite to the way the library has worked from its inception.</description>
                    </item>
                    <item>
                        <term>B</term>
                        <description>Force image data that is read or written to be treated with bits filled
            from Most Significant Bit (MSB) to Least Significant Bit (LSB); this is the
            default.</description>
                    </item>
                    <item>
                        <term>H</term>
                        <description>Force image data that is read or written to be treated with bits filled
            in the same order as the native CPU.</description>
                    </item>
                    <item>
                        <term>C</term>
                        <description>Enable the use of "strip chopping" when reading images that are comprised
            of a single strip or tile of uncompressed data. Strip chopping is a mechanism by which
            the library will automatically convert the single-strip image to multiple strips, each
            of which has about 8 Kilobytes of data. This facility can be useful in reducing the
            amount of memory used to read an image because the library normally reads each strip
            in its entirety. Strip chopping does however alter the apparent contents of the image
            because when an image is divided into multiple strips it looks as though the
            underlying file contains multiple separate strips. The default behaviour is to enable 
            strip chopping.</description>
                    </item>
                    <item>
                        <term>c</term>
                        <description>Disable the use of strip chopping when reading images.</description>
                    </item>
                    <item>
                        <term>h</term>
                        <description>Read TIFF header only, do not load the first image directory. That could
            be useful in case of the broken first directory. We can open the file and proceed to
            the other directories.</description>
                    </item>
                </list>
                <para>
            By default the library will create new files with the native byte-order of the CPU on
            which the application is run. This ensures optimal performance and is portable to any
            application that conforms to the TIFF specification. To force the library to use a
            specific byte-order when creating a new file the "b" and "l" option flags may be
            included in the <paramref name="mode" /> parameter; for example, "wb" or "wl".</para>
                <para>The use of the "l" and "b" flags is strongly discouraged. These flags are
            provided solely because numerous vendors do not correctly support TIFF; they only
            support one of the two byte orders. It is strongly recommended that you not use this
            feature except to deal with busted apps that write invalid TIFF.</para>
                <para>The "L", "B", and "H" flags are intended for applications that can optimize
            operations on data by using a particular bit order.  By default the library returns
            data in MSB2LSB bit order. Returning data in the bit order of the native CPU makes the
            most sense but also requires applications to check the value of the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag; something they probably do not do right now.</para>
                <para>The "c" option permits applications that only want to look at the tags, for
            example, to get the unadulterated TIFF tag information.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)">
            <summary>
            Initializes new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class and opens a stream with TIFF data
            for reading or writing.
            </summary>
            <param name="name">The name for the new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <param name="mode">The open mode. Specifies if the file is to be opened for
            reading ("r"), writing ("w"), or appending ("a") and, optionally, whether to override
            certain default aspects of library operation (see remarks for <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" />
            method for the list of the mode flags).</param>
            <param name="clientData">Some client data. This data is passed as parameter to every
            method of the <see cref="T:BitMiracle.LibTiff.Classic.TiffStream" /> object specified by the
            <paramref name="stream" /> parameter.</param>
            <param name="stream">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffStream" /> class to use for
            reading, writing and seeking of TIFF data.</param>
            <returns>The new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class if stream is successfully
            opened; otherwise, <c>null</c>.</returns>
            <remarks>
                <para>
            This method can be used to read TIFF data from sources other than file. When custom
            stream class derived from <see cref="T:BitMiracle.LibTiff.Classic.TiffStream" /> is used it is possible to read (or
            write) TIFF data that reside in memory, database, etc.
            </para>
                <para>Please note, that <paramref name="name" /> is an arbitrary string used as
            ID for the created <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />. It's not required to be a file name or anything
            meaningful at all.</para>
                <para>
            Please read remarks for <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> method for the list of option flags that
            can be specified in <paramref name="mode" /> parameter.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Close">
            <summary>
            Closes a previously opened TIFF file.
            </summary>
            <remarks>
            This method closes a file or stream that was previously opened with <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" />
            or <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)" />.
            Any buffered data are flushed to the file/stream,
            including the contents of the current directory (if modified); and all resources
            are reclaimed.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Dispose">
            <summary>
            Frees and releases all resources allocated by this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetTagListCount">
            <summary>
            Gets the number of elements in the custom tag list.
            </summary>
            <returns>The number of elements in the custom tag list.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetTagListEntry(System.Int32)">
            <summary>
            Retrieves the custom tag with specified index.
            </summary>
            <param name="index">The zero-based index of a custom tag to retrieve.</param>
            <returns>The custom tag with specified index.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.MergeFieldInfo(BitMiracle.LibTiff.Classic.TiffFieldInfo[],System.Int32)">
            <summary>
            Merges given field information to existing one.
            </summary>
            <param name="info">The array of <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo" /> objects.</param>
            <param name="count">The number of items to use from the <paramref name="info" /> array.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FindFieldInfo(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.TiffType)">
            <summary>
            Retrieves field information for the specified tag.
            </summary>
            <param name="tag">The tag to retrieve field information for.</param>
            <param name="type">The tiff data type to use us additional filter.</param>
            <returns>The field information for specified tag with specified type or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FindFieldInfoByName(System.String,BitMiracle.LibTiff.Classic.TiffType)">
            <summary>
            Retrieves field information for the tag with specified name.
            </summary>
            <param name="name">The name of the tag to retrieve field information for.</param>
            <param name="type">The tiff data type to use us additional filter.</param>
            <returns>The field information for specified tag with specified type or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FieldWithTag(BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Retrieves field information for the specified tag.
            </summary>
            <param name="tag">The tag to retrieve field information for.</param>
            <returns>The field information for specified tag or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FieldWithName(System.String)">
            <summary>
            Retrieves field information for the tag with specified name.
            </summary>
            <param name="name">The name of the tag to retrieve field information for.</param>
            <returns>The field information for specified tag or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetTagMethods">
            <summary>
            Gets the currently used tag methods.
            </summary>
            <returns>The currently used tag methods.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetTagMethods(BitMiracle.LibTiff.Classic.TiffTagMethods)">
            <summary>
            Sets the new tag methods to use.
            </summary>
            <param name="methods">Tag methods.</param>
            <returns>The previously used tag methods.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetClientInfo(System.String)">
            <summary>
            Gets the extra information with specified name associated with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <param name="name">Name of the extra information to retrieve.</param>
            <returns>The extra information with specified name associated with
            this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> or <c>null</c> if extra information with specified
            name was not found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetClientInfo(System.Object,System.String)">
            <summary>
            Associates extra information with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <param name="data">The information to associate with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.</param>
            <param name="name">The name (label) of the information.</param>
            <remarks>If there is already an extra information with the name specified by
            <paramref name="name" /> it will be replaced by the information specified by
            <paramref name="data" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Flush">
            <summary>
            Flushes pending writes to an open TIFF file.
            </summary>
            <returns>
                <c>true</c> if succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush" /> causes any pending writes for the specified file
            (including writes for the current directory) to be done. In normal operation this call
            is never needed − the library automatically does any flushing required.
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.FlushData" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FlushData">
            <summary>
            Flushes any pending image data for the specified file to be written out.
            </summary>
            <returns>
                <c>true</c> if succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <see cref="M:BitMiracle.LibTiff.Classic.Tiff.FlushData" /> flushes any pending image data for the specified file
            to be written out; directory-related data are not flushed. In normal operation this
            call is never needed − the library automatically does any flushing required.
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Gets the value(s) of a tag in an open TIFF file.
            </summary>
            <param name="tag">The tag.</param>
            <returns>The value(s) of a tag in an open TIFF file as array of
            <see cref="T:BitMiracle.LibTiff.Classic.FieldValue" /> objects or <c>null</c> if there is no such tag set.</returns>
            <remarks>
                <para>
                    <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)" /> returns the value(s) of a tag or pseudo-tag associated with the
            current directory of the opened TIFF file. The tag is identified by
            <paramref name="tag" />. The type and number of values returned is dependent on the
            tag being requested. You may want to consult
            <a href="54cbd23d-dc55-44b9-921f-3a06efc2f6ce.htm">"Well-known tags and their
            value(s) data types"</a> to become familiar with exact data types and calling
            conventions required for each tag supported by the library.
            </para>
                <para>
            A pseudo-tag is a parameter that is used to control the operation of the library but
            whose value is not read or written to the underlying file.
            </para>
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.GetFieldDefaulted(BitMiracle.LibTiff.Classic.TiffTag)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetFieldDefaulted(BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Gets the value(s) of a tag in an open TIFF file or default value(s) of a tag if a tag
            is not defined in the current directory and it has a default value(s).
            </summary>
            <param name="tag">The tag.</param>
            <returns>
            The value(s) of a tag in an open TIFF file as array of
            <see cref="T:BitMiracle.LibTiff.Classic.FieldValue" /> objects or <c>null</c> if there is no such tag set and
            tag has no default value.
            </returns>
            <remarks>
                <para>
                    <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetFieldDefaulted(BitMiracle.LibTiff.Classic.TiffTag)" /> returns the value(s) of a tag or pseudo-tag associated
            with the current directory of the opened TIFF file or default value(s) of a tag if a
            tag is not defined in the current directory and it has a default value(s). The tag is
            identified by <paramref name="tag" />. The type and number of values returned is
            dependent on the tag being requested. You may want to consult
            <a href="54cbd23d-dc55-44b9-921f-3a06efc2f6ce.htm">"Well-known tags and their
            value(s) data types"</a> to become familiar with exact data types and calling
            conventions required for each tag supported by the library.
            </para>
                <para>
            A pseudo-tag is a parameter that is used to control the operation of the library but
            whose value is not read or written to the underlying file.
            </para>
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadDirectory">
            <summary>
            Reads the contents of the next TIFF directory in an open TIFF file/stream and makes
            it the current directory.
            </summary>
            <returns>
                <c>true</c> if directory was successfully read; otherwise, <c>false</c> if an
            error was encountered, or if there are no more directories to be read.</returns>
            <remarks>
                <para>Directories are read sequentially.</para>
                <para>Applications only need to call <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadDirectory" /> to read multiple
            subfiles in a single TIFF file/stream - the first directory in a file/stream is
            automatically read when <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)" /> is called.
            </para>
                <para>
            The images that have a single uncompressed strip or tile of data are automatically
            treated as if they were made up of multiple strips or tiles of approximately 8
            kilobytes each. This operation is done only in-memory; it does not alter the contents
            of the file/stream. However, the construction of the "chopped strips" is visible to
            the application through the number of strips returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfStrips" />
            or the number of tiles returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfTiles" />.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadCustomDirectory(System.Int64,BitMiracle.LibTiff.Classic.TiffFieldInfo[],System.Int32)">
            <summary>
            Reads a custom directory from the arbitrary offset within file/stream.
            </summary>
            <param name="offset">The directory offset.</param>
            <param name="info">The array of <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo" /> objects to read from
            custom directory. Standard <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo" /> objects are ignored.</param>
            <param name="count">The number of items to use from
            the <paramref name="info" /> array.</param>
            <returns>
                <c>true</c> if a custom directory was read successfully;
            otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadEXIFDirectory(System.Int64)">
            <summary>
            Reads an EXIF directory from the given offset within file/stream.
            </summary>
            <param name="offset">The directory offset.</param>
            <returns>
                <c>true</c> if an EXIF directory was read successfully; 
            otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize">
            <summary>
            Calculates the size in bytes of a row of data as it would be returned in a call to
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadScanline" />, or as it would be
            expected in a call to <see cref="O:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" />.
            </summary>
            <returns>The size in bytes of a row of data.</returns>
            <remarks>
                <b>ScanlineSize</b> calculates size for one sample plane only. Please use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RasterScanlineSize" /> if you want to get size in bytes of a complete
            decoded and packed raster scanline.</remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RasterScanlineSize" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RasterScanlineSize">
            <summary>
            Calculates the size in bytes of a complete decoded and packed raster scanline.
            </summary>
            <returns>The size in bytes of a complete decoded and packed raster scanline.</returns>
            <remarks>The value returned by <b>RasterScanlineSize</b> may be different from the
            value returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize" /> if data is stored as separate
            planes (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.DefaultStripSize(System.Int32)">
            <summary>
            Computes the number of rows for a reasonable-sized strip according to the current
            settings of the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH" />, <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" />
            and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLESPERPIXEL" /> tags and any compression-specific requirements.
            </summary>
            <param name="estimate">The esimated value (may be zero).</param>
            <returns>The number of rows for a reasonable-sized strip according to the current
            tag settings and compression-specific requirements.</returns>
            <remarks>If the <paramref name="estimate" /> parameter is non-zero, then it is taken
            as an estimate of the desired strip size and adjusted according to any
            compression-specific requirements. The value returned by <b>DefaultStripSize</b> is
            typically used to define the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP" /> tag. If there is no
            any unusual requirements <b>DefaultStripSize</b> tries to create strips that have
            approximately 8 kilobytes of uncompressed data.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.StripSize">
            <summary>
            Computes the number of bytes in a row-aligned strip.
            </summary>
            <returns>The number of bytes in a row-aligned strip</returns>
            <remarks>
                <para>
                    <b>StripSize</b> returns the equivalent size for a strip of data as it would be
            returned in a call to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)" /> or as it would be expected in a
            call to <see cref="O:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedStrip" />.
            </para>
                <para>
            If the value of the field corresponding to <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP" /> is
            larger than the recorded <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />, then the strip size is
            truncated to reflect the actual space required to hold the strip.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.VStripSize(System.Int32)">
            <summary>
            Computes the number of bytes in a row-aligned strip with specified number of rows.
            </summary>
            <param name="rowCount">The number of rows in a strip.</param>
            <returns>
            The number of bytes in a row-aligned strip with specified number of rows.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RawStripSize(System.Int32)">
            <summary>
            Computes the number of bytes in a raw (i.e. not decoded) strip.
            </summary>
            <param name="strip">The zero-based index of a strip.</param>
            <returns>The number of bytes in a raw strip.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)">
            <summary>
            Computes which strip contains the specified coordinates (row, plane).
            </summary>
            <param name="row">The row.</param>
            <param name="plane">The sample plane.</param>
            <returns>The number of the strip that contains the specified coordinates.</returns>
            <remarks>
            A valid strip number is always returned; out-of-range coordinate values are clamped to
            the bounds of the image. The <paramref name="row" /> parameter is always used in
            calculating a strip. The <paramref name="plane" /> parameter is used only if data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfStrips">
            <summary>
            Retrives the number of strips in the image.
            </summary>
            <returns>The number of strips in the image.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.DefaultTileSize(System.Int32@,System.Int32@)">
            <summary>
            Computes the pixel width and height of a reasonable-sized tile suitable for setting
            up the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILEWIDTH" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILELENGTH" /> tags.
            </summary>
            <param name="width">The proposed tile width upon the call / tile width to use
            after the call.</param>
            <param name="height">The proposed tile height upon the call / tile height to use
            after the call.</param>
            <remarks>If the <paramref name="width" /> and <paramref name="height" /> values passed
            in are non-zero, then they are adjusted to reflect any compression-specific
            requirements. The returned width and height are constrained to be a multiple of
            16 pixels to conform with the TIFF specification.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.TileSize">
            <summary>
            Compute the number of bytes in a row-aligned tile.
            </summary>
            <returns>The number of bytes in a row-aligned tile.</returns>
            <remarks>
                <b>TileSize</b> returns the equivalent size for a tile of data as it would be
            returned in a call to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)" /> or as it would be expected in a
            call to <see cref="O:BitMiracle.LibTiff.Classic.Tiff.WriteTile" />.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.VTileSize(System.Int32)">
            <summary>
            Computes the number of bytes in a row-aligned tile with specified number of rows.
            </summary>
            <param name="rowCount">The number of rows in a tile.</param>
            <returns>
            The number of bytes in a row-aligned tile with specified number of rows.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RawTileSize(System.Int32)">
            <summary>
            Computes the number of bytes in a raw (i.e. not decoded) tile.
            </summary>
            <param name="tile">The zero-based index of a tile.</param>
            <returns>The number of bytes in a raw tile.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.TileRowSize">
            <summary>
            Compute the number of bytes in each row of a tile.
            </summary>
            <returns>The number of bytes in each row of a tile.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Computes which tile contains the specified coordinates (x, y, z, plane).
            </summary>
            <param name="x">The x-coordinate.</param>
            <param name="y">The y-coordinate.</param>
            <param name="z">The z-coordinate.</param>
            <param name="plane">The sample plane.</param>
            <returns>The number of the tile that contains the specified coordinates.</returns>
            <remarks>
            A valid tile number is always returned; out-of-range coordinate values are
            clamped to the bounds of the image. The <paramref name="x" /> and <paramref name="y" />
            parameters are always used in calculating a tile. The <paramref name="z" /> parameter
            is used if the image is deeper than 1 slice (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH" /> &gt; 1).
            The <paramref name="plane" /> parameter is used only if data are organized in separate
            planes (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CheckTile(System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Checks whether the specified (x, y, z, plane) coordinates are within the bounds of
            the image.
            </summary>
            <param name="x">The x-coordinate.</param>
            <param name="y">The y-coordinate.</param>
            <param name="z">The z-coordinate.</param>
            <param name="plane">The sample plane.</param>
            <returns>
                <c>true</c> if the specified coordinates are within the bounds of the image;
            otherwise, <c>false</c>.</returns>
            <remarks>The <paramref name="x" /> parameter is checked against the value of the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH" /> tag. The <paramref name="y" /> parameter is checked
            against the value of the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag. The <paramref name="z" />
            parameter is checked against the value of the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH" /> tag
            (if defined). The <paramref name="plane" /> parameter is checked against the value of
            the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLESPERPIXEL" /> tag if the data are organized in separate
            planes.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfTiles">
            <summary>
            Retrives the number of tiles in the image.
            </summary>
            <returns>The number of tiles in the image.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Clientdata">
            <summary>
            Returns the custom client data associated with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <returns>The custom client data associated with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetClientdata(System.Object)">
            <summary>
            Asscociates a custom data with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <param name="data">The data to associate.</param>
            <returns>The previously associated data.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetMode">
            <summary>
            Gets the mode with which the underlying file or stream was opened.
            </summary>
            <returns>The mode with which the underlying file or stream was opened.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetMode(System.Int32)">
            <summary>
            Sets the new mode for the underlying file or stream.
            </summary>
            <param name="mode">The new mode for the underlying file or stream.</param>
            <returns>The previous mode with which the underlying file or stream was opened.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled">
            <summary>
            Gets the value indicating whether the image data of this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> has a
            tiled organization.
            </summary>
            <returns>
                <c>true</c> if the image data of this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> has a tiled organization or
            <c>false</c> if the image data of this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> is organized in strips.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsByteSwapped">
            <summary>
            Gets the value indicating whether the image data was in a different byte-order than
            the host computer.
            </summary>
            <returns>
                <c>true</c> if the image data was in a different byte-order than the host
            computer or <c>false</c> if the TIFF file/stream and local host byte-orders are the
            same.</returns>
            <remarks>
                <para>
            Note that <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedTile(System.Int32,System.Byte[],System.Int32,System.Int32)" />,
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)" /> and
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadScanline" /> methods already
            normally perform byte swapping to local host order if needed.
            </para>
                <para>
            Also note that <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawTile(System.Int32,System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawStrip(System.Int32,System.Byte[],System.Int32,System.Int32)" /> do not
            perform byte swapping to local host order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsUpSampled">
            <summary>
            Gets the value indicating whether the image data returned through the read interface
            methods is being up-sampled.
            </summary>
            <returns>
                <c>true</c> if the data is returned up-sampled; otherwise, <c>false</c>.
            </returns>
            <remarks>The value returned by this method can be useful to applications that want to
            calculate I/O buffer sizes to reflect this usage (though the usual strip and tile size
            routines already do this).</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsMSB2LSB">
            <summary>
            Gets the value indicating whether the image data is being returned in MSB-to-LSB
            bit order.
            </summary>
            <returns>
                <c>true</c> if the data is being returned in MSB-to-LSB bit order (i.e with bit 0 as
            the most significant bit); otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsBigEndian">
            <summary>
            Gets the value indicating whether given image data was written in big-endian order.
            </summary>
            <returns>
                <c>true</c> if given image data was written in big-endian order; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetStream">
            <summary>
            Gets the tiff stream.
            </summary>
            <returns>The tiff stream.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentRow">
            <summary>
            Gets the current row that is being read or written.
            </summary>
            <returns>The current row that is being read or written.</returns>
            <remarks>The current row is updated each time a read or write is done.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentDirectory">
            <summary>
            Gets the zero-based index of the current directory.
            </summary>
            <returns>The zero-based index of the current directory.</returns>
            <remarks>The zero-based index returned by this method is suitable for use with
            the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)" /> method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfDirectories">
            <summary>
            Gets the number of directories in a file.
            </summary>
            <returns>The number of directories in a file.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentDirOffset">
            <summary>
            Retrieves the file/stream offset of the current directory.
            </summary>
            <returns>The file/stream offset of the current directory.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentStrip">
            <summary>
            Gets the current strip that is being read or written.
            </summary>
            <returns>The current strip that is being read or written.</returns>
            <remarks>The current strip is updated each time a read or write is done.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentTile">
            <summary>
            Gets the current tile that is being read or written.
            </summary>
            <returns>The current tile that is being read or written.</returns>
            <remarks>The current tile is updated each time a read or write is done.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadBufferSetup(System.Byte[],System.Int32)">
            <summary>
            Sets up the data buffer used to read raw (encoded) data from a file.
            </summary>
            <param name="buffer">The data buffer.</param>
            <param name="size">The buffer size.</param>
            <remarks>
                <para>
            This method is provided for client-control of the I/O buffers used by the library.
            Applications need never use this method; it's provided only for "intelligent clients"
            that wish to optimize memory usage and/or eliminate potential copy operations that can
            occur when working with images that have data stored without compression.
            </para>
                <para>
            If the <paramref name="buffer" /> is <c>null</c>, then a buffer of appropriate size is
            allocated by the library. Otherwise, the caller must guarantee that the buffer is
            large enough to hold any individual strip of raw data.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteBufferSetup(System.Byte[],System.Int32)">
            <summary>
            Sets up the data buffer used to write raw (encoded) data to a file.
            </summary>
            <param name="buffer">The data buffer.</param>
            <param name="size">The buffer size.</param>
            <remarks>
                <para>
            This method is provided for client-control of the I/O buffers used by the library.
            Applications need never use this method; it's provided only for "intelligent clients"
            that wish to optimize memory usage and/or eliminate potential copy operations that can
            occur when working with images that have data stored without compression.
            </para>
                <para>
            If the <paramref name="size" /> is -1 then the buffer size is selected to hold a
            complete tile or strip, or at least 8 kilobytes, whichever is greater. If the
            <paramref name="buffer" /> is <c>null</c>, then a buffer of appropriate size is
            allocated by the library.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetupStrips">
            <summary>
            Setups the strips.
            </summary>
            <returns>
                <c>true</c> if setup successfully; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteCheck(System.Boolean,System.String)">
            <summary>
            Verifies that file/stream is writable and that the directory information is
            setup properly.
            </summary>
            <param name="tiles">If set to <c>true</c> then ability to write tiles will be verified;
            otherwise, ability to write strips will be verified.</param>
            <param name="method">The name of the calling method.</param>
            <returns>
                <c>true</c> if file/stream is writeable and the directory information is
            setup properly; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FreeDirectory">
            <summary>
            Releases storage associated with current directory.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CreateDirectory">
            <summary>
            Creates a new directory within file/stream.
            </summary>
            <remarks>The newly created directory will not exist on the file/stream till
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.CheckpointDirectory" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush" />
            or <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Close" /> is called.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.LastDirectory">
            <summary>
            Returns an indication of whether the current directory is the last directory
            in the file.
            </summary>
            <returns>
                <c>true</c> if current directory is the last directory in the file;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)">
            <summary>
            Sets the directory with specified number as the current directory.
            </summary>
            <param name="number">The zero-based number of the directory to set as the
            current directory.</param>
            <returns>
                <c>true</c> if the specified directory was set as current successfully;
            otherwise, <c>false</c></returns>
            <remarks>
                <b>SetDirectory</b> changes the current directory and reads its contents with
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadDirectory" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetSubDirectory(System.Int64)">
            <summary>
            Sets the directory at specified file/stream offset as the current directory.
            </summary>
            <param name="offset">The offset from the beginnig of the file/stream to the directory
            to set as the current directory.</param>
            <returns>
                <c>true</c> if the directory at specified file offset was set as current
            successfully; otherwise, <c>false</c></returns>
            <remarks>
                <b>SetSubDirectory</b> acts like <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)" />, except the
            directory is specified as a file offset instead of an index; this is required for
            accessing subdirectories linked through a SubIFD tag (e.g. thumbnail images).</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.UnlinkDirectory(System.Int16)">
            <summary>
            Unlinks the specified directory from the directory chain.
            </summary>
            <param name="number">The zero-based number of the directory to unlink.</param>
            <returns>
                <c>true</c> if directory was unlinked successfully; otherwise, <c>false</c>.</returns>
            <remarks>
                <b>UnlinkDirectory</b> does not removes directory bytes from the file/stream.
            It only makes them unused.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])">
            <summary>
            Sets the value(s) of a tag in a TIFF file/stream open for writing.
            </summary>
            <param name="tag">The tag.</param>
            <param name="value">The tag value(s).</param>
            <returns>
                <c>true</c> if tag value(s) were set successfully; otherwise, <c>false</c>.</returns>
            <remarks>
                <para>
                    <b>SetField</b> sets the value of a tag or pseudo-tag in the current directory
            associated with the open TIFF file/stream. To set the value of a field the file/stream
            must have been previously opened for writing with <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)" />;
            pseudo-tags can be set whether the file was opened for
            reading or writing. The tag is identified by <paramref name="tag" />.
            The type and number of values in <paramref name="value" /> is dependent on the tag
            being set. You may want to consult
            <a href="54cbd23d-dc55-44b9-921f-3a06efc2f6ce.htm">"Well-known tags and their
            value(s) data types"</a> to become familiar with exact data types and calling
            conventions required for each tag supported by the library.
            </para>
                <para>
            A pseudo-tag is a parameter that is used to control the operation of the library but
            whose value is not read or written to the underlying file.
            </para>
                <para>
            The field will be written to the file when/if the directory structure is updated.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory">
            <summary>
            Writes the contents of the current directory to the file and setup to create a new
            subfile (page) in the same file.
            </summary>
            <returns>
                <c>true</c> if the current directory was written successfully;
            otherwise, <c>false</c></returns>
            <remarks>Applications only need to call <b>WriteDirectory</b> when writing multiple
            subfiles (pages) to a single TIFF file. <b>WriteDirectory</b> is automatically called
            by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Close" /> and <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush" /> to write a modified directory if the
            file is open for writing.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CheckpointDirectory">
            <summary>
            Writes the current state of the TIFF directory into the file to make what is currently
            in the file/stream readable.
            </summary>
            <returns>
                <c>true</c> if the current directory was rewritten successfully;
            otherwise, <c>false</c></returns>
            <remarks>Unlike <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory" />, <b>CheckpointDirectory</b> does not free
            up the directory data structures in memory, so they can be updated (as strips/tiles
            are written) and written again. Reading such a partial file you will at worst get a
            TIFF read error for the first strip/tile encountered that is incomplete, but you will
            at least get all the valid data in the file before that. When the file is complete,
            just use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory" /> as usual to finish it off cleanly.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RewriteDirectory">
            <summary>
            Rewrites the contents of the current directory to the file and setup to create a new
            subfile (page) in the same file.
            </summary>
            <returns>
                <c>true</c> if the current directory was rewritten successfully;
            otherwise, <c>false</c></returns>
            <remarks>The <b>RewriteDirectory</b> operates similarly to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory" />,
            but can be called with directories previously read or written that already have an
            established location in the file. It will rewrite the directory, but instead of place
            it at it's old location (as <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory" /> would) it will place them at
            the end of the file, correcting the pointer from the preceeding directory or file
            header to point to it's new location. This is particularly important in cases where
            the size of the directory and pointed to data has grown, so it won’t fit in the space
            available at the old location. Note that this will result in the loss of the 
            previously used directory space.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.PrintDirectory(System.IO.Stream)">
            <summary>
            Prints formatted description of the contents of the current directory to the
            specified stream.
            </summary>
            <overloads>
            Prints formatted description of the contents of the current directory to the
            specified stream possibly using specified print options.
            </overloads>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.PrintDirectory(System.IO.Stream,BitMiracle.LibTiff.Classic.TiffPrintFlags)">
            <summary>
            Prints formatted description of the contents of the current directory to the
            specified stream using specified print (formatting) options.
            </summary>
            <param name="stream">The stream.</param>
            <param name="flags">The print (formatting) options.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32)">
            <summary>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </summary>
            <overloads>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </overloads>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="row">The zero-based index of scanline (row) to read.</param>
            <returns>
                <c>true</c> if image data were read and decoded successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>ReadScanline</b> reads the data for the specified <paramref name="row" /> into the
            user supplied data buffer <paramref name="buffer" />. The data are returned
            decompressed and, in the native byte- and bit-ordering, but are otherwise packed
            (see further below). The <paramref name="buffer" /> must be large enough to hold an
            entire scanline of data. Applications should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize" />
            to find out the size (in bytes) of a scanline buffer. Applications should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int16)" /> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int32,System.Int16)" /> and specify correct sample plane if
            image data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            </para>
                <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="row">The zero-based index of scanline (row) to read.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
                <c>true</c> if image data were read and decoded successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>ReadScanline</b> reads the data for the specified <paramref name="row" /> and
            specified sample plane <paramref name="plane" /> into the user supplied data buffer
            <paramref name="buffer" />. The data are returned decompressed and, in the native
            byte- and bit-ordering, but are otherwise packed (see further below). The
            <paramref name="buffer" /> must be large enough to hold an entire scanline of data.
            Applications should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize" /> to find out the size (in
            bytes) of a scanline buffer. Applications may use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32)" /> or specify 0 for <paramref name="plane" />
            parameter if image data is contiguous (i.e not organized in separate planes, 
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG).
            </para>
                <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin storing read and decoded bytes.</param>
            <param name="row">The zero-based index of scanline (row) to read.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
                <c>true</c> if image data were read and decoded successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>ReadScanline</b> reads the data for the specified <paramref name="row" /> and
            specified sample plane <paramref name="plane" /> into the user supplied data buffer
            <paramref name="buffer" />. The data are returned decompressed and, in the native
            byte- and bit-ordering, but are otherwise packed (see further below). The
            <paramref name="buffer" /> must be large enough to hold an entire scanline of data.
            Applications should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize" /> to find out the size (in
            bytes) of a scanline buffer. Applications may use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32)" /> or specify 0 for <paramref name="plane" />
            parameter if image data is contiguous (i.e not organized in separate planes,
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG).
            </para>
                <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32)">
            <summary>
            Encodes and writes a scanline of data to an open TIFF file/stream.
            </summary>
            <overloads>Encodes and writes a scanline of data to an open TIFF file/stream.</overloads>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="row">The zero-based index of scanline (row) to place encoded data at.</param>
            <returns>
                <c>true</c> if image data were encoded and written successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>WriteScanline</b> encodes and writes to a file at the specified
            <paramref name="row" />. Applications should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int16)" /> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int32,System.Int16)" /> and specify correct sample plane
            parameter if image data in a file/stream is organized in separate planes (i.e
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            </para>
                <para>
            The data are assumed to be uncompressed and in the native bit- and byte-order of the
            host machine. The data written to the file is compressed according to the compression
            scheme of the current TIFF directory (see further below). If the current scanline is
            past the end of the current subfile, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the scanline (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8. The library attempts to hide bit-ordering differences between the image and
            the native machine by converting data from the native machine order.
            </para>
                <para>
            Once data are written to a file/stream for the current directory, the values of
            certain tags may not be altered; see
            <a href="54cbd23d-dc55-44b9-921f-3a06efc2f6ce.htm">"Well-known tags and their
            value(s) data types"</a> for more information.
            </para>
                <para>
            It is not possible to write scanlines to a file/stream that uses a tiled organization.
            The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled" /> can be used to determine if the file/stream is organized as
            tiles or strips.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Encodes and writes a scanline of data to an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="row">The zero-based index of scanline (row) to place encoded data at.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
                <c>true</c> if image data were encoded and written successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>WriteScanline</b> encodes and writes to a file at the specified
            <paramref name="row" /> and specified sample plane <paramref name="plane" />.
            Applications may use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32)" /> or specify 0 for
            <paramref name="plane" /> parameter if image data in a file/stream is contiguous (i.e
            not organized in separate planes,
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG).
            </para>
                <para>
            The data are assumed to be uncompressed and in the native bit- and byte-order of the
            host machine. The data written to the file is compressed according to the compression
            scheme of the current TIFF directory (see further below). If the current scanline is
            past the end of the current subfile, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the scanline (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8. The library attempts to hide bit-ordering differences between the image and
            the native machine by converting data from the native machine order.
            </para>
                <para>
            Once data are written to a file/stream for the current directory, the values of
            certain tags may not be altered; see
            <a href="54cbd23d-dc55-44b9-921f-3a06efc2f6ce.htm">"Well-known tags and their
            value(s) data types"</a> for more information.
            </para>
                <para>
            It is not possible to write scanlines to a file/stream that uses a tiled organization.
            The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled" /> can be used to determine if the file/stream is organized as
            tiles or strips.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes and writes a scanline of data to an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes.</param>
            <param name="row">The zero-based index of scanline (row) to place encoded data at.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
                <c>true</c> if image data were encoded and written successfully; otherwise, <c>false</c></returns>
            <remarks>
                <para>
                    <b>WriteScanline</b> encodes and writes to a file at the specified
            <paramref name="row" /> and specified sample plane <paramref name="plane" />.
            Applications may use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32)" /> or specify 0 for
            <paramref name="plane" /> parameter if image data in a file/stream is contiguous (i.e
            not organized in separate planes,
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG).
            </para>
                <para>
            The data are assumed to be uncompressed and in the native bit- and byte-order of the
            host machine. The data written to the file is compressed according to the compression
            scheme of the current TIFF directory (see further below). If the current scanline is
            past the end of the current subfile, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the scanline (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8. The library attempts to hide bit-ordering differences between the image and
            the native machine by converting data from the native machine order.
            </para>
                <para>
            Once data are written to a file/stream for the current directory, the values of
            certain tags may not be altered; see 
            <a href="54cbd23d-dc55-44b9-921f-3a06efc2f6ce.htm">"Well-known tags and their
            value(s) data types"</a> for more information.
            </para>
                <para>
            It is not possible to write scanlines to a file/stream that uses a tiled organization.
            The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled" /> can be used to determine if the file/stream is organized as
            tiles or strips.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Reads the image and decodes it into RGBA format raster.
            </summary>
            <overloads>
            Reads the image and decodes it into RGBA format raster.
            </overloads>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <returns>
                <c>true</c> if the image was successfully read and converted; otherwise,
            <c>false</c> is returned if an error was encountered.</returns>
            <remarks>
                <para>
                    <b>ReadRGBAImage</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster" />. The raster is assumed to
            be an array of <paramref name="width" /> times <paramref name="height" /> 32-bit entries,
            where <paramref name="width" /> must be less than or equal to the width of the image
            (<paramref name="height" /> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data are placed in the lower
            part of the raster. Note that the raster is assumed to be organized such that the
            pixel at location (x, y) is <paramref name="raster" />[y * width + x]; with the raster
            origin in the lower-left hand corner. Please use
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" /> if you
            want to specify another raster origin.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
                    <b>ReadRGBAImage</b> converts non-8-bit images by scaling sample values. Palette,
            grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently. Raster
            pixels are returned uncorrected by any colorimetry information present in the directory.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBAImage</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage(System.Int32,System.Int32,System.Int32[],System.Boolean)">
            <summary>
            Reads the image and decodes it into RGBA format raster.
            </summary>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="stopOnError">if set to <c>true</c> then an error will terminate the
            operation; otherwise method will continue processing data until all the possible data
            in the image have been requested.</param>
            <returns>
                <c>true</c> if the image was successfully read and converted; otherwise, <c>false</c>
            is returned if an error was encountered and stopOnError is <c>false</c>.
            </returns>
            <remarks>
                <para>
                    <b>ReadRGBAImage</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster" />. The raster is assumed to
            be an array of <paramref name="width" /> times <paramref name="height" /> 32-bit entries,
            where <paramref name="width" /> must be less than or equal to the width of the image
            (<paramref name="height" /> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data are placed in the lower
            part of the raster. Note that the raster is assumed to be organized such that the
            pixel at location (x, y) is <paramref name="raster" />[y * width + x]; with the raster
            origin in the lower-left hand corner. Please use
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" /> if you
            want to specify another raster origin.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
                    <b>ReadRGBAImage</b> converts non-8-bit images by scaling sample values. Palette,
            grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently. Raster
            pixels are returned uncorrected by any colorimetry information present in the directory.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBAImage</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented(System.Int32,System.Int32,System.Int32[],BitMiracle.LibTiff.Classic.Orientation)">
            <summary>
            Reads the image and decodes it into RGBA format raster using specified raster origin.
            </summary>
            <overloads>
            Reads the image and decodes it into RGBA format raster using specified raster origin.
            </overloads>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="orientation">The raster origin position.</param>
            <returns>
                <c>true</c> if the image was successfully read and converted; otherwise, <c>false</c>
            is returned if an error was encountered.
            </returns>
            <remarks>
                <para>
                    <b>ReadRGBAImageOriented</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster" />. The raster is assumed to
            be an array of <paramref name="width" /> times <paramref name="height" /> 32-bit entries,
            where <paramref name="width" /> must be less than or equal to the width of the image
            (<paramref name="height" /> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data placement depends on
            <paramref name="orientation" />. Note that the raster is assumed to be organized such
            that the pixel at location (x, y) is <paramref name="raster" />[y * width + x]; with
            the raster origin specified by <paramref name="orientation" /> parameter.
            </para>
                <para>
            When <b>ReadRGBAImageOriented</b> is used with <see cref="T:BitMiracle.LibTiff.Classic.Orientation" />.BOTLEFT for
            the <paramref name="orientation" /> the produced result is the same as retuned by
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
                    <b>ReadRGBAImageOriented</b> converts non-8-bit images by scaling sample values.
            Palette, grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently.
            Raster pixels are returned uncorrected by any colorimetry information present in
            the directory.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBAImageOriented</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented(System.Int32,System.Int32,System.Int32[],BitMiracle.LibTiff.Classic.Orientation,System.Boolean)">
            <summary>
            Reads the image and decodes it into RGBA format raster using specified raster origin.
            </summary>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="orientation">The raster origin position.</param>
            <param name="stopOnError">if set to <c>true</c> then an error will terminate the
            operation; otherwise method will continue processing data until all the possible data
            in the image have been requested.</param>
            <returns>
                <c>true</c> if the image was successfully read and converted; otherwise, <c>false</c>
            is returned if an error was encountered and stopOnError is <c>false</c>.
            </returns>
            <remarks>
                <para>
                    <b>ReadRGBAImageOriented</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster" />. The raster is assumed to
            be an array of <paramref name="width" /> times <paramref name="height" /> 32-bit entries,
            where <paramref name="width" /> must be less than or equal to the width of the image
            (<paramref name="height" /> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data placement depends on
            <paramref name="orientation" />. Note that the raster is assumed to be organized such
            that the pixel at location (x, y) is <paramref name="raster" />[y * width + x]; with
            the raster origin specified by <paramref name="orientation" /> parameter.
            </para>
                <para>
            When <b>ReadRGBAImageOriented</b> is used with <see cref="T:BitMiracle.LibTiff.Classic.Orientation" />.BOTLEFT for
            the <paramref name="orientation" /> the produced result is the same as retuned by
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
                    <b>ReadRGBAImageOriented</b> converts non-8-bit images by scaling sample values.
            Palette, grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently.
            Raster pixels are returned uncorrected by any colorimetry information present in
            the directory.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBAImageOriented</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])">
            <summary>
            Reads a whole strip of a strip-based image, decodes it and converts it to RGBA format.
            </summary>
            <param name="row">The row.</param>
            <param name="raster">The RGBA raster.</param>
            <returns>
                <c>true</c> if the strip was successfully read and converted; otherwise,
            <c>false</c></returns>
            <remarks>
                <para>
                    <b>ReadRGBAStrip</b> reads a single strip of a strip-based image into memory, storing
            the result in the user supplied RGBA <paramref name="raster" />. If specified strip is
            the last strip, then it will only contain the portion of the strip that is actually
            within the image space. The raster is assumed to be an array of width times
            rowsperstrip 32-bit entries, where width is the width of the image
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH" />) and rowsperstrip is the maximum lines in a strip
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP" />).
            </para>
                <para>
            The <paramref name="row" /> value should be the row of the first row in the strip
            (strip * rowsperstrip, zero based).
            </para>
                <para>
            Note that the raster is assumed to be organized such that the pixel at location (x, y)
            is <paramref name="raster" />[y * width + x]; with the raster origin in the lower-left
            hand corner of the strip. That is bottom to top organization. When reading a partial
            last strip in the file the last line of the image will begin at the beginning of
            the buffer.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
            See <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> for more details on how various image types are
            converted to RGBA values.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBAStrip</b>'s main advantage over the similar
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" /> function is that for
            large images a single buffer capable of holding the whole image doesn't need to be
            allocated, only enough for one strip. The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" /> function does a
            similar operation for tiled images.
            </para>
                <para>
                    <b>ReadRGBAStrip</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />
            <seealso cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Reads a whole tile of a tile-based image, decodes it and converts it to RGBA format.
            </summary>
            <param name="col">The column.</param>
            <param name="row">The row.</param>
            <param name="raster">The RGBA raster.</param>
            <returns>
                <c>true</c> if the strip was successfully read and converted; otherwise,
            <c>false</c></returns>
            <remarks>
                <para>
                    <b>ReadRGBATile</b> reads a single tile of a tile-based image into memory,
            storing the result in the user supplied RGBA <paramref name="raster" />. The raster is
            assumed to be an array of width times length 32-bit entries, where width is the width
            of the tile (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILEWIDTH" />) and length is the height of a tile
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILELENGTH" />).
            </para>
                <para>
            The <paramref name="col" /> and <paramref name="row" /> values are the offsets from the
            top left corner of the image to the top left corner of the tile to be read. They must
            be an exact multiple of the tile width and length.
            </para>
                <para>
            Note that the raster is assumed to be organized such that the pixel at location (x, y)
            is <paramref name="raster" />[y * width + x]; with the raster origin in the lower-left
            hand corner of the tile. That is bottom to top organization. Edge tiles which partly
            fall off the image will be filled out with appropriate zeroed areas.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
            See <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> for more details on how various image types are
            converted to RGBA values.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
                    <b>ReadRGBATile</b>'s main advantage over the similar
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" /> function is that for
            large images a single buffer capable of holding the whole image doesn't need to be
            allocated, only enough for one tile. The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" /> function does a
            similar operation for stripped images.
            </para>
                <para>
                    <b>ReadRGBATile</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> facilities.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
            <seealso cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />
            <seealso cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" />
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)">
            <summary>
            Check the image to see if it can be converted to RGBA format.
            </summary>
            <param name="errorMsg">The error message (if any) gets placed here.</param>
            <returns>
                <c>true</c> if the image can be converted to RGBA format; otherwise,
            <c>false</c> is returned and <paramref name="errorMsg" /> contains the reason why it
            is being rejected.</returns>
            <remarks>
                <para>
            To convert the image to RGBA format please use
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage" />,
            <see cref="O:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented" />,
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])" /> or <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])" /></para>
                <para>
            Convertible images should follow this rules: samples must be either 1, 2, 4, 8, or
            16 bits; colorimetric samples/pixel must be either 1, 3, or 4 (i.e. SamplesPerPixel
            minus ExtraSamples).</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FileName">
            <summary>
            Gets the name of the file or ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <returns>The name of the file or ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.</returns>
            <remarks>If this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> was created using <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> method then
            value of fileName parameter of <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)" /> method is returned. If this
            <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> was created using
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)" />
            then value of name parameter of
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)" />
            method is returned.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetFileName(System.String)">
            <summary>
            Sets the new ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
            <param name="name">The ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.</param>
            <returns>The previous file name or ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.</returns>
            <remarks>Please note, that <paramref name="name" /> is an arbitrary string used as
            ID for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />. It's not required to be a file name or anything
            meaningful at all.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Error(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
                <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" />.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Error(System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
                <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ErrorExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="clientData">The client data to be passed to error handler.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything you want. It will be passed
            unchanged to the error handler. Default error handler does not use it. Only custom
            error handlers may make use of it.
            </para>
                <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" /> and passes client data to the error handler.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ErrorExt(System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="clientData">The client data to be passed to error handler.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything you want. It will be passed
            unchanged to the error handler. Default error handler does not use it. Only custom
            error handlers may make use of it.
            </para>
                <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Warning(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter,
            if not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
                <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" />.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Warning(System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter,
            if not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
                <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WarningExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" /> and passes client data to the warning handler.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="clientData">The client data to be passed to warning handler.</param>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything you want. It will be passed
            unchanged to the warning handler. Default warning handler does not use it. Only custom
            warning handlers may make use of it.
            </para>
                <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" /> and passes client data to the warning handler.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WarningExt(System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error" /> and passes client data to the warning handler.
            </summary>
            <param name="clientData">The client data to be passed to warning handler.</param>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything you want. It will be passed
            unchanged to the warning handler. Default warning handler does not use it. Only custom
            warning handlers may make use of it.
            </para>
                <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)">
            <summary>
            Sets an instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffErrorHandler" /> class as custom library-wide
            error and warning handler.
            </summary>
            <param name="errorHandler">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffErrorHandler" /> class
            to set as custom library-wide error and warning handler.</param>
            <returns>
            Previous error handler or <c>null</c> if there was no error handler set.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetTagExtender(BitMiracle.LibTiff.Classic.Tiff.TiffExtendProc)">
            <summary>
            Sets the tag extender method.
            </summary>
            <param name="extender">The tag extender method.</param>
            <returns>Previous tag extender method.</returns>
            <remarks>
            Extender method is called upon creation of each instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> object.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Reads and decodes a tile of data from an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin storing read and decoded bytes.</param>
            <param name="x">The x-coordinate of the pixel within a tile to be read and decoded.</param>
            <param name="y">The y-coordinate of the pixel within a tile to be read and decoded.</param>
            <param name="z">The z-coordinate of the pixel within a tile to be read and decoded.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>The number of bytes in the decoded tile or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
            The tile to read and decode is selected by the (x, y, z, plane) coordinates (i.e.
            <b>ReadTile</b> returns the data for the tile containing the specified coordinates.
            The data placed in <paramref name="buffer" /> are returned decompressed and, typically,
            in the native byte- and bit-ordering, but are otherwise packed (see further below).
            The buffer must be large enough to hold an entire tile of data. Applications should
            call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize" /> to find out the size (in bytes) of a tile buffer.
            The <paramref name="x" /> and <paramref name="y" /> parameters are always used by
            <b>ReadTile</b>. The <paramref name="z" /> parameter is used if the image is deeper
            than 1 slice (a value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH" /> &gt; 1). In other cases the
            value of <paramref name="z" /> is ignored. The <paramref name="plane" /> parameter is
            used only if data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE). In other
            cases the value of <paramref name="plane" /> is ignored.
            </para>
                <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a tile of data from an open TIFF file/stream, decompresses it and places
            specified amount of decompressed bytes into the user supplied buffer.
            </summary>
            <param name="tile">The zero-based index of the tile to read.</param>
            <param name="buffer">The buffer to place decompressed tile bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            decompressed tile bytes.</param>
            <param name="count">The maximum number of decompressed tile bytes to be stored
            to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
                <para>
            The value of <paramref name="tile" /> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.</para>
                <para>To read a full tile of data the data buffer should typically be at least as
            large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize" />. If the -1 passed in
            <paramref name="count" /> parameter, the whole tile will be read. You should be sure
            you have enough space allocated for the buffer.</para>
                <para>The library attempts to hide bit- and byte-ordering differences between the
            image and the native machine by converting data to the native machine order. Bit
            reversal is done if the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the undecoded contents of a tile of data from an open TIFF file/stream and places
            specified amount of read bytes into the user supplied buffer.
            </summary>
            <param name="tile">The zero-based index of the tile to read.</param>
            <param name="buffer">The buffer to place read tile bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            read tile bytes.</param>
            <param name="count">The maximum number of read tile bytes to be stored to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
                <para>
            The value of <paramref name="tile" /> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.</para>
                <para>To read a full tile of data the data buffer should typically be at least as
            large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RawTileSize(System.Int32)" />. If the -1 passed in
            <paramref name="count" /> parameter, the whole tile will be read. You should be sure
            you have enough space allocated for the buffer.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <overloads>Encodes and writes a tile of data to an open TIFF file/stream.</overloads>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="x">The x-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="y">The y-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="z">The z-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
            The number of encoded and written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
                <para>
            The tile to place encoded data is selected by the (x, y, z, plane) coordinates (i.e.
            <b>WriteTile</b> writes data to the tile containing the specified coordinates.
            <b>WriteTile</b> (potentially) encodes the data <paramref name="buffer" /> and writes
            it to open file/stream. The buffer must contain an entire tile of data. Applications
            should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize" /> to find out the size (in bytes) of a tile buffer.
            The <paramref name="x" /> and <paramref name="y" /> parameters are always used by
            <b>WriteTile</b>. The <paramref name="z" /> parameter is used if the image is deeper
            than 1 slice (a value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH" /> &gt; 1). In other cases the
            value of <paramref name="z" /> is ignored. The <paramref name="plane" /> parameter is
            used only if data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE). In other
            cases the value of <paramref name="plane" /> is ignored.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteTile</b> does not support automatically growing the image on
            each write (as <see cref="O:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes to be encoded and written.</param>
            <param name="x">The x-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="y">The y-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="z">The z-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>The number of encoded and written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
            The tile to place encoded data is selected by the (x, y, z, plane) coordinates (i.e.
            <b>WriteTile</b> writes data to the tile containing the specified coordinates.
            <b>WriteTile</b> (potentially) encodes the data <paramref name="buffer" /> and writes
            it to open file/stream. The buffer must contain an entire tile of data. Applications
            should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize" /> to find out the size (in bytes) of a tile buffer.
            The <paramref name="x" /> and <paramref name="y" /> parameters are always used by
            <b>WriteTile</b>. The <paramref name="z" /> parameter is used if the image is deeper
            than 1 slice (a value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH" /> &gt; 1). In other cases the
            value of <paramref name="z" /> is ignored. The <paramref name="plane" /> parameter is
            used only if data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE). In other
            cases the value of <paramref name="plane" /> is ignored.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteTile</b> does not support automatically growing the image on
            each write (as <see cref="O:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a strip of data from an open TIFF file/stream, decompresses it and places
            specified amount of decompressed bytes into the user supplied buffer.
            </summary>
            <param name="strip">The zero-based index of the strip to read.</param>
            <param name="buffer">The buffer to place decompressed strip bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            decompressed strip bytes.</param>
            <param name="count">The maximum number of decompressed strip bytes to be stored
            to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
                <para>
            The value of <paramref name="strip" /> is a "raw strip number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to a
            strip index.</para>
                <para>To read a full strip of data the data buffer should typically be at least
            as large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.StripSize" />. If the -1 passed in
            <paramref name="count" /> parameter, the whole strip will be read. You should be sure
            you have enough space allocated for the buffer.</para>
                <para>The library attempts to hide bit- and byte-ordering differences between the
            image and the native machine by converting data to the native machine order. Bit
            reversal is done if the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER" /> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the undecoded contents of a strip of data from an open TIFF file/stream and
            places specified amount of read bytes into the user supplied buffer.
            </summary>
            <param name="strip">The zero-based index of the strip to read.</param>
            <param name="buffer">The buffer to place read bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            read bytes.</param>
            <param name="count">The maximum number of read bytes to be stored to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
                <para>
            The value of <paramref name="strip" /> is a "raw strip number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to a
            strip index.</para>
                <para>To read a full strip of data the data buffer should typically be at least
            as large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RawStripSize(System.Int32)" />. If the -1 passed in
            <paramref name="count" /> parameter, the whole strip will be read. You should be sure
            you have enough space allocated for the buffer.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedStrip(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encodes and writes a strip of data to an open TIFF file/stream.
            </summary>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>
            The number of encoded and written bytes or <c>-1</c> if an error occurred.
            </returns>
            <overloads>Encodes and writes a strip of data to an open TIFF file/stream.</overloads>
            <remarks>
                <para>
                    <b>WriteEncodedStrip</b> encodes <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> and append the result to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip" /> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to
            a strip index.
            </para>
                <para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes and writes a strip of data to an open TIFF file/stream.
            </summary>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes to be encoded and written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>The number of encoded and written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
                    <b>WriteEncodedStrip</b> encodes <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> and append the result to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip" /> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to
            a strip index.
            </para>
                <para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawStrip(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes a strip of raw data to an open TIFF file/stream.
            </summary>
            <overloads>Writes a strip of raw data to an open TIFF file/stream.</overloads>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>
            The number of written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
                <para>
                    <b>WriteRawStrip</b> appends <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip" /> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to
            a strip index.
            </para>
                <para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a strip of raw data to an open TIFF file/stream.
            </summary>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes to be written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>The number of written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
                    <b>WriteRawStrip</b> appends <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip" /> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)" /> automatically does this when converting an (row, plane) to
            a strip index.
            </para>
                <para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" />
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS" /> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedTile(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <overloads>Encodes and writes a tile of data to an open TIFF file/stream.</overloads>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>
            The number of encoded and written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
                <para>
                    <b>WriteEncodedTile</b> encodes <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> and append the result to the end of the specified tile. Note
            that the value of <paramref name="tile" /> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para>
                <para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteEncodedTile</b> does not support automatically growing the image on
            each write (as <see cref="O:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes to be encoded and written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>The number of encoded and written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
                    <b>WriteEncodedTile</b> encodes <paramref name="count" /> bytes of raw data from
            <paramref name="buffer" /> and append the result to the end of the specified tile. Note
            that the value of <paramref name="tile" /> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para>
                <para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteEncodedTile</b> does not support automatically growing the image on
            each write (as <see cref="O:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
                <para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE" /> tag greater
            than 8.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawTile(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes a tile of raw data to an open TIFF file/stream.
            </summary>
            <overloads>Writes a tile of raw data to an open TIFF file/stream.</overloads>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>
            The number of written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
                <para>
                    <b>WriteRawTile</b> appends <paramref name="count" /> bytes of raw data to the end of
            the specified tile. Note that the value of <paramref name="tile" /> is a "raw tile
            number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para>
                <para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteRawTile</b> does not support automatically growing the image on
            each write (as <see cref="O:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a tile of raw data to an open TIFF file/stream.
            </summary>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin reading bytes to be written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer" />.</param>
            <returns>The number of written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
                <para>
                    <b>WriteRawTile</b> appends <paramref name="count" /> bytes of raw data to the end of
            the specified tile. Note that the value of <paramref name="tile" /> is a "raw tile
            number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)" /> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para>
                <para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para>
                <para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH" /> tag must be setup before
            writing; <b>WriteRawTile</b> does not support automatically growing the image on
            each write (as <see cref="O:BitMiracle.LibTiff.Classic.Tiff.WriteScanline" /> does).
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetWriteOffset(System.Int64)">
            <summary>
            Sets the current write offset.
            </summary>
            <param name="offset">The write offset.</param>
            <remarks>This should only be used to set the offset to a known previous location
            (very carefully), or to 0 so that the next write gets appended to the end of the file.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.DataWidth(BitMiracle.LibTiff.Classic.TiffType)">
            <summary>
            Gets the number of bytes occupied by the item of given type.
            </summary>
            <param name="type">The type.</param>
            <returns>The number of bytes occupied by the <paramref name="type" /> or 0 if unknown
            data type is supplied.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabShort(System.Int16@)">
            <summary>
            Swaps the bytes in a single 16-bit item.
            </summary>
            <param name="value">The value to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabLong(System.Int32@)">
            <summary>
            Swaps the bytes in a single 32-bit item.
            </summary>
            <param name="value">The value to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabDouble(System.Double@)">
            <summary>
            Swaps the bytes in a single double-precision floating-point number.
            </summary>
            <param name="value">The value to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfShort(System.Int16[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 16-bit items.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of 16-bit items.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfShort(System.Int16[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 16-bit items starting at
            specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array" /> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfTriples(System.Byte[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of triples (24-bit items).
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of triples (24-bit items).
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfTriples(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of triples (24-bit items)
            starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array" /> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong(System.Int32[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 32-bit items.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of 32-bit items.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong8(System.Int64[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 64-bit items.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of 64-bit items.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 32-bit items
            starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array" /> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong8(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 64-bit items
            starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array" /> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfDouble(System.Double[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of double-precision
            floating-point numbers.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of double-precision
            floating-point numbers.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfDouble(System.Double[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of double-precision
            floating-point numbers starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array" /> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReverseBits(System.Byte[],System.Int32)">
            <summary>
            Replaces specified number of bytes in <paramref name="buffer" /> with the
            equivalent bit-reversed bytes.
            </summary>
            <overloads>
            Replaces specified number of bytes in <paramref name="buffer" /> with the
            equivalent bit-reversed bytes.
            </overloads>
            <param name="buffer">The buffer to replace bytes in.</param>
            <param name="count">The number of bytes to process.</param>
            <remarks>
            This operation is performed with a lookup table, which can be retrieved using the
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetBitRevTable(System.Boolean)" /> method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReverseBits(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Replaces specified number of bytes in <paramref name="buffer" /> with the
            equivalent bit-reversed bytes starting at specified offset.
            </summary>
            <param name="buffer">The buffer to replace bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer" /> at
            which to begin processing bytes.</param>
            <param name="count">The number of bytes to process.</param>
            <remarks>
            This operation is performed with a lookup table, which can be retrieved using the
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetBitRevTable(System.Boolean)" /> method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetBitRevTable(System.Boolean)">
            <summary>
            Retrieves a bit reversal table.
            </summary>
            <param name="reversed">if set to <c>true</c> then bit reversal table will be
            retrieved; otherwise, the table that do not reverse bit values will be retrieved.</param>
            <returns>The bit reversal table.</returns>
            <remarks>If <paramref name="reversed" /> is <c>false</c> then the table that do not
            reverse bit values will be retrieved. It is a lookup table that can be used as an
            identity function; i.e. NoBitRevTable[n] == n.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ByteArrayToInts(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts a byte buffer into array of 32-bit values.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer" /> at
            which to begin converting bytes.</param>
            <param name="count">The number of bytes to convert.</param>
            <returns>The array of 32-bit values.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ByteArrayToLong8(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts a byte buffer into array of 64-bit values.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer" /> at
            which to begin converting bytes.</param>
            <param name="count">The number of bytes to convert.</param>
            <returns>The array of 64-bit values.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Long8ToByteArray(System.Int64[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Converts array of 64-bit values into array of bytes.
            </summary>
            <param name="source">The array of 64-bit values.</param>
            <param name="srcOffset">The zero-based offset in <paramref name="source" /> at
            which to begin converting bytes.</param>
            <param name="srcCount">The number of 64-bit values to convert.</param>
            <param name="bytes">The byte array to store converted values at.</param>
            <param name="offset">The zero-based offset in <paramref name="bytes" /> at
            which to begin storing converted values.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IntsToByteArray(System.Int32[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Converts array of 32-bit values into array of bytes.
            </summary>
            <param name="source">The array of 32-bit values.</param>
            <param name="srcOffset">The zero-based offset in <paramref name="source" /> at
            which to begin converting bytes.</param>
            <param name="srcCount">The number of 32-bit values to convert.</param>
            <param name="bytes">The byte array to store converted values at.</param>
            <param name="offset">The zero-based offset in <paramref name="bytes" /> at
            which to begin storing converted values.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ByteArrayToShorts(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts a byte buffer into array of 16-bit values.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer" /> at
            which to begin converting bytes.</param>
            <param name="count">The number of bytes to convert.</param>
            <returns>The array of 16-bit values.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ShortsToByteArray(System.Int16[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Converts array of 16-bit values into array of bytes.
            </summary>
            <param name="source">The array of 16-bit values.</param>
            <param name="srcOffset">The zero-based offset in <paramref name="source" /> at
            which to begin converting bytes.</param>
            <param name="srcCount">The number of 16-bit values to convert.</param>
            <param name="bytes">The byte array to store converted values at.</param>
            <param name="offset">The zero-based offset in <paramref name="bytes" /> at
            which to begin storing converted values.</param>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffCodec">
            <summary>
            Base class for all codecs within the library.
            </summary>
            <remarks>
                <para>
            A codec is a class that implements decoding, encoding, or decoding and encoding of a
            compression algorithm.
            </para>
                <para>
            The library provides a collection of builtin codecs. More codecs may be registered
            through calls to the library and/or the builtin implementations may be overridden.
            </para>
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffCodec.m_tif">
            <summary>
            An instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" />.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffCodec.m_scheme">
            <summary>
            Compression scheme this codec impelements.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffCodec.m_name">
            <summary>
            Codec name.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.#ctor(BitMiracle.LibTiff.Classic.Tiff,BitMiracle.LibTiff.Classic.Compression,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffCodec" /> class.
            </summary>
            <param name="tif">An instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <param name="scheme">The compression scheme for the codec.</param>
            <param name="name">The name of the codec.</param>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
                <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
                <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Init">
            <summary>
            Initializes this instance.
            </summary>
            <returns>
                <c>true</c> if initialized successfully</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreDecode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.</returns>
            <remarks>
                <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode" /> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
                <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
                <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreEncode(System.Int16)" />.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.</returns>
            <remarks>
                <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode" /> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
                <c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
                <b>PostEncode</b> is called after encoding and can be used to release any external 
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer" />.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
                <c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Close">
            <summary>
            Flushes any internal data buffers and terminates current operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Seek(System.Int32)">
            <summary>
            Seeks the specified row in the strip being processed.
            </summary>
            <param name="row">The row to seek.</param>
            <returns>
                <c>true</c> if specified row was successfully found; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
                <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DefStripSize(System.Int32)">
            <summary>
            Calculates and/or constrains a strip size.
            </summary>
            <param name="size">The proposed strip size (may be zero or negative).</param>
            <returns>A strip size to use.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DefTileSize(System.Int32@,System.Int32@)">
            <summary>
            Calculate and/or constrains a tile size
            </summary>
            <param name="width">The proposed tile width upon the call / tile width to use after the call.</param>
            <param name="height">The proposed tile height upon the call / tile height to use after the call.</param>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffErrorHandler">
            <summary>
            Default error handler implementation.
            </summary>
            <remarks>
                <para>
                    <b>TiffErrorHandler</b> provides error and warning handling methods that write an
            error or a warning messages to the <see cref="P:System.Console.Error" />.
            </para>
                <para>
            Applications that desire to capture control in the event of an error or a warning should
            set their custom error and warning handler using <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)" /> method.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.ErrorHandler(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Handles an error by writing it text to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.ErrorHandlerExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Handles an error by writing it text to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="clientData">A client data.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything. Its value and meaning is
            defined by an application and not the library.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.WarningHandler(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Handles a warning by writing it text to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="method">The method where a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.WarningHandlerExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Handles a warning by writing it text to the <see cref="P:System.Console.Error" />.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class. Can be <c>null</c>.</param>
            <param name="clientData">A client data.</param>
            <param name="method">The method where a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
                <para>
            The <paramref name="format" /> is a composite format string that uses the same format as
            <see cref="O:System.String.Format" /> method. The <paramref name="method" /> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
                <para>
            The <paramref name="clientData" /> parameter can be anything. Its value and meaning is
            defined by an application and not the library.
            </para>
            </remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffFieldInfo">
            <summary>
            Represents a TIFF field information.
            </summary>
            <remarks>
                <b>TiffFieldInfo</b> describes a field. It provides information about field name, type,
            number of values etc.
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable">
            <summary>
            marker for variable length tags
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp">
            <summary>
            marker for SamplesPerPixel-bound tags
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2">
            <summary>
            marker for integer variable length tags
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffFieldInfo.#ctor(BitMiracle.LibTiff.Classic.TiffTag,System.Int16,System.Int16,BitMiracle.LibTiff.Classic.TiffType,System.Int16,System.Boolean,System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo" /> class.
            </summary>
            <param name="tag">The tag to describe.</param>
            <param name="readCount">The number of values to read when reading field information or
            one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable" />, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2" />.</param>
            <param name="writeCount">The number of values to write when writing field information
            or one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable" />, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2" />.</param>
            <param name="type">The type of the field value.</param>
            <param name="bit">Index of the bit to use in "Set Fields Vector" when this instance
            is merged into field info collection. Take a look at <see cref="T:BitMiracle.LibTiff.Classic.FieldBit" /> class.</param>
            <param name="okToChange">If true, then it is permissible to set the tag's value even
            after writing has commenced.</param>
            <param name="passCount">If true, then number of value elements should be passed to
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])" /> method as second parameter (right after tag type AND
            before value itself).</param>
            <param name="name">The name (description) of the tag this instance describes.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffFieldInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Tag">
            <summary>
            The tag described by this instance.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.ReadCount">
            <summary>
            Number of values to read when reading field information or
            one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable" />, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2" />.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.WriteCount">
            <summary>
            Number of values to write when writing field information or
            one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable" />, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp" /> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2" />.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Type">
            <summary>
            Type of the field values.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Bit">
            <summary>
            Index of the bit to use in "Set Fields Vector" when this instance
            is merged into field info collection. Take a look at <see cref="T:BitMiracle.LibTiff.Classic.FieldBit" /> class.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.OkToChange">
            <summary>
            If true, then it is permissible to set the tag's value even after writing has commenced.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.PassCount">
            <summary>
            If true, then number of value elements should be passed to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])" />
            method as second parameter (right after tag type AND before values itself).
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Name">
            <summary>
            The name (or description) of the tag this instance describes.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage">
            <summary>
            RGBA-style image support. Provides methods for decoding images into RGBA (or other) format.
            </summary>
            <remarks>
                <para>
                    <b>TiffRgbaImage</b> provide a high-level interface through which TIFF images may be read
            into memory. Images may be strip- or tile-based and have a variety of different
            characteristics: bits/sample, samples/pixel, photometric, etc. The target raster format
            can be customized to a particular application's needs by installing custom methods that
            manipulate image data according to application requirements.
            </para>
                <para>
            The default usage for this class: check if an image can be processed using
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)" />, construct an instance of
            <b>TiffRgbaImage</b> using <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.Create(BitMiracle.LibTiff.Classic.Tiff,System.Boolean,System.String@)" /> and then read and decode an image into a
            target raster using <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)" />. <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)" /> can be called
            multiple times to decode an image using different state parameters. If multiple images
            are to be displayed and there is not enough space for each of the decoded rasters,
            multiple instances of <b>TiffRgbaImage</b> can be managed and then calls can be made to
            <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)" /> as needed to display an image.</para>
                <para>
            To use the core support for reading and processing TIFF images, but write the resulting
            raster data in a different format one need only override the "put methods" used to store
            raster data. These methods are initially setup by <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.Create(BitMiracle.LibTiff.Classic.Tiff,System.Boolean,System.String@)" /> to point to methods
            that pack raster data in the default ABGR pixel format. Two different methods are used
            according to the physical organization of the image data in the file: one for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.CONTIG (packed samples),
            and another for <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG" /> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig" />.SEPARATE
            (separated samples). Note that this mechanism can be used to transform the data before 
            storing it in the raster. For example one can convert data to colormap indices for display
            on a colormap display.</para>
                <para>
            To setup custom "put" method please use <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig" /> property for contiguously
            packed samples and/or <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate" /> property for separated samples.</para>
                <para>
            The methods of <b>TiffRgbaImage</b> support the most commonly encountered flavors of TIFF.
            It is possible to extend this support by overriding the "get method" invoked by
            <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)" /> to read TIFF image data. Details of doing this are a bit involved,
            it is best to make a copy of an existing get method and modify it to suit the needs of an
            application. To setup custom "get" method please use <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get" /> property.</para>
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.tif">
            <summary>
            image handle
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.stoponerr">
            <summary>
            stop on read error
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.isContig">
            <summary>
            data is packed/separate
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.alpha">
            <summary>
            type of alpha data present
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.width">
            <summary>
            image width
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.height">
            <summary>
            image height
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.bitspersample">
            <summary>
            image bits/sample
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.samplesperpixel">
            <summary>
            image samples/pixel
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.orientation">
            <summary>
            image orientation
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.req_orientation">
            <summary>
            requested orientation
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.photometric">
            <summary>
            image photometric interp
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.redcmap">
            <summary>
            colormap pallete
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.Map">
            <summary>
            sample mapping array
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.BWmap">
            <summary>
            black and white map
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.PALmap">
            <summary>
            palette image map
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.ycbcr">
            <summary>
            YCbCr conversion state
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.cielab">
            <summary>
            CIE L*a*b conversion state
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContigDelegate">
            <summary>
            Delegate for "put" method (the method that is called to pack pixel data in the raster)
            used when converting contiguously packed samples.
            </summary>
            <param name="img">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> class.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="rasterOffset">The zero-based byte offset in <paramref name="raster" /> at
            which to begin storing decoded bytes.</param>
            <param name="rasterShift">The value that should be added to
            <paramref name="rasterOffset" /> after each row processed.</param>
            <param name="x">The x-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="y">The y-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="width">The block width.</param>
            <param name="height">The block height.</param>
            <param name="buffer">The buffer with image data.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin reading image bytes.</param>
            <param name="bufferShift">The value that should be added to <paramref name="offset" />
            after each row processed.</param>
            <remarks>
                <para>
            The image reading and conversion methods invoke "put" methods to copy/image/whatever
            tiles of raw image data. A default set of methods is provided to convert/copy raw
            image data to 8-bit packed ABGR format rasters. Applications can supply alternate
            methods that unpack the data into a different format or, for example, unpack the data
            and draw the unpacked raster on the display.
            </para>
                <para>
            To setup custom "put" method for contiguously packed samples please use
            <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig" /> property.</para>
                <para>
            The <paramref name="bufferShift" /> is usually 0. It is greater than 0 if width of strip
            being converted is greater than image width or part of the tile being converted is
            outside the image (may be true for tiles on the right and bottom edge of the image).
            In other words, <paramref name="bufferShift" /> is used to make up for any padding on
            the end of each line of the buffer with image data.
            </para>
                <para>
            The <paramref name="rasterShift" /> is 0 if width of tile being converted is equal to
            image width and image data should not be flipped vertically. In other circumstances
            <paramref name="rasterShift" /> is used to make up for any padding on the end of each
            line of the raster and/or for flipping purposes.
            </para>
            </remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparateDelegate">
            <summary>
            Delegate for "put" method (the method that is called to pack pixel data in the raster)
            used when converting separated samples.
            </summary>
            <param name="img">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> class.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="rasterOffset">The zero-based byte offset in <paramref name="raster" /> at
            which to begin storing decoded bytes.</param>
            <param name="rasterShift">The value that should be added to
            <paramref name="rasterOffset" /> after each row processed.</param>
            <param name="x">The x-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="y">The y-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="width">The block width.</param>
            <param name="height">The block height.</param>
            <param name="buffer">The buffer with image data.</param>
            <param name="offset1">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin reading image bytes that constitute first sample plane.</param>
            <param name="offset2">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin reading image bytes that constitute second sample plane.</param>
            <param name="offset3">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin reading image bytes that constitute third sample plane.</param>
            <param name="offset4">The zero-based byte offset in <paramref name="buffer" /> at
            which to begin reading image bytes that constitute fourth sample plane.</param>
            <param name="bufferShift">The value that should be added to <paramref name="offset1" />,
            <paramref name="offset2" />, <paramref name="offset3" /> and <paramref name="offset4" />
            after each row processed.</param>
            <remarks>
                <para>
            The image reading and conversion methods invoke "put" methods to copy/image/whatever
            tiles of raw image data. A default set of methods is provided to convert/copy raw
            image data to 8-bit packed ABGR format rasters. Applications can supply alternate
            methods that unpack the data into a different format or, for example, unpack the data
            and draw the unpacked raster on the display.
            </para>
                <para>
            To setup custom "put" method for separated samples please use
            <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate" /> property.</para>
                <para>
            The <paramref name="bufferShift" /> is usually 0. It is greater than 0 if width of strip
            being converted is greater than image width or part of the tile being converted is
            outside the image (may be true for tiles on the right and bottom edge of the image).
            In other words, <paramref name="bufferShift" /> is used to make up for any padding on
            the end of each line of the buffer with image data.
            </para>
                <para>
            The <paramref name="rasterShift" /> is 0 if width of tile being converted is equal to
            image width and image data should not be flipped vertically. In other circumstances
            <paramref name="rasterShift" /> is used to make up for any padding on the end of each
            line of the raster and/or for flipping purposes.
            </para>
            </remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetDelegate">
            <summary>
            Delegate for "get" method (the method that is called to produce RGBA raster).
            </summary>
            <param name="img">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> class.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="offset">The zero-based byte offset in <paramref name="raster" /> at which
            to begin storing decoded bytes.</param>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <returns>
                <c>true</c> if the image was successfully read and decoded; otherwise,
            <c>false</c>.</returns>
            <remarks>
                <para>
            A default set of methods is provided to read and convert/copy raw image data to 8-bit
            packed ABGR format rasters. Applications can supply alternate method for this.
            </para>
                <para>
            To setup custom "get" method please use <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get" /> property.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.Create(BitMiracle.LibTiff.Classic.Tiff,System.Boolean,System.String@)">
            <summary>
            Creates new instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> class.
            </summary>
            <param name="tif">
            The instance of the <see cref="N:BitMiracle.LibTiff.Classic" /> class used to retrieve
            image data.
            </param>
            <param name="stopOnError">
            if set to <c>true</c> then an error will terminate the conversion; otherwise "get"
            methods will continue processing data until all the possible data in the image have
            been requested.
            </param>
            <param name="errorMsg">The error message (if any) gets placed here.</param>
            <returns>
            New instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage" /> class if the image specified
            by <paramref name="tif" /> can be converted to RGBA format; otherwise, <c>null</c> is
            returned and <paramref name="errorMsg" /> contains the reason why it is being
            rejected.
            </returns>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.IsContig">
            <summary>
            Gets a value indicating whether image data has contiguous (packed) or separated samples.
            </summary>
            <value>
                <c>true</c> if this image data has contiguous (packed) samples; otherwise,
            <c>false</c>.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Alpha">
            <summary>
            Gets the type of alpha data present.
            </summary>
            <value>The type of alpha data present.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Width">
            <summary>
            Gets the image width.
            </summary>
            <value>The image width.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Height">
            <summary>
            Gets the image height.
            </summary>
            <value>The image height.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.BitsPerSample">
            <summary>
            Gets the image bits per sample count.
            </summary>
            <value>The image bits per sample count.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.SamplesPerPixel">
            <summary>
            Gets the image samples per pixel count.
            </summary>
            <value>The image samples per pixel count.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Orientation">
            <summary>
            Gets the image orientation.
            </summary>
            <value>The image orientation.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.ReqOrientation">
            <summary>
            Gets or sets the requested orientation.
            </summary>
            <value>The requested orientation.</value>
            <remarks>The <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)" /> method uses this value when placing converted
            image data into raster buffer.</remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Photometric">
            <summary>
            Gets the photometric interpretation of the image data.
            </summary>
            <value>The photometric interpretation of the image data.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get">
            <summary>
            Gets or sets the "get" method (the method that is called to produce RGBA raster).
            </summary>
            <value>The "get" method.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig">
            <summary>
            Gets or sets the "put" method (the method that is called to pack pixel data in the
            raster) used when converting contiguously packed samples.
            </summary>
            <value>The "put" method used when converting contiguously packed samples.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate">
            <summary>
            Gets or sets the "put" method (the method that is called to pack pixel data in the
            raster) used when converting separated samples.
            </summary>
            <value>The "put" method used when converting separated samples.</value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Reads the underlaying TIFF image and decodes it into RGBA format raster.
            </summary>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="offset">The zero-based byte offset in <paramref name="raster" /> at which
            to begin storing decoded bytes.</param>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <returns>
                <c>true</c> if the image was successfully read and decoded; otherwise,
            <c>false</c>.</returns>
            <remarks>
                <para>
                    <b>GetRaster</b> reads image into memory using current "get" (<see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get" />) method,
            storing the result in the user supplied RGBA <paramref name="raster" /> using one of
            the "put" (<see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig" /> or <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate" />) methods. The raster
            is assumed to be an array of <paramref name="width" /> times <paramref name="height" />
            32-bit entries, where <paramref name="width" /> must be less than or equal to the width
            of the image (<paramref name="height" /> may be any non-zero size). If the raster
            dimensions are smaller than the image, the image data is cropped to the raster bounds.
            If the raster height is greater than that of the image, then the image data placement
            depends on the value of <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.ReqOrientation" /> property. Note that the raster is
            assumed to be organized such that the pixel at location (x, y) is
            <paramref name="raster" />[y * width + x]; with the raster origin specified by the
            value of <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.ReqOrientation" /> property.
            </para>
                <para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The 
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)" />, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)" />, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)" /> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para>
                <para>
                    <b>GetRaster</b> converts non-8-bit images by scaling sample values. Palette,
            grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently.
            Raster pixels are returned uncorrected by any colorimetry information present in
            the directory.
            </para>
                <para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para>
                <para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para>
                <para>
            All error messages are directed to the current error handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.CMAP(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Palette images with &lt;= 8 bits/sample are handled with a table to avoid lots of shifts
            and masks. The table is setup so that put*cmaptile (below) can retrieve 8 / bitspersample
            pixel values simply by indexing into the table with one number.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GREY(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Greyscale images with less than 8 bits/sample are handled with a table to avoid lots
            of shifts and masks. The table is setup so that put*bwtile (below) can retrieve
            8 / bitspersample pixel values simply by indexing into the table with one number.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtTileContig(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get an tile-organized image that has
            PlanarConfiguration contiguous if SamplesPerPixel &gt; 1
             or
            SamplesPerPixel == 1
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtTileSeparate(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get an tile-organized image that has
            SamplesPerPixel &gt; 1
            PlanarConfiguration separated
            We assume that all such images are RGB.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtStripContig(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get a strip-organized image that has 
            PlanarConfiguration contiguous if SamplesPerPixel &gt; 1
             or
            SamplesPerPixel == 1
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtStripSeparate(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get a strip-organized image with
             SamplesPerPixel &gt; 1
             PlanarConfiguration separated
            We assume that all such images are RGB.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.pickContigCase">
            <summary>
            Select the appropriate conversion routine for packed data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.pickSeparateCase">
            <summary>
            Select the appropriate conversion routine for unpacked data.
            NB: we assume that unpacked single channel data is directed to the "packed routines.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.buildMap">
            <summary>
            Construct any mapping table used by the associated put method.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.setupMap">
            <summary>
            Construct a mapping table to convert from the range of the data samples to [0, 255] -
            for display. This process also handles inverting B&amp;W images when needed.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.YCbCrtoRGB(System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            YCbCr -&gt; RGB conversion and packing routines.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put8bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit palette =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put4bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            4-bit palette =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put2bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            2-bit palette =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put1bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            1-bit palette =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putgreytile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit greyscale =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putgreywithalphatile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit greyscale with alpha =&gt; colormap/RGBA
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put16bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit greyscale =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put1bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            1-bit bilevel =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put2bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            2-bit greyscale =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put4bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            4-bit greyscale =&gt; colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed samples, no Map =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAcontig8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed samples =&gt; RGBA w/ associated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAcontig8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed samples =&gt; RGBA w/ unassociated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit packed samples =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAcontig16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit packed samples =&gt; RGBA w/ associated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAcontig16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit packed samples =&gt; RGBA w/ unassociated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAcontig8bitCMYKAtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CMYKA samples w/o Map =&gt; RGBA.
            NB: The conversion of CMYKA-&gt;RGBA is *very* crude.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig8bitCMYKtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CMYK samples w/o Map =&gt; RGB.
            NB: The conversion of CMYK-&gt;RGB is *very* crude.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitCIELab(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CIE L*a*b 1976 samples =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr22tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 2,2 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr21tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 2,1 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr44tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 4,4 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr42tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 4,2 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr41tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 4,1 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr11tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ no subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr12tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 1,2 subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBseparate8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit unpacked samples =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAseparate8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit unpacked samples =&gt; RGBA w/ associated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAseparate8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit unpacked samples =&gt; RGBA w/ unassociated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBseparate16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            16-bit unpacked samples =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAseparate16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            16-bit unpacked samples =&gt; RGBA w/ associated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAseparate16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            16-bit unpacked samples =&gt; RGBA w/ unassociated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putseparate8bitYCbCr11tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ no subsampling =&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig8bitCMYKMaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CMYK samples w/Map =&gt; RGB
            NB: The conversion of CMYK-&gt;RGB is *very* crude.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffStream">
            <summary>
            A stream used by the library for TIFF reading and writing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Read(System.Object,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the stream and advances the position within the stream
            by the number of bytes read.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <param name="buffer">An array of bytes. When this method returns, the
            <paramref name="buffer" /> contains the specified byte array with the values between
            <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1)
            replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>The total number of bytes read into the <paramref name="buffer" />. This can
            be less than the number of bytes requested if that many bytes are not currently
            available, or zero (0) if the end of the stream has been reached.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Write(System.Object,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position
            within this stream by the number of bytes written.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <param name="buffer">An array of bytes. This method copies <paramref name="count" />
            bytes from <paramref name="buffer" /> to the current stream.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which
            to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Seek(System.Object,System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <param name="offset">A byte offset relative to the <paramref name="origin" /> parameter.</param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the
            reference point used to obtain the new position.</param>
            <returns>The new position within the current stream.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Close(System.Object)">
            <summary>
            Closes the current stream.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Size(System.Object)">
            <summary>
            Gets the length in bytes of the stream.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <returns>The length of the stream in bytes.</returns>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffTagMethods">
            <summary>
            Tiff tag methods.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_VOID">
            <summary>
            untyped data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_INT">
            <summary>
            signed integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_UINT">
            <summary>
            unsigned integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_IEEEFP">
            <summary>
            IEEE floating point data
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.SetField(BitMiracle.LibTiff.Classic.Tiff,BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.FieldValue[])">
            <summary>
            Sets the value(s) of a tag in a TIFF file/stream open for writing.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <param name="tag">The tag.</param>
            <param name="value">The tag value(s).</param>
            <returns>
                <c>true</c> if tag value(s) were set successfully; otherwise, <c>false</c>.
            </returns>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.GetField(BitMiracle.LibTiff.Classic.Tiff,BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Gets the value(s) of a tag in an open TIFF file.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <param name="tag">The tag.</param>
            <returns>The value(s) of a tag in an open TIFF file/stream as array of
            <see cref="T:BitMiracle.LibTiff.Classic.FieldValue" /> objects or <c>null</c> if there is no such tag set.</returns>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)" />
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.PrintDir(BitMiracle.LibTiff.Classic.Tiff,System.IO.Stream,BitMiracle.LibTiff.Classic.TiffPrintFlags)">
            <summary>
            Prints formatted description of the contents of the current directory to the
            specified stream using specified print (formatting) options.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff" /> class.</param>
            <param name="stream">The stream to print to.</param>
            <param name="flags">The print (formatting) options.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.setExtraSamples(BitMiracle.LibTiff.Classic.Internal.TiffDirectory,System.Int32@,BitMiracle.LibTiff.Classic.FieldValue[])">
            <summary>
            Install extra samples information.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.DensityUnit">
            <summary>
            The unit of density.
            </summary>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown">
            <summary>
            Unknown density
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.DotsInch">
            <summary>
            Dots/inch
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.DotsCm">
            <summary>
            Dots/cm
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.bitread_perm_state">
            <summary>
            Bitreading state saved across MCUs
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.bitread_working_state">
            <summary>
            Bitreading working state within an MCU
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer">
            <summary>
            Encapsulates buffer of image samples for one color component
            When provided with funny indices (see jpeg_d_main_controller for 
            explanation of what it is) uses them for non-linear row access.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl">
            <summary>
            Derived data constructed for each Huffman table
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder">
            <summary>
            Expanded entropy decoder object for Huffman decoding.
            
            The savable_state subrecord contains fields that change within an MCU,
            but must not be updated permanently until we complete the MCU.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.start_pass">
            <summary>
            Initialize for a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_full(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            Decode one MCU's worth of Huffman-compressed coefficients, full-size blocks.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_sub(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            Decode one MCU's worth of Huffman-compressed coefficients, partial blocks.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_DC_first(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for DC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_AC_first(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for AC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_DC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for DC successive approximation refinement scan.
            Note: we assume such scans can be multi-component,
            although the spec is not very clear on the point.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.undo_decode_mcu_AC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[],System.Int32[],System.Int32)">
            <summary>
            MCU decoding for AC successive approximation refinement scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.process_restart">
            <summary>
            Check for a restart marker and resynchronize decoder.
            Returns false if must suspend.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.jpeg_make_d_derived_tbl(System.Boolean,System.Int32,BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl@)">
            <summary>
            Expand a Huffman table definition into the derived format
            This routine also performs some validation checks on the table.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder">
            <summary>
            Expanded entropy encoder object for Huffman encoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.start_pass(System.Boolean)">
            <summary>
            Initialize for a Huffman-compressed scan.
            If gather_statistics is true, we do not output anything during the scan,
            just count the Huffman symbols used and generate Huffman code tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_huff(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            Encode and output one MCU's worth of Huffman-compressed coefficients.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.finish_pass_huff">
            <summary>
            Finish up at the end of a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_gather(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            Trial-encode one MCU's worth of Huffman-compressed coefficients.
            No data is actually output, so no suspension return is possible.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.finish_pass_gather">
            <summary>
            Finish up a statistics-gathering pass and create the new Huffman tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_one_block(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int16[],System.Int32,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl)">
            <summary>
            Encode a single block's worth of coefficients
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.htest_one_block(System.Int16[],System.Int32,System.Int64[],System.Int64[])">
            <summary>
            Huffman coding optimization.
            
            We first scan the supplied data and count the number of uses of each symbol
            that is to be Huffman-coded. (This process MUST agree with the code above.)
            Then we build a Huffman coding tree for the observed counts.
            Symbols which are not needed at all for the particular image are not
            assigned any code, which saves space in the DHT marker as well as in
            the compressed data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_bits_s(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int32,System.Int32)">
            <summary>
            Only the right 24 bits of put_buffer are used; the valid bits are
            left-justified in this part.  At most 16 bits can be passed to emit_bits
            in one call, and we never retain more than 7 bits in put_buffer
            between calls, so 24 bits are sufficient.
            </summary>
            Emit some bits; return true if successful, false if must suspend
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_bits_e(System.Int32,System.Int32)">
            <summary>
            Outputting bits to the file
            
            Only the right 24 bits of put_buffer are used; the valid bits are
            left-justified in this part.  At most 16 bits can be passed to emit_bits
            in one call, and we never retain more than 7 bits in put_buffer
            between calls, so 24 bits are sufficient.
            </summary>
            Emit some bits, unless we are in gather mode
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_restart_s(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int32)">
            <summary>
            Emit a restart marker and resynchronize predictions.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.IRIGHT_SHIFT(System.Int32,System.Int32)">
            <summary>
            IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than int.
            We assume that int right shift is unsigned if int right shift is,
            which should be safe.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_DC_first(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for DC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_AC_first(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for AC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_DC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for DC successive approximation refinement scan.
            Note: we assume such scans can be multi-component, although the spec
            is not very clear on the point.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_AC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for AC successive approximation refinement scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.jpeg_make_c_derived_tbl(System.Boolean,System.Int32,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl@)">
            <summary>
            Expand a Huffman table definition into the derived format
            Compute the derived values for a Huffman table.
            This routine also performs some validation checks on the table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.jpeg_gen_optimal_table(BitMiracle.LibJpeg.Classic.JHUFF_TBL,System.Int64[])">
            <summary>
            Generate the best Huffman code table for the given counts, fill htbl.
            
            The JPEG standard requires that no symbol be assigned a codeword of all
            one bits (so that padding bits added at the end of a compressed segment
            can't look like a valid code).  Because of the canonical ordering of
            codewords, this just means that there must be an unused slot in the
            longest codeword length category.  Section K.2 of the JPEG spec suggests
            reserving such a slot by pretending that symbol 256 is a valid symbol
            with count 1.  In theory that's not optimal; giving it count zero but
            including it in the symbol set anyway should give a better Huffman code.
            But the theoretically better code actually seems to come out worse in
            practice, because it produces more all-ones bytes (which incur stuffed
            zero bytes in the final file).  In any case the difference is tiny.
            
            The JPEG standard requires Huffman codes to be no more than 16 bits long.
            If some symbols have a very small but nonzero probability, the Huffman tree
            must be adjusted to meet the code length restriction.  We currently use
            the adjustment method suggested in JPEG section K.2.  This method is *not*
            optimal; it may not choose the best possible limited-length code.  But
            typically only very-low-frequency symbols will be given less-than-optimal
            lengths, so the code is almost optimal.  Experimental comparisons against
            an optimal limited-length-code algorithm indicate that the difference is
            microscopic --- usually less than a hundredth of a percent of total size.
            So the extra complexity of an optimal algorithm doesn't seem worthwhile.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order7">
            zz to natural order for 7x7 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order6">
            zz to natural order for 6x6 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order5">
            zz to natural order for 5x5 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order4">
            zz to natural order for 4x4 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order3">
            zz to natural order for 3x3 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order2">
            zz to natural order for 2x2 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_aritab">
            Arithmetic coding probability estimation tables
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jdiv_round_up(System.Int64,System.Int64)">
            <summary>
            Compute a/b rounded up to next integer, ie, ceil(a/b)
            Assumes a &gt;= 0, b &gt; 0
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jround_up(System.Int32,System.Int32)">
            <summary>
            Compute a rounded up to next multiple of b, ie, ceil(a/b)*b
            Assumes a &gt;= 0, b &gt; 0
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jcopy_sample_rows(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer,System.Int32,System.Byte[][],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy some rows of samples from one place to another.
            num_rows rows are copied from input_array[source_row++]
            to output_array[dest_row++]; these areas may overlap for duplication.
            The source and destination arrays must be at least as wide as num_cols.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter">
            <summary>
            Colorspace conversion
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.color_convert">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            
            Note that we change from the application's interleaved-pixel format
            to our internal noninterleaved, one-plane-per-component format.
            The input buffer is therefore three times as wide as the output buffer.
            
            A starting row offset is provided only for the output buffer.  The caller
            can easily adjust the passed input_buf value to accommodate any row
            offset required on that side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_ycc_start">
            <summary>
            Initialize for RGB-&gt;YCC colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_ycc_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            RGB -&gt; YCbCr conversion: most common case
            YCbCr is defined per CCIR 601-1, except that Cb and Cr are
            normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
            The conversion equations to be implemented are therefore
            Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
            Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE
            Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE
            (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
            To avoid floating-point arithmetic, we represent the fractional constants
            as integers scaled up by 2^16 (about 4 digits precision); we have to divide
            the products by 2^16, with appropriate rounding, to get the correct answer.
            For even more speed, we avoid doing any multiplications in the inner loop
            by precalculating the constants times R,G,B for all possible values.
            For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
            for 12-bit samples it is still acceptable.  It's not very reasonable for
            16-bit samples, but if you want lossless storage you shouldn't be changing
            colorspace anyway.
            The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included
            in the tables to save adding them separately in the inner loop.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_gray_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles RGB-&gt;grayscale conversion, which is the same
            as the RGB-&gt;Y portion of RGB-&gt;YCbCr.
            We assume rgb_ycc_start has been called (we only use the Y tables).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.cmyk_ycck_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles Adobe-style CMYK-&gt;YCCK conversion,
            where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
            conversion as above, while passing K (black) unchanged.
            We assume rgb_ycc_start has been called.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.grayscale_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles grayscale output with no conversion.
            The source can be either plain grayscale or YCC (since Y == gray).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.null_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles multi-component colorspaces without conversion.
            We assume input_components == num_components.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter">
            <summary>
            Colorspace conversion
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for output colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.color_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the output colorspace.
            
            Note that we change from noninterleaved, one-plane-per-component format
            to interleaved-pixel format.  The output buffer is therefore three times
            as wide as the input buffer.
            A starting row offset is provided only for the input buffer.  The caller
            can easily adjust the passed output_buf value to accommodate any row
            offset required on that side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.build_ycc_rgb_table">
            <summary>
            Initialize tables for YCbCr-&gt;RGB colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.build_bg_ycc_rgb_table">
            <summary>
            Initialize tables for BG_YCC-&gt;RGB colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.ycck_cmyk_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Adobe-style YCCK-&gt;CMYK conversion.
            We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
            conversion as above, while passing K (black) unchanged.
            We assume build_ycc_rgb_table has been called.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.gray_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Convert grayscale to RGB: just duplicate the graylevel three times.
            This is provided to support applications that don't want to cope
            with grayscale as a separate case.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.grayscale_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for grayscale: just copy the data.
            This also works for YCC -&gt; grayscale conversion, in which
            we just copy the Y (luminance) component and ignore chrominance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.cmyk_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for CMYK -&gt; RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.ycck_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for YCCK -&gt; RGB
            it's just a gybrid of YCCK -&gt; CMYK and CMYK -&gt; RGB conversions
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.null_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for no colorspace change: just copy the data,
            converting from separate-planes to interleaved representation.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_quantizer">
            <summary>
            Color quantization or color precision reduction
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master">
            <summary>
            Master control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.prepare_for_pass">
            <summary>
            Per-pass setup.
            
            This is called at the beginning of each pass.  We determine which 
            modules will be active during this pass and give them appropriate 
            start_pass calls. 
            We also set is_last_pass to indicate whether any more passes will 
            be required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.pass_startup">
            <summary>
            Special start-of-pass hook.
            
            This is called by jpeg_write_scanlines if call_pass_startup is true.
            In single-pass processing, we need this hook because we don't want to
            write frame/scan headers during jpeg_start_compress; we want to let the
            application write COM markers etc. between jpeg_start_compress and the
            jpeg_write_scanlines loop.
            In multi-pass processing, this routine is not used.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.finish_pass">
            <summary>
            Finish up at end of pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.per_scan_setup">
            <summary>
            Do computations that are needed before processing a JPEG scan
            cinfo.comps_in_scan and cinfo.cur_comp_info[] are already set
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_coef_controller">
            <summary>
            Coefficient buffer control
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller">
            <summary>
            Main buffer control (downsampled-data buffer)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller.process_data(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This routine handles the simple pass-through mode,
            where we have only a strip buffer.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller">
            <summary>
            Compression preprocessing (downsampling input buffer control).
            
            For the simple (no-context-row) case, we just need to buffer one
            row group's worth of pixels for the downsampling step.  At the bottom of
            the image, we pad to a full row group by replicating the last pixel row.
            The downsampler's last output row is then replicated if needed to pad
            out to a full iMCU row.
            
            When providing context rows, we must buffer three row groups' worth of
            pixels.  Three row groups are physically allocated, but the row pointer
            arrays are made five row groups high, with the extra pointers above and
            below "wrapping around" to point to the last and first real row groups.
            This allows the downsampler to access the proper context rows.
            At the top and bottom of the image, we create dummy context rows by
            copying the first or last real pixel row.  This copying could be avoided
            by pointer hacking as is done in jdmainct.c, but it doesn't seem worth the
            trouble on the compression side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.create_context_buffer">
            <summary>
            Create the wrapped-around downsampling input buffer needed for context mode.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.pre_process_WithoutContext(System.Byte[][],System.Int32@,System.Int32,System.Byte[][][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the simple no-context case.
            
            Preprocessor output data is counted in "row groups".  A row group
            is defined to be v_samp_factor sample rows of each component.
            Downsampling will produce this much data from each max_v_samp_factor
            input rows.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.pre_process_context(System.Byte[][],System.Int32@,System.Int32,System.Byte[][][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the context case.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.expand_bottom_edge(System.Byte[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expand an image vertically from height input_rows to height output_rows,
            by duplicating the bottom row.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master">
            <summary>
            Master control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.prepare_for_output_pass">
            <summary>
            Per-pass setup.
            This is called at the beginning of each output pass.  We determine which
            modules will be active during this pass and give them appropriate
            start_pass calls.  We also set is_dummy_pass to indicate whether this
            is a "real" output pass or a dummy pass for color quantization.
            (In the latter case, we will crank the pass to completion.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.finish_output_pass">
            <summary>
            Finish up at end of an output pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.master_selection">
            <summary>
            Master selection of decompression modules.
            This is done once at jpeg_start_decompress time.  We determine
            which modules will be used and give them appropriate initialization calls.
            We also initialize the decompressor input side to begin consuming data.
            
            Since jpeg_read_header has finished, we know what is in the SOF
            and (first) SOS markers.  We also have all the application parameter
            settings.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.prepare_range_limit_table">
            <summary>
            Allocate and fill in the sample_range_limit table.
            
            Several decompression processes need to range-limit values to the range
            0..MAXJSAMPLE; the input value may fall somewhat outside this range
            due to noise introduced by quantization, roundoff error, etc. These
            processes are inner loops and need to be as fast as possible. On most
            machines, particularly CPUs with pipelines or instruction prefetch,
            a (subscript-check-less) C table lookup
                x = sample_range_limit[x];
            is faster than explicit tests
            <c>
                if (x &amp; 0)
                   x = 0;
                else if (x &gt; MAXJSAMPLE)
                   x = MAXJSAMPLE;
            </c>
            These processes all use a common table prepared by the routine below.
            
            For most steps we can mathematically guarantee that the initial value
            of x is within 2*(MAXJSAMPLE+1) of the legal range, so a table running
            from -2*(MAXJSAMPLE+1) to 3*MAXJSAMPLE+2 is sufficient.But for the
            initial limiting step(just after the IDCT), a wildly out-of-range value
            is possible if the input data is corrupt.To avoid any chance of indexing
            off the end of memory and getting a bad-pointer trap, we perform the
            post-IDCT limiting thus:
                <c>x = (sample_range_limit - SUBSET)[(x + CENTER) &amp; MASK];</c>
            where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit
            samples.  Under normal circumstances this is more than enough range and
            a correct output will be generated; with bogus input data the mask will
            cause wraparound, and we will safely generate a bogus-but-in-range output.
            For the post-IDCT step, we want to convert the data from signed to unsigned
            representation by adding CENTERJSAMPLE at the same time that we limit it.
            This is accomplished with SUBSET = CENTER - CENTERJSAMPLE.
            
            Note that the table is allocated in near data space on PCs; it's small
            enough and used often enough to justify this.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler">
            <summary>
            Downsampling
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.downsample(System.Byte[][][],System.Int32,System.Byte[][][],System.Int32)">
            <summary>
            Do downsampling for a whole row group (all components).
            
            In this version we simply downsample each component independently.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.int_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            One row group is processed per call.
            This version handles arbitrary integral sampling ratios, without smoothing.
            Note that this version is not actually used for customary sampling ratios.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.fullsize_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the special case of a full-size component,
            without smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v1_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the common case of 2:1 horizontal and 1:1 vertical,
            without smoothing.
            
            A note about the "bias" calculations: when rounding fractional values to
            integer, we do not want to always round 0.5 up to the next integer.
            If we did that, we'd introduce a noticeable bias towards larger values.
            Instead, this code is arranged so that 0.5 will be rounded up or down at
            alternate pixel locations (a simple ordered dither pattern).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v2_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the standard case of 2:1 horizontal and 2:1 vertical,
            without smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v2_smooth_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the standard case of 2:1 horizontal and 2:1 vertical,
            with smoothing.  One row of context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.fullsize_smooth_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the special case of a full-size component,
            with smoothing.  One row of context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.expand_right_edge(System.Byte[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expand a component horizontally from width input_cols to width output_cols,
            by duplicating the rightmost samples.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller">
            <summary>
            Coefficient buffer control
            
            This code applies interblock smoothing as described by section K.8
            of the JPEG standard: the first 5 AC coefficients are estimated from
            the DC values of a DCT block and its 8 neighboring blocks.
            We apply smoothing only for progressive JPEG decoding, and only if
            the coefficients it can estimate are not yet known to full precision.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_input_pass">
            <summary>
            Initialize for an input processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.consume_data">
            <summary>
            Consume input data and store it in the full-image coefficient buffer.
            We read as much as one fully interleaved MCU row ("iMCU" row) per call,
            ie, v_samp_factor block rows for each component in the scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_output_pass">
            <summary>
            Initialize for an output processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_onepass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Decompress and return some data in the single-pass case.
            Always attempts to emit one fully interleaved MCU row ("iMCU" row).
            Input and output must run in lockstep since we have only a one-MCU buffer.
            Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
            
            NB: output_buf contains a plane for each component in image,
            which we index according to the component's SOF position.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_data_ordinary(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Decompress and return some data in the multi-pass case.
            Always attempts to emit one fully interleaved MCU row ("iMCU" row).
            Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
            
            NB: output_buf contains a plane for each component in image.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_smooth_data(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Variant of decompress_data for use when doing block smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.smoothing_ok">
            <summary>
            Determine whether block smoothing is applicable and safe.
            We also latch the current states of the coef_bits[] entries for the
            AC coefficients; otherwise, if the input side of the decompressor
            advances into a new scan, we might think the coefficients are known
            more accurately than they really are.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_iMCU_row">
            <summary>
            Reset within-iMCU-row counters for a new row (input side)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller">
            <summary>
            Main buffer control (downsampled-data buffer)
            
            In the current system design, the main buffer need never be a full-image
            buffer; any full-height buffers will be found inside the coefficient or
            postprocessing controllers.  Nonetheless, the main controller is not
            trivial.  Its responsibility is to provide context rows for upsampling/
            rescaling, and doing this in an efficient fashion is a bit tricky.
            
            Postprocessor input data is counted in "row groups".  A row group
            is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
            sample rows of each component.  (We require DCT_scaled_size values to be
            chosen such that these numbers are integers.  In practice DCT_scaled_size
            values will likely be powers of two, so we actually have the stronger
            condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)
            Upsampling will typically produce max_v_samp_factor pixel rows from each
            row group (times any additional scale factor that the upsampler is
            applying).
            
            The coefficient controller will deliver data to us one iMCU row at a time;
            each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or
            exactly min_DCT_scaled_size row groups.  (This amount of data corresponds
            to one row of MCUs when the image is fully interleaved.)  Note that the
            number of sample rows varies across components, but the number of row
            groups does not.  Some garbage sample rows may be included in the last iMCU
            row at the bottom of the image.
            
            Depending on the vertical scaling algorithm used, the upsampler may need
            access to the sample row(s) above and below its current input row group.
            The upsampler is required to set need_context_rows true at global selection
            time if so.  When need_context_rows is false, this controller can simply
            obtain one iMCU row at a time from the coefficient controller and dole it
            out as row groups to the postprocessor.
            
            When need_context_rows is true, this controller guarantees that the buffer
            passed to postprocessing contains at least one row group's worth of samples
            above and below the row group(s) being processed.  Note that the context
            rows "above" the first passed row group appear at negative row offsets in
            the passed buffer.  At the top and bottom of the image, the required
            context rows are manufactured by duplicating the first or last real sample
            row; this avoids having special cases in the upsampling inner loops.
            
            The amount of context is fixed at one row group just because that's a
            convenient number for this controller to work with.  The existing
            upsamplers really only need one sample row of context.  An upsampler
            supporting arbitrary output rescaling might wish for more than one row
            group of context when shrinking the image; tough, we don't handle that.
            (This is justified by the assumption that downsizing will be handled mostly
            by adjusting the DCT_scaled_size values, so that the actual scale factor at
            the upsample step needn't be much less than one.)
            
            To provide the desired context, we have to retain the last two row groups
            of one iMCU row while reading in the next iMCU row.  (The last row group
            can't be processed until we have another row group for its below-context,
            and so we have to save the next-to-last group too for its above-context.)
            We could do this most simply by copying data around in our buffer, but
            that'd be very slow.  We can avoid copying any data by creating a rather
            strange pointer structure.  Here's how it works.  We allocate a workspace
            consisting of M+2 row groups (where M = min_DCT_scaled_size is the number
            of row groups per iMCU row).  We create two sets of redundant pointers to
            the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
            pointer lists look like this:
                              M+1                          M-1
                              master pointer --&gt; 0         master pointer --&gt; 0
                              1                            1
                              ...                          ...
                              M-3                          M-3
                              M-2                           M
                              M-1                          M+1
                               M                           M-2
                              M+1                          M-1
                               0                            0
            We read alternate iMCU rows using each master pointer; thus the last two
            row groups of the previous iMCU row remain un-overwritten in the workspace.
            The pointer lists are set up so that the required context rows appear to
            be adjacent to the proper places when we pass the pointer lists to the
            upsampler.
            
            The above pictures describe the normal state of the pointer lists.
            At top and bottom of the image, we diddle the pointer lists to duplicate
            the first or last sample row as necessary (this is cheaper than copying
            sample rows around).
            
            This scheme breaks down if M less than 2, ie, min_DCT_scaled_size is 1.  In that
            situation each iMCU row provides only one row group so the buffering logic
            must be different (eg, we must read two iMCU rows before we can emit the
            first row group).  For now, we simply do not support providing context
            rows when min_DCT_scaled_size is 1.  That combination seems unlikely to
            be worth providing --- if someone wants a 1/8th-size preview, they probably
            want it quick and dirty, so a context-free upsampler is sufficient.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_simple_main(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This handles the simple case where no context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_context_main(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This handles the case where context rows must be provided.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_crank_post(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            Final pass of two-pass quantization: just call the postprocessor.
            Source data will be the postprocessor controller's internal buffer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.alloc_funny_pointers">
            <summary>
            Allocate space for the funny pointer lists.
            This is done only once, not once per pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.make_funny_pointers">
            <summary>
            Create the funny pointer lists discussed in the comments above.
            The actual workspace is already allocated (in main.buffer),
            and the space for the pointer lists is allocated too.
            This routine just fills in the curiously ordered lists.
            This will be repeated at the beginning of each pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.set_wraparound_pointers">
            <summary>
            Set up the "wraparound" pointers at top and bottom of the pointer lists.
            This changes the pointer list state from top-of-image to the normal state.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.set_bottom_pointers">
            <summary>
            Change the pointer lists to duplicate the last sample row at the bottom
            of the image.  m_whichFunny indicates which m_funnyIndices holds the final iMCU row.
            Also sets rowgroups_avail to indicate number of nondummy row groups in row.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller">
            <summary>
            Decompression postprocessing (color quantization buffer control)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Boolean)">
            <summary>
            Initialize postprocessing controller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_1pass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the one-pass (strip buffer) case.
            This is used for color precision reduction as well as one-pass quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_prepass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Int32@)">
            <summary>
            Process some data in the first pass of 2-pass quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_2pass(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the second pass of 2-pass quantization.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_decoder">
            <summary>
            Entropy decoding
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder">
            <summary>
            Entropy encoding
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct">
            <summary>
            Forward DCT (also controls coefficient quantization)
            
            A forward DCT routine is given a pointer to an input sample array and
            a pointer to a work area of type DCTELEM[]; the DCT is to be performed
            in-place in that buffer.  Type DCTELEM is int for 8-bit samples, INT32
            for 12-bit samples.  (NOTE: Floating-point DCT implementations use an
            array of type FAST_FLOAT, instead.)
            The input data is to be fetched from the sample array starting at a
            specified column.  (Any row offset needed will be applied to the array
            pointer before it is passed to the FDCT code.)
            Note that the number of samples fetched by the FDCT routine is
            DCT_h_scaled_size * DCT_v_scaled_size.
            The DCT outputs are returned scaled up by a factor of 8; they therefore
            have a range of +-8K for 8-bit data, +-128K for 12-bit data.  This
            convention improves accuracy in integer implementations and saves some
            work in floating-point ones.
            
            Each IDCT routine has its own ideas about the best dct_table element type.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.forward_DCT_ptr">
            <summary>
            Perform forward DCT on one or more blocks of a component.
            
            The input samples are taken from the sample_data[] array starting at
            position start_row/start_col, and moving to the right for any additional
            blocks. The quantized coefficients are returned in coef_blocks[].
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.start_pass">
            <summary>
            Initialize for a processing pass.
            Verify that all referenced Q-tables are present, and set up
            the divisor table for each one.
            In the current implementation, DCT of all components is done during
            the first pass, even if only some components will be output in the
            first scan.  Hence all components should be examined here.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_float(System.Single[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            
            A floating-point implementation of the 
            forward DCT (Discrete Cosine Transform).
            
            This implementation should be more accurate than either of the integer
            DCT implementations.  However, it may not give the same results on all
            machines because of differences in roundoff behavior.  Speed will depend
            on the hardware's floating point capacity.
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with a fixed-point
            implementation, accuracy is lost due to imprecise representation of the
            scaled quantization values.  However, that problem does not arise if
            we use floating point arithmetic.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_ifast(System.Int32[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            This file contains a fast, not so accurate integer implementation of the
            forward DCT (Discrete Cosine Transform).
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with fixed-point math,
            accuracy is lost due to imprecise representation of the scaled
            quantization values.  The smaller the quantization table entry, the less
            precise the scaled value, so this implementation does worse with high-
            quality-setting files than with low-quality ones.
            
            Scaling decisions are generally the same as in the LL&amp;M algorithm;
            see jpeg_fdct_islow for more details.  However, we choose to descale
            (right shift) multiplication products as soon as they are formed,
            rather than carrying additional fractional bits into subsequent additions.
            This compromises accuracy slightly, but it lets us save a few shifts.
            More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
            everywhere except in the multiplications proper; this saves a good deal
            of work on 16-bit-int machines.
            
            Again to save a few shifts, the intermediate results between pass 1 and
            pass 2 are not upscaled, but are represented only to integral precision.
            
            A final compromise is to represent the multiplicative constants to only
            8 fractional bits, rather than 13.  This saves some shifting work on some
            machines, and may also reduce the cost of multiplication (since there
            are fewer one-bits in the constants).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_islow(System.Int32[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            
            A slow-but-accurate integer implementation of the
            forward DCT (Discrete Cosine Transform).
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on an algorithm described in
            C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
            Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
            Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
            The primary algorithm described there uses 11 multiplies and 29 adds.
            We use their alternate method with 12 multiplies and 32 adds.
            The advantage of this method is that no data path contains more than one
            multiplication; this allows a very simple and accurate implementation in
            scaled fixed-point arithmetic, with a minimal number of shifts.
            
            The poop on this scaling stuff is as follows:
            
            Each 1-D DCT step produces outputs which are a factor of sqrt(N)
            larger than the true DCT outputs.  The final outputs are therefore
            a factor of N larger than desired; since N=8 this can be cured by
            a simple right shift at the end of the algorithm.  The advantage of
            this arrangement is that we save two multiplications per 1-D DCT,
            because the y0 and y4 outputs need not be divided by sqrt(N).
            In the IJG code, this factor of 8 is removed by the quantization 
            step, NOT here.
            
            We have to do addition and subtraction of the integer inputs, which
            is no problem, and multiplication by fractional constants, which is
            a problem to do in integer arithmetic.  We multiply all the constants
            by CONST_SCALE and convert them to integer constants (thus retaining
            SLOW_INTEGER_CONST_BITS bits of precision in the constants).  After doing a
            multiplication we have to divide the product by CONST_SCALE, with proper
            rounding, to produce the correct output.  This division can be done
            cheaply as a right shift of SLOW_INTEGER_CONST_BITS bits.  We postpone shifting
            as long as possible so that partial sums can be added together with
            full fractional precision.
            
            The outputs of the first pass are scaled up by SLOW_INTEGER_PASS1_BITS bits so that
            they are represented to better-than-integral precision.  These outputs
            require BITS_IN_JSAMPLE + SLOW_INTEGER_PASS1_BITS + 3 bits; this fits in a 16-bit word
            with the recommended scaling.  (For 12-bit sample data, the intermediate
            array is int anyway.)
            
            To avoid overflow of the 32-bit intermediate results in pass 2, we must
            have BITS_IN_JSAMPLE + SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS &lt;= 26.  Error analysis
            shows that the values given below are the most effective.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.FAST_INTEGER_MULTIPLY(System.Int32,System.Int32)">
            <summary>
            Multiply a DCTELEM variable by an int constant, and immediately
            descale to yield a DCTELEM result.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller">
            <summary>
            Input control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize the input controller module.
            This is called only once, when the decompression object is created.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.reset_input_controller">
            <summary>
            Reset state to begin a fresh datastream.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.start_input_pass">
            <summary>
            Initialize the input modules to read a scan of compressed data.
            The first call to this is done after initializing
            the entire decompressor (during jpeg_start_decompress).
            Subsequent calls come from consume_markers, below.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.finish_input_pass">
            <summary>
            Finish up after inputting a compressed-data scan.
            This is called by the coefficient controller after it's read all
            the expected data of the scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.consume_markers">
            <summary>
            Read JPEG markers before, between, or after compressed-data scans.
            Change state as necessary when a new scan is reached.
            Return value is JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
            
            The consume_input method pointer points either here or to the
            coefficient controller's consume_data routine, depending on whether
            we are reading a compressed data segment or inter-segment markers.
            
            Note: This function should NOT return a pseudo SOS marker(with zero
            component number) to the caller.A pseudo marker received by
            read_markers is processed and then skipped for other markers.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.initial_setup">
            <summary>
            Routines to calculate various quantities related to the size of the image.
            Called once, when first SOS marker is reached
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.latch_quant_tables">
            <summary>
            Save away a copy of the Q-table referenced by each component present
            in the current scan, unless already saved during a prior scan.
            
            In a multiple-scan JPEG file, the encoder could assign different components
            the same Q-table slot number, but change table definitions between scans
            so that each component uses a different Q-table.  (The IJG encoder is not
            currently capable of doing this, but other encoders might.)  Since we want
            to be able to dequantize all the components at the end of the file, this
            means that we have to save away the table actually used for each component.
            We do this by copying the table at the start of the first scan containing
            the component.
            The JPEG spec prohibits the encoder from changing the contents of a Q-table
            slot between scans of a component using that slot.  If the encoder does so
            anyway, this decoder will simply use the Q-table values that were current
            at the start of the first scan for the component.
            
            The decompressor output side looks only at the saved quant tables,
            not at the current Q-table slots.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.per_scan_setup">
            <summary>
            Do computations that are needed before processing a JPEG scan
            cinfo.comps_in_scan and cinfo.cur_comp_info[] were set from SOS marker
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct">
            <summary>
            An inverse DCT routine is given a pointer to the input JBLOCK and a pointer
            to an output sample array.  The routine must dequantize the input data as
            well as perform the IDCT; for dequantization, it uses the multiplier table
            pointed to by componentInfo.dct_table.  The output data is to be placed into the
            sample array starting at a specified column. (Any row offset needed will
            be applied to the array pointer before it is passed to the IDCT code)
            Note that the number of samples emitted by the IDCT routine is
            DCT_h_scaled_size * DCT_v_scaled_size.
            
            Each IDCT routine has its own ideas about the best dct_table element type.
            
            The decompressor input side saves away the appropriate
            quantization table for each component at the start of the first scan
            involving that component.  (This is necessary in order to correctly
            decode files that reuse Q-table slots.)
            When we are ready to make an output pass, the saved Q-table is converted
            to a multiplier table that will actually be used by the IDCT routine.
            The multiplier table contents are IDCT-method-dependent.  To support
            application changes in IDCT method between scans, we can remake the
            multiplier tables if necessary.
            In buffered-image mode, the first output pass may occur before any data
            has been seen for some components, and thus before their Q-tables have
            been saved away.  To handle this case, multiplier tables are preset
            to zeroes; the result of the IDCT will be a neutral gray level.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.start_pass">
            <summary>
            Prepare for an output pass.
            Here we select the proper IDCT routine for each component and build
            a matching multiplier table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_islow(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            A slow-but-accurate integer implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on an algorithm described in
            C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
            Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
            Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
            The primary algorithm described there uses 11 multiplies and 29 adds.
            We use their alternate method with 12 multiplies and 32 adds.
            The advantage of this method is that no data path contains more than one
            multiplication; this allows a very simple and accurate implementation in
            scaled fixed-point arithmetic, with a minimal number of shifts.
            
            The poop on this scaling stuff is as follows:
            
            Each 1-D IDCT step produces outputs which are a factor of sqrt(N)
            larger than the true IDCT outputs.  The final outputs are therefore
            a factor of N larger than desired; since N=8 this can be cured by
            a simple right shift at the end of the algorithm.  The advantage of
            this arrangement is that we save two multiplications per 1-D IDCT,
            because the y0 and y4 inputs need not be divided by sqrt(N).
            
            We have to do addition and subtraction of the integer inputs, which
            is no problem, and multiplication by fractional constants, which is
            a problem to do in integer arithmetic.  We multiply all the constants
            by CONST_SCALE and convert them to integer constants (thus retaining
            SLOW_INTEGER_CONST_BITS bits of precision in the constants).  After doing a
            multiplication we have to divide the product by CONST_SCALE, with proper
            rounding, to produce the correct output.  This division can be done
            cheaply as a right shift of SLOW_INTEGER_CONST_BITS bits.  We postpone shifting
            as long as possible so that partial sums can be added together with
            full fractional precision.
            
            The outputs of the first pass are scaled up by SLOW_INTEGER_PASS1_BITS bits so that
            they are represented to better-than-integral precision.  These outputs
            require BITS_IN_JSAMPLE + SLOW_INTEGER_PASS1_BITS + 3 bits; this fits in a 16-bit word
            with the recommended scaling.  (To scale up 12-bit sample data further, an
            intermediate int array would be needed.)
            
            To avoid overflow of the 32-bit intermediate results in pass 2, we must
            have BITS_IN_JSAMPLE + SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS &lt;= 26.  Error analysis
            shows that the values given below are the most effective.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.SLOW_INTEGER_DEQUANTIZE(System.Int32,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce an int result.  In this module, both inputs and result
            are 16 bits or less, so either int or short multiply will work.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_ifast(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            
            A fast, not so accurate integer implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with fixed-point math,
            accuracy is lost due to imprecise representation of the scaled
            quantization values.  The smaller the quantization table entry, the less
            precise the scaled value, so this implementation does worse with high-
            quality-setting files than with low-quality ones.
            
            Scaling decisions are generally the same as in the LL&amp;M algorithm;
            However, we choose to descale
            (right shift) multiplication products as soon as they are formed,
            rather than carrying additional fractional bits into subsequent additions.
            This compromises accuracy slightly, but it lets us save a few shifts.
            More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
            everywhere except in the multiplications proper; this saves a good deal
            of work on 16-bit-int machines.
            
            The dequantized coefficients are not integers because the AA&amp;N scaling
            factors have been incorporated.  We represent them scaled up by FAST_INTEGER_PASS1_BITS,
            so that the first and second IDCT rounds have the same input scaling.
            For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = FAST_INTEGER_PASS1_BITS so as to
            avoid a descaling shift; this compromises accuracy rather drastically
            for small quantization table entries, but it saves a lot of shifts.
            For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
            so we use a much larger scaling factor to preserve accuracy.
            
            A final compromise is to represent the multiplicative constants to only
            8 fractional bits, rather than 13.  This saves some shifting work on some
            machines, and may also reduce the cost of multiplication (since there
            are fewer one-bits in the constants).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_MULTIPLY(System.Int32,System.Int32)">
            <summary>
            Multiply a DCTELEM variable by an int constant, and immediately
            descale to yield a DCTELEM result.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_DEQUANTIZE(System.Int16,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce a DCTELEM result.  For 8-bit data a 16x16-&gt;16
            multiplication will do.  For 12-bit data, the multiplier table is
            declared int, so a 32-bit multiply will be used.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_IRIGHT_SHIFT(System.Int32,System.Int32)">
            <summary>
            Like DESCALE, but applies to a DCTELEM and produces an int.
            We assume that int right shift is unsigned if int right shift is.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_float(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            
            A floating-point implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            This implementation should be more accurate than either of the integer
            IDCT implementations.  However, it may not give the same results on all
            machines because of differences in roundoff behavior.  Speed will depend
            on the hardware's floating point capacity.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with a fixed-point
            implementation, accuracy is lost due to imprecise representation of the
            scaled quantization values.  However, that problem does not arise if
            we use floating point arithmetic.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FLOAT_DEQUANTIZE(System.Int16,System.Single)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce a float result.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_4x4(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Inverse-DCT routines that produce reduced-size output:
            either 4x4, 2x2, or 1x1 pixels from an 8x8 DCT block.
            
            NOTE: this code only copes with 8x8 DCTs.
            
            The implementation is based on the Loeffler, Ligtenberg and Moschytz (LL&amp;M)
            algorithm. We simply replace each 8-to-8 1-D IDCT step
            with an 8-to-4 step that produces the four averages of two adjacent outputs
            (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).
            These steps were derived by computing the corresponding values at the end
            of the normal LL&amp;M code, then simplifying as much as possible.
            
            1x1 is trivial: just take the DC coefficient divided by 8.
            
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 4x4 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_2x2(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 2x2 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_1x1(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 1x1 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.REDUCED_DEQUANTIZE(System.Int16,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce an int result.  In this module, both inputs and result
            are 16 bits or less, so either int or short multiply will work.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader">
            <summary>
            Marker reading and parsing
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize the marker reader module.
            This is called only once, when the decompression object is created.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.reset_marker_reader">
            <summary>
            Reset marker processing state to begin a fresh datastream.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.read_markers">
            <summary>
            Read markers until SOS or EOI.
            
            Returns same codes as are defined for jpeg_consume_input:
            JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
            
            Note: This function may return a pseudo SOS marker(with zero
            component number) for treat by input controller's consume_input.
            consume_input itself should filter out (skip) the pseudo marker
            after processing for the caller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.read_restart_marker">
            <summary>
            Read a restart marker, which is expected to appear next in the datastream;
            if the marker is not there, take appropriate recovery action.
            Returns false if suspension is required.
            
            Made public for use by entropy decoder only
            
            This is called by the entropy decoder after it has read an appropriate
            number of MCUs.  cinfo.unread_marker may be nonzero if the entropy decoder
            has already read a marker from the data source.  Under normal conditions
            cinfo.unread_marker will be reset to 0 before returning; if not reset,
            it holds a marker which the decoder will be unable to read past.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.next_marker">
            <summary>
            Find the next JPEG marker, save it in cinfo.unread_marker.
            Returns false if had to suspend before reaching a marker;
            in that case cinfo.unread_marker is unchanged.
            
            Note that the result might not be a valid marker code,
            but it will never be 0 or FF.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)">
            <summary>
            Install a special processing method for COM or APPn markers.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.save_marker(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Save an APPn or COM marker into the marker list
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.skip_variable(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Skip over an unknown or uninteresting variable-length marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_interesting_appn(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Process an APP0 or APP14 marker without saving it
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.examine_app0(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Examine first few bytes from an APP0.
            Take appropriate action if it is a JFIF marker.
            datalen is # of bytes at data[], remaining is length of rest of marker data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.examine_app14(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Examine first few bytes from an APP14.
            Take appropriate action if it is an Adobe marker.
            datalen is # of bytes at data[], remaining is length of rest of marker data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_soi">
            <summary>
            Process an SOI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_sof(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Process a SOFn marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_sos">
            <summary>
            Process a SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dac">
            <summary>
            Process a DAC marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dht">
            <summary>
            Process a DHT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dqt">
            <summary>
            Process a DQT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dri">
            <summary>
            Process a DRI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_lse">
            <summary>
            Process an LSE marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.first_marker">
            <summary>
            Like next_marker, but used to obtain the initial SOI marker.
            For this marker, we do not allow preceding garbage or fill; otherwise,
            we might well scan an entire input file before realizing it ain't JPEG.
            If an application wants to process non-JFIF files, it must seek to the
            SOI before calling the JPEG library.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer">
            <summary>
            Marker writing
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_file_header">
            <summary>
            Write datastream header.
            This consists of an SOI and optional APPn markers.
            We recommend use of the JFIF marker, but not the Adobe marker,
            when using YCbCr or grayscale data. The JFIF marker is also used
            for other standard JPEG colorspaces. The Adobe marker is helpful
            to distinguish RGB, CMYK, and YCCK colorspaces.
            Note that an application can write additional header markers after
            jpeg_start_compress returns.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_frame_header">
            <summary>
            Write frame header.
            This consists of DQT and SOFn markers,
            a conditional LSE marker and a conditional pseudo SOS marker.
            Note that we do not emit the SOF until we have emitted the DQT(s).
            This avoids compatibility problems with incorrect implementations that
            try to error-check the quant table numbers as soon as they see the SOF.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_scan_header">
            <summary>
            Write scan header.
            This consists of DHT or DAC markers, optional DRI, and SOS.
            Compressed data will be written following the SOS.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_file_trailer">
            <summary>
            Write datastream trailer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_tables_only">
            <summary>
            Write an abbreviated table-specification datastream.
            This consists of SOI, DQT and DHT tables, and EOI.
            Any table that is defined and not marked sent_table = true will be
            emitted.  Note that all tables will be marked sent_table = true at exit.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_marker_header(System.Int32,System.Int32)">
            <summary>
            Emit an arbitrary marker header
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_marker_byte(System.Byte)">
            <summary>
            Emit one byte of marker parameters following write_marker_header
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_sos">
            <summary>
            Emit a SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_lse_ict">
            <summary>
            Emit an LSE inverse color transform specification marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_sof(BitMiracle.LibJpeg.Classic.JPEG_MARKER)">
            <summary>
            Emit a SOF marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_adobe_app14">
            <summary>
            Emit an Adobe APP14 marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dri">
            <summary>
            Emit a DRI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dht(System.Int32,System.Boolean)">
            <summary>
            Emit a DHT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dqt(System.Int32)">
            <summary>
            Emit a DQT marker
            </summary>
            <param name="index">The index.</param>
            <returns>the precision used (0 = 8bits, 1 = 16bits) for baseline checking</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_pseudo_sos">
            <summary>
            Emit a pseudo SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_jfif_app0">
            <summary>
            Emit a JFIF-compliant APP0 marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_marker(BitMiracle.LibJpeg.Classic.JPEG_MARKER)">
            <summary>
            Emit a marker code
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_2bytes(System.Int32)">
            <summary>
            Emit a 2-byte integer; these are always MSB first in JPEG files
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_byte(System.Int32)">
            <summary>
            Emit a byte
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_scan_info">
            <summary>
            The script for encoding a multiple-scan file is an array of these:
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_upsampler">
            <summary>
            Upsampling (note that upsampler must also call color converter)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE">
            <summary>
            Operating modes for buffer controllers
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer">
            <summary>
            The main purpose of 1-pass quantization is to provide a fast, if not very
            high quality, colormapped output capability.  A 2-pass quantizer usually
            gives better visual quality; however, for quantized grayscale output this
            quantizer is perfectly adequate.  Dithering is highly recommended with this
            quantizer, though you can turn it off if you really want to.
            
            In 1-pass quantization the colormap must be chosen in advance of seeing the
            image.  We use a map consisting of all combinations of Ncolors[i] color
            values for the i'th component.  The Ncolors[] values are chosen so that
            their product, the total number of colors, is no more than that requested.
            (In most cases, the product will be somewhat less.)
            
            Since the colormap is orthogonal, the representative value for each color
            component can be determined without considering the other components;
            then these indexes can be combined into a colormap index by a standard
            N-dimensional-array-subscript calculation.  Most of the arithmetic involved
            can be precalculated and stored in the lookup table colorindex[].
            colorindex[i][j] maps pixel value j in component i to the nearest
            representative value (grid plane) for that component; this index is
            multiplied by the array stride for component i, so that the
            index of the colormap entry closest to a given pixel value is just
                sum( colorindex[component-number][pixel-component-value] )
            Aside from being fast, this scheme allows for variable spacing between
            representative values with no additional lookup cost.
            
            If gamma correction has been applied in color conversion, it might be wise
            to adjust the color grid spacing so that the representative colors are
            equidistant in linear space.  At this writing, gamma correction is not
            implemented, so nothing is done here.
            
            
            Declarations for Floyd-Steinberg dithering.
            
            Errors are accumulated into the array fserrors[], at a resolution of
            1/16th of a pixel count.  The error at a given pixel is propagated
            to its not-yet-processed neighbors using the standard F-S fractions,
                ...	(here)	7/16
               3/16	5/16	1/16
            We work left-to-right on even rows, right-to-left on odd rows.
            
            We can get away with a single array (holding one row's worth of errors)
            by using it to store the current row's errors at pixel columns not yet
            processed, but the next row's errors at columns already processed.  We
            need only a few extra variables to hold the errors immediately around the
            current column.  (If we are lucky, those variables are in registers, but
            even if not, they're probably cheaper to access than array elements are.)
            
            The fserrors[] array is indexed [component#][position].
            We provide (#columns + 2) entries per component; the extra entry at each
            end saves us from special-casing the first and last pixels.
            
            
            Declarations for ordered dithering.
            
            We use a standard 16x16 ordered dither array.  The basic concept of ordered
            dithering is described in many references, for instance Dale Schumacher's
            chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).
            In place of Schumacher's comparisons against a "threshold" value, we add a
            "dither" value to the input pixel and then round the result to the nearest
            output value.  The dither value is equivalent to (0.5 - threshold) times
            the distance between output values.  For ordered dithering, we assume that
            the output colors are equally spaced; if not, results will probably be
            worse, since the dither may be too much or too little at a given point.
            
            The normal calculation would be to form pixel value + dither, range-limit
            this to 0..MAXJSAMPLE, and then index into the colorindex table as usual.
            We can skip the separate range-limiting step by extending the colorindex
            table in both directions.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for 1-pass color quantization.
            </summary>
            <param name="cinfo">The cinfo.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.start_pass(System.Boolean)">
            <summary>
            Initialize for one-pass color quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.finish_pass">
            <summary>
            Finish up at the end of the pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.new_color_map">
            <summary>
            Switch to a new external colormap between output passes.
            Shouldn't get to this!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, no dithering.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize3(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            Fast path for out_color_components==3, no dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize_ord_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, with ordered dithering.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize3_ord_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            Fast path for out_color_components==3, with ordered dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize_fs_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, with Floyd-Steinberg dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_colormap">
            <summary>
            Create the colormap.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_colorindex">
            <summary>
            Create the color index table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_odither_tables">
            <summary>
            Create the ordered-dither tables.
            Components having the same number of representative colors may 
            share a dither table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.alloc_fs_workspace">
            <summary>
            Allocate workspace for Floyd-Steinberg errors.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.largest_input_value(System.Int32,System.Int32)">
            <summary>
            Return largest input value that should map to j'th output value
            Must have largest(j=0) &gt;= 0, and largest(j=maxj) &gt;= MAXJSAMPLE
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.output_value(System.Int32,System.Int32)">
            <summary>
            Return j'th output value, where j will range from 0 to maxj
            The output values must fall in 0..MAXJSAMPLE in increasing order
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.select_ncolors(System.Int32[])">
            <summary>
            Determine allocation of desired colors to components,
            and fill in Ncolors[] array to indicate choice.
            Return value is total number of colors (product of Ncolors[] values).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.make_odither_array(System.Int32)">
            <summary>
            Create an ordered-dither array for a component having ncolors
            distinct output values.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer">
            <summary>
            This module implements the well-known Heckbert paradigm for color
            quantization.  Most of the ideas used here can be traced back to
            Heckbert's seminal paper
            Heckbert, Paul.  "Color Image Quantization for Frame Buffer Display",
            Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
            
            In the first pass over the image, we accumulate a histogram showing the
            usage count of each possible color.  To keep the histogram to a reasonable
            size, we reduce the precision of the input; typical practice is to retain
            5 or 6 bits per color, so that 8 or 4 different input values are counted
            in the same histogram cell.
            
            Next, the color-selection step begins with a box representing the whole
            color space, and repeatedly splits the "largest" remaining box until we
            have as many boxes as desired colors.  Then the mean color in each
            remaining box becomes one of the possible output colors.
            
            The second pass over the image maps each input pixel to the closest output
            color (optionally after applying a Floyd-Steinberg dithering correction).
            This mapping is logically trivial, but making it go fast enough requires
            considerable care.
            
            Heckbert-style quantizers vary a good deal in their policies for choosing
            the "largest" box and deciding where to cut it.  The particular policies
            used here have proved out well in experimental comparisons, but better ones
            may yet be found.
            
            In earlier versions of the IJG code, this module quantized in YCbCr color
            space, processing the raw upsampled data without a color conversion step.
            This allowed the color conversion math to be done only once per colormap
            entry, not once per pixel.  However, that optimization precluded other
            useful optimizations (such as merging color conversion with upsampling)
            and it also interfered with desired capabilities such as quantizing to an
            externally-supplied colormap.  We have therefore abandoned that approach.
            The present code works in the post-conversion color space, typically RGB.
            
            To improve the visual quality of the results, we actually work in scaled
            RGB space, giving G distances more weight than R, and R in turn more than
            B.  To do everything in integer math, we must use integer scale factors.
            The 2/3/1 scale factors used here correspond loosely to the relative
            weights of the colors in the NTSC grayscale equation.
            If you want to use this code to quantize a non-RGB color space, you'll
            probably need to change these scale factors.
            
            First we have the histogram data structure and routines for creating it.
            
            The number of bits of precision can be adjusted by changing these symbols.
            We recommend keeping 6 bits for G and 5 each for R and B.
            If you have plenty of memory and cycles, 6 bits all around gives marginally
            better results; if you are short of memory, 5 bits all around will save
            some space but degrade the results.
            To maintain a fully accurate histogram, we'd need to allocate a "long"
            (preferably unsigned long) for each cell.  In practice this is overkill;
            we can get by with 16 bits per cell.  Few of the cell counts will overflow,
            and clamping those that do overflow to the maximum value will give close-
            enough results.  This reduces the recommended histogram size from 256Kb
            to 128Kb, which is a useful savings on PC-class machines.
            (In the second pass the histogram space is re-used for pixel mapping data;
            in that capacity, each cell must be able to store zero to the number of
            desired colors.  16 bits/cell is plenty for that too.)
            Since the JPEG code is intended to run in small memory model on 80x86
            machines, we can't just allocate the histogram in one chunk.  Instead
            of a true 3-D array, we use a row of pointers to 2-D arrays.  Each
            pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and
            each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that
            on 80x86 machines, the pointer row is in near memory but the actual
            arrays are in far memory (same arrangement as we use for image arrays).
            
            
            Declarations for Floyd-Steinberg dithering.
            
            Errors are accumulated into the array fserrors[], at a resolution of
            1/16th of a pixel count.  The error at a given pixel is propagated
            to its not-yet-processed neighbors using the standard F-S fractions,
                ... (here)  7/16
            3/16    5/16    1/16
            We work left-to-right on even rows, right-to-left on odd rows.
            
            We can get away with a single array (holding one row's worth of errors)
            by using it to store the current row's errors at pixel columns not yet
            processed, but the next row's errors at columns already processed.  We
            need only a few extra variables to hold the errors immediately around the
            current column.  (If we are lucky, those variables are in registers, but
            even if not, they're probably cheaper to access than array elements are.)
            
            The fserrors[] array has (#columns + 2) entries; the extra entry at
            each end saves us from special-casing the first and last pixels.
            Each entry is three values long, one value for each color component.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for 2-pass color quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.start_pass(System.Boolean)">
            <summary>
            Initialize for each processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.new_color_map">
            <summary>
            Switch to a new external colormap between output passes.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.prescan_quantize(System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Prescan some rows of pixels.
            In this module the prescan simply updates the histogram, which has been
            initialized to zeroes by start_pass.
            An output_buf parameter is required by the method signature, but no data
            is actually output (in fact the buffer controller is probably passing a
            null pointer).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.pass2_fs_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            This version performs Floyd-Steinberg dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.pass2_no_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            This version performs no dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.finish_pass1">
            <summary>
            Finish up at the end of each pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.compute_color(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32,System.Int32)">
            <summary>
            Compute representative color for a box, put it in colormap[icolor]
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.select_colors(System.Int32)">
            <summary>
            Master routine for color selection
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.median_cut(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32,System.Int32)">
            <summary>
            Repeatedly select and split the largest box until we have enough boxes
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_biggest_color_pop(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Find the splittable box with the largest color population
            Returns null if no splittable boxes remain
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_biggest_volume(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Find the splittable box with the largest (scaled) volume
            Returns null if no splittable boxes remain
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.update_box(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Shrink the min/max bounds of a box to enclose only nonzero elements,
            and recompute its volume and population
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.init_error_limit">
            <summary>
            Initialize the error-limiting transfer function (lookup table).
            The raw F-S error computation can potentially compute error values of up to
            +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
            much less, otherwise obviously wrong pixels will be created.  (Typical
            effects include weird fringes at color-area boundaries, isolated bright
            pixels in a dark area, etc.)  The standard advice for avoiding this problem
            is to ensure that the "corners" of the color cube are allocated as output
            colors; then repeated errors in the same direction cannot cause cascading
            error buildup.  However, that only prevents the error from getting
            completely out of hand; Aaron Giles reports that error limiting improves
            the results even with corner colors allocated.
            A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
            well, but the smoother transfer function used below is even better.  Thanks
            to Aaron Giles for this idea.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_nearby_colors(System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>
            Locate the colormap entries close enough to an update box to be candidates
            for the nearest entry to some cell(s) in the update box.  The update box
            is specified by the center coordinates of its first cell.  The number of
            candidate colormap entries is returned, and their colormap indexes are
            placed in colorlist[].
            This routine uses Heckbert's "locally sorted search" criterion to select
            the colors that need further consideration.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_best_colors(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Find the closest colormap entry for each cell in the update box,
            given the list of candidate colors prepared by find_nearby_colors.
            Return the indexes of the closest entries in the bestcolor[] array.
            This routine uses Thomas' incremental distance calculation method to
            find the distance from a colormap entry to successive cells in the box.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.fill_inverse_cmap(System.Int32,System.Int32,System.Int32)">
            <summary>
            Fill the inverse-colormap entries in the update box that contains
            histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but
            we can fill as many others as we wish.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressDataImpl(System.Byte[][][])">
            <summary>
            Process some data in the single-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the image.
            Returns true if the iMCU row is completed, false if suspended.
            
            NB: input_buf contains a plane for each component in image,
            which we index according to the component's SOF position.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressFirstPass(System.Byte[][][])">
            <summary>
            Process some data in the first pass of a multi-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the image.
            This amount of data is read from the source buffer, DCT'd and quantized,
            and saved into the virtual arrays.  We also generate suitable dummy blocks
            as needed at the right and lower edges.  (The dummy blocks are constructed
            in the virtual arrays, which have been padded appropriately.)  This makes
            it possible for subsequent passes not to worry about real vs. dummy blocks.
            
            We must also emit the data to the entropy encoder.  This is conveniently
            done by calling compress_output() after we've loaded the current strip
            of the virtual arrays.
            
            NB: input_buf contains a plane for each component in image.  All
            components are DCT'd and loaded into the virtual arrays in this pass.
            However, it may be that only a subset of the components are emitted to
            the entropy encoder during this first pass; be careful about looking
            at the scan-dependent variables (MCU dimensions, etc).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressOutput">
            <summary>
            Process some data in subsequent passes of a multi-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the scan.
            The data is obtained from the virtual arrays and fed to the entropy coder.
            Returns true if the iMCU row is completed, false if suspended.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr">
            <summary>
            Expanded data destination object for output to Stream
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.init_destination">
            <summary>
            Initialize destination --- called by jpeg_start_compress
            before any data is actually written.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.empty_output_buffer">
            <summary>
            Empty the output buffer --- called whenever buffer fills up.
            
            In typical applications, this should write the entire output buffer
            (ignoring the current state of next_output_byte and free_in_buffer),
            reset the pointer and count to the start of the buffer, and return true
            indicating that the buffer has been dumped.
            
            In applications that need to be able to suspend compression due to output
            overrun, a false return indicates that the buffer cannot be emptied now.
            In this situation, the compressor will return to its caller (possibly with
            an indication that it has not accepted all the supplied scanlines).  The
            application should resume compression after it has made more room in the
            output buffer.  Note that there are substantial restrictions on the use of
            suspension --- see the documentation.
            
            When suspending, the compressor will back up to a convenient restart point
            (typically the start of the current MCU). next_output_byte and free_in_buffer
            indicate where the restart point will be if the current call returns false.
            Data beyond this point will be regenerated after resumption, so do not
            write it out when emptying the buffer externally.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.term_destination">
            <summary>
            Terminate destination --- called by jpeg_finish_compress
            after all data has been written.  Usually needs to flush buffer.
            
            NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.start_pass">
            <summary>
            Initialize for an upsampling pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.merged_1v_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Byte[][],System.Int32@)">
            <summary>
            Control routine to do upsampling (and color conversion).
            The control routine just handles the row buffering considerations.
            1:1 vertical sampling case: much easier, never need a spare row.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.merged_2v_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Control routine to do upsampling (and color conversion).
            The control routine just handles the row buffering considerations.
            2:1 vertical sampling case: may need a spare row.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.h2v1_merged_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.h2v2_merged_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][])">
            <summary>
            Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.build_ycc_rgb_table">
            <summary>
            Initialize tables for YCbCr-&gt;RGB colorspace conversion.
            This is taken directly from jpeg_color_deconverter; see that file for more info.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.build_bg_ycc_rgb_table">
            <summary>
            Initialize tables for BG_YCC-&gt;RGB colorspace conversion.
            This is taken directly from jpeg_color_deconverter; see that file for more info.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr">
            <summary>
            Expanded data source object for stdio input
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize source - called by jpeg_read_header
            before any data is actually read.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr.fill_input_buffer">
            <summary>
            Fill the input buffer - called whenever buffer is emptied.
            
            In typical applications, this should read fresh data into the buffer
            (ignoring the current state of next_input_byte and bytes_in_buffer),
            reset the pointer and count to the start of the buffer, and return true
            indicating that the buffer has been reloaded.  It is not necessary to
            fill the buffer entirely, only to obtain at least one more byte.
            
            There is no such thing as an EOF return.  If the end of the file has been
            reached, the routine has a choice of ERREXIT() or inserting fake data into
            the buffer.  In most cases, generating a warning message and inserting a
            fake EOI marker is the best course of action --- this will allow the
            decompressor to output however much of the image is there.  However,
            the resulting error message is misleading if the real problem is an empty
            input file, so we handle that case specially.
            
            In applications that need to be able to suspend compression due to input
            not being available yet, a false return indicates that no more data can be
            obtained right now, but more may be forthcoming later.  In this situation,
            the decompressor will return to its caller (with an indication of the
            number of scanlines it has read, if any).  The application should resume
            decompression after it has loaded more data into the input buffer.  Note
            that there are substantial restrictions on the use of suspension --- see
            the documentation.
            
            When suspending, the decompressor will back up to a convenient restart point
            (typically the start of the current MCU). next_input_byte and bytes_in_buffer
            indicate where the restart point will be if the current call returns false.
            Data beyond this point must be rescanned after resumption, so move it to
            the front of the buffer rather than discarding it.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller">
            <summary>
            This is a special implementation of the coefficient
            buffer controller.  This is similar to jccoefct.c, but it handles only
            output from presupplied virtual arrays.  Furthermore, we generate any
            dummy padding blocks on-the-fly rather than expecting them to be present
            in the arrays.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_compress_struct,BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Initialize coefficient buffer controller.
            
            Each passed coefficient array must be the right size for that
            coefficient: width_in_blocks wide and height_in_blocks high,
            with unit height at least v_samp_factor.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.compress_data(System.Byte[][][])">
            <summary>
            Process some data.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the scan.
            The data is obtained from the virtual arrays and fed to the entropy coder.
            Returns true if the iMCU row is completed, false if suspended.
            
            NB: input_buf is ignored; it is likely to be a null pointer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.start_iMCU_row">
            <summary>
            Reset within-iMCU-row counters for a new row
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.start_pass">
            <summary>
            Initialize for an upsampling pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Control routine to do upsampling (and color conversion).
            
            In this version we upsample each component independently.
            We upsample one row group into the conversion buffer, then apply
            color conversion a row at a time.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.noop_upsample">
            <summary>
            This is a no-op version used for "uninteresting" components.
            These components will not be referenced by color conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.fullsize_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            For full-size components, we just make color_buf[ci] point at the
            input buffer, and thus avoid copying any data.  Note that this is
            safe only because sep_upsample doesn't declare the input row group
            "consumed" until we are done color converting and emitting it.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v1_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
            It's still a box filter.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v2_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
            It's still a box filter.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.int_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            This version handles any integral sampling ratios.
            This is not used for typical JPEG files, so it need not be fast.
            Nor, for that matter, is it particularly accurate: the algorithm is
            simple replication of the input pixel onto the corresponding output
            pixels.  The hi-falutin sampling literature refers to this as a
            "box filter".  A box filter tends to introduce visible artifacts,
            so if you are actually going to use 3:1 or 4:1 sampling ratios
            you would be well advised to improve this code.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JBLOCK">
            <summary>
            One block of coefficients.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JBLOCK.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The index of required element.</param>
            <value>The required element.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JHUFF_TBL">
            <summary>
            Huffman coding table.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JHUFF_TBL.Sent_table">
            <summary>
            Gets or sets a value indicating whether the table has been output to file.
            </summary>
            <value>It's initialized <c>false</c> when the table is created, and set 
            <c>true</c> when it's been output to the file. You could suppress output 
            of a table by setting this to <c>true</c>.
            </value>
            <remarks>This property is used only during compression. It's initialized
            <c>false</c> when the table is created, and set <c>true</c> when it's been
            output to the file. You could suppress output of a table by setting this to
            <c>true</c>. (See jpeg_suppress_tables for an example.)</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)" />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JpegConstants">
            <summary>
            Defines some JPEG constants.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.DCTSIZE">
            <summary>
            The basic DCT block is 8x8 coefficients
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.DCTSIZE2">
            <summary>
            DCTSIZE squared; the number of elements in a block. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_QUANT_TBLS">
            <summary>
            Quantization tables are numbered 0..3 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_HUFF_TBLS">
            <summary>
            Huffman tables are numbered 0..3
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_ARITH_TBLS">
            <summary>
            Arith-coding tables are numbered 0..15
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_COMPS_IN_SCAN">
            <summary>
            JPEG limit on the number of components in one scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.C_MAX_BLOCKS_IN_MCU">
            <summary>
            Compressor's limit on blocks per MCU.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.D_MAX_BLOCKS_IN_MCU">
            <summary>
            Decompressor's limit on blocks per MCU.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_SAMP_FACTOR">
            <summary>
            JPEG limit on sampling factors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_COMPONENTS">
            <summary>
            Maximum number of color channels allowed in JPEG image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.BITS_IN_JSAMPLE">
            <summary>
            The size of sample.
            </summary>
            <remarks>Are either:
            8 - for 8-bit sample values (the usual setting)<br />
            9 - for 9-bit sample values
            10 - for 10-bit sample values
            11 - for 11-bit sample values
            12 - for 12-bit sample values (not supported by this version)<br />
            Only 8, 9, 10, 11, and 12 bits sample data precision are supported for
            full-feature DCT processing.Further depths up to 16-bit may be added
            later for the lossless modes of operation.
            Run-time selection and conversion of data precision will be added later
            and are currently not supported, sorry.
            Exception:  The transcoding part(jpegtran) supports all settings in a
            single instance, since it operates on the level of DCT coefficients and
            not sample values.The DCT coefficients are of the same type(16 bits)
            in all cases(see below).
            </remarks>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JDCT_DEFAULT">
            <summary>
            DCT method used by default.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JDCT_FASTEST">
            <summary>
            Fastest DCT method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JPEG_MAX_DIMENSION">
            <summary>
            A tad under 64K to prevent overflows. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAXJSAMPLE">
            <summary>
            The maximum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.CENTERJSAMPLE">
            <summary>
            The medium sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_RED">
            <summary>
            Offset of Red in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_GREEN">
            <summary>
            Offset of Green in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_BLUE">
            <summary>
            Offset of Blue in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_PIXELSIZE">
            <summary>
            Bytes per RGB scanline element.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.HUFF_LOOKAHEAD">
            <summary>
            The number of bits of lookahead.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_common_struct">
            <summary>Base class for both JPEG compressor and decompresor.</summary>
            <remarks>
            Routines that are to be used by both halves of the library are declared
            to receive an instance of this class. There are no actual instances of 
            <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_common_struct" />, only of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" /> 
            and <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" /></remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.#ctor">
            <summary>
            Base constructor.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Base constructor.
            </summary>
            <param name="errorManager">The error manager.</param>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.IsDecompressor">
            <summary>
            Gets a value indicating whether this instance is Jpeg decompressor.
            </summary>
            <value>
                <c>true</c> if this is Jpeg decompressor; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Progress">
            <summary>
            Progress monitor.
            </summary>
            <value>The progress manager.</value>
            <remarks>Default value: <c>null</c>.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Err">
            <summary>
            Error handler module.
            </summary>
            <value>The error manager.</value>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Version">
            <summary>
            Gets the version of LibJpeg.
            </summary>
            <value>The version of LibJpeg.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Copyright">
            <summary>
            Gets the LibJpeg's copyright.
            </summary>
            <value>The copyright.</value>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateSamplesArray(System.Int32,System.Int32)">
            <summary>
            Creates the array of samples.
            </summary>
            <param name="samplesPerRow">The number of samples in row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateBlocksArray(System.Int32,System.Int32)">
            <summary>
            Creates the array of blocks.
            </summary>
            <param name="blocksPerRow">The number of blocks in row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of blocks.</returns>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.JBLOCK" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.AllocJpegSamples(System.Int32,System.Int32)">
            <summary>
            Creates 2-D sample array.
            </summary>
            <param name="samplesPerRow">The number of samples per row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort">
            <summary>
            Abort processing of a JPEG compression or decompression operation,
            but don't destroy the object itself.
            
            Closing a data source or destination, if necessary, is the 
            application's responsibility.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_destroy">
            <summary>
            Destruction of a JPEG object. 
            
            Closing a data source or destination, if necessary, is the 
            application's responsibility.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(System.Int32,System.Object[])">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(System.Int32,System.Object[])">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" /> for description.</param>
            <param name="code">The message code.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" /> for description.</param>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,System.Int32,System.Object[])">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" /> for description.</param>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_component_info">
            <summary>
            Basic info about one component (color channel).
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Component_id">
            <summary>
            Identifier for this component (0..255)
            </summary>
            <value>The component ID.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Component_index">
            <summary>
            Its index in SOF or <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Comp_info" />.
            </summary>
            <value>The component index.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.H_samp_factor">
            <summary>
            Horizontal sampling factor (1..4)
            </summary>
            <value>The horizontal sampling factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.V_samp_factor">
            <summary>
            Vertical sampling factor (1..4)
            </summary>
            <value>The vertical sampling factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Quant_tbl_no">
            <summary>
            Quantization table selector (0..3)
            </summary>
            <value>The quantization table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Dc_tbl_no">
            <summary>
            DC entropy table selector (0..3)
            </summary>
            <value>The DC entropy table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Ac_tbl_no">
            <summary>
            AC entropy table selector (0..3)
            </summary>
            <value>The AC entropy table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Width_in_blocks">
            <summary>
            Gets or sets the width in blocks.
            </summary>
            <value>The width in blocks.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Downsampled_width">
            <summary>
            Gets the downsampled width.
            </summary>
            <value>The downsampled width.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct">
            <summary>
            JPEG compression routine.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.scale_num">
            <summary>
            The scale numerator
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.scale_denom">
            <summary>
            The scale denomenator
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.q_scale_factor">
            <summary>
            corresponding scale factors (percentage, initialized 100).
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.do_fancy_downsampling">
            <summary>
            TRUE=apply fancy downsampling
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.color_transform">
            <summary>
            Color transform identifier, writes LSE marker if nonzero
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.block_size">
            <summary>
            the basic DCT block size: 1..16
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" /> class.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" /> class.
            </summary>
            <param name="errorManager">The error manager.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.IsDecompressor">
            <summary>
            Retrieves <c>false</c> because this is not decompressor.
            </summary>
            <value>
                <c>false</c>
            </value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dest">
            <summary>
            Gets or sets the destination for compressed data
            </summary>
            <value>The destination for compressed data.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Image_width">
            <summary>
            Gets or sets the width of image, in pixels.
            </summary>
            <value>The width of image.</value>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Image_height">
            <summary>
            Gets or sets the height of image, in pixels.
            </summary>
            <value>The height of image.</value>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Input_components">
            <summary>
            Gets or sets the number of color channels (components per pixel)
            </summary>
            <value>The number of color channels.</value>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space">
            <summary>
            Gets or sets the color space of source image.
            </summary>
            <value>The color space.</value>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
            <seealso href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Data_precision">
            <summary>
            Gets or sets the number of bits of precision in image data.
            </summary>
            <remarks>Default value: 8<br />
            The number of bits.
            </remarks>
            <value>The data precision.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Num_components">
            <summary>
            Gets or sets the number of color components for JPEG color space.
            </summary>
            <value>The number of color components for JPEG color space.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Jpeg_color_space">
            <summary>
            Gets or sets the JPEG color space.
            </summary>
            <remarks>We recommend to use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)" /> if you want to change this.</remarks>
            <value>The JPEG color space.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Raw_data_in">
            <summary>
            Gets or sets a value indicating whether you will be supplying raw data.
            </summary>
            <remarks>Default value: <c>false</c></remarks>
            <value>
                <c>true</c> if you will be supplying raw data; otherwise, <c>false</c>.</value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Optimize_coding">
            <summary>
            Gets or sets a value indicating a way of using Huffman coding tables.
            </summary>
            <remarks>When this is <c>true</c>, you need not supply Huffman tables at all, and any you do supply will be overwritten.</remarks>
            <value>
                <c>true</c> causes the compressor to compute optimal Huffman coding tables 
            for the image. This requires an extra pass over the data and therefore costs a good 
            deal of space and time. The default is <c>false</c>, which tells the compressor to use the 
            supplied or default Huffman tables. In most cases optimal tables save only a few 
            percent of file size compared to the default tables.</value>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.CCIR601_sampling">
            <summary>
            Gets or sets a value indicating whether first samples are cosited.
            </summary>
            <value>
                <c>true</c> if first samples are cosited; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Smoothing_factor">
            <summary>
            Gets or sets the coefficient of image smoothing.
            </summary>
            <remarks>Default value: 0<br />
            If non-zero, the input image is smoothed; the value should be 1 for minimal smoothing 
            to 100 for maximum smoothing.</remarks>
            <value>The coefficient of image smoothing.</value>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dct_method">
            <summary>
            Gets or sets the algorithm used for the DCT step.
            </summary>
            <value>The DCT algorithm.</value>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval">
            <summary>
            Gets or sets the exact interval in MCU blocks.
            </summary>
            <remarks>Default value: 0<br />
            One restart marker per MCU row is often a good choice. The overhead of restart markers 
            is higher in grayscale JPEG files than in color files, and MUCH higher in progressive JPEGs. 
            If you use restarts, you may want to use larger intervals in those cases.</remarks>
            <value>The restart interval.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_in_rows" />
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_in_rows">
            <summary>
            Gets or sets the interval in MCU rows.
            </summary>
            <remarks>Default value: 0<br />
            If Restart_in_rows is not 0, then <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval" /> is set 
            after the image width in MCUs is computed.<br />
            One restart marker per MCU row is often a good choice. 
            The overhead of restart markers is higher in grayscale JPEG files than in color files, and MUCH higher in progressive JPEGs. If you use restarts, you may want to use larger intervals in those cases.
            </remarks>
            <value>The restart interval in MCU rows.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval" />
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header">
            <summary>
            Gets or sets a value indicating whether the JFIF APP0 marker is emitted.
            </summary>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults" /> and 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)" /> set this <c>true</c> 
            if a JFIF-legal JPEG color space (i.e., YCbCr or grayscale) is selected, otherwise <c>false</c>.</remarks>
            <value>
                <c>true</c> if JFIF APP0 marker is emitted; otherwise, <c>false</c>.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version" />
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version">
            <summary>
            Gets or sets the version number to be written into the JFIF marker.
            </summary>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults" /> initializes the version to 
            1.01 (major=minor=1). You should set it to 1.02 (major=1, minor=2) if you plan to write any 
            JFIF 1.02 extension markers.</remarks>
            <value>The version number to be written into the JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_minor_version" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_minor_version">
            <summary>
            Gets or sets the version number to be written into the JFIF marker.
            </summary>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults" /> initializes the version to 
            1.01 (major=minor=1). You should set it to 1.02 (major=1, minor=2) if you plan to write any 
            JFIF 1.02 extension markers.</remarks>
            <value>The version number to be written into the JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit">
            <summary>
            Gets or sets the resolution information to be written into the JFIF marker; not used otherwise.
            </summary>
            <remarks>Default value: <see cref="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown" /><br />
            The pixel aspect ratio is defined by 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density" />/<see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density" /> 
            even when Density_unit is <see cref="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown">Unknown</see>.</remarks>
            <value>The density unit.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density" />
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density">
            <summary>
            Gets or sets the horizontal component of pixel ratio.
            </summary>
            <remarks>Default value: 1</remarks>
            <value>The horizontal density.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density">
            <summary>
            Gets or sets the vertical component of pixel ratio.
            </summary>
            <remarks>Default value: 1</remarks>
            <value>The vertical density.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_Adobe_marker">
            <summary>
            Gets or sets a value indicating whether to emit Adobe APP14 marker.
            </summary>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults" /> and <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)" /> 
            set this <c>true</c> if JPEG color space RGB, CMYK, or YCCK is selected, otherwise <c>false</c>. 
            It is generally a bad idea to set both <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header" /> and 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_Adobe_marker" />. 
            In fact, you probably shouldn't change the default settings at all - the default behavior ensures that the JPEG file's 
            color space can be recognized by the decoder.</remarks>
            <value>If <c>true</c> an Adobe APP14 marker is emitted; <c>false</c>, otherwise.</value>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Max_v_samp_factor">
            <summary>
            Gets the largest vertical sample factor.
            </summary>
            <value>The largest vertical sample factor.</value>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Component_info">
            <summary>
            Gets the components that appears in SOF.
            </summary>
            <value>The component info array.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Quant_tbl_ptrs">
            <summary>
            Gets the coefficient quantization tables.
            </summary>
            <value>The coefficient quantization tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dc_huff_tbl_ptrs">
            <summary>
            Gets the Huffman coding tables.
            </summary>
            <value>The Huffman coding tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Ac_huff_tbl_ptrs">
            <summary>
            Gets the Huffman coding tables.
            </summary>
            <value>The Huffman coding tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Next_scanline">
            <summary>
            Gets the index of next scanline to be written to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)" />.
            </summary>
            <remarks>Application may use this to control its processing loop, 
            e.g., "while (Next_scanline &lt; Image_height)"</remarks>
            <value>Range: from 0 to (Image_height - 1)</value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_abort_compress">
            <summary>
            Abort processing of a JPEG compression operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)">
            <summary>
            Forcibly suppress or un-suppress all quantization and Huffman tables.
            </summary>
            <remarks>Marks all currently defined tables as already written (if suppress)
            or not written (if !suppress). This will control whether they get 
            emitted by a subsequent <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)" /> call.<br />
            
            This routine is exported for use by applications that want to produce
            abbreviated JPEG datastreams.</remarks>
            <param name="suppress">if set to <c>true</c> then suppress tables; 
            otherwise unsuppress.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress">
            <summary>
            Finishes JPEG compression.
            </summary>
            <remarks>If a multipass operating mode was selected, this may do a great 
            deal of work including most of the actual output.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_marker(System.Int32,System.Byte[])">
            <summary>
            Write a special marker.
            </summary>
            <remarks>This is only recommended for writing COM or APPn markers. 
            Must be called after <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)" /> and before first call to 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)" /> or <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)" />.
            </remarks>
            <param name="marker">Specify the marker type parameter as <see cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER" />.COM for COM or 
            <see cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER" />.APP0 + n for APPn. (Actually, jpeg_write_marker will let you write any marker type, 
            but we don't recommend writing any other kinds of marker)</param>
            <param name="data">The data associated with the marker.</param>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_header(System.Int32,System.Int32)">
            <summary>
            Writes special marker's header.
            </summary>
            <param name="marker">Special marker.</param>
            <param name="datalen">Length of data associated with the marker.</param>
            <remarks>After calling this method you need to call <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)" />
            exactly the number of times given in the length parameter.<br />
            This method lets you empty the output buffer partway through a marker, which might be important when 
            using a suspending data destination module. In any case, if you are using a suspending destination, 
            you should flush its buffer after inserting any special markers.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)" />
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_marker(System.Int32,System.Byte[])" />
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)">
            <summary>
            Writes a byte of special marker's data.
            </summary>
            <param name="val">The byte of data.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_header(System.Int32,System.Int32)" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables">
            <summary>
            Alternate compression function: just write an abbreviated table file.
            </summary>
            <remarks>Before calling this, all parameters and a data destination must be set up.<br />
            
            To produce a pair of files containing abbreviated tables and abbreviated
            image data, one would proceed as follows:<br /><c>Initialize JPEG object<br />
            Set JPEG parameters<br />
            Set destination to table file<br /><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables">jpeg_write_tables();</see><br />
            Set destination to image file<br /><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">jpeg_start_compress(false);</see><br />
            Write data...<br /><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress">jpeg_finish_compress();</see><br /></c><br />
            
            jpeg_write_tables has the side effect of marking all tables written
            (same as <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)">jpeg_suppress_tables(true)</see>).
            Thus a subsequent <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">jpeg_start_compress</see> 
            will not re-emit the tables unless it is passed <c>write_all_tables=true</c>.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_stdio_dest(System.IO.Stream)">
            <summary>
            Sets output stream.
            </summary>
            <param name="outfile">The output stream.</param>
            <remarks>The caller must have already opened the stream, and is responsible
            for closing it after finishing compression.</remarks>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults">
            <summary>
            Jpeg_set_defaultses this instance.
            </summary>
            <remarks>Uses only the input image's color space (property <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space" />, 
            which must already be set in <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />). Many applications will only need 
            to use this routine and perhaps <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)" />.
            </remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)">
            <summary>
            Set the JPEG colorspace (property <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Jpeg_color_space" />,
            and choose colorspace-dependent parameters appropriately.
            </summary>
            <param name="colorspace">The required colorspace.</param>
            <remarks>See <see href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</see>, 
            below, before using this. A large number of parameters, including all per-component parameters, 
            are set by this routine; if you want to twiddle individual parameters you should call 
            <c>jpeg_set_colorspace</c> before rather than after.</remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
            <seealso href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_default_colorspace">
            <summary>
            Select an appropriate JPEG colorspace based on <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space" />,
            and calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)" /></summary>
            <remarks>This is actually a subroutine of <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults" />. 
            It's broken out in case you want to change just the colorspace-dependent JPEG parameters.</remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)">
            <summary>
            Constructs JPEG quantization tables appropriate for the indicated quality setting.
            </summary>
            <param name="quality">The quality value is expressed on the 0..100 scale recommended by IJG.</param>
            <param name="force_baseline">If <c>true</c>, then the quantization table entries are constrained 
            to the range 1..255 for full JPEG baseline compatibility. In the current implementation, 
            this only makes a difference for quality settings below 25, and it effectively prevents 
            very small/low quality files from being generated. The IJG decoder is capable of reading 
            the non-baseline files generated at low quality settings when <c>force_baseline</c> is <c>false</c>,
            but other decoders may not be.</param>
            <remarks>Note that the exact mapping from quality values to tables may change in future IJG releases 
            as more is learned about DCT quantization.</remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_default_qtables(System.Boolean)">
            <summary>
            Set or change the 'quality' (quantization) setting, using default tables
            and straight percentage-scaling quality scales.
            This entry point allows different scalings for luminance and chrominance.
            </summary>
            <param name="force_baseline">if set to <c>true</c> then baseline version is forced.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_linear_quality(System.Int32,System.Boolean)">
            <summary>
            Same as <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)" /> except that the generated tables are the 
            sample tables given in the JPEG specification section K.1, multiplied by 
            the specified scale factor.
            </summary>
            <param name="scale_factor">The scale_factor.</param>
            <param name="force_baseline">If <c>true</c>, then the quantization table entries are 
            constrained to the range 1..255 for full JPEG baseline compatibility. In the current 
            implementation, this only makes a difference for quality settings below 25, and it 
            effectively prevents very small/low quality files from being generated. The IJG decoder 
            is capable of reading the non-baseline files generated at low quality settings when 
            <c>force_baseline</c> is <c>false</c>, but other decoders may not be.</param>
            <remarks>Note that larger scale factors give lower quality. This entry point is 
            useful for conforming to the Adobe PostScript DCT conventions, but we do not 
            recommend linear scaling as a user-visible quality scale otherwise.
            </remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_add_quant_table(System.Int32,System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Allows an arbitrary quantization table to be created.
            </summary>
            <param name="which_tbl">Indicates which table slot to fill.</param>
            <param name="basic_table">An array of 64 unsigned integers given in normal array order.
            These values are multiplied by <c>scale_factor/100</c> and then clamped to the range 1..65535 
            (or to 1..255 if <c>force_baseline</c> is <c>true</c>).<br />
            The basic table should be given in JPEG zigzag order.
            </param>
            <param name="scale_factor">Multiplier for values in <c>basic_table</c>.</param>
            <param name="force_baseline">Defines range of values in <c>basic_table</c>. 
            If <c>true</c> - 1..255, otherwise - 1..65535.</param>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_quality_scaling(System.Int32)">
            <summary>
            Converts a value on the IJG-recommended quality scale to a linear scaling percentage.
            </summary>
            <param name="quality">The IJG-recommended quality scale. Should be 0 (terrible) to 100 (very good).</param>
            <returns>The linear scaling percentage.</returns>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_simple_progression">
            <summary>
            Generates a default scan script for writing a progressive-JPEG file.
            </summary>
            <remarks>This is the recommended method of creating a progressive file, unless you want 
            to make a custom scan sequence. You must ensure that the JPEG color space is 
            set correctly before calling this routine.</remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">
            <summary>
            Starts JPEG compression.
            </summary>
            <param name="write_all_tables">Write or not write all quantization and Huffman tables.</param>
            <remarks>Before calling this, all parameters and a data destination must be set up.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)" />
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables" />
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)">
            <summary>
            Write some scanlines of data to the JPEG compressor.
            </summary>
            <param name="scanlines">The array of scanlines.</param>
            <param name="num_lines">The number of scanlines for writing.</param>
            <returns>The return value will be the number of lines actually written.<br />
            This should be less than the supplied <c>num_lines</c> only in case that 
            the data destination module has requested suspension of the compressor, 
            or if more than image_height scanlines are passed in.
            </returns>
            <remarks>We warn about excess calls to <c>jpeg_write_scanlines()</c> since this likely 
            signals an application programmer error. However, excess scanlines passed in the last 
            valid call are "silently" ignored, so that the application need not adjust <c>num_lines</c>
            for end-of-image when using a multiple-scanline buffer.</remarks>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)">
            <summary>
            Alternate entry point to write raw data.
            </summary>
            <param name="data">The raw data.</param>
            <param name="num_lines">The number of scanlines for writing.</param>
            <returns>The number of lines actually written.</returns>
            <remarks>Processes exactly one iMCU row per call, unless suspended.
            Replaces <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)" /> when writing raw downsampled data.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_coefficients(BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Compression initialization for writing raw-coefficient data. Useful for lossless transcoding.
            </summary>
            <param name="coef_arrays">The virtual arrays need not be filled or even realized at the time 
            <c>jpeg_write_coefficients</c> is called; indeed, the virtual arrays typically will be realized 
            during this routine and filled afterwards.
            </param>
            <remarks>Before calling this, all parameters and a data destination must be set up.
            Call <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress" /> to actually write the data.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.initialize">
            <summary>
            Initialization of a JPEG compression object
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_compress_master">
            <summary>
            Master selection of compression modules.
            This is done once at the start of processing an image.  We determine
            which modules will be used and give them appropriate initialization calls.
            This routine is in charge of selecting the modules to be executed and
            making an initialization call to each one.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_c_master_control(System.Boolean)">
            <summary>
            Initialize master compression control.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_c_main_controller(System.Boolean)">
            <summary>
            Initialize main buffer controller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.transencode_master_selection(BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Master selection of compression modules for transcoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.initial_setup(System.Boolean)">
            <summary>
            Do computations that are needed before master selection phase
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.validate_script">
            <summary>
            Verify that the scan script in scan_info[] is valid; 
            also determine whether it uses progressive JPEG, and set progressive_mode.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.std_huff_tables">
            <summary>
            Set up the standard Huffman tables (cf. JPEG standard section K.3)
            
            IMPORTANT: these are only valid for 8-bit data precision!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.add_huff_table(BitMiracle.LibJpeg.Classic.JHUFF_TBL@,System.Byte[],System.Byte[])">
            <summary>
            Define a Huffman table
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_a_scan(System.Int32@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate one scan for specified component
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_dc_scans(System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate interleaved DC scan if possible, else N scans
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_scans(System.Int32@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate one scan for each component
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct">
            <summary>
            JPEG decompression routine.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method">
            <summary>
            The delegate for application-supplied marker processing methods.
            </summary>
            <param name="cinfo">Decompressor.</param>
            <returns>Return <c>true</c> to indicate success. <c>false</c> should be returned only 
            if you are using a suspending data source and it tells you to suspend.
            </returns>
            <remarks>Although the marker code is not explicitly passed, the routine can find it 
            in the <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Unread_marker" />. At the time of call, 
            the marker proper has been read from the data source module. The processor routine 
            is responsible for reading the marker length word and the remaining parameter bytes, if any.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" /> class.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" /> class.
            </summary>
            <param name="errorManager">The error manager.</param>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.IsDecompressor">
            <summary>
            Retrieves <c>true</c> because this is a decompressor.
            </summary>
            <value>
                <c>true</c>
            </value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Src">
            <summary>
            Gets or sets the source for decompression.
            </summary>
            <value>The source for decompression.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Image_width">
            <summary>
            Gets the width of image, set by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)" /></summary>
            <value>The width of image.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Image_height">
            <summary>
            Gets the height of image, set by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)" /></summary>
            <value>The height of image.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Num_components">
            <summary>
            Gets the number of color components in JPEG image.
            </summary>
            <value>The number of color components.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Jpeg_color_space">
            <summary>
            Gets or sets the colorspace of JPEG image.
            </summary>
            <value>The colorspace of JPEG image.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">
            <summary>
            Gets the list of loaded special markers.
            </summary>
            <remarks>All the special markers in the file appear in this list, in order of 
            their occurrence in the file (but omitting any markers of types you didn't ask for)
            </remarks>
            <value>The list of loaded special markers.</value>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space">
            <summary>
            Gets or sets the output color space.
            </summary>
            <value>The output color space.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num">
            <summary>
            Gets or sets the numerator of the fraction of image scaling.
            </summary>
            <value>Scale the image by the fraction Scale_num/<see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom">Scale_denom</see>. 
            Default is 1/1, or no scaling. Currently, the only supported scaling ratios are 1/1, 1/2, 1/4, and 1/8.
            (The library design allows for arbitrary scaling ratios but this is not likely to be implemented any time soon.)
            </value>
            <remarks>Smaller scaling ratios permit significantly faster decoding since fewer pixels 
            need to be processed and a simpler <see cref="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">DCT method</see> can be used.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom" />
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom">
            <summary>
            Gets or sets the denominator of the fraction of image scaling.
            </summary>
            <value>Scale the image by the fraction <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num">Scale_num</see>/Scale_denom. 
            Default is 1/1, or no scaling. Currently, the only supported scaling ratios are 1/1, 1/2, 1/4, and 1/8.
            (The library design allows for arbitrary scaling ratios but this is not likely to be implemented any time soon.)
            </value>
            <remarks>Smaller scaling ratios permit significantly faster decoding since fewer pixels 
            need to be processed and a simpler <see cref="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">DCT method</see> can be used.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num" />
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Buffered_image">
            <summary>
            Gets or sets a value indicating whether to use buffered-image mode.
            </summary>
            <value>
                <c>true</c> if buffered-image mode is turned on; otherwise, <c>false</c>.</value>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Raw_data_out">
            <summary>
            Enable or disable raw data output.
            </summary>
            <value>
                <c>true</c> if raw data output is enabled; otherwise, <c>false</c>.</value>
            <remarks>Default value: <c>false</c><br />
            Set this to true before <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" /> 
            if you need to obtain raw data output.
            </remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_raw_data(System.Byte[][][],System.Int32)" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dct_method">
            <summary>
            Gets or sets the algorithm used for the DCT step.
            </summary>
            <value>The algorithm used for the DCT step.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Do_fancy_upsampling">
            <summary>
            Enable or disable upsampling of chroma components.
            </summary>
            <value>If <c>true</c>, do careful upsampling of chroma components. 
            If <c>false</c>, a faster but sloppier method is used. 
            The visual impact of the sloppier method is often very small.
            </value>
            <remarks>Default value: <c>true</c></remarks>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Do_block_smoothing">
            <summary>
            Apply interblock smoothing in early stages of decoding progressive JPEG files.
            </summary>
            <value>If <c>true</c>, interblock smoothing is applied in early stages of decoding progressive JPEG files; 
            if <c>false</c>, not. Early progression stages look "fuzzy" with smoothing, "blocky" without.</value>
            <remarks>Default value: <c>true</c><br />
            In any case, block smoothing ceases to be applied after the first few AC coefficients are 
            known to full accuracy, so it is relevant only when using 
            <see href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">buffered-image mode</see> for progressive images.
            </remarks>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors">
            <summary>
            Colors quantization.
            </summary>
            <value>If set <c>true</c>, colormapped output will be delivered.<br />
            Default value: <c>false</c>, meaning that full-color output will be delivered.
            </value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dither_mode">
            <summary>
            Selects color dithering method.
            </summary>
            <value>Default value: <see cref="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_FS" />.</value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" /> is <c>false</c>.<br />
            At present, ordered dither is implemented only in the single-pass, standard-colormap case. 
            If you ask for ordered dither when <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Two_pass_quantize" /> is <c>true</c>
            or when you supply an external color map, you'll get F-S dithering.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" />
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Two_pass_quantize">
            <summary>
            Gets or sets a value indicating whether to use two-pass color quantization.
            </summary>
            <value>If <c>true</c>, an extra pass over the image is made to select a custom color map for the image.
            This usually looks a lot better than the one-size-fits-all colormap that is used otherwise.
            Ignored when the application supplies its own color map.<br />
            
            Default value: <c>true</c></value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" /> is <c>false</c>.<br /></remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" />
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Desired_number_of_colors">
            <summary>
            Maximum number of colors to use in generating a library-supplied color map.
            </summary>
            <value>Default value: 256.</value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" /> is <c>false</c>.<br />
            The actual number of colors is returned in a <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors" />.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" />
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_1pass_quant">
            <summary>
            Enable future use of 1-pass quantizer.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_external_quant">
            <summary>
            Enable future use of external colormap.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_2pass_quant">
            <summary>
            Enable future use of 2-pass quantizer.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_width">
            <summary>
            Gets the actual width of output image.
            </summary>
            <value>The width of output image.</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions" /> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_height" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_height">
            <summary>
            Gets the actual height of output image.
            </summary>
            <value>The height of output image.</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions" /> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_width" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components">
            <summary>
            Gets the number of color components in <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space" />.
            </summary>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions" /> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.</remarks>
            <value>The number of color components.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space" />
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_components">
            <summary>
            Gets the number of color components returned.
            </summary>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions" /> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.</remarks>
            <value>When <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors">quantizing colors</see>, 
            <c>Output_components</c> is 1, indicating a single color map index per pixel. 
            Otherwise it equals to <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components" />.
            </value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space" />
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Rec_outbuf_height">
            <summary>
            Gets the recommended height of scanline buffer.
            </summary>
            <value>In high-quality modes, <c>Rec_outbuf_height</c> is always 1, but some faster, 
            lower-quality modes set it to larger values (typically 2 to 4).</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions" /> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />.<br /><c>Rec_outbuf_height</c> is the recommended minimum height (in scanlines) 
            of the buffer passed to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)" />.
            If the buffer is smaller, the library will still work, but time will be wasted due 
            to unnecessary data copying. If you are going to ask for a high-speed processing mode, 
            you may as well go to the trouble of honoring <c>Rec_outbuf_height</c> so as to avoid data copying.
            (An output buffer larger than <c>Rec_outbuf_height</c> lines is OK, but won't provide 
            any material speed improvement over that height.)
            </remarks>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors">
            <summary>
            The number of colors in the color map.
            </summary>
            <value>The number of colors in the color map.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Colormap" />
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Colormap">
            <summary>
            The color map, represented as a 2-D pixel array of <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components" /> rows 
            and <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors" /> columns.
            </summary>
            <value>Colormap is set to <c>null</c> by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)" />.
            The application can supply a color map by setting <c>Colormap</c> non-null and setting 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors" /> to the map size.
            </value>
            <remarks>Ignored if not quantizing.<br />
            Implementation restriction: at present, an externally supplied <c>Colormap</c>
            is only accepted for 3-component output color spaces.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors" />
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_scanline">
            <summary>
            Gets the number of scanlines returned so far.
            </summary>
            <value>The output_scanline.</value>
            <remarks>Usually you can just use this variable as the loop counter, 
            so that the loop test looks like 
            <c>while (cinfo.Output_scanline &lt; cinfo.Output_height)</c></remarks>
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Input_scan_number">
            <summary>
            Gets the number of SOS markers seen so far.
            </summary>
            <value>The number of SOS markers seen so far.</value>
            <remarks>Indicates the progress of the decompressor input side.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Input_iMCU_row">
            <summary>
            Gets the number of iMCU rows completed.
            </summary>
            <value>The number of iMCU rows completed.</value>
            <remarks>Indicates the progress of the decompressor input side.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_scan_number">
            <summary>
            Gets the nominal scan number being displayed.
            </summary>
            <value>The nominal scan number being displayed.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_iMCU_row">
            <summary>
            Gets the number of iMCU rows read.
            </summary>
            <value>The number of iMCU rows read.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Coef_bits">
            <summary>
            Gets the current progression status..
            </summary>
            <value>
                <c>Coef_bits[c][i]</c> indicates the precision with 
            which component c's DCT coefficient i (in zigzag order) is known. 
            It is <c>-1</c> when no data has yet been received, otherwise 
            it is the point transform (shift) value for the most recent scan of the coefficient 
            (thus, 0 at completion of the progression). This is null when reading a non-progressive file.
            </value>
            <seealso href="bda5b19b-88e0-44bf-97de-cd30fc61bb65.htm" target="_self">Progressive JPEG support</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit">
            <summary>
            Gets the resolution information from JFIF marker.
            </summary>
            <value>The information from JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density" />
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density">
            <summary>
            Gets the horizontal component of pixel ratio.
            </summary>
            <value>The horizontal component of pixel ratio.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density">
            <summary>
            Gets the vertical component of pixel ratio.
            </summary>
            <value>The vertical component of pixel ratio.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Data_precision">
            <summary>
            Gets the data precision.
            </summary>
            <value>The data precision.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Max_v_samp_factor">
            <summary>
            Gets the largest vertical sample factor.
            </summary>
            <value>The largest vertical sample factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Unread_marker">
            <summary>
            Gets the last read and unprocessed JPEG marker.
            </summary>
            <value>It is either zero or the code of a JPEG marker that has been
            read from the data source, but has not yet been processed.
            </value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)" />
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Comp_info">
            <summary>
            Comp_info[i] describes component that appears i'th in SOF
            </summary>
            <value>The components in SOF.</value>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_component_info" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_stdio_src(System.IO.Stream)">
            <summary>
            Sets input stream.
            </summary>
            <param name="infile">The input stream.</param>
            <remarks>
            The caller must have already opened the stream, and is responsible
            for closing it after finishing decompression.
            </remarks>
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">
            <summary>
            Decompression startup: this will read the source datastream header markers, up to the beginning of the compressed data proper.
            </summary>
            <param name="require_image">Read a description of <b>Return Value</b>.</param>
            <returns>
            If you pass <c>require_image=true</c> (normal case), you need not check for a
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY" /> return code; an abbreviated file will cause
            an error exit. <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED" /> is only possible if you use a data source
            module that can give a suspension return.<br /><br />
            
            This method will read as far as the first SOS marker (ie, actual start of compressed data),
            and will save all tables and parameters in the JPEG object. It will also initialize the
            decompression parameters to default values, and finally return <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK" />.
            On return, the application may adjust the decompression parameters and then call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />. (Or, if the application only wanted to
            determine the image parameters, the data need not be decompressed. In that case, call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort" /> to release any temporary space.)<br /><br />
            
            If an abbreviated (tables only) datastream is presented, the routine will return
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY" /> upon reaching EOI. The application may then re-use
            the JPEG object to read the abbreviated image datastream(s). It is unnecessary (but OK) to call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort">jpeg_abort</see> in this case.
            The <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED" /> return code only occurs if the data source module
            requests suspension of the decompressor. In this case the application should load more source
            data and then re-call <c>jpeg_read_header</c> to resume processing.<br /><br />
            
            If a non-suspending data source is used and <c>require_image</c> is <c>true</c>,
            then the return code need not be inspected since only <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK" /> is possible.
            </returns>
            <remarks>Need only initialize JPEG object and supply a data source before calling.<br />
            On return, the image dimensions and other info have been stored in the JPEG object.
            The application may wish to consult this information before selecting decompression parameters.<br />
            This routine is now just a front end to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input" />, with some extra error checking.
            </remarks>
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress">
            <summary>
            Decompression initialization.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected 
            only if a suspending data source is used.
            </returns>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">jpeg_read_header</see> must be completed before calling this.<br />
            
            If a multipass operating mode was selected, this will do all but the last pass, and thus may take a great deal of time.
            </remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress" />
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)">
            <summary>
            Read some scanlines of data from the JPEG decompressor.
            </summary>
            <param name="scanlines">Buffer for filling.</param>
            <param name="max_lines">Required number of lines.</param>
            <returns>The return value will be the number of lines actually read. 
            This may be less than the number requested in several cases, including 
            bottom of image, data source suspension, and operating modes that emit multiple scanlines at a time.
            </returns>
            <remarks>We warn about excess calls to <c>jpeg_read_scanlines</c> since this likely signals an 
            application programmer error. However, an oversize buffer <c>(max_lines &gt; scanlines remaining)</c> 
            is not an error.
            </remarks>
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress">
            <summary>
            Finish JPEG decompression.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected 
            only if a suspending data source is used.
            </returns>
            <remarks>This will normally just verify the file trailer and release temp storage.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress" />
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_raw_data(System.Byte[][][],System.Int32)">
            <summary>
            Alternate entry point to read raw data.
            </summary>
            <param name="data">The raw data.</param>
            <param name="max_lines">The number of scanlines for reading.</param>
            <returns>The number of lines actually read.</returns>
            <remarks>Replaces <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)">jpeg_read_scanlines</see> 
            when reading raw downsampled data. Processes exactly one iMCU row per call, unless suspended.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_has_multiple_scans">
            <summary>
            Is there more than one scan?
            </summary>
            <returns>
                <c>true</c> if image has more than one scan; otherwise, <c>false</c></returns>
            <remarks>If you are concerned about maximum performance on baseline JPEG files,
            you should use <see href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">buffered-image mode</see> only
            when the incoming file actually has multiple scans. This can be tested by calling this method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_output(System.Int32)">
            <summary>
            Initialize for an output pass in <see href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">buffered-image mode</see>.
            </summary>
            <param name="scan_number">Indicates which scan of the input file is to be displayed; 
            the scans are numbered starting at 1 for this purpose.</param>
            <returns>
                <c>true</c> if done; <c>false</c> if suspended</returns>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output" />
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output">
            <summary>
            Finish up after an output pass in <see href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">buffered-image mode</see>.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected only if a suspending data source is used.</returns>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_output(System.Int32)" />
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_input_complete">
            <summary>
            Indicates if we have finished reading the input file.
            </summary>
            <returns>
                <c>true</c> if we have finished reading the input file.</returns>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input">
            <summary>
            Consume data in advance of what the decompressor requires.
            </summary>
            <returns>The result of data consumption.</returns>
            <remarks>This routine can be called at any time after initializing the JPEG object.
            It reads some additional data and returns when one of the indicated significant events
            occurs. If called after the EOI marker is reached, it will immediately return
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_EOI" /> without attempting to read more data.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions">
            <summary>
            Pre-calculate output image dimensions and related values for current decompression parameters.
            </summary>
            <remarks>This is allowed for possible use by application. Hence it mustn't do anything 
            that can't be done twice. Also note that it may be called before the master module is initialized!
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_coefficients">
            <summary>
            Read or write the raw DCT coefficient arrays from a JPEG file (useful for lossless transcoding).
            </summary>
            <returns>Returns <c>null</c> if suspended. This case need be checked only 
            if a suspending data source is used.
            </returns>
            <remarks>
                <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">jpeg_read_header</see> must be completed before calling this.<br />
            
            The entire image is read into a set of virtual coefficient-block arrays, one per component.
            The return value is an array of virtual-array descriptors.<br />
            
            An alternative usage is to simply obtain access to the coefficient arrays during a 
            <see href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">buffered-image mode</see> decompression operation. This is allowed after any 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output">jpeg_finish_output</see> call. The arrays can be accessed 
            until <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress">jpeg_finish_decompress</see> is called. 
            Note that any call to the library may reposition the arrays, 
            so don't rely on <see cref="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.Access(System.Int32,System.Int32)" /> results to stay valid across library calls.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_copy_critical_parameters(BitMiracle.LibJpeg.Classic.jpeg_compress_struct)">
            <summary>
            Initializes the compression object with default parameters, then copy from the source object 
            all parameters needed for lossless transcoding.
            </summary>
            <param name="dstinfo">Target JPEG compression object.</param>
            <remarks>Parameters that can be varied without loss (such as scan script and 
            Huffman optimization) are left in their default states.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_abort_decompress">
            <summary>
            Aborts processing of a JPEG decompression operation.
            </summary>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort" />
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)">
            <summary>
            Sets processor for special marker.
            </summary>
            <param name="marker_code">The marker code.</param>
            <param name="routine">The processor.</param>
            <remarks>Allows you to supply your own routine to process 
            COM and/or APPn markers on-the-fly as they are read.
            </remarks>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_save_markers(System.Int32,System.Int32)">
            <summary>
            Control saving of COM and APPn markers into <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">Marker_list</see>.
            </summary>
            <param name="marker_code">The marker type to save (see JPEG_MARKER enumeration).<br />
            To arrange to save all the special marker types, you need to call this 
            routine 17 times, for COM and APP0-APP15 markers.</param>
            <param name="length_limit">If the incoming marker is longer than <c>length_limit</c> data bytes, 
            only <c>length_limit</c> bytes will be saved; this parameter allows you to avoid chewing up memory 
            when you only need to see the first few bytes of a potentially large marker. If you want to save 
            all the data, set <c>length_limit</c> to 0xFFFF; that is enough since marker lengths are only 16 bits. 
            As a special case, setting <c>length_limit</c> to 0 prevents that marker type from being saved at all. 
            (That is the default behavior, in fact.)
            </param>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list" />
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.use_merged_upsample">
            <summary>
            Determine whether merged upsample/color conversion should be used.
            CRUCIAL: this must match the actual capabilities of merged upsampler!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.initialize">
            <summary>
            Initialization of JPEG compression objects.
            The error manager must already be set up (in case memory manager fails).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.transdecode_master_selection">
            <summary>
            Master selection of decompression modules for transcoding (that is, reading 
            raw DCT coefficient arrays from an input JPEG file.)
            This substitutes for initialization of the full decompressor.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.output_pass_setup">
            <summary>
            Set up for an output pass, and perform any dummy pass(es) needed.
            Common subroutine for jpeg_start_decompress and jpeg_start_output.
            Entry: global_state = DSTATE_PRESCAN only if previously suspended.
            Exit: If done, returns true and sets global_state for proper output mode.
                  If suspended, returns false and sets global_state = DSTATE_PRESCAN.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.default_decompress_parms">
            <summary>
            Set default decompression parameters.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr">
            <summary>
            Data destination object for compression.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.init_destination">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.empty_output_buffer">
            <summary>
            Empties output buffer.
            </summary>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.term_destination">
            <summary>
            Term_destinations this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.emit_byte(System.Int32)">
            <summary>
            Emits a byte.
            </summary>
            <param name="val">The byte value.</param>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.initInternalBuffer(System.Byte[],System.Int32)">
            <summary>
            Initializes the internal buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.freeInBuffer">
            <summary>
            Gets the number of free bytes in buffer.
            </summary>
            <value>The number of free bytes in buffer.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr">
            <summary>
            Contains simple error-reporting and trace-message routines.
            </summary>
            <remarks>This class is used by both the compression and decompression code.</remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr" /> class.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.Trace_level">
            <summary>
            Gets or sets the maximum message level that will be displayed.
            </summary>
            <value>Values are:
            -1: recoverable corrupt-data warning, may want to abort.<br />
            0: important advisory messages (always display to user).<br />
            1: first level of tracing detail.<br />
            2, 3, ...: successively more detailed tracing messages.
            </value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)" />
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.Num_warnings">
            <summary>
            Gets the number of corrupt-data warnings.
            </summary>
            <value>The num_warnings.</value>
            <remarks>For recoverable corrupt-data errors, we emit a warning message, but keep going 
            unless <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)">emit_message</see> chooses to abort. 
            <c>emit_message</c> should count warnings in <c>Num_warnings</c>. The surrounding application 
            can check for bad data by seeing if <c>Num_warnings</c> is nonzero at the end of processing.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.error_exit">
            <summary>
            Receives control for a fatal error.
            </summary>
            <remarks>This method calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see> 
            and then throws an exception.</remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)">
            <summary>
            Conditionally emit a trace or warning message.
            </summary>
            <param name="msg_level">The message severity level.<br />
            Values are:<br />
            -1: recoverable corrupt-data warning, may want to abort.<br />
            0: important advisory messages (always display to user).<br />
            1: first level of tracing detail.<br />
            2, 3, ...: successively more detailed tracing messages.
            </param>
            <remarks>The main reason for overriding this method would be to abort on warnings.
            This method calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see> for message showing.<br />
            
            An application might override this method if it wanted to abort on 
            warnings or change the policy about which messages to display.
            </remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">
            <summary>
            Actual output of any JPEG message.
            </summary>
            <remarks>Override this to send messages somewhere other than Console. 
            Note that this method does not know how to generate a message, only where to send it.
            For extending a generation of messages see <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.format_message">format_message</see>.
            </remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.format_message">
            <summary>
            Constructs a readable error message string.
            </summary>
            <remarks>This method is called by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see>.
            Few applications should need to override this method. One possible reason for doing so is to 
            implement dynamic switching of error message language.</remarks>
            <returns>The formatted message</returns>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.reset_error_mgr">
            <summary>
            Resets error manager to initial state.
            </summary>
            <remarks>This is called during compression startup to reset trace/error
            processing to default state. An application might possibly want to
            override this method if it has additional error processing state.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.GetMessageText(System.Int32)">
            <summary>
            Gets the actual message texts.
            </summary>
            <param name="code">The message code. See <see cref="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE" /> for details.</param>
            <returns>The message text associated with <c>code</c>.</returns>
            <remarks>It may be useful for an application to add its own message texts that are handled 
            by the same mechanism. You can override <c>GetMessageText</c> for this purpose. If you number 
            the addon messages beginning at 1000 or so, you won't have to worry about conflicts 
            with the library's built-in messages.
            </remarks>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE" />
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER">
            <summary>
            JPEG marker codes.
            </summary>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF0">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF1">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF2">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF3">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF5">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF6">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF7">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF9">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF10">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF11">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF13">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF14">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF15">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DHT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DAC">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST0">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST1">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST2">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST3">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST4">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST5">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST6">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST7">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.EOI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DQT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DNL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DRI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DHP">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.EXP">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP0">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP1">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP2">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP3">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP4">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP5">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP6">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP7">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP8">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP9">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP10">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP11">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP12">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP13">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP14">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP15">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG0">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG8">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG13">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.COM">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.TEM">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.ERROR">
            <summary />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_marker_struct">
            <summary>
            Representation of special JPEG marker.
            </summary>
            <remarks>You can't create instance of this class manually.
            Concrete objects are instantiated by library and you can get them
            through <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">Marker_list</see> property.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list" />
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.Marker">
            <summary>
            Gets the special marker.
            </summary>
            <value>The marker value.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.OriginalLength">
            <summary>
            Gets the full length of original data associated with the marker.
            </summary>
            <value>The length of original data associated with the marker.</value>
            <remarks>This length excludes the marker length word, whereas the stored representation 
            within the JPEG file includes it. (Hence the maximum data length is really only 65533.)
            </remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.Data">
            <summary>
            Gets the data associated with the marker.
            </summary>
            <value>The data associated with the marker.</value>
            <remarks>The length of this array doesn't exceed <c>length_limit</c> for the particular marker type.
            Note that this length excludes the marker length word, whereas the stored representation 
            within the JPEG file includes it. (Hence the maximum data length is really only 65533.)
            </remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr">
            <summary>
            The progress monitor object.
            </summary>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="E:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.OnProgress">
            <summary>
            Occurs when progress is changed.
            </summary>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Pass_counter">
            <summary>
            Gets or sets the number of work units completed in this pass.
            </summary>
            <value>The number of work units completed in this pass.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Pass_limit">
            <summary>
            Gets or sets the total number of work units in this pass.
            </summary>
            <value>The total number of work units in this pass.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Completed_passes">
            <summary>
            Gets or sets the number of passes completed so far.
            </summary>
            <value>The number of passes completed so far.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Total_passes">
            <summary>
            Gets or sets the total number of passes expected.
            </summary>
            <value>The total number of passes expected.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Updated">
            <summary>
            Indicates that progress was changed.
            </summary>
            <remarks>Call this method if you change some progress parameters manually.
            This method ensures happening of the <see cref="E:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.OnProgress">OnProgress</see> event.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_source_mgr">
            <summary>
            Data source object for decompression.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.init_source">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.fill_input_buffer">
            <summary>
            Fills input buffer
            </summary>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.initInternalBuffer(System.Byte[],System.Int32)">
            <summary>
            Initializes the internal buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.skip_input_data(System.Int32)">
            <summary>
            Skip data - used to skip over a potentially large amount of
            uninteresting data (such as an APPn marker).
            </summary>
            <param name="num_bytes">The number of bytes to skip.</param>
            <remarks>Writers of suspendable-input applications must note that skip_input_data
            is not granted the right to give a suspension return.  If the skip extends
            beyond the data currently in the buffer, the buffer can be marked empty so
            that the next read will cause a fill_input_buffer call that can suspend.
            Arranging for additional bytes to be discarded before reloading the input
            buffer is the application writer's problem.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.resync_to_restart(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Int32)">
            <summary>
            This is the default resync_to_restart method for data source 
            managers to use if they don't have any better approach.
            </summary>
            <param name="cinfo">An instance of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct" /></param>
            <param name="desired">The desired</param>
            <returns>
                <c>false</c> if suspension is required.</returns>
            <remarks>That method assumes that no backtracking is possible. 
            Some data source managers may be able to back up, or may have 
            additional knowledge about the data which permits a more 
            intelligent recovery strategy; such managers would
            presumably supply their own resync method.<br /><br />
            
            read_restart_marker calls resync_to_restart if it finds a marker other than
            the restart marker it was expecting.  (This code is *not* used unless
            a nonzero restart interval has been declared.)  cinfo.unread_marker is
            the marker code actually found (might be anything, except 0 or FF).
            The desired restart marker number (0..7) is passed as a parameter.<br /><br />
            
            This routine is supposed to apply whatever error recovery strategy seems
            appropriate in order to position the input stream to the next data segment.
            Note that cinfo.unread_marker is treated as a marker appearing before
            the current data-source input point; usually it should be reset to zero
            before returning.<br /><br />
            
            This implementation is substantially constrained by wanting to treat the
            input as a data stream; this means we can't back up.  Therefore, we have
            only the following actions to work with:<br />
            1. Simply discard the marker and let the entropy decoder resume at next
            byte of file.<br />
            2. Read forward until we find another marker, discarding intervening
            data.  (In theory we could look ahead within the current bufferload,
            without having to discard data if we don't find the desired marker.
            This idea is not implemented here, in part because it makes behavior
            dependent on buffer size and chance buffer-boundary positions.)<br />
            3. Leave the marker unread (by failing to zero cinfo.unread_marker).
            This will cause the entropy decoder to process an empty data segment,
            inserting dummy zeroes, and then we will reprocess the marker.<br />
            
            #2 is appropriate if we think the desired marker lies ahead, while #3 is
            appropriate if the found marker is a future restart marker (indicating
            that we have missed the desired restart marker, probably because it got
            corrupted).<br />
            We apply #2 or #3 if the found marker is a restart marker no more than
            two counts behind or ahead of the expected one.  We also apply #2 if the
            found marker is not a legal JPEG marker code (it's certainly bogus data).
            If the found marker is a restart marker more than 2 counts away, we do #1
            (too much risk that the marker is erroneous; with luck we will be able to
            resync at some future point).<br />
            For any valid non-restart JPEG marker, we apply #3.  This keeps us from
            overrunning the end of a scan.  An implementation limited to single-scan
            files might find it better to apply #2 for markers other than EOI, since
            any other marker would have to be bogus data in that case.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.term_source">
            <summary>
            Terminate source - called by jpeg_finish_decompress
            after all data has been read.  Often a no-op.
            </summary>
            <remarks>NB: <b>not</b> called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetTwoBytes(System.Int32@)">
            <summary>
            Reads two bytes interpreted as an unsigned 16-bit integer.
            </summary>
            <param name="V">The result.</param>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetByte(System.Int32@)">
            <summary>
            Read a byte into variable V.
            If must suspend, take the specified action (typically "return false").
            </summary>
            <param name="V">The result.</param>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetBytes(System.Byte[],System.Int32)">
            <summary>
            Gets the bytes.
            </summary>
            <param name="dest">The destination.</param>
            <param name="amount">The amount.</param>
            <returns>The number of available bytes.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.MakeByteAvailable">
            <summary>
            Functions for fetching data from the data source module.
            </summary>
            <returns>
                <c>true</c> if operation succeed; otherwise, <c>false</c></returns>
            <remarks>At all times, cinfo.src.next_input_byte and .bytes_in_buffer reflect
            the current restart point; we update them only when we have reached a
            suitable place to restart if a suspension occurs.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JQUANT_TBL">
            <summary>
            DCT coefficient quantization tables.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JQUANT_TBL.Sent_table">
            <summary>
            Gets or sets a value indicating whether the table has been output to file.
            </summary>
            <value>It's initialized <c>false</c> when the table is created, and set 
            <c>true</c> when it's been output to the file. You could suppress output of a table by setting this to <c>true</c>.
            </value>
            <remarks>This property is used only during compression.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)" />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jvirt_array`1">
            <summary>
            JPEG virtual array.
            </summary>
            <typeparam name="T">The type of array's elements.</typeparam>
            <remarks>You can't create virtual array manually. For creation use methods
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateSamplesArray(System.Int32,System.Int32)" /> and
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateBlocksArray(System.Int32,System.Int32)" />.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.#ctor(System.Int32,System.Int32,BitMiracle.LibJpeg.Classic.jvirt_array{`0}.Allocator)">
            <summary>
            Request a virtual 2-D array
            </summary>
            <param name="width">Width of array</param>
            <param name="height">Total virtual array height</param>
            <param name="allocator">The allocator.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jvirt_array`1.ErrorProcessor">
            <summary>
            Gets or sets the error processor.
            </summary>
            <value>The error processor.<br />
            Default value: <c>null</c></value>
            <remarks>Uses only for calling 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">jpeg_common_struct.ERREXIT</see>
            on error.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.Access(System.Int32,System.Int32)">
            <summary>
            Access the part of a virtual array.
            </summary>
            <param name="startRow">The first row in required block.</param>
            <param name="numberOfRows">The number of required rows.</param>
            <returns>The required part of virtual array.</returns>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE">
            <summary>
            Known color spaces.
            </summary>
            <seealso href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</seealso>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_UNKNOWN">
            <summary>
            Unspecified color space.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_GRAYSCALE">
            <summary>
            Monochrome
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_RGB">
            <summary>
            Red/Green/Blue, standard RGB (sRGB)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_YCbCr">
            <summary>
            Y/Cb/Cr (also known as YUV), standard YCC
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_CMYK">
            <summary>
            C/M/Y/K
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_YCCK">
            <summary>
             Y/Cb/Cr/K 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_BG_RGB">
            <summary>
            big gamut red/green/blue, bg-sRGB
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_BG_YCC">
            <summary>
            big gamut Y/Cb/Cr, bg-sYCC
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_NCHANNEL">
            <summary>
            N channels
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM">
            <summary>
            Supported color transforms.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM.JCT_NONE">
            <summary>
            No transform
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN">
            <summary>
            Substract green
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">
            <summary>
            Algorithm used for the DCT step.
            </summary>
            <remarks>The <c>FLOAT</c> method is very slightly more accurate than the <c>ISLOW</c> method, 
            but may give different results on different machines due to varying roundoff behavior. 
            The integer methods should give the same results on all machines. On machines with 
            sufficiently fast hardware, the floating-point method may also be the fastest. 
            The <c>IFAST</c> method is considerably less accurate than the other two; its use is not recommended 
            if high quality is a concern.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dct_method" />
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dct_method" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_ISLOW">
            <summary>
            Slow but accurate integer algorithm.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_IFAST">
            <summary>
            Faster, less accurate integer method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_FLOAT">
            <summary>
            Floating-point method.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_DITHER_MODE">
            <summary>
            Dithering options for decompression.
            </summary>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dither_mode" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_NONE">
            <summary>
            No dithering: fast, very low quality
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_ORDERED">
            <summary>
            Ordered dither: moderate speed and quality
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_FS">
            <summary>
            Floyd-Steinberg dither: slow, high quality
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE">
            <summary>
            Message codes used in code to signal errors, warning and trace messages.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_NOMESSAGE">
            <summary>
            Must be first entry!
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_BUFFER_MODE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_COMPONENT_ID">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_CROP_SPEC">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DCT_COEF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DCTSIZE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DROP_SAMPLING">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_LENGTH">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_MCU_SIZE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PRECISION">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PROGRESSION">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_SAMPLING">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_SCAN_SCRIPT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_STATE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_VIRTUAL_ACCESS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BUFFER_SIZE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CANT_SUSPEND">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CCIR601_NOTIMPL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_COMPONENT_COUNT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DAC_INDEX">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DAC_VALUE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DHT_INDEX">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DQT_INDEX">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_EMPTY_IMAGE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_EOI_EXPECTED">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_FILE_WRITE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_HUFF_CLEN_OVERFLOW">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_HUFF_MISSING_CODE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_IMAGE_TOO_BIG">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_INPUT_EMPTY">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_INPUT_EOF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MISMATCHED_QUANT_TABLE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MISSING_DATA">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MODE_CHANGE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NOTIMPL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NOT_COMPILED">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_ARITH_TABLE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_HUFF_TABLE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_IMAGE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_QUANT_TABLE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_SOI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_OUT_OF_MEMORY">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_COMPONENTS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_BEFORE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_DUPLICATE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_NO_SOS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_UNSUPPORTED">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOI_DUPLICATE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOS_NO_SOF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_TOO_LITTLE_DATA">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_UNKNOWN_MARKER">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_WIDTH_OVERFLOW">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_16BIT_TABLES">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_ADOBE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_APP0">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_APP14">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DAC">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DHT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DQT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DRI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_EOI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_HUFFBITS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_EXTENSION">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_MISC_MARKER">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_PARMLESS_MARKER">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANTVALS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_3_NCOLORS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_NCOLORS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_SELECTED">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_RECOVERY_ACTION">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_RST">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SMOOTH_NOTIMPL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOF_COMPONENT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOI">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS_COMPONENT">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS_PARAMS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_JPEG">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_PALETTE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_RGB">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_UNKNOWN_IDS">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_ADOBE_XFORM">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_ARITH_BAD_CODE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_BOGUS_PROGRESSION">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_EXTRANEOUS_DATA">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_HIT_MARKER">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_JFIF_MAJOR">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_JPEG_EOF">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_MUST_RESYNC">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_NOT_SEQUENTIAL">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_TOO_MUCH_DATA">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_UNKNOWNMSGCODE">
            <summary />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_LASTMSGCODE">
            <summary />
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.ReadResult">
            <summary>
            Describes a result of read operation.
            </summary>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input" />
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED">
            <summary>
            Suspended due to lack of input data. Can occur only if a suspending data source is used.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK">
            <summary>
            Found valid image datastream.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY">
            <summary>
            Found valid table-specs-only datastream.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_SOS">
            <summary>
            Reached a SOS marker (the start of a new scan)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_EOI">
            <summary>
            Reached the EOI marker (end of image)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_ROW_COMPLETED">
            <summary>
            Completed reading one MCU row of compressed data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SCAN_COMPLETED">
            <summary>
            Completed reading last MCU row of current scan.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.Int64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.UInt64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.Single)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.Double)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int32,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int64,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ReadInput(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source Stream and writes the data to the target array at the specified index.</summary>
            <param name="sourceStream">The source Stream to read from.</param>
            <param name="target">Contains the array of characteres read from the source Stream.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to read from the source Stream.</param>
            <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source Stream. Returns -1 if the end of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source TextReader and writes the data to the target array at the specified index.</summary>
            <param name="sourceTextReader">The source TextReader to read from</param>
            <param name="target">Contains the array of characteres read from the source TextReader.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to read from the source TextReader.</param>
            <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source TextReader. Returns -1 if the end of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ToByteArray(System.String)">
            <summary>
            Converts a string to an array of bytes
            </summary>
            <param name="sourceString">The string to be converted</param>
            <returns>The new array of bytes</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ToCharArray(System.Byte[])">
            <summary>
            Converts an array of bytes to an array of chars
            </summary>
            <param name="byteArray">The array of bytes to convert</param>
            <returns>The new array of chars</returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZInputStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZInputStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZOutputStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZOutputStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:Ionic.BZip2.BitWriter.RemainingBits">
            <summary>
              Delivers the remaining bits, left-aligned, in a byte.
            </summary>
            <remarks>
                <para>
                This is valid only if NumRemainingBits is less than 8;
                in other words it is valid only after a call to Flush().
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.Reset">
            <summary>
              Reset the BitWriter.
            </summary>
            <remarks>
                <para>
                This is useful when the BitWriter writes into a MemoryStream, and
                is used by a BZip2Compressor, which itself is re-used for multiple
                distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteBits(System.Int32,System.UInt32)">
            <summary>
              Write some number of bits from the given value, into the output.
            </summary>
            <remarks>
                <para>
                The nbits value should be a max of 25, for safety. For performance
                reasons, this method does not check!
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteByte(System.Byte)">
            <summary>
              Write a full 8-bit byte into the output.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteInt(System.UInt32)">
            <summary>
              Write four 8-bit bytes into the output.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.Flush">
            <summary>
              Write all available byte-aligned bytes.
            </summary>
            <remarks>
                <para>
                This method writes no new output, but flushes any accumulated
                bits. At completion, the accumulator may contain up to 7
                bits.
              </para>
                <para>
                This is necessary when re-assembling output from N independent
                compressors, one for each of N blocks. The output of any
                particular compressor will in general have some fragment of a byte
                remaining. This fragment needs to be accumulated into the
                parent BZip2OutputStream.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.FinishAndPad">
            <summary>
              Writes all available bytes, and emits padding for the final byte as
              necessary. This must be the last method invoked on an instance of
              BitWriter.
            </summary>
        </member>
        <member name="F:Ionic.BZip2.BZip2Compressor.increments">
            Knuth's increments seem to work better than Incerpi-Sedgewick here.
            Possibly because the number of elems to sort is usually small, typically
            &lt;= 20.
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.#ctor(Ionic.BZip2.BitWriter)">
            <summary>
              BZip2Compressor writes its compressed data out via a BitWriter. This
              is necessary because BZip2 does byte shredding.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2Compressor.UncompressedBytes">
            <summary>
              The number of uncompressed bytes being held in the buffer.
            </summary>
            <remarks>
                <para>
                I am thinking this may be useful in a Stream that uses this
                compressor class. In the Close() method on the stream it could
                check this value to see if anything has been written at all.  You
                may think the stream could easily track the number of bytes it
                wrote, which would eliminate the need for this. But, there is the
                case where the stream writes a complete block, and it is full, and
                then writes no more. In that case the stream may want to check.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.Fill(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Accept new bytes into the compressor data buffer
            </summary>
            <remarks>
                <para>
                This method does the first-level (cheap) run-length encoding, and
                stores the encoded data into the rle block.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.write0(System.Byte)">
            <summary>
               Process one input byte into the block.
             </summary>
            <remarks>
                <para>
                 To "process" the byte means to do the run-length encoding.
                 There are 3 possible return values:
            
                    0 - the byte was not written, in other words, not
                        encoded into the block. This happens when the
                        byte b would require the start of a new run, and
                        the block has no more room for new runs.
            
                    1 - the byte was written, and the block is not full.
            
                    2 - the byte was written, and the block is full.
            
               </para>
            </remarks>
            <returns>0 if the byte was not written, non-zero if written.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.AddRunToOutputBlock(System.Boolean)">
            <summary>
               Append one run to the output block.
             </summary>
            <remarks>
                <para>
                 This compressor does run-length-encoding before BWT and etc. This
                 method simply appends a run to the output block. The append always
                 succeeds. The return value indicates whether the block is full:
                 false (not full) implies that at least one additional run could be
                 processed.
               </para>
            </remarks>
            <returns>true if the block is now full; otherwise false.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.CompressAndWrite">
            <summary>
              Compress the data that has been placed (Run-length-encoded) into the
              block. The compressed data goes into the CompressedBytes array.
            </summary>
            <remarks>
                <para>
                Side effects: 1.  fills the CompressedBytes array.  2. sets the
                AvailableBytesOut property.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.mainSimpleSort(Ionic.BZip2.BZip2Compressor.CompressionState,System.Int32,System.Int32,System.Int32)">
             This is the most hammered method of this class.
            
             <p>
             This is the version using unrolled loops.
             </p></member>
        <member name="M:Ionic.BZip2.BZip2Compressor.mainQSort3(Ionic.BZip2.BZip2Compressor.CompressionState,System.Int32,System.Int32,System.Int32)">
            Method "mainQSort3", file "blocksort.c", BZip2 1.0.2
        </member>
        <member name="F:Ionic.BZip2.BZip2Compressor.CompressionState.quadrant">
            Array instance identical to sfmap, both are used only
            temporarily and independently, so we do not need to allocate
            additional memory.
        </member>
        <member name="T:Ionic.BZip2.BZip2InputStream">
            <summary>
              A read-only decorator stream that performs BZip2 decompression on Read.
            </summary>
        </member>
        <member name="T:Ionic.BZip2.BZip2InputStream.CState">
            <summary>
              Compressor State
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.#ctor(System.IO.Stream)">
            <summary>
              Create a BZip2InputStream, wrapping it around the given input Stream.
            </summary>
            <remarks>
                <para>
                The input stream will be closed when the BZip2InputStream is closed.
              </para>
            </remarks>
            <param name="input">The stream from which to read compressed data</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
               Create a BZip2InputStream with the given stream, and
               specifying whether to leave the wrapped stream open when
               the BZip2InputStream is closed.
             </summary>
            <param name="input">The stream from which to read compressed data</param>
            <param name="leaveOpen">
               Whether to leave the input stream open, when the BZip2InputStream closes.
             </param>
            <example>
            
               This example reads a bzip2-compressed file, decompresses it,
               and writes the decompressed data into a newly created file.
            
               <code>
               var fname = "logfile.log.bz2";
               using (var fs = File.OpenRead(fname))
               {
                   using (var decompressor = new Ionic.BZip2.BZip2InputStream(fs))
                   {
                       var outFname = fname + ".decompressed";
                       using (var output = File.Create(outFname))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = decompressor.Read(buffer, 0, buffer.Length)) &gt; 0)
                           {
                               output.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code></example>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
               Read data from the stream.
             </summary>
            <remarks>
                <para>
                 To decompress a BZip2 data stream, create a <c>BZip2InputStream</c>,
                 providing a stream that reads compressed data.  Then call Read() on
                 that <c>BZip2InputStream</c>, and the data read will be decompressed
                 as you read.
               </para>
                <para>
                 A <c>BZip2InputStream</c> can be used only for <c>Read()</c>, not for <c>Write()</c>.
               </para>
            </remarks>
            <param name="buffer">The buffer into which the read data should be placed.</param>
            <param name="offset">the offset within that data array to put the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.ReadByte">
            <summary>
              Read a single byte from the stream.
            </summary>
            <returns>the byte read from the stream, or -1 if EOF</returns>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.Position">
            <summary>
             The position of the stream pointer.
             </summary>
            <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException" />. Reading will return the
               total number of uncompressed bytes read in.
             </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="buffer">this parameter is never used</param>
            <param name="offset">this parameter is never used</param>
            <param name="count">this parameter is never used</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Close">
            <summary>
              Close the stream.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.GetBits(System.Int32)">
            <summary>
              Read n bits from input, right justifying the result.
            </summary>
            <remarks>
                <para>
                For example, if you read 1 bit, the result is either 0
                or 1.
              </para>
            </remarks>
            <param name="n">
              The number of bits to read, always between 1 and 32.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.hbCreateDecodeTables(System.Int32[],System.Int32[],System.Int32[],System.Char[],System.Int32,System.Int32,System.Int32)">
            Called by createHuffmanDecodingTables() exclusively.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.createHuffmanDecodingTables(System.Int32,System.Int32)">
            Called by recvDecodingTables() exclusively.
        </member>
        <member name="F:Ionic.BZip2.BZip2InputStream.DecompressionState.unzftab">
            Freq table collected to save a pass over the data during
            decompression.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.DecompressionState.initTT(System.Int32)">
             Initializes the tt array.
            
             This method is called when the required length of the array is known.
             I don't initialize it at construction time to avoid unneccessary
             memory allocation when compressing small files.
        </member>
        <member name="T:Ionic.BZip2.BZip2OutputStream">
            <summary>
              A write-only decorator stream that compresses data as it is
              written using the BZip2 algorithm.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream)">
            <summary>
               Constructs a new <c>BZip2OutputStream</c>, that sends its
               compressed output to the given output stream.
             </summary>
            <param name="output">
               The destination stream, to which compressed output will be sent.
             </param>
            <example>
            
               This example reads a file, then compresses it with bzip2 file,
               and writes the compressed data into a newly created file.
            
               <code>
               var fname = "logfile.log";
               using (var fs = File.OpenRead(fname))
               {
                   var outFname = fname + ".bz2";
                   using (var output = File.Create(outFname))
                   {
                       using (var compressor = new Ionic.BZip2.BZip2OutputStream(output))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = fs.Read(buffer, 0, buffer.Length)) &gt; 0)
                           {
                               compressor.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code></example>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
              Constructs a new <c>BZip2OutputStream</c> with specified blocksize.
            </summary>
            <param name="output">the destination stream.</param>
            <param name="blockSize">
              The blockSize in units of 100000 bytes.
              The valid range is 1..9.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              Constructs a new <c>BZip2OutputStream</c>.
            </summary>
            <param name="output">the destination stream.</param>
            <param name="leaveOpen">
              whether to leave the captive stream open upon closing this stream.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
               Constructs a new <c>BZip2OutputStream</c> with specified blocksize,
               and explicitly specifies whether to leave the wrapped stream open.
             </summary>
            <param name="output">the destination stream.</param>
            <param name="blockSize">
               The blockSize in units of 100000 bytes.
               The valid range is 1..9.
             </param>
            <param name="leaveOpen">
               whether to leave the captive stream open upon closing this stream.
             </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Close">
            <summary>
              Close the stream.
            </summary>
            <remarks>
                <para>
                This may or may not close the underlying stream.  Check the
                constructors that accept a bool value.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Flush">
            <summary>
              Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.BlockSize">
            <summary>
              The blocksize parameter specified at construction time.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
               Write data to the stream.
             </summary>
            <remarks>
                <para>
               Use the <c>BZip2OutputStream</c> to compress data while writing:
               create a <c>BZip2OutputStream</c> with a writable output stream.
               Then call <c>Write()</c> on that <c>BZip2OutputStream</c>, providing
               uncompressed data as input.  The data sent to the output stream will
               be the compressed form of the input data.
             </para>
                <para>
               A <c>BZip2OutputStream</c> can be used only for <c>Write()</c> not for <c>Read()</c>.
             </para>
            </remarks>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value is always false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value should always be true, unless and until the
            object is disposed and closed.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.Position">
            <summary>
             The position of the stream pointer.
             </summary>
            <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException" />. Reading will return the
               total number of uncompressed bytes written through.
             </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="buffer">this parameter is never used</param>
            <param name="offset">this parameter is never used</param>
            <param name="count">this parameter is never used</param>
            <returns>never returns anything; always throws</returns>
        </member>
        <member name="T:Ionic.BZip2.ParallelBZip2OutputStream">
            <summary>
               A write-only decorator stream that compresses data as it is
               written using the BZip2 algorithm. This stream compresses by
               block using multiple threads.
             </summary>
            <para>
               This class performs BZIP2 compression through writing.  For
               more information on the BZIP2 algorithm, see
               <see href="http://en.wikipedia.org/wiki/BZIP2" />.
             </para>
            <para>
               This class is similar to <see cref="T:Ionic.BZip2.BZip2OutputStream" />,
               except that this implementation uses an approach that employs multiple
               worker threads to perform the compression.  On a multi-cpu or multi-core
               computer, the performance of this class can be significantly higher than
               the single-threaded BZip2OutputStream, particularly for larger streams.
               How large?  Anything over 10mb is a good candidate for parallel
               compression.
             </para>
            <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla <c>BZip2OutputStream</c>. Also, for small files, the
               <c>ParallelBZip2OutputStream</c> can be much slower than the vanilla
               <c>BZip2OutputStream</c>, because of the overhead associated to using the
               thread pool.
             </para>
            <seealso cref="T:Ionic.BZip2.BZip2OutputStream" />
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream)">
            <summary>
               Constructs a new <c>ParallelBZip2OutputStream</c>, that sends its
               compressed output to the given output stream.
             </summary>
            <param name="output">
               The destination stream, to which compressed output will be sent.
             </param>
            <example>
            
               This example reads a file, then compresses it with bzip2 file,
               and writes the compressed data into a newly created file.
            
               <code>
               var fname = "logfile.log";
               using (var fs = File.OpenRead(fname))
               {
                   var outFname = fname + ".bz2";
                   using (var output = File.Create(outFname))
                   {
                       using (var compressor = new Ionic.BZip2.ParallelBZip2OutputStream(output))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = fs.Read(buffer, 0, buffer.Length)) &gt; 0)
                           {
                               compressor.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code></example>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
              Constructs a new <c>ParallelBZip2OutputStream</c> with specified blocksize.
            </summary>
            <param name="output">the destination stream.</param>
            <param name="blockSize">
              The blockSize in units of 100000 bytes.
              The valid range is 1..9.
            </param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              Constructs a new <c>ParallelBZip2OutputStream</c>.
            </summary>
            <param name="output">the destination stream.</param>
            <param name="leaveOpen">
              whether to leave the captive stream open upon closing this stream.
            </param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
               Constructs a new <c>ParallelBZip2OutputStream</c> with specified blocksize,
               and explicitly specifies whether to leave the wrapped stream open.
             </summary>
            <param name="output">the destination stream.</param>
            <param name="blockSize">
               The blockSize in units of 100000 bytes.
               The valid range is 1..9.
             </param>
            <param name="leaveOpen">
               whether to leave the captive stream open upon closing this stream.
             </param>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.MaxWorkers">
            <summary>
               The maximum number of concurrent compression worker threads to use.
             </summary>
            <remarks>
                <para>
               This property sets an upper limit on the number of concurrent worker
               threads to employ for compression. The implementation of this stream
               employs multiple threads from the .NET thread pool, via <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see>, to compress the incoming data by
               block.  As each block of data is compressed, this stream re-orders the
               compressed blocks and writes them to the output stream.
             </para>
                <para>
               A higher number of workers enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
                <para>
               By default, DotNetZip allocates 4 workers per CPU core, subject to the
               upper limit specified in this property. For example, suppose the
               application sets this property to 16.  Then, on a machine with 2
               cores, DotNetZip will use 8 workers; that number does not exceed the
               upper limit specified by this property, so the actual number of
               workers used will be 4 * 2 = 8.  On a machine with 4 cores, DotNetZip
               will use 16 workers; again, the limit does not apply. On a machine
               with 8 cores, DotNetZip will use 16 workers, because of the limit.
             </para>
                <para>
               For each compression "worker thread" that occurs in parallel, there is
               up to 2mb of memory allocated, for buffering and processing. The
               actual number depends on the <see cref="P:Ionic.BZip2.ParallelBZip2OutputStream.BlockSize" /> property.
             </para>
                <para>
               CPU utilization will also go up with additional workers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
                <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
                <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Close">
            <summary>
              Close the stream.
            </summary>
            <remarks>
                <para>
                This may or may not close the underlying stream.  Check the
                constructors that accept a bool value.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Flush">
            <summary>
              Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.BlockSize">
            <summary>
              The blocksize parameter specified at construction time.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
               Write data to the stream.
             </summary>
            <remarks>
                <para>
               Use the <c>ParallelBZip2OutputStream</c> to compress data while
               writing: create a <c>ParallelBZip2OutputStream</c> with a writable
               output stream.  Then call <c>Write()</c> on that
               <c>ParallelBZip2OutputStream</c>, providing uncompressed data as
               input.  The data sent to the output stream will be the compressed
               form of the input data.
             </para>
                <para>
               A <c>ParallelBZip2OutputStream</c> can be used only for
               <c>Write()</c> not for <c>Read()</c>.
             </para>
            </remarks>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value is always false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.Position">
            <summary>
             The position of the stream pointer.
             </summary>
            <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException" />. Reading will return the
               total number of uncompressed bytes written through.
             </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.BytesWrittenOut">
            <summary>
            The total number of bytes written out by the stream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="buffer">this parameter is never used</param>
            <param name="offset">this parameter is never used</param>
            <param name="count">this parameter is never used</param>
            <returns>never returns anything; always throws</returns>
        </member>
        <member name="M:Ionic.BZip2.Rand.Rnums(System.Int32)">
            <summary>
              Returns the "random" number at a specific index.
            </summary>
            <param name="i">the index</param>
            <returns>the random number</returns>
        </member>
        <member name="T:Ionic.Zip.SelfExtractorFlavor">
            <summary>
            An enum that provides the different self-extractor flavors
            </summary>
        </member>
        <member name="F:Ionic.Zip.SelfExtractorFlavor.ConsoleApplication">
            <summary>
            A self-extracting zip archive that runs from the console or
            command line.
            </summary>
        </member>
        <member name="F:Ionic.Zip.SelfExtractorFlavor.WinFormsApplication">
            <summary>
            A self-extracting zip archive that presents a graphical user
            interface when it is executed.
            </summary>
        </member>
        <member name="T:Ionic.Zip.SelfExtractorSaveOptions">
            <summary>
            The options for generating a self-extracting archive.
            </summary>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Flavor">
            <summary>
              The type of SFX to create.
            </summary>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.PostExtractCommandLine">
            <summary>
               The command to run after extraction.
             </summary>
            <remarks>
                <para>
               This is optional. Leave it empty (<c>null</c> in C# or <c>Nothing</c> in
               VB) to run no command after extraction.
             </para>
                <para>
               If it is non-empty, the SFX will execute the command specified in this
               string on the user's machine, and using the extract directory as the
               working directory for the process, after unpacking the archive. The
               program to execute can include a path, if you like. If you want to execute
               a program that accepts arguments, specify the program name, followed by a
               space, and then the arguments for the program, each separated by a space,
               just as you would on a normal command line. Example: <c>program.exe arg1
               arg2</c>.  The string prior to the first space will be taken as the
               program name, and the string following the first space specifies the
               arguments to the program.
             </para>
                <para>
               If you want to execute a program that has a space in the name or path of
               the file, surround the program name in double-quotes. The first character
               of the command line should be a double-quote character, and there must be
               a matching double-quote following the end of the program file name. Any
               optional arguments to the program follow that, separated by
               spaces. Example: <c>"c:\project files\program name.exe" arg1 arg2</c>.
             </para>
                <para>
               If the flavor of the SFX is <c>SelfExtractorFlavor.ConsoleApplication</c>,
               then the SFX starts a new process, using this string as the post-extract
               command line.  The SFX waits for the process to exit.  The exit code of
               the post-extract command line is returned as the exit code of the
               command-line self-extractor exe. A non-zero exit code is typically used to
               indicated a failure by the program. In the case of an SFX, a non-zero exit
               code may indicate a failure during extraction, OR, it may indicate a
               failure of the run-after-extract program if specified, OR, it may indicate
               the run-after-extract program could not be fuond. There is no way to
               distinguish these conditions from the calling shell, aside from parsing
               the output of the SFX. If you have Quiet set to <c>true</c>, you may not
               see error messages, if a problem occurs.
             </para>
                <para>
               If the flavor of the SFX is
               <c>SelfExtractorFlavor.WinFormsApplication</c>, then the SFX starts a new
               process, using this string as the post-extract command line, and using the
               extract directory as the working directory for the process. The SFX does
               not wait for the command to complete, and does not check the exit code of
               the program. If the run-after-extract program cannot be fuond, a message
               box is displayed indicating that fact.
             </para>
                <para>
               You can specify environment variables within this string, with a format like
               <c>%NAME%</c>. The value of these variables will be expanded at the time
               the SFX is run. Example: <c>%WINDIR%\system32\xcopy.exe</c> may expand at
               runtime to <c>c:\Windows\System32\xcopy.exe</c>.
             </para>
                <para>
               By combining this with the <c>RemoveUnpackedFilesAfterExecute</c>
               flag, you can create an SFX that extracts itself, runs a file that
               was extracted, then deletes all the files that were extracted. If
               you want it to run "invisibly" then set <c>Flavor</c> to
               <c>SelfExtractorFlavor.ConsoleApplication</c>, and set <c>Quiet</c>
               to true.  The user running such an EXE will see a console window
               appear, then disappear quickly.  You may also want to specify the
               default extract location, with <c>DefaultExtractDirectory</c>.
             </para>
                <para>
               If you set <c>Flavor</c> to
               <c>SelfExtractorFlavor.WinFormsApplication</c>, and set <c>Quiet</c> to
               true, then a GUI with progressbars is displayed, but it is
               "non-interactive" - it accepts no input from the user.  Instead the SFX
               just automatically unpacks and exits.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.DefaultExtractDirectory">
            <summary>
               The default extract directory the user will see when
               running the self-extracting archive.
             </summary>
            <remarks>
                <para>
               Passing null (or Nothing in VB) here will cause the Self Extractor to use
               the the user's personal directory (<see cref="F:System.Environment.SpecialFolder.Personal" />) for the default extract
               location.
             </para>
                <para>
               This is only a default location.  The actual extract location will be
               settable on the command line when the SFX is executed.
             </para>
                <para>
               You can specify environment variables within this string,
               with <c>%NAME%</c>. The value of these variables will be
               expanded at the time the SFX is run. Example:
               <c>%USERPROFILE%\Documents\unpack</c> may expand at runtime to
               <c>c:\users\melvin\Documents\unpack</c>.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.IconFile">
            <summary>
               The name of an .ico file in the filesystem to use for the application icon
               for the generated SFX.
             </summary>
            <remarks>
                <para>
               Normally, DotNetZip will embed an "zipped folder" icon into the generated
               SFX.  If you prefer to use a different icon, you can specify it here. It
               should be a .ico file.  This file is passed as the <c>/win32icon</c>
               option to the csc.exe compiler when constructing the SFX file.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Quiet">
            <summary>
               Whether the ConsoleApplication SFX will be quiet during extraction.
             </summary>
            <remarks>
                <para>
               This option affects the way the generated SFX runs. By default it is
               false.  When you set it to true,...
             </para>
                <list type="table">
                    <listheader>
                        <term>Flavor</term>
                        <description>Behavior</description>
                    </listheader>
                    <item>
                        <term>
                            <c>ConsoleApplication</c>
                        </term>
                        <description>
                            <para>no messages will be emitted during successful
                 operation.</para>
                            <para> Double-clicking the SFX in Windows
                 Explorer or as an attachment in an email will cause a console
                 window to appear briefly, before it disappears. If you run the
                 ConsoleApplication SFX from the cmd.exe prompt, it runs as a
                 normal console app; by default, because it is quiet, it displays
                 no messages to the console.  If you pass the -v+ command line
                 argument to the Console SFX when you run it, you will get verbose
                 messages to the console. </para>
                        </description>
                    </item>
                    <item>
                        <term>
                            <c>WinFormsApplication</c>
                        </term>
                        <description>the SFX extracts automatically when the application
                    is launched, with no additional user input.
               </description>
                    </item>
                </list>
                <para>
               When you set it to false,...
             </para>
                <list type="table">
                    <listheader>
                        <term>Flavor</term>
                        <description>Behavior</description>
                    </listheader>
                    <item>
                        <term>
                            <c>ConsoleApplication</c>
                        </term>
                        <description>
                            <para>the extractor will emit a
                 message to the console for each entry extracted.</para>
                            <para>
                   When double-clicking to launch the SFX, the console window will
                   remain, and the SFX will emit a message for each file as it
                   extracts. The messages fly by quickly, they won't be easily
                   readable, unless the extracted files are fairly large.
                 </para>
                        </description>
                    </item>
                    <item>
                        <term>
                            <c>WinFormsApplication</c>
                        </term>
                        <description>the SFX presents a forms UI and allows the user to select
                 options before extracting.
               </description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.ExtractExistingFile">
            <summary>
              Specify what the self-extractor will do when extracting an entry
              would overwrite an existing file.
            </summary>
            <remarks>
                <para>
              The default behavvior is to Throw.
            </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.RemoveUnpackedFilesAfterExecute">
            <summary>
               Whether to remove the files that have been unpacked, after executing the
               PostExtractCommandLine.
             </summary>
            <remarks>
                <para>
               If true, and if there is a <see cref="P:Ionic.Zip.SelfExtractorSaveOptions.PostExtractCommandLine">
               PostExtractCommandLine</see>, and if the command runs successfully,
               then the files that the SFX unpacked will be removed, afterwards.  If
               the command does not complete successfully (non-zero return code),
               that is interpreted as a failure, and the extracted files will not be
               removed.
             </para>
                <para>
               Setting this flag, and setting <c>Flavor</c> to
               <c>SelfExtractorFlavor.ConsoleApplication</c>, and setting <c>Quiet</c> to
               true, results in an SFX that extracts itself, runs a file that was
               extracted, then deletes all the files that were extracted, with no
               intervention by the user.  You may also want to specify the default
               extract location, with <c>DefaultExtractDirectory</c>.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.FileVersion">
            <summary>
               The file version number to embed into the generated EXE. It will show up, for
               example, during a mouseover in Windows Explorer.
             </summary>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.ProductVersion">
            <summary>
               The product version to embed into the generated EXE. It will show up, for
               example, during a mouseover in Windows Explorer.
             </summary>
            <remarks>
               You can use any arbitrary string, but a human-readable version number is
               recommended. For example "v1.2 alpha" or "v4.2 RC2".  If you specify nothing,
               then there is no product version embedded into the EXE.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Copyright">
            <summary>
               The copyright notice, if any, to embed into the generated EXE.
             </summary>
            <remarks>
               It will show up, for example, while viewing properties of the file in
               Windows Explorer.  You can use any arbitrary string, but typically you
               want something like "Copyright © Dino Chiesa 2011".
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Description">
            <summary>
               The description to embed into the generated EXE.
             </summary>
            <remarks>
               Use any arbitrary string.  This text will be displayed during a
               mouseover in Windows Explorer.  If you specify nothing, then the string
               "DotNetZip SFX Archive" is embedded into the EXE as the description.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.ProductName">
            <summary>
               The product name to embed into the generated EXE.
             </summary>
            <remarks>
               Use any arbitrary string. This text will be displayed
               while viewing properties of the EXE file in
               Windows Explorer.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.SfxExeWindowTitle">
            <summary>
               The title to display in the Window of a GUI SFX, while it extracts.
             </summary>
            <remarks>
                <para>
                 By default the title show in the GUI window of a self-extractor
                 is "DotNetZip Self-extractor (http://DotNetZip.codeplex.com/)".
                 You can change that by setting this property before saving the SFX.
               </para>
                <para>
                 This property has an effect only when producing a Self-extractor
                 of flavor <c>SelfExtractorFlavor.WinFormsApplication</c>.
               </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.AdditionalCompilerSwitches">
            <summary>
              Additional options for the csc.exe compiler, when producing the SFX
              EXE.
            </summary>
            <exclude />
        </member>
        <member name="T:Ionic.Zip.ZipFile">
            <summary>
               The ZipFile type represents a zip archive file.
             </summary>
            <remarks>
                <para>
               This is the main type in the DotNetZip class library. This class reads and
               writes zip files, as defined in the <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
               for zip files described by PKWare</see>.  The compression for this
               implementation is provided by a managed-code version of Zlib, included with
               DotNetZip in the classes in the Ionic.Zlib namespace.
             </para>
                <para>
               This class provides a general purpose zip file capability.  Use it to read,
               create, or update zip files.  When you want to create zip files using a
               <c>Stream</c> type to write the zip file, you may want to consider the <see cref="T:Ionic.Zip.ZipOutputStream" /> class.
             </para>
                <para>
               Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can
               be used to create zip files. Both of them support many of the common zip
               features, including Unicode, different compression methods and levels,
               and ZIP64. They provide very similar performance when creating zip
               files.
             </para>
                <para>
               The <c>ZipFile</c> class is generally easier to use than
               <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
               example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
               <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
               responsible for opening the file, reading the bytes from the file, writing
               those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
               <c>ZipEntry</c>, and setting the created, last modified, and last accessed
               timestamps on the zip entry. All of these things are done automatically by a
               call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">ZipFile.AddFile()</see>.
               For this reason, the <c>ZipOutputStream</c> is generally recommended for use
               only when your application emits arbitrary data, not necessarily data from a
               filesystem file, directly into a zip file, and does so using a <c>Stream</c>
               metaphor.
             </para>
                <para>
               Aside from the differences in programming model, there are other
               differences in capability between the two classes.
             </para>
                <list type="bullet">
                    <item>
                        <c>ZipFile</c> can be used to read and extract zip files, in addition to
                 creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
                 to use a stream to read zip files, check out the <see cref="T:Ionic.Zip.ZipInputStream" /> class.
               </item>
                    <item>
                        <c>ZipOutputStream</c> does not support the creation of segmented or spanned
                 zip files.
               </item>
                    <item>
                        <c>ZipOutputStream</c> cannot produce a self-extracting archive.
               </item>
                </list>
                <para>
               Be aware that the <c>ZipFile</c> class implements the <see cref="T:System.IDisposable" /> interface.  In order for <c>ZipFile</c> to
               produce a valid zip file, you use use it within a using clause (<c>Using</c>
               in VB), or call the <c>Dispose()</c> method explicitly.  See the examples
               for how to employ a using clause.
             </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)">
            <summary>
             Saves the ZipFile instance to a self-extracting zip archive.
             </summary>
            <remarks>
                <para>
             The generated exe image will execute on any machine that has the .NET
             Framework 2.0 installed on it.  The generated exe image is also a
             valid ZIP file, readable with DotNetZip or another Zip library or tool
             such as WinZip.
             </para>
                <para>
             There are two "flavors" of self-extracting archive.  The
             <c>WinFormsApplication</c> version will pop up a GUI and allow the
             user to select a target directory into which to extract. There's also
             a checkbox allowing the user to specify to overwrite existing files,
             and another checkbox to allow the user to request that Explorer be
             opened to see the extracted files after extraction.  The other flavor
             is <c>ConsoleApplication</c>.  A self-extractor generated with that
             flavor setting will run from the command line. It accepts command-line
             options to set the overwrite behavior, and to specify the target
             extraction directory.
             </para>
                <para>
             There are a few temporary files created during the saving to a
             self-extracting zip.  These files are created in the directory pointed
             to by <see cref="P:Ionic.Zip.ZipFile.TempFileFolder" />, which defaults to <see cref="M:System.IO.Path.GetTempPath" />.  These temporary files are
             removed upon successful completion of this method.
             </para>
                <para>
             When a user runs the WinForms SFX, the user's personal directory (<see cref="F:System.Environment.SpecialFolder.Personal">Environment.SpecialFolder.Personal</see>)
             will be used as the default extract location.  If you want to set the
             default extract location, you should use the other overload of
             <c>SaveSelfExtractor()</c>/ The user who runs the SFX will have the
             opportunity to change the extract directory before extracting. When
             the user runs the Command-Line SFX, the user must explicitly specify
             the directory to which to extract.  The .NET Framework 2.0 is required
             on the computer when the self-extracting archive is run.
             </para>
                <para>
             NB: This method is not available in the version of DotNetZip build for
             the .NET Compact Framework, nor in the "Reduced" DotNetZip library.
             </para>
            </remarks>
            <example>
                <code>
             string DirectoryPath = "c:\\Documents\\Project7";
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                 zip.Comment = "This will be embedded into a self-extracting console-based exe";
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication);
             }
             </code>
                <code lang="VB">
             Dim DirectoryPath As String = "c:\Documents\Project7"
             Using zip As New ZipFile()
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                 zip.Comment = "This will be embedded into a self-extracting console-based exe"
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication)
             End Using
             </code>
            </example>
            <param name="exeToGenerate">
               a pathname, possibly fully qualified, to be created. Typically it
               will end in an .exe extension.</param>
            <param name="flavor">
               Indicates whether a Winforms or Console self-extractor is
               desired. </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorSaveOptions)">
            <summary>
               Saves the ZipFile instance to a self-extracting zip archive, using
               the specified save options.
             </summary>
            <remarks>
                <para>
               This method saves a self extracting archive, using the specified save
               options. These options include the flavor of the SFX, the default extract
               directory, the icon file, and so on.  See the documentation
               for <see cref="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)" /> for more
               details.
             </para>
                <para>
               The user who runs the SFX will have the opportunity to change the extract
               directory before extracting. If at the time of extraction, the specified
               directory does not exist, the SFX will create the directory before
               extracting the files.
             </para>
            </remarks>
            <example>
               This example saves a WinForms-based self-extracting archive EXE that
               will use c:\ExtractHere as the default extract location. The C# code
               shows syntax for .NET 3.0, which uses an object initializer for
               the SelfExtractorOptions object.
             <code>
             string DirectoryPath = "c:\\Documents\\Project7";
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                 zip.Comment = "This will be embedded into a self-extracting WinForms-based exe";
                 var options = new SelfExtractorOptions
                 {
                   Flavor = SelfExtractorFlavor.WinFormsApplication,
                   DefaultExtractDirectory = "%USERPROFILE%\\ExtractHere",
                   PostExtractCommandLine = ExeToRunAfterExtract,
                   SfxExeWindowTitle = "My Custom Window Title",
                   RemoveUnpackedFilesAfterExecute = true
                 };
                 zip.SaveSelfExtractor("archive.exe", options);
             }
             </code><code lang="VB">
             Dim DirectoryPath As String = "c:\Documents\Project7"
             Using zip As New ZipFile()
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                 zip.Comment = "This will be embedded into a self-extracting console-based exe"
                 Dim options As New SelfExtractorOptions()
                 options.Flavor = SelfExtractorFlavor.WinFormsApplication
                 options.DefaultExtractDirectory = "%USERPROFILE%\\ExtractHere"
                 options.PostExtractCommandLine = ExeToRunAfterExtract
                 options.SfxExeWindowTitle = "My Custom Window Title"
                 options.RemoveUnpackedFilesAfterExecute = True
                 zip.SaveSelfExtractor("archive.exe", options)
             End Using
             </code></example>
            <param name="exeToGenerate">The name of the EXE to generate.</param>
            <param name="options">provides the options for creating the
             Self-extracting archive.</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddItem(System.String)">
            <summary>
               Adds an item, either a file or a directory, to a zip file archive.
             </summary>
            <remarks>
                <para>
               This method is handy if you are adding things to zip archive and don't
               want to bother distinguishing between directories or files.  Any files are
               added as single entries.  A directory added through this method is added
               recursively: all files and subdirectories contained within the directory
               are added to the <c>ZipFile</c>.
             </para>
                <para>
               The name of the item may be a relative path or a fully-qualified
               path. Remember, the items contained in <c>ZipFile</c> instance get written
               to the disk only when you call <see cref="M:Ionic.Zip.ZipFile.Save" /> or a similar
               save method.
             </para>
                <para>
               The directory name used for the file within the archive is the same
               as the directory name (potentially a relative path) specified in the
               <paramref name="fileOrDirectoryName" />.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
            <overloads>This method has two overloads.</overloads>
            <param name="fileOrDirectoryName">
             the name of the file or directory to add.</param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)">
            <summary>
               Adds an item, either a file or a directory, to a zip file archive,
               explicitly specifying the directory path to be used in the archive.
             </summary>
            <remarks>
                <para>
               If adding a directory, the add is recursive on all files and
               subdirectories contained within it.
             </para>
                <para>
               The name of the item may be a relative path or a fully-qualified path.
               The item added by this call to the <c>ZipFile</c> is not read from the
               disk nor written to the zip file archive until the application calls
               Save() on the <c>ZipFile</c>.
             </para>
                <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive, which would override the
               "natural" path of the filesystem file.
             </para>
                <para>
               Encryption will be used on the file data if the <c>Password</c> has
               been set on the <c>ZipFile</c> object, prior to calling this method.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <exception cref="T:System.IO.FileNotFoundException">
               Thrown if the file or directory passed in does not exist.
             </exception>
            <param name="fileOrDirectoryName">the name of the file or directory to add.
             </param>
            <param name="directoryPathInArchive">
               The name of the directory path to use within the zip archive.  This path
               need not refer to an extant directory in the current filesystem.  If the
               files within the zip are later extracted, this is the path used for the
               extracted file.  Passing <c>null</c> (<c>Nothing</c> in VB) will use the
               path on the fileOrDirectoryName.  Passing the empty string ("") will
               insert the item at the root path within the archive.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
            <example>
               This example shows how to zip up a set of files into a flat hierarchy,
               regardless of where in the filesystem the files originated. The resulting
               zip archive will contain a toplevel directory named "flat", which itself
               will contain files Readme.txt, MyProposal.docx, and Image1.jpg.  A
               subdirectory under "flat" called SupportFiles will contain all the files
               in the "c:\SupportFiles" directory on disk.
            
             <code>
             String[] itemnames= {
               "c:\\fixedContent\\Readme.txt",
               "MyProposal.docx",
               "c:\\SupportFiles",  // a directory
               "images\\Image1.jpg"
             };
            
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 for (int i = 1; i &lt; itemnames.Length; i++)
                 {
                   // will add Files or Dirs, recurses and flattens subdirectories
                   zip.AddItem(itemnames[i],"flat");
                 }
                 zip.Save(ZipToCreate);
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code><code lang="VB">
               Dim itemnames As String() = _
                 New String() { "c:\fixedContent\Readme.txt", _
                                "MyProposal.docx", _
                                "SupportFiles", _
                                "images\Image1.jpg" }
               Try
                   Using zip As New ZipFile
                       Dim i As Integer
                       For i = 1 To itemnames.Length - 1
                           ' will add Files or Dirs, recursing and flattening subdirectories.
                           zip.AddItem(itemnames(i), "flat")
                       Next i
                       zip.Save(ZipToCreate)
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code></example>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFile(System.String)">
            <summary>
               Adds a File to a Zip file archive.
             </summary>
            <remarks>
                <para>
               This call collects metadata for the named file in the filesystem,
               including the file attributes and the timestamp, and inserts that metadata
               into the resulting ZipEntry.  Only when the application calls Save() on
               the <c>ZipFile</c>, does DotNetZip read the file from the filesystem and
               then write the content to the zip file archive.
             </para>
                <para>
               This method will throw an exception if an entry with the same name already
               exists in the <c>ZipFile</c>.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <example>
                <para>
               In this example, three files are added to a Zip archive. The ReadMe.txt
               file will be placed in the root of the archive. The .png file will be
               placed in a folder within the zip called photos\personal.  The pdf file
               will be included into a folder within the zip called Desktop.
             </para>
                <code>
                try
                {
                  using (ZipFile zip = new ZipFile())
                  {
                    zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
                    zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf");
                    zip.AddFile("ReadMe.txt");
            
                    zip.Save("Package.zip");
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
                <code lang="VB">
              Try
                   Using zip As ZipFile = New ZipFile
                       zip.AddFile("c:\photos\personal\7440-N49th.png")
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf")
                       zip.AddFile("ReadMe.txt")
                       zip.Save("Package.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
            </example>
            <overloads>This method has two overloads.</overloads>
            <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
            <param name="fileName">
               The name of the file to add. It should refer to a file in the filesystem.
               The name of the file may be a relative path or a fully-qualified path.
             </param>
            <returns>The <c>ZipEntry</c> corresponding to the File added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">
            <summary>
               Adds a File to a Zip file archive, potentially overriding the path to be
               used within the zip archive.
             </summary>
            <remarks>
                <para>
               The file added by this call to the <c>ZipFile</c> is not written to the
               zip file archive until the application calls Save() on the <c>ZipFile</c>.
             </para>
                <para>
               This method will throw an exception if an entry with the same name already
               exists in the <c>ZipFile</c>.
             </para>
                <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <example>
                <para>
               In this example, three files are added to a Zip archive. The ReadMe.txt
               file will be placed in the root of the archive. The .png file will be
               placed in a folder within the zip called images.  The pdf file will be
               included into a folder within the zip called files\docs, and will be
               encrypted with the given password.
             </para>
                <code>
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 // the following entry will be inserted at the root in the archive.
                 zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
                 // this image file will be inserted into the "images" directory in the archive.
                 zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
                 // the following will result in a password-protected file called
                 // files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                 zip.Password = "EncryptMe!";
                 zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf", "files\\docs");
                 zip.Save("Archive.zip");
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
                <code lang="VB">
               Try
                   Using zip As ZipFile = New ZipFile
                       ' the following entry will be inserted at the root in the archive.
                       zip.AddFile("c:\datafiles\ReadMe.txt", "")
                       ' this image file will be inserted into the "images" directory in the archive.
                       zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                       ' the following will result in a password-protected file called
                       ' files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                       zip.Password = "EncryptMe!"
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf", "files\documents")
                       zip.Save("Archive.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1)
               End Try
             </code>
            </example>
            <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
            <param name="fileName">
               The name of the file to add.  The name of the file may be a relative path
               or a fully-qualified path.
             </param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the fileName.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on the fileName, if any.  Passing the empty string
               ("") will insert the item at the root path within the archive.
             </param>
            <returns>The <c>ZipEntry</c> corresponding to the file added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{Ionic.Zip.ZipEntry})">
            <summary>
               This method removes a collection of entries from the <c>ZipFile</c>.
             </summary>
            <param name="entriesToRemove">
               A collection of ZipEntry instances from this zip file to be removed. For
               example, you can pass in an array of ZipEntry instances; or you can call
               SelectEntries(), and then add or remove entries from that
               ICollection&lt;ZipEntry&gt; (ICollection(Of ZipEntry) in VB), and pass
               that ICollection to this method.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.SelectEntries(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{System.String})">
            <summary>
               This method removes a collection of entries from the <c>ZipFile</c>, by name.
             </summary>
            <param name="entriesToRemove">
               A collection of strings that refer to names of entries to be removed
               from the <c>ZipFile</c>.  For example, you can pass in an array or a
               List of Strings that provide the names of entries to be removed.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.SelectEntries(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
               This method adds a set of files to the <c>ZipFile</c>.
             </summary>
            <remarks>
                <para>
               Use this method to add a set of files to the zip archive, in one call.
               For example, a list of files received from
               <c>System.IO.Directory.GetFiles()</c> can be added to a zip archive in one
               call.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            </remarks>
            <param name="fileNames">
               The collection of names of the files to add. Each string should refer to a
               file in the filesystem. The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            <example>
               This example shows how to create a zip file, and add a few files into it.
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save(ZipFileToCreate);
             }
             </code><code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save(ZipFileToCreate)
             End Using
             </code></example>
            <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
               Adds or updates a set of files in the <c>ZipFile</c>.
             </summary>
            <remarks>
                <para>
               Any files that already exist in the archive are updated. Any files that
               don't yet exist in the archive are added.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            </remarks>
            <param name="fileNames">
               The collection of names of the files to update. Each string should refer to a file in
               the filesystem. The name of the file may be a relative path or a fully-qualified path.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
               Adds a set of files to the <c>ZipFile</c>, using the
               specified directory path in the archive.
             </summary>
            <remarks>
                <para>
               Any directory structure that may be present in the
               filenames contained in the list is "flattened" in the
               archive.  Each file in the list is added to the archive in
               the specified top-level directory.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their respective values at the
               time of this call will be applied to each ZipEntry added.
             </para>
            </remarks>
            <param name="fileNames">
               The names of the files to add. Each string should refer to
               a file in the filesystem.  The name of the file may be a
               relative path or a fully-qualified path.
             </param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               Th is path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.String)">
            <summary>
               Adds a set of files to the <c>ZipFile</c>, using the specified directory
               path in the archive, and preserving the full directory structure in the
               filenames.
             </summary>
            <remarks>
                <para>
               Think of the <paramref name="directoryPathInArchive" /> as a "root" or
               base directory used in the archive for the files that get added.  when
               <paramref name="preserveDirHierarchy" /> is true, the hierarchy of files
               found in the filesystem will be placed, with the hierarchy intact,
               starting at that root in the archive. When <c>preserveDirHierarchy</c>
               is false, the path hierarchy of files is flattned, and the flattened
               set of files gets placed in the root within the archive as specified in
               <c>directoryPathInArchive</c>.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            </remarks>
            <param name="fileNames">
               The names of the files to add. Each string should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use as a prefix for each entry name.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            <param name="preserveDirHierarchy">
               whether the entries in the zip archive will reflect the directory
               hierarchy that is present in the various filenames.  For example, if
               <paramref name="fileNames" /> includes two paths,
               \Animalia\Chordata\Mammalia\Info.txt and
               \Plantae\Magnoliophyta\Dicotyledon\Info.txt, then calling this method
               with <paramref name="preserveDirHierarchy" /> = <c>false</c> will
               result in an exception because of a duplicate entry name, while
               calling this method with <paramref name="preserveDirHierarchy" /> =
               <c>true</c> will result in the full direcory paths being included in
               the entries added to the ZipFile.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
               Adds or updates a set of files to the <c>ZipFile</c>, using the specified
               directory path in the archive.
             </summary>
            <remarks>
                <para>
               Any files that already exist in the archive are updated. Any files that
               don't yet exist in the archive are added.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            </remarks>
            <param name="fileNames">
               The names of the files to add or update. Each string should refer to a
               file in the filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String)">
            <summary>
               Adds or Updates a File in a Zip file archive.
             </summary>
            <remarks>
                <para>
               This method adds a file to a zip archive, or, if the file already exists
               in the zip archive, this method Updates the content of that given filename
               in the zip archive.  The <c>UpdateFile</c> method might more accurately be
               called "AddOrUpdateFile".
             </para>
                <para>
               Upon success, there is no way for the application to learn whether the file
               was added versus updated.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <example>
            
               This example shows how to Update an existing entry in a zipfile. The first
               call to UpdateFile adds the file to the newly-created zip archive.  The
               second call to UpdateFile updates the content for that file in the zip
               archive.
            
             <code>
             using (ZipFile zip1 = new ZipFile())
             {
               // UpdateFile might more accurately be called "AddOrUpdateFile"
               zip1.UpdateFile("MyDocuments\\Readme.txt");
               zip1.UpdateFile("CustomerList.csv");
               zip1.Comment = "This zip archive has been created.";
               zip1.Save("Content.zip");
             }
            
             using (ZipFile zip2 = ZipFile.Read("Content.zip"))
             {
               zip2.UpdateFile("Updates\\Readme.txt");
               zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed.";
               zip2.Save();
             }
            
             </code><code lang="VB">
               Using zip1 As New ZipFile
                   ' UpdateFile might more accurately be called "AddOrUpdateFile"
                   zip1.UpdateFile("MyDocuments\Readme.txt")
                   zip1.UpdateFile("CustomerList.csv")
                   zip1.Comment = "This zip archive has been created."
                   zip1.Save("Content.zip")
               End Using
            
               Using zip2 As ZipFile = ZipFile.Read("Content.zip")
                   zip2.UpdateFile("Updates\Readme.txt")
                   zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."
                   zip2.Save
               End Using
             </code></example>
            <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
            <param name="fileName">
               The name of the file to add or update. It should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            <returns>
               The <c>ZipEntry</c> corresponding to the File that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)">
            <summary>
               Adds or Updates a File in a Zip file archive.
             </summary>
            <remarks>
                <para>
               This method adds a file to a zip archive, or, if the file already exists
               in the zip archive, this method Updates the content of that given filename
               in the zip archive.
             </para>
                <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive.  The entry to be added or
               updated is found by using the specified directory path, combined with the
               basename of the specified filename.
             </para>
                <para>
               Upon success, there is no way for the application to learn if the file was
               added versus updated.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
            <param name="fileName">
               The name of the file to add or update. It should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>fileName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>fileName</c>, if any.  Passing the empty string ("") will insert the
               item at the root path within the archive.
             </param>
            <returns>
               The <c>ZipEntry</c> corresponding to the File that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)">
            <summary>
               Add or update a directory in a zip archive.
             </summary>
            <remarks>
               If the specified directory does not exist in the archive, then this method
               is equivalent to calling <c>AddDirectory()</c>.  If the specified
               directory already exists in the archive, then this method updates any
               existing entries, and adds any new entries. Any entries that are in the
               zip archive but not in the specified directory, are left alone.  In other
               words, the contents of the zip file will be a union of the previous
               contents and the new files.
             </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
            <param name="directoryName">
               The path to the directory to be added to the zip archive, or updated in
               the zip archive.
             </param>
            <returns>
             The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)">
            <summary>
               Add or update a directory in the zip archive at the specified root
               directory in the archive.
             </summary>
            <remarks>
               If the specified directory does not exist in the archive, then this method
               is equivalent to calling <c>AddDirectory()</c>.  If the specified
               directory already exists in the archive, then this method updates any
               existing entries, and adds any new entries. Any entries that are in the
               zip archive but not in the specified directory, are left alone.  In other
               words, the contents of the zip file will be a union of the previous
               contents and the new files.
             </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
            <param name="directoryName">
               The path to the directory to be added to the zip archive, or updated
               in the zip archive.
             </param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>directoryName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>directoryName</c>, if any.  Passing the empty string ("") will insert
               the item at the root path within the archive.
             </param>
            <returns>
               The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String)">
            <summary>
               Add or update a file or directory in the zip archive.
             </summary>
            <remarks>
                <para>
               This is useful when the application is not sure or does not care if the
               item to be added is a file or directory, and does not know or does not
               care if the item already exists in the <c>ZipFile</c>. Calling this method
               is equivalent to calling <c>RemoveEntry()</c> if an entry by the same name
               already exists, followed calling by <c>AddItem()</c>.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
            <param name="itemName">
              the path to the file or directory to be added or updated.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)">
            <summary>
               Add or update a file or directory.
             </summary>
            <remarks>
                <para>
               This method is useful when the application is not sure or does not care if
               the item to be added is a file or directory, and does not know or does not
               care if the item already exists in the <c>ZipFile</c>. Calling this method
               is equivalent to calling <c>RemoveEntry()</c>, if an entry by that name
               exists, and then calling <c>AddItem()</c>.
             </para>
                <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used for the item being added to the archive.  The
               entry or entries that are added or updated will use the specified
               <c>DirectoryPathInArchive</c>. Extracting the entry from the archive will
               result in a file stored in that directory path.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
            <param name="itemName">
               The path for the File or Directory to be added or updated.
             </param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>itemName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>itemName</c>, if any.  Passing the empty string ("") will insert the
               item at the root path within the archive.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)">
            <summary>
               Adds a named entry into the zip archive, taking content for the entry
               from a string.
             </summary>
            <remarks>
               Calling this method creates an entry using the given fileName and
               directory path within the archive.  There is no need for a file by the
               given name to exist in the filesystem; the name is used within the zip
               archive only. The content for the entry is encoded using the default text
               encoding for the machine, or on Silverlight, using UTF-8.
             </remarks>
            <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            <param name="entryName">
               The name, including any path, to use for the entry within the archive.
             </param>
            <returns>The <c>ZipEntry</c> added.</returns>
            <example>
            
             This example shows how to add an entry to the zipfile, using a string as
             content for that entry.
            
             <code lang="C#">
             string Content = "This string will be the content of the Readme.txt file in the zip archive.";
             using (ZipFile zip1 = new ZipFile())
             {
               zip1.AddFile("MyDocuments\\Resume.doc", "files");
               zip1.AddEntry("Readme.txt", Content);
               zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
               zip1.Save("Content.zip");
             }
            
             </code><code lang="VB">
             Public Sub Run()
               Dim Content As String = "This string will be the content of the Readme.txt file in the zip archive."
               Using zip1 As ZipFile = New ZipFile
                 zip1.AddEntry("Readme.txt", Content)
                 zip1.AddFile("MyDocuments\Resume.doc", "files")
                 zip1.Comment = ("This zip file was created at " &amp; DateTime.Now.ToString("G"))
                 zip1.Save("Content.zip")
               End Using
             End Sub
             </code></example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)">
            <summary>
               Adds a named entry into the zip archive, taking content for the entry
               from a string, and using the specified text encoding.
             </summary>
            <remarks>
                <para>
               Calling this method creates an entry using the given fileName and
               directory path within the archive.  There is no need for a file by the
               given name to exist in the filesystem; the name is used within the zip
               archive only.
             </para>
                <para>
               The content for the entry, a string value, is encoded using the given
               text encoding. A BOM (byte-order-mark) is emitted into the file, if the
               Encoding parameter is set for that.
             </para>
                <para>
               Most Encoding classes support a constructor that accepts a boolean,
               indicating whether to emit a BOM or not. For example see <see cref="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />.
             </para>
            </remarks>
            <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            <param name="encoding">
               The text encoding to use when encoding the string. Be aware: This is
               distinct from the text encoding used to encode the fileName, as specified
               in <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />.
             </param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)">
            <summary>
               Create an entry in the <c>ZipFile</c> using the given <c>Stream</c>
               as input.  The entry will have the given filename.
             </summary>
            <remarks>
                <para>
               The application should provide an open, readable stream; in this case it
               will be read during the call to <see cref="M:Ionic.Zip.ZipFile.Save" /> or one of
               its overloads.
             </para>
                <para>
               The passed stream will be read from its current position. If
               necessary, callers should set the position in the stream before
               calling AddEntry(). This might be appropriate when using this method
               with a MemoryStream, for example.
             </para>
                <para>
               In cases where a large number of streams will be added to the
               <c>ZipFile</c>, the application may wish to avoid maintaining all of the
               streams open simultaneously.  To handle this situation, the application
               should use the <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />
               overload.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <example>
                <para>
               This example adds a single entry to a <c>ZipFile</c> via a <c>Stream</c>.
             </para>
                <code lang="C#">
             String zipToCreate = "Content.zip";
             String fileNameInArchive = "Content-From-Stream.bin";
             using (System.IO.Stream streamToRead = MyStreamOpener())
             {
               using (ZipFile zip = new ZipFile())
               {
                 ZipEntry entry= zip.AddEntry(fileNameInArchive, streamToRead);
                 zip.AddFile("Readme.txt");
                 zip.Save(zipToCreate);  // the stream is read implicitly here
               }
             }
             </code>
                <code lang="VB">
             Dim zipToCreate As String = "Content.zip"
             Dim fileNameInArchive As String = "Content-From-Stream.bin"
             Using streamToRead as System.IO.Stream = MyStreamOpener()
               Using zip As ZipFile = New ZipFile()
                 Dim entry as ZipEntry = zip.AddEntry(fileNameInArchive, streamToRead)
                 zip.AddFile("Readme.txt")
                 zip.Save(zipToCreate)  '' the stream is read implicitly, here
               End Using
             End Using
             </code>
            </example>
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)" />
            <param name="entryName">
               The name, including any path, which is shown in the zip file for the added
               entry.
             </param>
            <param name="stream">
               The input stream from which to grab content for the file
             </param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)">
            <summary>
               Add a ZipEntry for which content is written directly by the application.
             </summary>
            <remarks>
                <para>
               When the application needs to write the zip entry data, use this
               method to add the ZipEntry. For example, in the case that the
               application wishes to write the XML representation of a DataSet into
               a ZipEntry, the application can use this method to do so.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
                <para>
               About progress events: When using the WriteDelegate, DotNetZip does
               not issue any SaveProgress events with <c>EventType</c> = <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
               Saving_EntryBytesRead</see>. (This is because it is the
               application's code that runs in WriteDelegate - there's no way for
               DotNetZip to know when to issue a EntryBytesRead event.)
               Applications that want to update a progress bar or similar status
               indicator should do so from within the WriteDelegate
               itself. DotNetZip will issue the other SaveProgress events,
               including <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_Started">
               Saving_Started</see>,
               <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
               Saving_BeforeWriteEntry</see>, and <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
               Saving_AfterWriteEntry</see>.
             </para>
                <para>
               Note: When you use PKZip encryption, it's normally necessary to
               compute the CRC of the content to be encrypted, before compressing or
               encrypting it. Therefore, when using PKZip encryption with a
               WriteDelegate, the WriteDelegate CAN BE called twice: once to compute
               the CRC, and the second time to potentially compress and
               encrypt. Surprising, but true. This is because PKWARE specified that
               the encryption initialization data depends on the CRC.
               If this happens, for each call of the delegate, your
               application must stream the same entry data in its entirety. If your
               application writes different data during the second call, it will
               result in a corrupt zip file.
             </para>
                <para>
               The double-read behavior happens with all types of entries, not only
               those that use WriteDelegate. It happens if you add an entry from a
               filesystem file, or using a string, or a stream, or an opener/closer
               pair. But in those cases, DotNetZip takes care of reading twice; in
               the case of the WriteDelegate, the application code gets invoked
               twice. Be aware.
             </para>
                <para>
               As you can imagine, this can cause performance problems for large
               streams, and it can lead to correctness problems when you use a
               <c>WriteDelegate</c>. This is a pretty big pitfall.  There are two
               ways to avoid it.  First, and most preferred: don't use PKZIP
               encryption.  If you use the WinZip AES encryption, this problem
               doesn't occur, because the encryption protocol doesn't require the CRC
               up front. Second: if you do choose to use PKZIP encryption, write out
               to a non-seekable stream (like standard output, or the
               Response.OutputStream in an ASP.NET application).  In this case,
               DotNetZip will use an alternative encryption protocol that does not
               rely on the CRC of the content.  This also implies setting bit 3 in
               the zip entry, which still presents problems for some zip tools.
             </para>
                <para>
               In the future I may modify DotNetZip to *always* use bit 3 when PKZIP
               encryption is in use.  This seems like a win overall, but there will
               be some work involved.  If you feel strongly about it, visit the
               DotNetZip forums and vote up <see href="http://dotnetzip.codeplex.com/workitem/13686">the Workitem
               tracking this issue</see>.
             </para>
            </remarks>
            <param name="entryName">the name of the entry to add</param>
            <param name="writer">the delegate which will write the entry content</param>
            <returns>the ZipEntry added</returns>
            <example>
            
               This example shows an application filling a DataSet, then saving the
               contents of that DataSet as XML, into a ZipEntry in a ZipFile, using an
               anonymous delegate in C#. The DataSet XML is never saved to a disk file.
            
             <code lang="C#">
             var c1= new System.Data.SqlClient.SqlConnection(connstring1);
             var da = new System.Data.SqlClient.SqlDataAdapter()
                 {
                     SelectCommand=  new System.Data.SqlClient.SqlCommand(strSelect, c1)
                 };
            
             DataSet ds1 = new DataSet();
             da.Fill(ds1, "Invoices");
            
             using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
             {
                 zip.AddEntry(zipEntryName, (name,stream) =&gt; ds1.WriteXml(stream) );
                 zip.Save(zipFileName);
             }
             </code></example>
            <example>
            
             This example uses an anonymous method in C# as the WriteDelegate to provide
             the data for the ZipEntry. The example is a bit contrived - the
             <c>AddFile()</c> method is a simpler way to insert the contents of a file
             into an entry in a zip file. On the other hand, if there is some sort of
             processing or transformation of the file contents required before writing,
             the application could use the <c>WriteDelegate</c> to do it, in this way.
            
             <code lang="C#">
             using (var input = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ))
             {
                 using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
                 {
                     zip.AddEntry(zipEntryName, (name,output) =&gt;
                         {
                             byte[] buffer = new byte[BufferSize];
                             int n;
                             while ((n = input.Read(buffer, 0, buffer.Length)) != 0)
                             {
                                 // could transform the data here...
                                 output.Write(buffer, 0, n);
                                 // could update a progress bar here
                             }
                         });
            
                     zip.Save(zipFileName);
                 }
             }
             </code></example>
            <example>
            
             This example uses a named delegate in VB to write data for the given
             ZipEntry (VB9 does not have anonymous delegates). The example here is a bit
             contrived - a simpler way to add the contents of a file to a ZipEntry is to
             simply use the appropriate <c>AddFile()</c> method.  The key scenario for
             which the <c>WriteDelegate</c> makes sense is saving a DataSet, in XML
             format, to the zip file. The DataSet can write XML to a stream, and the
             WriteDelegate is the perfect place to write into the zip file.  There may be
             other data structures that can write to a stream, but cannot be read as a
             stream.  The <c>WriteDelegate</c> would be appropriate for those cases as
             well.
            
             <code lang="VB">
             Private Sub WriteEntry (ByVal name As String, ByVal output As Stream)
                 Using input As FileStream = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                     Dim n As Integer = -1
                     Dim buffer As Byte() = New Byte(BufferSize){}
                     Do While n &lt;&gt; 0
                         n = input.Read(buffer, 0, buffer.Length)
                         output.Write(buffer, 0, n)
                     Loop
                 End Using
             End Sub
            
             Public Sub Run()
                 Using zip = New ZipFile
                     zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
                     zip.Save(zipFileName)
                 End Using
             End Sub
             </code></example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)">
            <summary>
               Add an entry, for which the application will provide a stream
               containing the entry data, on a just-in-time basis.
             </summary>
            <remarks>
                <para>
               In cases where the application wishes to open the stream that
               holds the content for the ZipEntry, on a just-in-time basis, the
               application can use this method.  The application provides an
               opener delegate that will be called by the DotNetZip library to
               obtain a readable stream that can be read to get the bytes for
               the given entry.  Typically, this delegate opens a stream.
               Optionally, the application can provide a closer delegate as
               well, which will be called by DotNetZip when all bytes have been
               read from the entry.
             </para>
                <para>
               These delegates are called from within the scope of the call to
               ZipFile.Save().
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <example>
            
               This example uses anonymous methods in C# to open and close the
               source stream for the content for a zip entry.
            
             <code lang="C#">
             using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
             {
                 zip.AddEntry(zipEntryName,
                              (name) =&gt;  File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ),
                              (name, stream) =&gt;  stream.Close()
                              );
            
                 zip.Save(zipFileName);
             }
             </code></example>
            <example>
            
               This example uses delegates in VB.NET to open and close the
               the source stream for the content for a zip entry.  VB 9.0 lacks
               support for "Sub" lambda expressions, and so the CloseDelegate must
               be an actual, named Sub.
            
             <code lang="VB">
            
             Function MyStreamOpener(ByVal entryName As String) As Stream
                 '' This simply opens a file.  You probably want to do somethinig
                 '' more involved here: open a stream to read from a database,
                 '' open a stream on an HTTP connection, and so on.
                 Return File.OpenRead(entryName)
             End Function
            
             Sub MyStreamCloser(entryName As String, stream As Stream)
                 stream.Close()
             End Sub
            
             Public Sub Run()
                 Dim dirToZip As String = "fodder"
                 Dim zipFileToCreate As String = "Archive.zip"
                 Dim opener As OpenDelegate = AddressOf MyStreamOpener
                 Dim closer As CloseDelegate = AddressOf MyStreamCloser
                 Dim numFilestoAdd As Int32 = 4
                 Using zip As ZipFile = New ZipFile
                     Dim i As Integer
                     For i = 0 To numFilesToAdd - 1
                         zip.AddEntry(String.Format("content-{0:000}.txt"), opener, closer)
                     Next i
                     zip.Save(zipFileToCreate)
                 End Using
             End Sub
            
             </code></example>
            <param name="entryName">the name of the entry to add</param>
            <param name="opener">
              the delegate that will be invoked by ZipFile.Save() to get the
              readable stream for the given entry. ZipFile.Save() will call
              read on this stream to obtain the data for the entry. This data
              will then be compressed and written to the newly created zip
              file.
             </param>
            <param name="closer">
              the delegate that will be invoked to close the stream. This may
              be null (Nothing in VB), in which case no call is makde to close
              the stream.
             </param>
            <returns>the ZipEntry added</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String)">
            <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given
               string as content for the <c>ZipEntry</c>.
             </summary>
            <remarks>
                <para>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for
               the given file name and directory path, if it exists, and then calling
               <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)" />.  See the documentation for
               that method for further explanation. The string content is encoded
               using the default encoding for the machine, or on Silverlight, using
               UTF-8. This encoding is distinct from the encoding used for the
               filename itself.  See <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />.
             </para>
            </remarks>
            <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.Text.Encoding)">
            <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given string as
               content for the <c>ZipEntry</c>.
             </summary>
            <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            <param name="encoding">
               The text encoding to use when encoding the string. Be aware: This is
               distinct from the text encoding used to encode the filename. See <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />.
             </param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,Ionic.Zip.WriteDelegate)">
            <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given delegate
               as the source for content for the <c>ZipEntry</c>.
             </summary>
            <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            <param name="writer">the delegate which will write the entry content.</param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)">
            <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given delegates
               to open and close the stream that provides the content for the <c>ZipEntry</c>.
             </summary>
            <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            <param name="opener">
              the delegate that will be invoked to open the stream
             </param>
            <param name="closer">
              the delegate that will be invoked to close the stream
             </param>
            <returns>The <c>ZipEntry</c> added or updated.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)">
            <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given stream as
               input, and the given filename and given directory Path.
             </summary>
            <remarks>
                <para>
               Calling the method is equivalent to calling <c>RemoveEntry()</c> if an
               entry by the same name already exists, and then calling <c>AddEntry()</c>
               with the given <c>fileName</c> and stream.
             </para>
                <para>
               The stream must be open and readable during the call to
               <c>ZipFile.Save</c>.  You can dispense the stream on a just-in-time basis
               using the <see cref="P:Ionic.Zip.ZipEntry.InputStream" /> property. Check the
               documentation of that property for more information.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)" />
            <seealso cref="P:Ionic.Zip.ZipEntry.InputStream" />
            <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            <param name="stream">The input stream from which to read file data.</param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])">
            <summary>
               Add an entry into the zip archive using the given filename and
               directory path within the archive, and the given content for the
               file. No file is created in the filesystem.
             </summary>
            <param name="byteContent">The data to use for the entry.</param>
            <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.Byte[])">
            <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given byte
               array as content for the entry.
             </summary>
            <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c>
               for the given filename and directory path, if it exists, and then
               calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])" />.  See the
               documentation for that method for further explanation.
             </remarks>
            <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            <param name="byteContent">The content to use for the <c>ZipEntry</c>.</param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String)">
            <summary>
               Adds the contents of a filesystem directory to a Zip file archive.
             </summary>
            <remarks>
                <para>
               The name of the directory may be a relative path or a fully-qualified
               path. Any files within the named directory are added to the archive.  Any
               subdirectories within the named directory are also added to the archive,
               recursively.
             </para>
                <para>
               Top-level entries in the named directory will appear as top-level entries
               in the zip archive.  Entries in subdirectories in the named directory will
               result in entries in subdirectories in the zip archive.
             </para>
                <para>
               If you want the entries to appear in a containing directory in the zip
               archive itself, then you should call the AddDirectory() overload that
               allows you to explicitly specify a directory path for use in the archive.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
            <overloads>This method has 2 overloads.</overloads>
            <param name="directoryName">The name of the directory to add.</param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)">
            <summary>
               Adds the contents of a filesystem directory to a Zip file archive,
               overriding the path to be used for entries in the archive.
             </summary>
            <remarks>
                <para>
               The name of the directory may be a relative path or a fully-qualified
               path. The add operation is recursive, so that any files or subdirectories
               within the name directory are also added to the archive.
             </para>
                <para>
               Top-level entries in the named directory will appear as top-level entries
               in the zip archive.  Entries in subdirectories in the named directory will
               result in entries in subdirectories in the zip archive.
             </para>
                <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.SetCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            </remarks>
            <example>
                <para>
               In this code, calling the ZipUp() method with a value of "c:\reports" for
               the directory parameter will result in a zip file structure in which all
               entries are contained in a toplevel "reports" directory.
             </para>
                <code lang="C#">
             public void ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile())
               {
                 zip.AddDirectory(directory, System.IO.Path.GetFileName(directory));
                 zip.Save(targetZip);
               }
             }
             </code>
            </example>
            <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
            <param name="directoryName">The name of the directory to add.</param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               DirectoryName.  This path may, or may not, correspond to a real directory
               in the current filesystem.  If the zip is later extracted, this is the
               path used for the extracted file or directory.  Passing <c>null</c>
               (<c>Nothing</c> in VB) or the empty string ("") will insert the items at
               the root path within the archive.
             </param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectoryByName(System.String)">
            <summary>
               Creates a directory in the zip archive.
             </summary>
            <remarks>
                <para>
               Use this when you want to create a directory in the archive but there is
               no corresponding filesystem representation for that directory.
             </para>
                <para>
               You will probably not need to do this in your code. One of the only times
               you will want to do this is if you want an empty directory in the zip
               archive.  The reason: if you add a file to a zip archive that is stored
               within a multi-level directory, all of the directory tree is implicitly
               created in the zip archive.
             </para>
            </remarks>
            <param name="directoryNameInArchive">
               The name of the directory to create in the archive.
             </param>
            <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.CheckZip(System.String)">
            <summary>
               Checks a zip file to see if its directory is consistent.
             </summary>
            <remarks>
                <para>
               In cases of data error, the directory within a zip file can get out
               of synch with the entries in the zip file.  This method checks the
               given zip file and returns true if this has occurred.
             </para>
                <para> This method may take a long time to run for large zip files.  </para>
                <para>
               This method is not supported in the Reduced or Compact Framework
               versions of DotNetZip.
             </para>
                <para>
               Developers using COM can use the <see cref="M:Ionic.Zip.ComHelper.CheckZip(System.String)">ComHelper.CheckZip(String)</see>
               method.
             </para>
            </remarks>
            <param name="zipFileName">The filename to of the zip file to check.</param>
            <returns>true if the named zip file checks OK. Otherwise, false. </returns>
            <seealso cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)">
            <summary>
               Checks a zip file to see if its directory is consistent,
               and optionally fixes the directory if necessary.
             </summary>
            <remarks>
                <para>
               In cases of data error, the directory within a zip file can get out of
               synch with the entries in the zip file.  This method checks the given
               zip file, and returns true if this has occurred. It also optionally
               fixes the zipfile, saving the fixed copy in <em>Name</em>_Fixed.zip.
             </para>
                <para>
               This method may take a long time to run for large zip files.  It
               will take even longer if the file actually needs to be fixed, and if
               <c>fixIfNecessary</c> is true.
             </para>
                <para>
               This method is not supported in the Reduced or Compact
               Framework versions of DotNetZip.
             </para>
            </remarks>
            <param name="zipFileName">The filename to of the zip file to check.</param>
            <param name="fixIfNecessary">If true, the method will fix the zip file if
                 necessary.</param>
            <param name="writer">
             a TextWriter in which messages generated while checking will be written.
             </param>
            <returns>true if the named zip is OK; false if the file needs to be fixed.</returns>
            <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)">
            <summary>
               Rewrite the directory within a zipfile.
             </summary>
            <remarks>
                <para>
               In cases of data error, the directory in a zip file can get out of
               synch with the entries in the zip file.  This method attempts to fix
               the zip file if this has occurred.
             </para>
                <para> This can take a long time for large zip files. </para>
                <para> This won't work if the zip file uses a non-standard
             code page - neither IBM437 nor UTF-8. </para>
                <para>
               This method is not supported in the Reduced or Compact Framework
               versions of DotNetZip.
             </para>
                <para>
               Developers using COM can use the <see cref="M:Ionic.Zip.ComHelper.FixZipDirectory(System.String)">ComHelper.FixZipDirectory(String)</see>
               method.
             </para>
            </remarks>
            <param name="zipFileName">The filename to of the zip file to fix.</param>
            <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)" />
            <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.CheckZipPassword(System.String,System.String)">
            <summary>
               Verify the password on a zip file.
             </summary>
            <remarks>
                <para>
                 Keep in mind that passwords in zipfiles are applied to
                 zip entries, not to the entire zip file. So testing a
                 zipfile for a particular password doesn't work in the
                 general case. On the other hand, it's often the case
                 that a single password will be used on all entries in a
                 zip file. This method works for that case.
               </para>
                <para>
                 There is no way to check a password without doing the
                 decryption. So this code decrypts and extracts the given
                 zipfile into <see cref="F:System.IO.Stream.Null" /></para>
            </remarks>
            <param name="zipFileName">The filename to of the zip file to fix.</param>
            <param name="password">The password to check.</param>
            <returns>a bool indicating whether the password matches.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Info">
            <summary>
               Provides a human-readable string with information about the ZipFile.
             </summary>
            <remarks>
                <para>
                 The information string contains 10 lines or so, about each ZipEntry,
                 describing whether encryption is in use, the compressed and uncompressed
                 length of the entry, the offset of the entry, and so on. As a result the
                 information string can be very long for zip files that contain many
                 entries.
               </para>
                <para>
                 This information is mostly useful for diagnostic purposes.
               </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.FullScan">
            <summary>
             Indicates whether to perform a full scan of the zip file when reading it.
             </summary>
            <remarks>
                <para>
               You almost never want to use this property.
             </para>
                <para>
               When reading a zip file, if this flag is <c>true</c> (<c>True</c> in
               VB), the entire zip archive will be scanned and searched for entries.
               For large archives, this can take a very, long time. The much more
               efficient default behavior is to read the zip directory, which is
               stored at the end of the zip file. But, in some cases the directory is
               corrupted and you need to perform a full scan of the zip file to
               determine the contents of the zip file. This property lets you do
               that, when necessary.
             </para>
                <para>
               This flag is effective only when calling <see cref="M:Ionic.Zip.ZipFile.Initialize(System.String)" />. Normally you would read a ZipFile with the
               static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)">ZipFile.Read</see>
               method. But you can't set the <c>FullScan</c> property on the
               <c>ZipFile</c> instance when you use a static factory method like
               <c>ZipFile.Read</c>.
             </para>
            </remarks>
            <example>
            
               This example shows how to read a zip file using the full scan approach,
               and then save it, thereby producing a corrected zip file.
            
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.FullScan = true;
                 zip.Initialize(zipFileName);
                 zip.Save(newName);
             }
             </code><code lang="VB">
             Using zip As New ZipFile
                 zip.FullScan = True
                 zip.Initialize(zipFileName)
                 zip.Save(newName)
             End Using
             </code></example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.SortEntriesBeforeSaving">
            <summary>
               Whether to sort the ZipEntries before saving the file.
             </summary>
            <remarks>
               The default is false.  If you have a large number of zip entries, the sort
               alone can consume significant time.
             </remarks>
            <example>
                <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddFiles(filesToAdd);
                 zip.SortEntriesBeforeSaving = true;
                 zip.Save(name);
             }
             </code>
                <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFiles(filesToAdd)
                 zip.SortEntriesBeforeSaving = True
                 zip.Save(name)
             End Using
             </code>
            </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.AddDirectoryWillTraverseReparsePoints">
            <summary>
               Indicates whether NTFS Reparse Points, like junctions, should be
               traversed during calls to <c>AddDirectory()</c>.
             </summary>
            <remarks>
               By default, calls to AddDirectory() will traverse NTFS reparse
               points, like mounted volumes, and directory junctions.  An example
               of a junction is the "My Music" directory in Windows Vista.  In some
               cases you may not want DotNetZip to traverse those directories.  In
               that case, set this property to false.
             </remarks>
            <example>
                <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddDirectoryWillTraverseReparsePoints = false;
                 zip.AddDirectory(dirToZip,"fodder");
                 zip.Save(zipFileToCreate);
             }
             </code>
            </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.BufferSize">
            <summary>
               Size of the IO buffer used while saving.
             </summary>
            <remarks>
                <para>
               First, let me say that you really don't need to bother with this.  It is
               here to allow for optimizations that you probably won't make! It will work
               fine if you don't set or get this property at all. Ok?
             </para>
                <para>
               Now that we have <em>that</em> out of the way, the fine print: This
               property affects the size of the buffer that is used for I/O for each
               entry contained in the zip file. When a file is read in to be compressed,
               it uses a buffer given by the size here.  When you update a zip file, the
               data for unmodified entries is copied from the first zip file to the
               other, through a buffer given by the size here.
             </para>
                <para>
               Changing the buffer size affects a few things: first, for larger buffer
               sizes, the memory used by the <c>ZipFile</c>, obviously, will be larger
               during I/O operations.  This may make operations faster for very much
               larger files.  Last, for any given entry, when you use a larger buffer
               there will be fewer progress events during I/O operations, because there's
               one progress event generated for each time the buffer is filled and then
               emptied.
             </para>
                <para>
               The default buffer size is 8k.  Increasing the buffer size may speed
               things up as you compress larger files.  But there are no hard-and-fast
               rules here, eh?  You won't know til you test it.  And there will be a
               limit where ever larger buffers actually slow things down.  So as I said
               in the beginning, it's probably best if you don't set or get this property
               at all.
             </para>
            </remarks>
            <example>
             This example shows how you might set a large buffer size for efficiency when
             dealing with zip entries that are larger than 1gb.
             <code lang="C#">
             using (ZipFile zip = new ZipFile())
             {
                 zip.SaveProgress += this.zip1_SaveProgress;
                 zip.AddDirectory(directoryToZip, "");
                 zip.UseZip64WhenSaving = Zip64Option.Always;
                 zip.BufferSize = 65536*8; // 65536 * 8 = 512k
                 zip.Save(ZipFileToCreate);
             }
             </code></example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CodecBufferSize">
            <summary>
               Size of the work buffer to use for the ZLIB codec during compression.
             </summary>
            <remarks>
                <para>
                 When doing ZLIB or Deflate compression, the library fills a buffer,
                 then passes it to the compressor for compression. Then the library
                 reads out the compressed bytes. This happens repeatedly until there
                 is no more uncompressed data to compress. This property sets the
                 size of the buffer that will be used for chunk-wise compression. In
                 order for the setting to take effect, your application needs to set
                 this property before calling one of the <c>ZipFile.Save()</c>
                 overloads.
               </para>
                <para>
                 Setting this affects the performance and memory efficiency of
                 compression and decompression. For larger files, setting this to a
                 larger size may improve compression performance, but the exact
                 numbers vary depending on available memory, the size of the streams
                 you are compressing, and a bunch of other variables. I don't have
                 good firm recommendations on how to set it.  You'll have to test it
                 yourself. Or just leave it alone and accept the default.
               </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.FlattenFoldersOnExtract">
            <summary>
               Indicates whether extracted files should keep their paths as
               stored in the zip archive.
             </summary>
            <remarks>
                <para>
                This property affects Extraction.  It is not used when creating zip
                archives.
              </para>
                <para>
                With this property set to <c>false</c>, the default, extracting entries
                from a zip file will create files in the filesystem that have the full
                path associated to the entry within the zip file.  With this property set
                to <c>true</c>, extracting entries from the zip file results in files
                with no path: the folders are "flattened."
              </para>
                <para>
                An example: suppose the zip file contains entries /directory1/file1.txt and
                /directory2/file2.txt.  With <c>FlattenFoldersOnExtract</c> set to false,
                the files created will be \directory1\file1.txt and \directory2\file2.txt.
                With the property set to true, the files created are file1.txt and file2.txt.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Strategy">
            <summary>
               The compression strategy to use for all entries.
             </summary>
            <remarks>
               Set the Strategy used by the ZLIB-compatible compressor, when
               compressing entries using the DEFLATE method. Different compression
               strategies work better on different sorts of data. The strategy
               parameter can affect the compression ratio and the speed of
               compression but not the correctness of the compresssion.  For more
               information see <see cref="T:Ionic.Zlib.CompressionStrategy">Ionic.Zlib.CompressionStrategy</see>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Name">
            <summary>
               The name of the <c>ZipFile</c>, on disk.
             </summary>
            <remarks>
                <para>
               When the <c>ZipFile</c> instance was created by reading an archive using
               one of the <c>ZipFile.Read</c> methods, this property represents the name
               of the zip file that was read.  When the <c>ZipFile</c> instance was
               created by using the no-argument constructor, this value is <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
                <para>
               If you use the no-argument constructor, and you then explicitly set this
               property, when you call <see cref="M:Ionic.Zip.ZipFile.Save" />, this name will
               specify the name of the zip file created.  Doing so is equivalent to
               calling <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" />.  When instantiating a
               <c>ZipFile</c> by reading from a stream or byte array, the <c>Name</c>
               property remains <c>null</c>.  When saving to a stream, the <c>Name</c>
               property is implicitly set to <c>null</c>.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CompressionLevel">
            <summary>
               Sets the compression level to be used for entries subsequently added to
               the zip archive.
             </summary>
            <remarks>
                <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
                <para>
                As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.Encryption" />, and <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>CompressionLevel</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry" /> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified compression level.
              </para>
                <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CompressionMethod">
            <summary>
              The compression method for the zipfile.
            </summary>
            <remarks>
                <para>
                By default, the compression method is <c>CompressionMethod.Deflate.</c></para>
            </remarks>
            <seealso cref="T:Ionic.Zip.CompressionMethod" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.Comment">
            <summary>
               A comment attached to the zip archive.
             </summary>
            <remarks>
                <para>
               This property is read/write. It allows the application to specify a
               comment for the <c>ZipFile</c>, or read the comment for the
               <c>ZipFile</c>.  After setting this property, changes are only made
               permanent when you call a <c>Save()</c> method.
             </para>
                <para>
               According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see>, the comment is not encrypted, even if there is a
               password set on the zip file.
             </para>
                <para>
               The specification does not describe how to indicate the encoding used
               on a comment string. Many "compliant" zip tools and libraries use
               IBM437 as the code page for comments; DotNetZip, too, follows that
               practice.  On the other hand, there are situations where you want a
               Comment to be encoded with something else, for example using code page
               950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
               comment following the same procedure it follows for encoding
               filenames: (a) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" /> is
               <c>Never</c>, it uses the default encoding (IBM437). (b) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" /> is <c>Always</c>, it always uses the
               alternate encoding (<see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />). (c) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" /> is <c>AsNecessary</c>, it uses the
               alternate encoding only if the default encoding is not sufficient for
               encoding the comment - in other words if decoding the result does not
               produce the original string.  This decision is taken at the time of
               the call to <c>ZipFile.Save()</c>.
             </para>
                <para>
               When creating a zip archive using this library, it is possible to change
               the value of <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" /> between each
               entry you add, and between adding entries and the call to
               <c>Save()</c>. Don't do this.  It will likely result in a zip file that is
               not readable by any tool or application.  For best interoperability, leave
               <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" /> alone, or specify it only
               once, before adding any entries to the <c>ZipFile</c> instance.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">
            <summary>
               Specifies whether the Creation, Access, and Modified times for entries
               added to the zip file will be emitted in Windows format
               when the zip archive is saved.
             </summary>
            <remarks>
                <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entries should or should not be stored
               in the zip archive in the format used by Windows. By default this flag is
               <c>true</c>, meaning the Windows-format times are stored in the zip
               archive.
             </para>
                <para>
               When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime" />), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />), and Modified (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />) times for the given entry are
               automatically set from the filesystem values. When adding an entry from a
               stream or string, all three values are implicitly set to
               <c>DateTime.Now</c>.  Applications can also explicitly set those times by
               calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
             </para>
                <para>
                    <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since January 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since January 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455, although you probably don't need to know that.
             </para>
                <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe <see href="http://www.info-zip.org/">the Infozip
               tools</see> can read the Unix format timestamps. Some tools and libraries
               may be able to read only one or the other. DotNetZip can read or write
               times in either or both formats.
             </para>
                <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime" />.
             </para>
                <para>
               The value set here applies to all entries subsequently added to the
               <c>ZipFile</c>.
             </para>
                <para>
               This property is not mutually exclusive of the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving" /> property. It is possible and
               legal and valid to produce a zip file that contains timestamps encoded in
               the Unix format as well as in the Windows format, in addition to the <see cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
               entry in the archive, a time that is always stored in "DOS format". And,
               notwithstanding the names PKWare uses for these time formats, any of them
               can be read and written by any computer, on any operating system.  But,
               there are no guarantees that a program running on Mac or Linux will
               gracefully handle a zip file with "Windows" formatted times, or that an
               application that does not use DotNetZip but runs on Windows will be able to
               handle file times in Unix format.
             </para>
                <para>
               When in doubt, test.  Sorry, I haven't got a complete list of tools and
               which sort of timestamps they can use and will tolerate.  If you get any
               good information and would like to pass it on, please do so and I will
               include that information in this documentation.
             </para>
            </remarks>
            <example>
               This example shows how to save a zip file that contains file timestamps
               in a format normally used by Unix.
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 // produce a zip file the Mac will like
                 zip.EmitTimesInWindowsFormatWhenSaving = false;
                 zip.EmitTimesInUnixFormatWhenSaving = true;
                 zip.AddDirectory(directoryToZip, "files");
                 zip.Save(outputFile);
             }
             </code><code lang="VB">
             Using zip As New ZipFile
                 '' produce a zip file the Mac will like
                 zip.EmitTimesInWindowsFormatWhenSaving = False
                 zip.EmitTimesInUnixFormatWhenSaving = True
                 zip.AddDirectory(directoryToZip, "files")
                 zip.Save(outputFile)
             End Using
             </code></example>
            <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
            <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">
            <summary>
             Specifies whether the Creation, Access, and Modified times
             for entries added to the zip file will be emitted in "Unix(tm)
             format" when the zip archive is saved.
             </summary>
            <remarks>
                <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entries should or should not be stored
               in the zip archive in the format used by Unix. By default this flag is
               <c>false</c>, meaning the Unix-format times are not stored in the zip
               archive.
             </para>
                <para>
               When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime" />), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />), and Modified (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />) times for the given entry are
               automatically set from the filesystem values. When adding an entry from a
               stream or string, all three values are implicitly set to DateTime.Now.
               Applications can also explicitly set those times by calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
             </para>
                <para>
                    <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since January 1, 1601 UTC.  The other is a format Unix applications
               typically use: seconds since January 1, 1970 UTC.  Each format can be
               stored in an "extra field" in the zip entry when saving the zip
               archive. The former uses an extra field with a Header Id of 0x000A, while
               the latter uses a header ID of 0x5455, although you probably don't need to
               know that.
             </para>
                <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Some tools and libraries may be
               able to read only one or the other.  DotNetZip can read or write times in
               either or both formats.
             </para>
                <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime" />.
             </para>
                <para>
               This property is not mutually exclusive of the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving" /> property. It is possible and
               legal and valid to produce a zip file that contains timestamps encoded in
               the Unix format as well as in the Windows format, in addition to the <see cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
               entry in the zip archive, a time that is always stored in "DOS
               format". And, notwithstanding the names PKWare uses for these time
               formats, any of them can be read and written by any computer, on any
               operating system.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle a zip file with "Windows" formatted
               times, or that an application that does not use DotNetZip but runs on
               Windows will be able to handle file times in Unix format.
             </para>
                <para>
               When in doubt, test.  Sorry, I haven't got a complete list of tools and
               which sort of timestamps they can use and will tolerate.  If you get any
               good information and would like to pass it on, please do so and I will
               include that information in this documentation.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
            <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.Verbose">
            <summary>
               Indicates whether verbose output is sent to the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" /> during <c>AddXxx()</c> and
               <c>ReadXxx()</c> operations.
             </summary>
            <remarks>
               This is a <em>synthetic</em> property.  It returns true if the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" /> is non-null.
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ContainsEntry(System.String)">
            <summary>
               Returns true if an entry by the given name exists in the ZipFile.
             </summary>
            <param name="name">the name of the entry to find</param>
            <returns>true if an entry with the given name exists; otherwise false.
             </returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval">
            <summary>
               Indicates whether to perform case-sensitive matching on the filename when
               retrieving entries in the zipfile via the string-based indexer.
             </summary>
            <remarks>
               The default value is <c>false</c>, which means don't do case-sensitive
               matching. In other words, retrieving zip["ReadMe.Txt"] is the same as
               zip["readme.txt"].  It really makes sense to set this to <c>true</c> only
               if you are not running on Windows, which has case-insensitive
               filenames. But since this library is not built for non-Windows platforms,
               in most cases you should just leave this property alone.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.IgnoreDuplicateFiles">
            <summary>
              Indicates whether to ignore duplicate files (report only the first entry)
              when loading a zipfile.
            </summary>
            <remarks>
              The default value is <c>false</c>, which will try to make all files
              available (duplicates will have a "copy" suffix appended to their name).
              Setting this to <c>true</c> prior to using <c>Initialize</c> to read a
              zipfile will prevent this and instead just ignore the duplicates.
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.UseUnicodeAsNecessary">
            <summary>
               Indicates whether to encode entry filenames and entry comments using Unicode
               (UTF-8).
             </summary>
            <remarks>
                <para>
                    <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               PKWare zip specification</see> provides for encoding file names and file
               comments in either the IBM437 code page, or in UTF-8.  This flag selects
               the encoding according to that specification.  By default, this flag is
               false, and filenames and comments are encoded into the zip file in the
               IBM437 codepage.  Setting this flag to true will specify that filenames
               and comments that cannot be encoded with IBM437 will be encoded with
               UTF-8.
             </para>
                <para>
               Zip files created with strict adherence to the PKWare specification with
               respect to UTF-8 encoding can contain entries with filenames containing
               any combination of Unicode characters, including the full range of
               characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
               alphabets.  However, because at this time, the UTF-8 portion of the PKWare
               specification is not broadly supported by other zip libraries and
               utilities, such zip files may not be readable by your favorite zip tool or
               archiver. In other words, interoperability will decrease if you set this
               flag to true.
             </para>
                <para>
               In particular, Zip files created with strict adherence to the PKWare
               specification with respect to UTF-8 encoding will not work well with
               Explorer in Windows XP or Windows Vista, because Windows compressed
               folders, as far as I know, do not support UTF-8 in zip files.  Vista can
               read the zip files, but shows the filenames incorrectly. Unpacking from
               Windows Vista Explorer will result in filenames that have rubbish
               characters in place of the high-order UTF-8 bytes.
             </para>
                <para>
               Also, zip files that use UTF-8 encoding will not work well with Java
               applications that use the java.util.zip classes, as of v5.0 of the Java
               runtime. The Java runtime does not correctly implement the PKWare
               specification in this regard.
             </para>
                <para>
               As a result, we have the unfortunate situation that "correct" behavior by
               the DotNetZip library with regard to Unicode encoding of filenames during
               zip creation will result in zip files that are readable by strictly
               compliant and current tools (for example the most recent release of the
               commercial WinZip tool); but these zip files will not be readable by
               various other tools or libraries, including Windows Explorer.
             </para>
                <para>
               The DotNetZip library can read and write zip files with UTF8-encoded
               entries, according to the PKware spec.  If you use DotNetZip for both
               creating and reading the zip file, and you use UTF-8, there will be no
               loss of information in the filenames. For example, using a self-extractor
               created by this library will allow you to unpack files correctly with no
               loss of information in the filenames.
             </para>
                <para>
               If you do not set this flag, it will remain false.  If this flag is false,
               your <c>ZipFile</c> will encode all filenames and comments using the
               IBM437 codepage.  This can cause "loss of information" on some filenames,
               but the resulting zipfile will be more interoperable with other
               utilities. As an example of the loss of information, diacritics can be
               lost.  The o-tilde character will be down-coded to plain o.  The c with a
               cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
               Likewise, the O-stroke character (Unicode 248), used in Danish and
               Norwegian, will be down-coded to plain o. Chinese characters cannot be
               represented in codepage IBM437; when using the default encoding, Chinese
               characters in filenames will be represented as ?. These are all examples
               of "information loss".
             </para>
                <para>
               The loss of information associated to the use of the IBM437 encoding is
               inconvenient, and can also lead to runtime errors. For example, using
               IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
               your application creates a <c>ZipFile</c>, then adds two files, each with
               names of four Chinese characters each, this will result in a duplicate
               filename exception.  In the case where you add a single file with a name
               containing four Chinese characters, calling Extract() on the entry that
               has question marks in the filename will result in an exception, because
               the question mark is not legal for use within filenames on Windows.  These
               are just a few examples of the problems associated to loss of information.
             </para>
                <para>
               This flag is independent of the encoding of the content within the entries
               in the zip file. Think of the zip file as a container - it supports an
               encoding.  Within the container are other "containers" - the file entries
               themselves.  The encoding within those entries is independent of the
               encoding of the zip archive container for those entries.
             </para>
                <para>
               Rather than specify the encoding in a binary fashion using this flag, an
               application can specify an arbitrary encoding via the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property.  Setting the encoding
               explicitly when creating zip archives will result in non-compliant zip
               files that, curiously, are fairly interoperable.  The challenge is, the
               PKWare specification does not provide for a way to specify that an entry
               in a zip archive uses a code page that is neither IBM437 nor UTF-8.
               Therefore if you set the encoding explicitly when creating a zip archive,
               you must take care upon reading the zip archive to use the same code page.
               If you get it wrong, the behavior is undefined and may result in incorrect
               filenames, exceptions, stomach upset, hair loss, and acne.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.UseZip64WhenSaving">
            <summary>
               Specify whether to use ZIP64 extensions when saving a zip archive.
             </summary>
            <remarks>
                <para>
               When creating a zip file, the default value for the property is <see cref="F:Ionic.Zip.Zip64Option.Never" />. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> is
               safest, in the sense that you will not get an Exception if a pre-ZIP64
               limit is exceeded.
             </para>
                <para>
               You may set the property at any time before calling Save().
             </para>
                <para>
               When reading a zip file via the <c>Zipfile.Read()</c> method, DotNetZip
               will properly read ZIP64-endowed zip archives, regardless of the value of
               this property.  DotNetZip will always read ZIP64 archives.  This property
               governs only whether DotNetZip will write them. Therefore, when updating
               archives, be careful about setting this property after reading an archive
               that may use ZIP64 extensions.
             </para>
                <para>
               An interesting question is, if you have set this property to
               <c>AsNecessary</c>, and then successfully saved, does the resulting
               archive use ZIP64 extensions or not?  To learn this, check the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64" /> property, after calling <c>Save()</c>.
             </para>
                <para>
               Have you thought about
               <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">donating</see>?
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.RequiresZip64">
            <summary>
               Indicates whether the archive requires ZIP64 extensions.
             </summary>
            <remarks>
                <para>
               This property is <c>null</c> (or <c>Nothing</c> in VB) if the archive has
               not been saved, and there are fewer than 65334 <c>ZipEntry</c> items
               contained in the archive.
             </para>
                <para>
               The <c>Value</c> is true if any of the following four conditions holds:
               the uncompressed size of any entry is larger than 0xFFFFFFFF; the
               compressed size of any entry is larger than 0xFFFFFFFF; the relative
               offset of any entry within the zip archive is larger than 0xFFFFFFFF; or
               there are more than 65534 entries in the archive.  (0xFFFFFFFF =
               4,294,967,295).  The result may not be known until a <c>Save()</c> is attempted
               on the zip archive.  The Value of this <see cref="T:System.Nullable" />
               property may be set only AFTER one of the Save() methods has been called.
             </para>
                <para>
               If none of the four conditions holds, and the archive has been saved, then
               the <c>Value</c> is false.
             </para>
                <para>
               A <c>Value</c> of false does not indicate that the zip archive, as saved,
               does not use ZIP64.  It merely indicates that ZIP64 is not required.  An
               archive may use ZIP64 even when not required if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property is set to <see cref="F:Ionic.Zip.Zip64Option.Always" />, or if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> and the output stream was not
               seekable. Use the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64" /> property to determine if
               the most recent <c>Save()</c> method resulted in an archive that utilized
               the ZIP64 extensions.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" />
            <seealso cref="P:Ionic.Zip.ZipFile.OutputUsedZip64" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.OutputUsedZip64">
            <summary>
               Indicates whether the most recent <c>Save()</c> operation used ZIP64 extensions.
             </summary>
            <remarks>
                <para>
               The use of ZIP64 extensions within an archive is not always necessary, and
               for interoperability concerns, it may be desired to NOT use ZIP64 if
               possible.  The <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property can be
               set to use ZIP64 extensions only when necessary.  In those cases,
               Sometimes applications want to know whether a Save() actually used ZIP64
               extensions.  Applications can query this read-only property to learn
               whether ZIP64 has been used in a just-saved <c>ZipFile</c>.
             </para>
                <para>
               The value is <c>null</c> (or <c>Nothing</c> in VB) if the archive has not
               been saved.
             </para>
                <para>
               Non-null values (<c>HasValue</c> is true) indicate whether ZIP64
               extensions were used during the most recent <c>Save()</c> operation.  The
               ZIP64 extensions may have been used as required by any particular entry
               because of its uncompressed or compressed size, or because the archive is
               larger than 4294967295 bytes, or because there are more than 65534 entries
               in the archive, or because the <c>UseZip64WhenSaving</c> property was set
               to <see cref="F:Ionic.Zip.Zip64Option.Always" />, or because the
               <c>UseZip64WhenSaving</c> property was set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> and the output stream was not seekable.
               The value of this property does not indicate the reason the ZIP64
               extensions were used.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" />
            <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.InputUsesZip64">
            <summary>
               Indicates whether the most recent <c>Read()</c> operation read a zip file that uses
               ZIP64 extensions.
             </summary>
            <remarks>
               This property will return null (Nothing in VB) if you've added an entry after reading
               the zip file.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">
            <summary>
               The text encoding to use when writing new entries to the <c>ZipFile</c>,
               for those entries that cannot be encoded with the default (IBM437)
               encoding; or, the text encoding that was used when reading the entries
               from the <c>ZipFile</c>.
             </summary>
            <remarks>
                <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
                <para>
               When using DotNetZip to write zip archives that will be read by one of
               these other archivers, set this property to specify the code page to use
               when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName" /> and <see cref="P:Ionic.Zip.ZipEntry.Comment" /> for each <c>ZipEntry</c> in the zip file, for
               values that cannot be encoded with the default codepage for zip files,
               IBM437.  This is why this property is "provisional".  In all cases, IBM437
               is used where possible, in other words, where no loss of data would
               result. It is possible, therefore, to have a given entry with a
               <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
               specified "provisional" codepage.
             </para>
                <para>
               Be aware that a zip file created after you've explicitly set the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property to a value other than
               IBM437 may not be compliant to the PKWare specification, and may not be
               readable by compliant archivers.  On the other hand, many (most?)
               archivers are non-compliant and can read zip files created in arbitrary
               code pages.  The trick is to use or specify the proper codepage when
               reading the zip.
             </para>
                <para>
               When creating a zip archive using this library, it is possible to change
               the value of <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> between each
               entry you add, and between adding entries and the call to
               <c>Save()</c>. Don't do this. It will likely result in a zipfile that is
               not readable.  For best interoperability, either leave <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> alone, or specify it only once,
               before adding any entries to the <c>ZipFile</c> instance.  There is one
               exception to this recommendation, described later.
             </para>
                <para>
               When using an arbitrary, non-UTF8 code page for encoding, there is no
               standard way for the creator application - whether DotNetZip, WinZip,
               WinRar, or something else - to formally specify in the zip file which
               codepage has been used for the entries. As a result, readers of zip files
               are not able to inspect the zip file and determine the codepage that was
               used for the entries contained within it.  It is left to the application
               or user to determine the necessary codepage when reading zip files encoded
               this way.  In other words, if you explicitly specify the codepage when you
               create the zipfile, you must explicitly specify the same codepage when
               reading the zipfile.
             </para>
                <para>
               The way you specify the code page to use when reading a zip file varies
               depending on the tool or library you use to read the zip.  In DotNetZip,
               you use a ZipFile.Read() method that accepts an encoding parameter.  It
               isn't possible with Windows Explorer, as far as I know, to specify an
               explicit codepage to use when reading a zip.  If you use an incorrect
               codepage when reading a zipfile, you will get entries with filenames that
               are incorrect, and the incorrect filenames may even contain characters
               that are not legal for use within filenames in Windows. Extracting entries
               with illegal characters in the filenames will lead to exceptions. It's too
               bad, but this is just the way things are with code pages in zip
               files. Caveat Emptor.
             </para>
                <para>
               Example: Suppose you create a zipfile that contains entries with
               filenames that have Danish characters.  If you use <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> equal to "iso-8859-1" (cp 28591),
               the filenames will be correctly encoded in the zip.  But, to read that
               zipfile correctly, you have to specify the same codepage at the time you
               read it. If try to read that zip file with Windows Explorer or another
               application that is not flexible with respect to the codepage used to
               decode filenames in zipfiles, you will get a filename like "Inf°.txt".
             </para>
                <para>
               When using DotNetZip to read a zip archive, and the zip archive uses an
               arbitrary code page, you must specify the encoding to use before or when
               the <c>Zipfile</c> is READ.  This means you must use a <c>ZipFile.Read()</c>
               method that allows you to specify a System.Text.Encoding parameter.  Setting
               the ProvisionalAlternateEncoding property after your application has read in
               the zip archive will not affect the entry names of entries that have already
               been read in.
             </para>
                <para>
               And now, the exception to the rule described above.  One strategy for
               specifying the code page for a given zip file is to describe the code page
               in a human-readable form in the Zip comment. For example, the comment may
               read "Entries in this archive are encoded in the Big5 code page".  For
               maximum interoperability, the zip comment in this case should be encoded
               in the default, IBM437 code page.  In this case, the zip comment is
               encoded using a different page than the filenames.  To do this, Specify
               <c>ProvisionalAlternateEncoding</c> to your desired region-specific code
               page, once before adding any entries, and then reset
               <c>ProvisionalAlternateEncoding</c> to IBM437 before setting the <see cref="P:Ionic.Zip.ZipFile.Comment" /> property and calling Save().
             </para>
            </remarks>
            <example>
             This example shows how to read a zip file using the Big-5 Chinese code page
             (950), and extract each entry in the zip file.  For this code to work as
             desired, the <c>Zipfile</c> must have been created using the big5 code page
             (CP950). This is typical, for example, when using WinRar on a machine with
             CP950 set as the default code page.  In that case, the names of entries
             within the Zip archive will be stored in that code page, and reading the zip
             archive must be done using that code page.  If the application did not use
             the correct code page in <c>ZipFile.Read()</c>, then names of entries within the
             zip archive would not be correctly retrieved.
             <code>
             using (var zip = ZipFile.Read(zipFileName, System.Text.Encoding.GetEncoding("big5")))
             {
                 // retrieve and extract an entry using a name encoded with CP950
                 zip[MyDesiredEntry].Extract("unpack");
             }
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipToExtract, System.Text.Encoding.GetEncoding("big5"))
                 ' retrieve and extract an entry using a name encoded with CP950
                 zip(MyDesiredEntry).Extract("unpack")
             End Using
             </code></example>
            <seealso cref="P:Ionic.Zip.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.AlternateEncoding">
            <summary>
              A Text Encoding to use when encoding the filenames and comments for
              all the ZipEntry items, during a ZipFile.Save() operation.
            </summary>
            <remarks>
                <para>
                Whether the encoding specified here is used during the save depends
                on <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" />.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.AlternateEncodingUsage">
            <summary>
              A flag that tells if and when this instance should apply
              AlternateEncoding to encode the filenames and comments associated to
              of ZipEntry objects contained within this instance.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipFile.StatusMessageTextWriter">
            <summary>
             Gets or sets the <c>TextWriter</c> to which status messages are delivered
             for the instance.
             </summary>
            <remarks>
               If the TextWriter is set to a non-null value, then verbose output is sent
               to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
               <c>Extract</c> operations.  Typically, console applications might use
               <c>Console.Out</c> and graphical or headless applications might use a
               <c>System.IO.StringWriter</c>. The output of this is suitable for viewing
               by humans.
             </remarks>
            <example>
                <para>
               In this example, a console application instantiates a <c>ZipFile</c>, then
               sets the <c>StatusMessageTextWriter</c> to <c>Console.Out</c>.  At that
               point, all verbose status messages for that <c>ZipFile</c> are sent to the
               console.
             </para>
                <code lang="C#">
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= System.Console.Out;
               // messages are sent to the console during extraction
               zip.ExtractAll();
             }
             </code>
                <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= System.Console.Out
               'Status Messages will be sent to the console during extraction
               zip.ExtractAll()
             End Using
             </code>
                <para>
               In this example, a Windows Forms application instantiates a
               <c>ZipFile</c>, then sets the <c>StatusMessageTextWriter</c> to a
               <c>StringWriter</c>.  At that point, all verbose status messages for that
               <c>ZipFile</c> are sent to the <c>StringWriter</c>.
             </para>
                <code lang="C#">
             var sw = new System.IO.StringWriter();
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= sw;
               zip.ExtractAll();
             }
             Console.WriteLine("{0}", sw.ToString());
             </code>
                <code lang="VB">
             Dim sw as New System.IO.StringWriter
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= sw
               zip.ExtractAll()
             End Using
             'Status Messages are now available in sw
            
             </code>
            </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.TempFileFolder">
            <summary>
               Gets or sets the name for the folder to store the temporary file
               this library writes when saving a zip archive.
             </summary>
            <remarks>
                <para>
               This library will create a temporary file when saving a Zip archive to a
               file.  This file is written when calling one of the <c>Save()</c> methods
               that does not save to a stream, or one of the <c>SaveSelfExtractor()</c>
               methods.
             </para>
                <para>
               By default, the library will create the temporary file in the directory
               specified for the file itself, via the <see cref="P:Ionic.Zip.ZipFile.Name" /> property or via
               the <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" /> method.
             </para>
                <para>
               Setting this property allows applications to override this default
               behavior, so that the library will create the temporary file in the
               specified folder. For example, to have the library create the temporary
               file in the current working directory, regardless where the <c>ZipFile</c>
               is saved, specfy ".".  To revert to the default behavior, set this
               property to <c>null</c> (<c>Nothing</c> in VB).
             </para>
                <para>
               When setting the property to a non-null value, the folder specified must
               exist; if it does not an exception is thrown.  The application should have
               write and delete permissions on the folder.  The permissions are not
               explicitly checked ahead of time; if the application does not have the
               appropriate rights, an exception will be thrown at the time <c>Save()</c>
               is called.
             </para>
                <para>
               There is no temporary file created when reading a zip archive.  When
               saving to a Stream, there is no temporary file created.  For example, if
               the application is an ASP.NET application and calls <c>Save()</c>
               specifying the <c>Response.OutputStream</c> as the output stream, there is
               no temporary file created.
             </para>
            </remarks>
            <exception cref="T:System.IO.FileNotFoundException">
             Thrown when setting the property if the directory does not exist.
             </exception>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Password">
            <summary>
             Sets the password to be used on the <c>ZipFile</c> instance.
             </summary>
            <remarks>
                <para>
               When writing a zip archive, this password is applied to the entries, not
               to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
               added to the <c>ZipFile</c>, using one of the <c>AddFile</c>,
               <c>AddDirectory</c>, <c>AddEntry</c>, or <c>AddItem</c> methods, etc.
               When reading a zip archive, this property applies to any entry
               subsequently extracted from the <c>ZipFile</c> using one of the Extract
               methods on the <c>ZipFile</c> class.
             </para>
                <para>
               When writing a zip archive, keep this in mind: though the password is set
               on the ZipFile object, according to the Zip spec, the "directory" of the
               archive - in other words the list of entries or files contained in the archive - is
               not encrypted with the password, or protected in any way.  If you set the
               Password property, the password actually applies to individual entries
               that are added to the archive, subsequent to the setting of this property.
               The list of filenames in the archive that is eventually created will
               appear in clear text, but the contents of the individual files are
               encrypted.  This is how Zip encryption works.
             </para>
                <para>
               One simple way around this limitation is to simply double-wrap sensitive
               filenames: Store the files in a zip file, and then store that zip file
               within a second, "outer" zip file.  If you apply a password to the outer
               zip file, then readers will be able to see that the outer zip file
               contains an inner zip file.  But readers will not be able to read the
               directory or file list of the inner zip file.
             </para>
                <para>
               If you set the password on the <c>ZipFile</c>, and then add a set of files
               to the archive, then each entry is encrypted with that password.  You may
               also want to change the password between adding different entries. If you
               set the password, add an entry, then set the password to <c>null</c>
               (<c>Nothing</c> in VB), and add another entry, the first entry is
               encrypted and the second is not.  If you call <c>AddFile()</c>, then set
               the <c>Password</c> property, then call <c>ZipFile.Save</c>, the file
               added will not be password-protected, and no warning will be generated.
             </para>
                <para>
               When setting the Password, you may also want to explicitly set the <see cref="P:Ionic.Zip.ZipFile.Encryption" /> property, to specify how to encrypt the entries added
               to the ZipFile.  If you set the Password to a non-null value and do not
               set <see cref="P:Ionic.Zip.ZipFile.Encryption" />, then PKZip 2.0 ("Weak") encryption is used.
               This encryption is relatively weak but is very interoperable. If you set
               the password to a <c>null</c> value (<c>Nothing</c> in VB), Encryption is
               reset to None.
             </para>
                <para>
               All of the preceding applies to writing zip archives, in other words when
               you use one of the Save methods.  To use this property when reading or an
               existing ZipFile, do the following: set the Password property on the
               <c>ZipFile</c>, then call one of the Extract() overloads on the <see cref="T:Ionic.Zip.ZipEntry" />. In this case, the entry is extracted using the
               <c>Password</c> that is specified on the <c>ZipFile</c> instance. If you
               have not set the <c>Password</c> property, then the password is
               <c>null</c>, and the entry is extracted with no password.
             </para>
                <para>
               If you set the Password property on the <c>ZipFile</c>, then call
               <c>Extract()</c> an entry that has not been encrypted with a password, the
               password is not used for that entry, and the <c>ZipEntry</c> is extracted
               as normal. In other words, the password is used only if necessary.
             </para>
                <para>
               The <see cref="T:Ionic.Zip.ZipEntry" /> class also has a <see cref="P:Ionic.Zip.ZipEntry.Password">Password</see> property.  It takes precedence
               over this property on the <c>ZipFile</c>.  Typically, you would use the
               per-entry Password when most entries in the zip archive use one password,
               and a few entries use a different password.  If all entries in the zip
               file use the same password, then it is simpler to just set this property
               on the <c>ZipFile</c> itself, whether creating a zip archive or extracting
               a zip archive.
             </para>
            </remarks>
            <example>
                <para>
               This example creates a zip file, using password protection for the
               entries, and then extracts the entries from the zip file.  When creating
               the zip file, the Readme.txt file is not protected with a password, but
               the other two are password-protected as they are saved. During extraction,
               each file is extracted with the appropriate password.
             </para>
                <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt");
                 zip.Password= "!Secret1";
                 zip.AddFile("MapToTheSite-7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
             }
            
             // extract entries that use encryption
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 zip.Password= "!Secret1";
                 zip.ExtractAll("extractDir");
             }
            
             </code>
                <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFile("ReadMe.txt")
                 zip.Password = "123456!"
                 zip.AddFile("MapToTheSite-7440-N49th.png")
                 zip.Password= "!Secret1";
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
             End Using
            
            
             ' extract entries that use encryption
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 zip.Password= "!Secret1"
                 zip.ExtractAll("extractDir")
             End Using
            
             </code>
            </example>
            <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
            <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ExtractExistingFile">
            <summary>
               The action the library should take when extracting a file that already
               exists.
             </summary>
            <remarks>
                <para>
               This property affects the behavior of the Extract methods (one of the
               <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
               extraction would would overwrite an existing filesystem file. If you do
               not set this property, the library throws an exception when extracting an
               entry would overwrite an existing file.
             </para>
                <para>
               This property has no effect when extracting to a stream, or when the file
               to be extracted does not already exist.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.ZipErrorAction">
            <summary>
               The action the library should take when an error is encountered while
               opening or reading files as they are saved into a zip archive.
             </summary>
            <remarks>
                <para>
                Errors can occur as a file is being saved to the zip archive.  For
                example, the File.Open may fail, or a File.Read may fail, because of
                lock conflicts or other reasons.
              </para>
                <para>
                The first problem might occur after having called AddDirectory() on a
                directory that contains a Clipper .dbf file; the file is locked by
                Clipper and cannot be opened for read by another process. An example of
                the second problem might occur when trying to zip a .pst file that is in
                use by Microsoft Outlook. Outlook locks a range on the file, which allows
                other processes to open the file, but not read it in its entirety.
              </para>
                <para>
                This property tells DotNetZip what you would like to do in the case of
                these errors.  The primary options are: <c>ZipErrorAction.Throw</c> to
                throw an exception (this is the default behavior if you don't set this
                property); <c>ZipErrorAction.Skip</c> to Skip the file for which there
                was an error and continue saving; <c>ZipErrorAction.Retry</c> to Retry
                the entry that caused the problem; or
                <c>ZipErrorAction.InvokeErrorEvent</c> to invoke an event handler.
              </para>
                <para>
                This property is implicitly set to <c>ZipErrorAction.InvokeErrorEvent</c>
                if you add a handler to the <see cref="E:Ionic.Zip.ZipFile.ZipError" /> event.  If you set
                this property to something other than
                <c>ZipErrorAction.InvokeErrorEvent</c>, then the <c>ZipError</c>
                event is implicitly cleared.  What it means is you can set one or the
                other (or neither), depending on what you want, but you never need to set
                both.
              </para>
                <para>
                As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.Encryption" />, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>ZipErrorAction</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry" /> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified error handling action.
              </para>
                <para>
                If you want to handle any errors that occur with any entry in the zip
                file in the same way, then set this property once, before adding any
                entries to the zip archive.
              </para>
                <para>
                If you set this property to <c>ZipErrorAction.Skip</c> and you'd like to
                learn which files may have been skipped after a <c>Save()</c>, you can
                set the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" /> on the ZipFile before
                calling <c>Save()</c>. A message will be emitted into that writer for
                each skipped file, if any.
              </para>
            </remarks>
            <example>
               This example shows how to tell DotNetZip to skip any files for which an
               error is generated during the Save().
             <code lang="VB">
             Public Sub SaveZipFile()
                 Dim SourceFolder As String = "fodder"
                 Dim DestFile As String =  "eHandler.zip"
                 Dim sw as New StringWriter
                 Using zipArchive As ZipFile = New ZipFile
                     ' Tell DotNetZip to skip any files for which it encounters an error
                     zipArchive.ZipErrorAction = ZipErrorAction.Skip
                     zipArchive.StatusMessageTextWriter = sw
                     zipArchive.AddDirectory(SourceFolder)
                     zipArchive.Save(DestFile)
                 End Using
                 ' examine sw here to see any messages
             End Sub
            
             </code></example>
            <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction" />
            <seealso cref="E:Ionic.Zip.ZipFile.ZipError" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.Encryption">
            <summary>
               The Encryption to use for entries added to the <c>ZipFile</c>.
             </summary>
            <remarks>
                <para>
               Set this when creating a zip archive, or when updating a zip archive. The
               specified Encryption is applied to the entries subsequently added to the
               <c>ZipFile</c> instance.  Applications do not need to set the
               <c>Encryption</c> property when reading or extracting a zip archive.
             </para>
                <para>
               If you set this to something other than EncryptionAlgorithm.None, you
               will also need to set the <see cref="P:Ionic.Zip.ZipFile.Password" />.
             </para>
                <para>
               As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password" /> and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" />, setting this
               property on a <c>ZipFile</c> instance will cause the specified
               <c>EncryptionAlgorithm</c> to be used on all <see cref="T:Ionic.Zip.ZipEntry" /> items
               that are subsequently added to the <c>ZipFile</c> instance. In other
               words, if you set this property after you have added items to the
               <c>ZipFile</c>, but before you have called <c>Save()</c>, those items will
               not be encrypted or protected with a password in the resulting zip
               archive. To get a zip archive with encrypted entries, set this property,
               along with the <see cref="P:Ionic.Zip.ZipFile.Password" /> property, before calling
               <c>AddFile</c>, <c>AddItem</c>, or <c>AddDirectory</c> (etc.) on the
               <c>ZipFile</c> instance.
             </para>
                <para>
               If you read a <c>ZipFile</c>, you can modify the <c>Encryption</c> on an
               encrypted entry, only by setting the <c>Encryption</c> property on the
               <c>ZipEntry</c> itself.  Setting the <c>Encryption</c> property on the
               <c>ZipFile</c>, once it has been created via a call to
               <c>ZipFile.Read()</c>, does not affect entries that were previously read.
             </para>
                <para>
               For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
               then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
               <c>Encryption</c> used for the entries in the archive.  Neither is an
               exception thrown. Instead, what happens during the <c>Save()</c> is that
               all previously existing entries are copied through to the new zip archive,
               with whatever encryption and password that was used when originally
               creating the zip archive. Upon re-reading that archive, to extract
               entries, applications should use the original password or passwords, if
               any.
             </para>
                <para>
               Suppose an application reads a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
               then adding new entries (via <c>AddFile()</c>, <c>AddEntry()</c>, etc)
               and then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
               <c>Encryption</c> on any of the entries that had previously been in the
               <c>ZipFile</c>.  The <c>Encryption</c> property applies only to the
               newly-added entries.
             </para>
            </remarks>
            <example>
                <para>
               This example creates a zip archive that uses encryption, and then extracts
               entries from the archive.  When creating the zip archive, the ReadMe.txt
               file is zipped without using a password or encryption.  The other files
               use encryption.
             </para>
                <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt");
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256;
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.AddFile("7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
             }
            
             // Extract a zip archive that uses AES Encryption.
             // You do not need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.ExtractAll("extractDirectory");
             }
             </code>
                <code lang="VB">
             ' Create a zip that uses Encryption.
             Using zip As New ZipFile()
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.AddFile("ReadMe.txt")
                 zip.AddFile("7440-N49th.png")
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
             End Using
            
             ' Extract a zip archive that uses AES Encryption.
             ' You do not need to specify the algorithm during extraction.
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.ExtractAll("extractDirectory")
             End Using
             </code>
            </example>
            <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
            <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.SetCompression">
            <summary>
               A callback that allows the application to specify the compression level
               to use for entries subsequently added to the zip archive.
             </summary>
            <remarks>
                <para>
               With this callback, the DotNetZip library allows the application to
               determine whether compression will be used, at the time of the
               <c>Save</c>. This may be useful if the application wants to favor
               speed over size, and wants to defer the decision until the time of
               <c>Save</c>.
             </para>
                <para>
               Typically applications set the <see cref="P:Ionic.Zip.ZipFile.CompressionLevel" /> property on
               the <c>ZipFile</c> or on each <c>ZipEntry</c> to determine the level of
               compression used. This is done at the time the entry is added to the
               <c>ZipFile</c>. Setting the property to
               <c>Ionic.Zlib.CompressionLevel.None</c> means no compression will be used.
             </para>
                <para>
               This callback allows the application to defer the decision on the
               <c>CompressionLevel</c> to use, until the time of the call to
               <c>ZipFile.Save()</c>. The callback is invoked once per <c>ZipEntry</c>,
               at the time the data for the entry is being written out as part of a
               <c>Save()</c> operation. The application can use whatever criteria it
               likes in determining the level to return.  For example, an application may
               wish that no .mp3 files should be compressed, because they are already
               compressed and the extra compression is not worth the CPU time incurred,
               and so can return <c>None</c> for all .mp3 entries.
             </para>
                <para>
               The library determines whether compression will be attempted for an entry
               this way: If the entry is a zero length file, or a directory, no
               compression is used.  Otherwise, if this callback is set, it is invoked
               and the <c>CompressionLevel</c> is set to the return value. If this
               callback has not been set, then the previously set value for
               <c>CompressionLevel</c> is used.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize">
            <summary>
             The maximum size of an output segment, when saving a split Zip file.
             </summary>
            <remarks>
                <para>
                 Set this to a non-zero value before calling <see cref="M:Ionic.Zip.ZipFile.Save" /> or <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" /> to specify that the ZipFile should be saved as a
                 split archive, also sometimes called a spanned archive. Some also
                 call them multi-file archives.
               </para>
                <para>
                 A split zip archive is saved in a set of discrete filesystem files,
                 rather than in a single file. This is handy when transmitting the
                 archive in email or some other mechanism that has a limit to the size of
                 each file.  The first file in a split archive will be named
                 <c>basename.z01</c>, the second will be named <c>basename.z02</c>, and
                 so on. The final file is named <c>basename.zip</c>. According to the zip
                 specification from PKWare, the minimum value is 65536, for a 64k segment
                 size. The maximum number of segments allows in a split archive is 99.
               </para>
                <para>
                 The value of this property determines the maximum size of a split
                 segment when writing a split archive.  For example, suppose you have a
                 <c>ZipFile</c> that would save to a single file of 200k. If you set the
                 <c>MaxOutputSegmentSize</c> to 65536 before calling <c>Save()</c>, you
                 will get four distinct output files. On the other hand if you set this
                 property to 256k, then you will get a single-file archive for that
                 <c>ZipFile</c>.
               </para>
                <para>
                 The size of each split output file will be as large as possible, up to
                 the maximum size set here. The zip specification requires that some data
                 fields in a zip archive may not span a split boundary, and an output
                 segment may be smaller than the maximum if necessary to avoid that
                 problem. Also, obviously the final segment of the archive may be smaller
                 than the maximum segment size. Segments will never be larger than the
                 value set with this property.
               </para>
                <para>
                 You can save a split Zip file only when saving to a regular filesystem
                 file. It's not possible to save a split zip file as a self-extracting
                 archive, nor is it possible to save a split zip file to a stream. When
                 saving to a SFX or to a Stream, this property is ignored.
               </para>
                <para>
                 About interoperability: Split or spanned zip files produced by DotNetZip
                 can be read by WinZip or PKZip, and vice-versa. Segmented zip files may
                 not be readable by other tools, if those other tools don't support zip
                 spanning or splitting.  When in doubt, test.  I don't believe Windows
                 Explorer can extract a split archive.
               </para>
                <para>
                 This property has no effect when reading a split archive. You can read
                 a split archive in the normal way with DotNetZip.
               </para>
                <para>
                 When saving a zip file, if you want a regular zip file rather than a
                 split zip file, don't set this property, or set it to Zero.
               </para>
                <para>
                 If you read a split archive, with <see cref="M:Ionic.Zip.ZipFile.Read(System.String)" /> and
                 then subsequently call <c>ZipFile.Save()</c>, unless you set this
                 property before calling <c>Save()</c>, you will get a normal,
                 single-file archive.
               </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave">
            <summary>
              Returns the number of segments used in the most recent Save() operation.
            </summary>
            <remarks>
                <para>
                This is normally zero, unless you have set the <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize" /> property.  If you have set <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize" />, and then you save a file, after the call to
                Save() completes, you can read this value to learn the number of segments that
                were created.
              </para>
                <para>
                If you call Save("Archive.zip"), and it creates 5 segments, then you
                will have filesystem files named Archive.z01, Archive.z02, Archive.z03,
                Archive.z04, and Archive.zip, and the value of this property will be 5.
              </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.ParallelDeflateThreshold">
            <summary>
               The size threshold for an entry, above which a parallel deflate is used.
             </summary>
            <remarks>
                <para>
                 DotNetZip will use multiple threads to compress any ZipEntry,
                 if the entry is larger than the given size.  Zero means "always
                 use parallel deflate", while -1 means "never use parallel
                 deflate". The default value for this property is 512k. Aside
                 from the special values of 0 and 1, the minimum value is 65536.
               </para>
                <para>
                 If the entry size cannot be known before compression, as with a
                 read-forward stream, then Parallel deflate will never be
                 performed, unless the value of this property is zero.
               </para>
                <para>
                 A parallel deflate operations will speed up the compression of
                 large files, on computers with multiple CPUs or multiple CPU
                 cores.  For files above 1mb, on a dual core or dual-cpu (2p)
                 machine, the time required to compress the file can be 70% of the
                 single-threaded deflate.  For very large files on 4p machines the
                 compression can be done in 30% of the normal time.  The downside
                 is that parallel deflate consumes extra memory during the deflate,
                 and the deflation is not as effective.
               </para>
                <para>
                 Parallel deflate tends to yield slightly less compression when
                 compared to as single-threaded deflate; this is because the original
                 data stream is split into multiple independent buffers, each of which
                 is compressed in parallel.  But because they are treated
                 independently, there is no opportunity to share compression
                 dictionaries.  For that reason, a deflated stream may be slightly
                 larger when compressed using parallel deflate, as compared to a
                 traditional single-threaded deflate. Sometimes the increase over the
                 normal deflate is as much as 5% of the total compressed size. For
                 larger files it can be as small as 0.1%.
               </para>
                <para>
                 Multi-threaded compression does not give as much an advantage when
                 using Encryption. This is primarily because encryption tends to slow
                 down the entire pipeline. Also, multi-threaded compression gives less
                 of an advantage when using lower compression levels, for example <see cref="F:Ionic.Zlib.CompressionLevel.BestSpeed" />.  You may have to
                 perform some tests to determine the best approach for your situation.
               </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.ParallelDeflateMaxBufferPairs" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.ParallelDeflateMaxBufferPairs">
            <summary>
               The maximum number of buffer pairs to use when performing
               parallel compression.
             </summary>
            <remarks>
                <para>
               This property sets an upper limit on the number of memory
               buffer pairs to create when performing parallel
               compression.  The implementation of the parallel
               compression stream allocates multiple buffers to
               facilitate parallel compression.  As each buffer fills up,
               the stream uses <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see> to compress those
               buffers in a background threadpool thread. After a buffer
               is compressed, it is re-ordered and written to the output
               stream.
             </para>
                <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
                <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see cref="P:Ionic.Zip.ZipFile.BufferSize" />).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
                <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
                <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
                <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
                <para>
               The application can set this value at any time
               before calling <c>ZipFile.Save()</c>.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.ParallelDeflateThreshold" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.LibraryVersion">
            <summary>
             Returns the version number on the DotNetZip assembly.
             </summary>
            <remarks>
                <para>
                 This property is exposed as a convenience.  Callers could also get the
                 version value by retrieving GetName().Version on the
                 System.Reflection.Assembly object pointing to the DotNetZip
                 assembly. But sometimes it is not clear which assembly is being loaded.
                 This property makes it clear.
               </para>
                <para>
                 This static property is primarily useful for diagnostic purposes.
               </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String)">
            <summary>
               Creates a new <c>ZipFile</c> instance, using the specified filename.
             </summary>
            <remarks>
                <para>
               Applications can use this constructor to create a new ZipFile for writing,
               or to slurp in an existing zip archive for read and update purposes.
             </para>
                <para>
               To create a new zip archive, an application can call this constructor,
               passing the name of a file that does not exist.  The name may be a fully
               qualified path. Then the application can add directories or files to the
               <c>ZipFile</c> via <c>AddDirectory()</c>, <c>AddFile()</c>, <c>AddItem()</c>
               and then write the zip archive to the disk by calling <c>Save()</c>. The
               zip file is not actually opened and written to the disk until the
               application calls <c>ZipFile.Save()</c>.  At that point the new zip file
               with the given name is created.
             </para>
                <para>
               If you won't know the name of the <c>Zipfile</c> until the time you call
               <c>ZipFile.Save()</c>, or if you plan to save to a stream (which has no
               name), then you should use the no-argument constructor.
             </para>
                <para>
               The application can also call this constructor to read an existing zip
               archive.  passing the name of a valid zip file that does exist. But, it's
               better form to use the static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)" /> method,
               passing the name of the zip file, because using <c>ZipFile.Read()</c> in
               your code communicates very clearly what you are doing.  In either case,
               the file is then read into the <c>ZipFile</c> instance.  The app can then
               enumerate the entries or can modify the zip file, for example adding
               entries, removing entries, changing comments, and so on.
             </para>
                <para>
               One advantage to this parameterized constructor: it allows applications to
               use the same code to add items to a zip archive, regardless of whether the
               zip file exists.
             </para>
                <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
                <para>
               By the way, since DotNetZip is so easy to use, don't you think <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">you should
               donate $5 or $10</see>?
             </para>
            </remarks>
            <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            <example>
             This example shows how to create a zipfile, and add a few files into it.
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip  = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames, "files");
               zip.Save(ZipFileToCreate);
             }
             </code><code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile()
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames, "files")
                 zip.Save(ZipFileToCreate)
             End Using
             </code></example>
            <param name="fileName">The filename to use for the new zip archive.</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.Text.Encoding)">
            <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, and the specified Encoding.
             </summary>
            <remarks>
                <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
                <para>
               The Encoding is used as the default alternate encoding for entries with
               filenames or comments that cannot be encoded with the IBM437 code page.
               This is equivalent to setting the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property on the <c>ZipFile</c>
               instance after construction.
             </para>
                <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            </remarks>
            <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            <param name="fileName">The filename to use for the new zip archive.</param>
            <param name="encoding">The Encoding is used as the default alternate
             encoding for entries with filenames or comments that cannot be encoded
             with the IBM437 code page. </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor">
            <summary>
               Create a zip file, without specifying a target filename or stream to save to.
             </summary>
            <remarks>
                <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
                <para>
               After instantiating with this constructor and adding entries to the
               archive, the application should call <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" /> or
               <see cref="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)" /> to save to a file or a
               stream, respectively.  The application can also set the <see cref="P:Ionic.Zip.ZipFile.Name" />
               property and then call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save" /> method.  (This
               is the preferred approach for applications that use the library through
               COM interop.)  If you call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save" /> method
               without having set the <c>Name</c> of the <c>ZipFile</c>, either through
               the parameterized constructor or through the explicit property , the
               Save() will throw, because there is no place to save the file.  </para>
                <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               have multiple threads that each use a distinct <c>ZipFile</c> instance, or
               you can synchronize multi-thread access to a single instance.  </para>
            </remarks>
            <example>
             This example creates a Zip archive called Backup.zip, containing all the files
             in the directory DirectoryToZip. Files within subdirectories are not zipped up.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames, "files");
               zip.Save("Backup.zip");
             }
             </code><code lang="VB">
             Using zip As New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames, "files")
                 zip.Save("Backup.zip")
             End Using
             </code></example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.Text.Encoding)">
            <summary>
               Create a zip file, specifying a text Encoding, but without specifying a
               target filename or stream to save to.
             </summary>
            <remarks>
                <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            </remarks>
            <param name="encoding">
             The Encoding is used as the default alternate encoding for entries with
             filenames or comments that cannot be encoded with the IBM437 code page.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter)">
            <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, and the specified status message writer.
             </summary>
            <remarks>
                <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
                <para>
               This version of the constructor allows the caller to pass in a TextWriter,
               to which verbose messages will be written during extraction or creation of
               the zip archive.  A console application may wish to pass
               System.Console.Out to get messages on the Console. A graphical or headless
               application may wish to capture the messages in a different
               <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
               the messages in a TextBox, or generate an audit log of ZipFile operations.
             </para>
                <para>
               To encrypt the data for the files added to the <c>ZipFile</c> instance,
               set the Password property after creating the <c>ZipFile</c> instance.
             </para>
                <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            </remarks>
            <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            <example>
                <code>
             using (ZipFile zip = new ZipFile("Backup.zip", Console.Out))
             {
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               // Status messages will be written to Console.Out
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save();
             }
             </code>
                <code lang="VB">
             Using zip As New ZipFile("Backup.zip", Console.Out)
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 ' Status messages will be written to Console.Out
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save()
             End Using
             </code>
            </example>
            <param name="fileName">The filename to use for the new zip archive.</param>
            <param name="statusMessageWriter">A TextWriter to use for writing
             verbose status messages.</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter,System.Text.Encoding)">
            <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, the specified status message writer, and the specified Encoding.
             </summary>
            <remarks>
                <para>
               This constructor works like the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument.</see> See that
               reference for detail on what this constructor does.
             </para>
                <para>
               This version of the constructor allows the caller to pass in a
               <c>TextWriter</c>, and an Encoding.  The <c>TextWriter</c> will collect
               verbose messages that are generated by the library during extraction or
               creation of the zip archive.  A console application may wish to pass
               <c>System.Console.Out</c> to get messages on the Console. A graphical or
               headless application may wish to capture the messages in a different
               <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
               the messages in a <c>TextBox</c>, or generate an audit log of
               <c>ZipFile</c> operations.
             </para>
                <para>
               The <c>Encoding</c> is used as the default alternate encoding for entries
               with filenames or comments that cannot be encoded with the IBM437 code
               page.  This is a equivalent to setting the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property on the <c>ZipFile</c>
               instance after construction.
             </para>
                <para>
               To encrypt the data for the files added to the <c>ZipFile</c> instance,
               set the <c>Password</c> property after creating the <c>ZipFile</c>
               instance.
             </para>
                <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            </remarks>
            <exception cref="T:Ionic.Zip.ZipException">
             Thrown if <c>fileName</c> refers to an existing file that is not a valid zip file.
             </exception>
            <param name="fileName">The filename to use for the new zip archive.</param>
            <param name="statusMessageWriter">A TextWriter to use for writing verbose
             status messages.</param>
            <param name="encoding">
             The Encoding is used as the default alternate encoding for entries with
             filenames or comments that cannot be encoded with the IBM437 code page.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Initialize(System.String)">
            <summary>
               Initialize a <c>ZipFile</c> instance by reading in a zip file.
             </summary>
            <remarks>
                <para>
               This method is primarily useful from COM Automation environments, when
               reading or extracting zip files. In COM, it is not possible to invoke
               parameterized constructors for a class. A COM Automation application can
               update a zip file by using the <see cref="M:Ionic.Zip.ZipFile.#ctor">default (no argument)
               constructor</see>, then calling <c>Initialize()</c> to read the contents
               of an on-disk zip archive into the <c>ZipFile</c> instance.
             </para>
                <para>
               .NET applications are encouraged to use the <c>ZipFile.Read()</c> methods
               for better clarity.
             </para>
            </remarks>
            <param name="fileName">the name of the existing zip file to read in.</param>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Item(System.Int32)">
            <summary>
               This is an integer indexer into the Zip archive.
             </summary>
            <remarks>
                <para>
               This property is read-only.
             </para>
                <para>
               Internally, the <c>ZipEntry</c> instances that belong to the
               <c>ZipFile</c> are stored in a Dictionary.  When you use this
               indexer the first time, it creates a read-only
               <c>List&lt;ZipEntry&gt;</c> from the Dictionary.Values Collection.
               If at any time you modify the set of entries in the <c>ZipFile</c>,
               either by adding an entry, removing an entry, or renaming an
               entry, a new List will be created, and the numeric indexes for the
               remaining entries may be different.
             </para>
                <para>
               This means you cannot rename any ZipEntry from
               inside an enumeration of the zip file.
             </para>
                <param name="ix">
               The index value.
             </param>
            </remarks>
            <returns>
               The <c>ZipEntry</c> within the Zip archive at the specified index. If the
               entry does not exist in the archive, this indexer throws.
             </returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Item(System.String)">
            <summary>
               This is a name-based indexer into the Zip archive.
             </summary>
            <remarks>
                <para>
               This property is read-only.
             </para>
                <para>
               The <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" /> property on the <c>ZipFile</c>
               determines whether retrieval via this indexer is done via case-sensitive
               comparisons. By default, retrieval is not case sensitive.  This makes
               sense on Windows, in which filesystems are not case sensitive.
             </para>
                <para>
               Regardless of case-sensitivity, it is not always the case that
               <c>this[value].FileName == value</c>. In other words, the <c>FileName</c>
               property of the <c>ZipEntry</c> retrieved with this indexer, may or may
               not be equal to the index value.
             </para>
                <para>
               This is because DotNetZip performs a normalization of filenames passed to
               this indexer, before attempting to retrieve the item.  That normalization
               includes: removal of a volume letter and colon, swapping backward slashes
               for forward slashes.  So, <c>zip["dir1\\entry1.txt"].FileName ==
               "dir1/entry.txt"</c>.
             </para>
                <para>
               Directory entries in the zip file may be retrieved via this indexer only
               with names that have a trailing slash. DotNetZip automatically appends a
               trailing slash to the names of any directory entries added to a zip.
             </para>
            </remarks>
            <example>
             This example extracts only the entries in a zip file that are .txt files.
             <code>
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                   zip[s1].Extract("textfiles");
               }
             }
             </code><code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code></example>
            <seealso cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)" />
            <exception cref="T:System.ArgumentException">
               Thrown if the caller attempts to assign a non-null value to the indexer.
             </exception>
            <param name="fileName">
               The name of the file, including any directory path, to retrieve from the
               zip.  The filename match is not case-sensitive by default; you can use the
               <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" /> property to change this behavior. The
               pathname can use forward-slashes or backward slashes.
             </param>
            <returns>
               The <c>ZipEntry</c> within the Zip archive, given by the specified
               filename. If the named entry does not exist in the archive, this indexer
               returns <c>null</c> (<c>Nothing</c> in VB).
             </returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EntryFileNames">
            <summary>
               The list of filenames for the entries contained within the zip archive.
             </summary>
            <remarks>
               According to the ZIP specification, the names of the entries use forward
               slashes in pathnames.  If you are scanning through the list, you may have
               to swap forward slashes for backslashes.
             </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.Item(System.String)" />
            <example>
               This example shows one way to test if a filename is already contained
               within a zip archive.
             <code>
             String zipFileToRead= "PackedDocuments.zip";
             string candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(zipFileToRead))
             {
               if (zip.EntryFilenames.Contains(candidate))
                 Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
                                   candidate,
                                   zipFileName);
               else
                 Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
                                   candidate,
                                   zipFileName);
               Console.WriteLine();
             }
             </code><code lang="VB">
               Dim zipFileToRead As String = "PackedDocuments.zip"
               Dim candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile.Read(ZipFileToRead)
                   If zip.EntryFilenames.Contains(candidate) Then
                       Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
                                   candidate, _
                                   zipFileName)
                   Else
                     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
                                   candidate, _
                                   zipFileName)
                   End If
                   Console.WriteLine
               End Using
             </code></example>
            <returns>
               The list of strings for the filenames contained within the Zip archive.
             </returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Entries">
            <summary>
               Returns the readonly collection of entries in the Zip archive.
             </summary>
            <remarks>
                <para>
               If there are no entries in the current <c>ZipFile</c>, the value returned is a
               non-null zero-element collection.  If there are entries in the zip file,
               the elements are returned in no particular order.
             </para>
                <para>
               This is the implied enumerator on the <c>ZipFile</c> class.  If you use a
               <c>ZipFile</c> instance in a context that expects an enumerator, you will
               get this collection.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.EntriesSorted" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.EntriesSorted">
            <summary>
               Returns a readonly collection of entries in the Zip archive, sorted by FileName.
             </summary>
            <remarks>
               If there are no entries in the current <c>ZipFile</c>, the value returned
               is a non-null zero-element collection.  If there are entries in the zip
               file, the elements are returned sorted by the name of the entry.
             </remarks>
            <example>
            
               This example fills a Windows Forms ListView with the entries in a zip file.
            
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(zipFile))
             {
                 foreach (ZipEntry entry in zip.EntriesSorted)
                 {
                     ListViewItem item = new ListViewItem(n.ToString());
                     n++;
                     string[] subitems = new string[] {
                         entry.FileName.Replace("/","\\"),
                         entry.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                         entry.UncompressedSize.ToString(),
                         String.Format("{0,5:F0}%", entry.CompressionRatio),
                         entry.CompressedSize.ToString(),
                         (entry.UsesEncryption) ? "Y" : "N",
                         String.Format("{0:X8}", entry.Crc)};
            
                     foreach (String s in subitems)
                     {
                         ListViewItem.ListViewSubItem subitem = new ListViewItem.ListViewSubItem();
                         subitem.Text = s;
                         item.SubItems.Add(subitem);
                     }
            
                     this.listView1.Items.Add(item);
                 }
             }
             </code></example>
            <seealso cref="P:Ionic.Zip.ZipFile.Entries" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.Count">
            <summary>
            Returns the number of entries in the Zip archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)">
            <summary>
               Removes the given <c>ZipEntry</c> from the zip archive.
             </summary>
            <remarks>
                <para>
               After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
               make the changes permanent.
             </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
               Thrown if the specified <c>ZipEntry</c> does not exist in the <c>ZipFile</c>.
             </exception>
            <example>
               In this example, all entries in the zip archive dating from before
               December 31st, 2007, are removed from the archive.  This is actually much
               easier if you use the RemoveSelectedEntries method.  But I needed an
               example for RemoveEntry, so here it is.
             <code>
             String ZipFileToRead = "ArchiveToModify.zip";
             System.DateTime Threshold = new System.DateTime(2007,12,31);
             using (ZipFile zip = ZipFile.Read(ZipFileToRead))
             {
               var EntriesToRemove = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                 {
                   // We cannot remove the entry from the list, within the context of
                   // an enumeration of said list.
                   // So we add the doomed entry to a list to be removed later.
                   EntriesToRemove.Add(e);
                 }
               }
            
               // actually remove the doomed entries.
               foreach (ZipEntry zombie in EntriesToRemove)
                 zip.RemoveEntry(zombie);
            
               zip.Comment= String.Format("This zip archive was updated at {0}.",
                                          System.DateTime.Now.ToString("G"));
            
               // save with a different name
               zip.Save("Archive-Updated.zip");
             }
             </code><code lang="VB">
               Dim ZipFileToRead As String = "ArchiveToModify.zip"
               Dim Threshold As New DateTime(2007, 12, 31)
               Using zip As ZipFile = ZipFile.Read(ZipFileToRead)
                   Dim EntriesToRemove As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           ' We cannot remove the entry from the list, within the context of
                           ' an enumeration of said list.
                           ' So we add the doomed entry to a list to be removed later.
                           EntriesToRemove.Add(e)
                       End If
                   Next
            
                   ' actually remove the doomed entries.
                   Dim zombie As ZipEntry
                   For Each zombie In EntriesToRemove
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = String.Format("This zip archive was updated at {0}.", DateTime.Now.ToString("G"))
                   'save as a different name
                   zip.Save("Archive-Updated.zip")
               End Using
             </code></example>
            <param name="entry">
             The <c>ZipEntry</c> to remove from the zip.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)">
            <summary>
             Removes the <c>ZipEntry</c> with the given filename from the zip archive.
             </summary>
            <remarks>
                <para>
               After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
               make the changes permanent.
             </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">
               Thrown if the <c>ZipFile</c> is not updatable.
             </exception>
            <exception cref="T:System.ArgumentException">
               Thrown if a <c>ZipEntry</c> with the specified filename does not exist in
               the <c>ZipFile</c>.
             </exception>
            <example>
            
               This example shows one way to remove an entry with a given filename from
               an existing zip archive.
            
             <code>
             String zipFileToRead= "PackedDocuments.zip";
             string candidate = "DatedMaterial.xps";
             using (ZipFile zip = ZipFile.Read(zipFileToRead))
             {
               if (zip.EntryFilenames.Contains(candidate))
               {
                 zip.RemoveEntry(candidate);
                 zip.Comment= String.Format("The file '{0}' has been removed from this archive.",
                                            Candidate);
                 zip.Save();
               }
             }
             </code><code lang="VB">
               Dim zipFileToRead As String = "PackedDocuments.zip"
               Dim candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile = ZipFile.Read(zipFileToRead)
                   If zip.EntryFilenames.Contains(candidate) Then
                       zip.RemoveEntry(candidate)
                       zip.Comment = String.Format("The file '{0}' has been removed from this archive.", Candidate)
                       zip.Save
                   End If
               End Using
             </code></example>
            <param name="fileName">
             The name of the file, including any directory path, to remove from the zip.
             The filename match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Dispose">
            <summary>
               Closes the read and write streams associated
               to the <c>ZipFile</c>, if necessary.
             </summary>
            <remarks>
               The Dispose() method is generally employed implicitly, via a <c>using(..) {..}</c>
               statement. (<c>Using...End Using</c> in VB) If you do not employ a using
               statement, insure that your application calls Dispose() explicitly.  For
               example, in a Powershell application, or an application that uses the COM
               interop interface, you must call Dispose() explicitly.
             </remarks>
            <example>
             This example extracts an entry selected by name, from the Zip file to the
             Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               foreach (ZipEntry e in zip)
               {
                 if (WantThisEntry(e.FileName))
                   zip.Extract(e.FileName, Console.OpenStandardOutput());
               }
             } // Dispose() is called implicitly here.
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read(zipfile)
                 Dim e As ZipEntry
                 For Each e In zip
                   If WantThisEntry(e.FileName) Then
                       zip.Extract(e.FileName, Console.OpenStandardOutput())
                   End If
                 Next
             End Using ' Dispose is implicity called here
             </code></example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Dispose(System.Boolean)">
            <summary>
               Disposes any managed resources, if the flag is set, then marks the
               instance disposed.  This method is typically not called explicitly from
               application code.
             </summary>
            <remarks>
               Applications should call <see cref="M:Ionic.Zip.ZipFile.Dispose">the no-arg Dispose method</see>.
             </remarks>
            <param name="disposeManagedResources">
               indicates whether the method should dispose streams or not.
             </param>
        </member>
        <member name="F:Ionic.Zip.ZipFile.BufferSizeDefault">
            <summary>
              Default size of the buffer used for IO.
            </summary>
        </member>
        <member name="E:Ionic.Zip.ZipFile.SaveProgress">
            <summary>
               An event handler invoked when a Save() starts, before and after each
               entry has been written to the archive, when a Save() completes, and
               during other Save events.
             </summary>
            <remarks>
                <para>
               Depending on the particular event, different properties on the <see cref="T:Ionic.Zip.SaveProgressEventArgs" /> parameter are set.  The following
               table summarizes the available EventTypes and the conditions under
               which this event handler is invoked with a
               <c>SaveProgressEventArgs</c> with the given EventType.
             </para>
                <list type="table">
                    <listheader>
                        <term>value of EntryType</term>
                        <description>Meaning and conditions</description>
                    </listheader>
                    <item>
                        <term>ZipProgressEventType.Saving_Started</term>
                        <description>Fired when ZipFile.Save() begins.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
                        <description>
               Fired within ZipFile.Save(), just before writing data for each
               particular entry.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
                        <description>
               Fired within ZipFile.Save(), just after having finished writing data
               for each particular entry.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Saving_Completed</term>
                        <description>Fired when ZipFile.Save() has completed.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Saving_AfterSaveTempArchive</term>
                        <description>
               Fired after the temporary file has been created.  This happens only
               when saving to a disk file.  This event will not be invoked when
               saving to a stream.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Saving_BeforeRenameTempArchive</term>
                        <description>
               Fired just before renaming the temporary file to the permanent
               location.  This happens only when saving to a disk file.  This event
               will not be invoked when saving to a stream.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Saving_AfterRenameTempArchive</term>
                        <description>
               Fired just after renaming the temporary file to the permanent
               location.  This happens only when saving to a disk file.  This event
               will not be invoked when saving to a stream.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Saving_AfterCompileSelfExtractor</term>
                        <description>
               Fired after a self-extracting archive has finished compiling.  This
               EventType is used only within SaveSelfExtractor().
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Saving_BytesRead</term>
                        <description>
               Set during the save of a particular entry, to update progress of the
               Save().  When this EventType is set, the BytesTransferred is the
               number of bytes that have been read from the source stream.  The
               TotalBytesToTransfer is the number of bytes in the uncompressed
               file.
             </description>
                    </item>
                </list>
            </remarks>
            <example>
            
                This example uses an anonymous method to handle the
                SaveProgress event, by updating a progress bar.
            
             <code lang="C#">
             progressBar1.Value = 0;
             progressBar1.Max = listbox1.Items.Count;
             using (ZipFile zip = new ZipFile())
             {
                // listbox1 contains a list of filenames
                zip.AddFiles(listbox1.Items);
            
                // do the progress bar:
                zip.SaveProgress += (sender, e) =&gt; {
                   if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry) {
                      progressBar1.PerformStep();
                   }
                };
            
                zip.Save(fs);
             }
             </code></example>
            <example>
               This example uses a named method as the
               <c>SaveProgress</c> event handler, to update the user, in a
               console-based application.
            
             <code lang="C#">
             static bool justHadByteUpdate= false;
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Saving_Started)
                     Console.WriteLine("Saving: {0}", e.ArchiveName);
            
                 else if (e.EventType == ZipProgressEventType.Saving_Completed)
                 {
                     justHadByteUpdate= false;
                     Console.WriteLine();
                     Console.WriteLine("Done: {0}", e.ArchiveName);
                 }
            
                 else if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
                 {
                     if (justHadByteUpdate)
                         Console.WriteLine();
                     Console.WriteLine("  Writing: {0} ({1}/{2})",
                                       e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal);
                     justHadByteUpdate= false;
                 }
            
                 else if (e.EventType == ZipProgressEventType.Saving_EntryBytesRead)
                 {
                     if (justHadByteUpdate)
                         Console.SetCursorPosition(0, Console.CursorTop);
                      Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                                   e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                     justHadByteUpdate= true;
                 }
             }
            
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress;
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code><code lang="VB">
             Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
                 Using zip As ZipFile = New ZipFile
                     AddHandler zip.SaveProgress, AddressOf MySaveProgress
                     zip.AddDirectory(directory)
                     zip.Save(targetZip)
                 End Using
             End Sub
            
             Private Shared justHadByteUpdate As Boolean = False
            
             Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Saving_Started) Then
                     Console.WriteLine("Saving: {0}", e.ArchiveName)
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_Completed) Then
                     justHadByteUpdate = False
                     Console.WriteLine
                     Console.WriteLine("Done: {0}", e.ArchiveName)
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_BeforeWriteEntry) Then
                     If justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("  Writing: {0} ({1}/{2})", e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal)
                     justHadByteUpdate = False
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_EntryBytesRead) Then
                     If justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, _
                                   e.TotalBytesToTransfer, _
                                   (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     justHadByteUpdate = True
                 End If
             End Sub
             </code></example>
            <example>
            
             This is a more complete example of using the SaveProgress
             events in a Windows Forms application, with a
             Thread object.
            
             <code lang="C#">
             delegate void SaveEntryProgress(SaveProgressEventArgs e);
             delegate void ButtonClick(object sender, EventArgs e);
            
             public class WorkerOptions
             {
                 public string ZipName;
                 public string Folder;
                 public string Encoding;
                 public string Comment;
                 public int ZipFlavor;
                 public Zip64Option Zip64;
             }
            
             private int _progress2MaxFactor;
             private bool _saveCanceled;
             private long _totalBytesBeforeCompress;
             private long _totalBytesAfterCompress;
             private Thread _workerThread;
            
            
             private void btnZipup_Click(object sender, EventArgs e)
             {
                 KickoffZipup();
             }
            
             private void btnCancel_Click(object sender, EventArgs e)
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
                 }
                 else
                 {
                     _saveCanceled = true;
                     lblStatus.Text = "Canceled...";
                     ResetState();
                 }
             }
            
             private void KickoffZipup()
             {
                 _folderName = tbDirName.Text;
            
                 if (_folderName == null || _folderName == "") return;
                 if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
            
                 // check for existence of the zip file:
                 if (System.IO.File.Exists(this.tbZipName.Text))
                 {
                     var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." +
                                                                   "  Do you want to overwrite this file?", this.tbZipName.Text),
                                                     "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                     if (dlgResult != DialogResult.Yes) return;
                     System.IO.File.Delete(this.tbZipName.Text);
                 }
            
                  _saveCanceled = false;
                 _nFilesCompleted = 0;
                 _totalBytesAfterCompress = 0;
                 _totalBytesBeforeCompress = 0;
                 this.btnOk.Enabled = false;
                 this.btnOk.Text = "Zipping...";
                 this.btnCancel.Enabled = true;
                 lblStatus.Text = "Zipping...";
            
                 var options = new WorkerOptions
                 {
                     ZipName = this.tbZipName.Text,
                     Folder = _folderName,
                     Encoding = "ibm437"
                 };
            
                 if (this.comboBox1.SelectedIndex != 0)
                 {
                     options.Encoding = this.comboBox1.SelectedItem.ToString();
                 }
            
                 if (this.radioFlavorSfxCmd.Checked)
                     options.ZipFlavor = 2;
                 else if (this.radioFlavorSfxGui.Checked)
                     options.ZipFlavor = 1;
                 else options.ZipFlavor = 0;
            
                 if (this.radioZip64AsNecessary.Checked)
                     options.Zip64 = Zip64Option.AsNecessary;
                 else if (this.radioZip64Always.Checked)
                     options.Zip64 = Zip64Option.Always;
                 else options.Zip64 = Zip64Option.Never;
            
                 options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
                             options.Encoding,
                             FlavorToString(options.ZipFlavor),
                             options.Zip64.ToString(),
                             System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
                             this.Text);
            
                 if (this.tbComment.Text != TB_COMMENT_NOTE)
                     options.Comment += this.tbComment.Text;
            
                 _workerThread = new Thread(this.DoSave);
                 _workerThread.Name = "Zip Saver thread";
                 _workerThread.Start(options);
                 this.Cursor = Cursors.WaitCursor;
              }
            
            
             private void DoSave(Object p)
             {
                 WorkerOptions options = p as WorkerOptions;
                 try
                 {
                     using (var zip1 = new ZipFile())
                     {
                         zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
                         zip1.Comment = options.Comment;
                         zip1.AddDirectory(options.Folder);
                         _entriesToZip = zip1.EntryFileNames.Count;
                         SetProgressBars();
                         zip1.SaveProgress += this.zip1_SaveProgress;
            
                         zip1.UseZip64WhenSaving = options.Zip64;
            
                         if (options.ZipFlavor == 1)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
                         else if (options.ZipFlavor == 2)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
                         else
                             zip1.Save(options.ZipName);
                     }
                 }
                 catch (System.Exception exc1)
                 {
                     MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
                     btnCancel_Click(null, null);
                 }
             }
            
            
            
             void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Saving_AfterWriteEntry:
                         StepArchiveProgress(e);
                         break;
                     case ZipProgressEventType.Saving_EntryBytesRead:
                         StepEntryProgress(e);
                         break;
                     case ZipProgressEventType.Saving_Completed:
                         SaveCompleted();
                         break;
                     case ZipProgressEventType.Saving_AfterSaveTempArchive:
                         // this event only occurs when saving an SFX file
                         TempArchiveSaved();
                         break;
                 }
                 if (_saveCanceled)
                     e.Cancel = true;
             }
            
            
            
             private void StepArchiveProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar1.InvokeRequired)
                 {
                     this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         _nFilesCompleted++;
                         this.progressBar1.PerformStep();
                         _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
                         _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
            
                         // reset the progress bar for the entry:
                         this.progressBar2.Value = this.progressBar2.Maximum = 1;
            
                         this.Update();
                     }
                 }
             }
            
            
             private void StepEntryProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar2.InvokeRequired)
                 {
                     this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         if (this.progressBar2.Maximum == 1)
                         {
                             // reset
                             Int64 max = e.TotalBytesToTransfer;
                             _progress2MaxFactor = 0;
                             while (max &gt; System.Int32.MaxValue)
                             {
                                 max /= 2;
                                 _progress2MaxFactor++;
                             }
                             this.progressBar2.Maximum = (int)max;
                             lblStatus.Text = String.Format("{0} of {1} files...({2})",
                                 _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
                         }
            
                          int xferred = e.BytesTransferred &gt;&gt; _progress2MaxFactor;
            
                          this.progressBar2.Value = (xferred &gt;= this.progressBar2.Maximum)
                             ? this.progressBar2.Maximum
                             : xferred;
            
                          this.Update();
                     }
                 }
             }
            
             private void SaveCompleted()
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
                 }
                 else
                 {
                     lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
                         _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
                      ResetState();
                 }
             }
            
             private void ResetState()
             {
                 this.btnCancel.Enabled = false;
                 this.btnOk.Enabled = true;
                 this.btnOk.Text = "Zip it!";
                 this.progressBar1.Value = 0;
                 this.progressBar2.Value = 0;
                 this.Cursor = Cursors.Default;
                 if (!_workerThread.IsAlive)
                     _workerThread.Join();
             }
             </code></example>
            <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress" />
            <seealso cref="E:Ionic.Zip.ZipFile.AddProgress" />
            <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress" />
        </member>
        <member name="E:Ionic.Zip.ZipFile.ReadProgress">
            <summary>
             An event handler invoked before, during, and after the reading of a zip archive.
             </summary>
            <remarks>
                <para>
             Depending on the particular event being signaled, different properties on the
             <see cref="T:Ionic.Zip.ReadProgressEventArgs" /> parameter are set.  The following table
             summarizes the available EventTypes and the conditions under which this
             event handler is invoked with a <c>ReadProgressEventArgs</c> with the given EventType.
             </para>
                <list type="table">
                    <listheader>
                        <term>value of EntryType</term>
                        <description>Meaning and conditions</description>
                    </listheader>
                    <item>
                        <term>ZipProgressEventType.Reading_Started</term>
                        <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Reading_Completed</term>
                        <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Reading_ArchiveBytesRead</term>
                        <description>Fired while reading, updates the number of bytes read for the entire archive.
             Meaningful properties: ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Reading_BeforeReadEntry</term>
                        <description>Indicates an entry is about to be read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Reading_AfterReadEntry</term>
                        <description>Indicates an entry has just been read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal, CurrentEntry.
             </description>
                    </item>
                </list>
            </remarks>
            <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress" />
            <seealso cref="E:Ionic.Zip.ZipFile.AddProgress" />
            <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress" />
        </member>
        <member name="E:Ionic.Zip.ZipFile.ExtractProgress">
            <summary>
               An event handler invoked before, during, and after extraction of
               entries in the zip archive.
             </summary>
            <remarks>
                <para>
               Depending on the particular event, different properties on the <see cref="T:Ionic.Zip.ExtractProgressEventArgs" /> parameter are set.  The following
               table summarizes the available EventTypes and the conditions under
               which this event handler is invoked with a
               <c>ExtractProgressEventArgs</c> with the given EventType.
             </para>
                <list type="table">
                    <listheader>
                        <term>value of EntryType</term>
                        <description>Meaning and conditions</description>
                    </listheader>
                    <item>
                        <term>ZipProgressEventType.Extracting_BeforeExtractAll</term>
                        <description>
               Set when ExtractAll() begins. The ArchiveName, Overwrite, and
               ExtractLocation properties are meaningful.</description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Extracting_AfterExtractAll</term>
                        <description>
               Set when ExtractAll() has completed.  The ArchiveName, Overwrite,
               and ExtractLocation properties are meaningful.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Extracting_BeforeExtractEntry</term>
                        <description>
               Set when an Extract() on an entry in the ZipFile has begun.
               Properties that are meaningful: ArchiveName, EntriesTotal,
               CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Extracting_AfterExtractEntry</term>
                        <description>
               Set when an Extract() on an entry in the ZipFile has completed.
               Properties that are meaningful: ArchiveName, EntriesTotal,
               CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Extracting_EntryBytesWritten</term>
                        <description>
               Set within a call to Extract() on an entry in the ZipFile, as data
               is extracted for the entry.  Properties that are meaningful:
               ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
                    </item>
                    <item>
                        <term>ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite</term>
                        <description>
               Set within a call to Extract() on an entry in the ZipFile, when the
               extraction would overwrite an existing file. This event type is used
               only when <c>ExtractExistingFileAction</c> on the <c>ZipFile</c> or
               <c>ZipEntry</c> is set to <c>InvokeExtractProgressEvent</c>.
             </description>
                    </item>
                </list>
            </remarks>
            <example>
                <code>
             private static bool justHadByteUpdate = false;
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
               if(e.EventType == ZipProgressEventType.Extracting_EntryBytesWritten)
               {
                 if (justHadByteUpdate)
                   Console.SetCursorPosition(0, Console.CursorTop);
            
                 Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                               e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                 justHadByteUpdate = true;
               }
               else if(e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
               {
                 if (justHadByteUpdate)
                   Console.WriteLine();
                 Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName);
                 justHadByteUpdate= false;
               }
             }
            
             public static ExtractZip(string zipToExtract, string directory)
             {
               string TargetDirectory= "extract";
               using (var zip = ZipFile.Read(zipToExtract)) {
                 zip.ExtractProgress += ExtractProgress;
                 foreach (var e in zip1)
                 {
                   e.Extract(TargetDirectory, true);
                 }
               }
             }
            
             </code>
                <code lang="VB">
             Public Shared Sub Main(ByVal args As String())
                 Dim ZipToUnpack As String = "C1P3SML.zip"
                 Dim TargetDir As String = "ExtractTest_Extract"
                 Console.WriteLine("Extracting file {0} to {1}", ZipToUnpack, TargetDir)
                 Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)
                     AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress
                     Dim e As ZipEntry
                     For Each e In zip1
                         e.Extract(TargetDir, True)
                     Next
                 End Using
             End Sub
            
             Private Shared justHadByteUpdate As Boolean = False
            
             Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)
                 If (e.EventType = ZipProgressEventType.Extracting_EntryBytesWritten) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer, (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     ExtractTest.justHadByteUpdate = True
                 ElseIf (e.EventType = ZipProgressEventType.Extracting_BeforeExtractEntry) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName)
                     ExtractTest.justHadByteUpdate = False
                 End If
             End Sub
             </code>
            </example>
            <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress" />
            <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress" />
            <seealso cref="E:Ionic.Zip.ZipFile.AddProgress" />
        </member>
        <member name="E:Ionic.Zip.ZipFile.AddProgress">
            <summary>
             An event handler invoked before, during, and after Adding entries to a zip archive.
             </summary>
            <remarks>
                 Adding a large number of entries to a zip file can take a long
                 time.  For example, when calling <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" /> on a
                 directory that contains 50,000 files, it could take 3 minutes or so.
                 This event handler allws an application to track the progress of the Add
                 operation, and to optionally cancel a lengthy Add operation.
             </remarks>
            <example>
                <code lang="C#">
            
             int _numEntriesToAdd= 0;
             int _numEntriesAdded= 0;
             void AddProgressHandler(object sender, AddProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Adding_Started:
                         Console.WriteLine("Adding files to the zip...");
                         break;
                     case ZipProgressEventType.Adding_AfterAddEntry:
                         _numEntriesAdded++;
                         Console.WriteLine(String.Format("Adding file {0}/{1} :: {2}",
                                                  _numEntriesAdded, _numEntriesToAdd, e.CurrentEntry.FileName));
                         break;
                     case ZipProgressEventType.Adding_Completed:
                         Console.WriteLine("Added all files");
                         break;
                 }
             }
            
             void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     zip.AddProgress += AddProgressHandler;
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip));
                     zip.Save(ZipFileToCreate);
                 }
             }
            
             </code>
                <code lang="VB">
            
             Private Sub AddProgressHandler(ByVal sender As Object, ByVal e As AddProgressEventArgs)
                 Select Case e.EventType
                     Case ZipProgressEventType.Adding_Started
                         Console.WriteLine("Adding files to the zip...")
                         Exit Select
                     Case ZipProgressEventType.Adding_AfterAddEntry
                         Console.WriteLine(String.Format("Adding file {0}", e.CurrentEntry.FileName))
                         Exit Select
                     Case ZipProgressEventType.Adding_Completed
                         Console.WriteLine("Added all files")
                         Exit Select
                 End Select
             End Sub
            
             Sub CreateTheZip()
                 Using zip as ZipFile = New ZipFile
                     AddHandler zip.AddProgress, AddressOf AddProgressHandler
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip))
                     zip.Save(ZipFileToCreate);
                 End Using
             End Sub
            
             </code>
            </example>
            <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress" />
            <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress" />
            <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress" />
        </member>
        <member name="E:Ionic.Zip.ZipFile.ZipError">
            <summary>
             An event that is raised when an error occurs during open or read of files
             while saving a zip archive.
             </summary>
            <remarks>
                <para>
                 Errors can occur as a file is being saved to the zip archive.  For
                 example, the File.Open may fail, or a File.Read may fail, because of
                 lock conflicts or other reasons.  If you add a handler to this event,
                 you can handle such errors in your own code.  If you don't add a
                 handler, the library will throw an exception if it encounters an I/O
                 error during a call to <c>Save()</c>.
              </para>
                <para>
                Setting a handler implicitly sets <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction" /> to
                <c>ZipErrorAction.InvokeErrorEvent</c>.
              </para>
                <para>
                The handler you add applies to all <see cref="T:Ionic.Zip.ZipEntry" /> items that are
                subsequently added to the <c>ZipFile</c> instance. If you set this
                property after you have added items to the <c>ZipFile</c>, but before you
                have called <c>Save()</c>, errors that occur while saving those items
                will not cause the error handler to be invoked.
              </para>
                <para>
                If you want to handle any errors that occur with any entry in the zip
                file using the same error handler, then add your error handler once,
                before adding any entries to the zip archive.
              </para>
                <para>
                In the error handler method, you need to set the <see cref="P:Ionic.Zip.ZipEntry.ZipErrorAction" /> property on the
                <c>ZipErrorEventArgs.CurrentEntry</c>.  This communicates back to
                DotNetZip what you would like to do with this particular error.  Within
                an error handler, if you set the <c>ZipEntry.ZipErrorAction</c> property
                on the <c>ZipEntry</c> to <c>ZipErrorAction.InvokeErrorEvent</c> or if
                you don't set it at all, the library will throw the exception. (It is the
                same as if you had set the <c>ZipEntry.ZipErrorAction</c> property on the
                <c>ZipEntry</c> to <c>ZipErrorAction.Throw</c>.) If you set the
                <c>ZipErrorEventArgs.Cancel</c> to true, the entire <c>Save()</c> will be
                canceled.
              </para>
                <para>
                In the case that you use <c>ZipErrorAction.Skip</c>, implying that
                you want to skip the entry for which there's been an error, DotNetZip
                tries to seek backwards in the output stream, and truncate all bytes
                written on behalf of that particular entry. This works only if the
                output stream is seekable.  It will not work, for example, when using
                ASPNET's Response.OutputStream.
              </para>
            </remarks>
            <example>
            
             This example shows how to use an event handler to handle
             errors during save of the zip file.
             <code lang="C#">
            
             public static void MyZipError(object sender, ZipErrorEventArgs e)
             {
                 Console.WriteLine("Error saving {0}...", e.FileName);
                 Console.WriteLine("   Exception: {0}", e.exception);
                 ZipEntry entry = e.CurrentEntry;
                 string response = null;
                 // Ask the user whether he wants to skip this error or not
                 do
                 {
                     Console.Write("Retry, Skip, Throw, or Cancel ? (R/S/T/C) ");
                     response = Console.ReadLine();
                     Console.WriteLine();
            
                 } while (response != null &amp;&amp;
                          response[0]!='S' &amp;&amp; response[0]!='s' &amp;&amp;
                          response[0]!='R' &amp;&amp; response[0]!='r' &amp;&amp;
                          response[0]!='T' &amp;&amp; response[0]!='t' &amp;&amp;
                          response[0]!='C' &amp;&amp; response[0]!='c');
            
                 e.Cancel = (response[0]=='C' || response[0]=='c');
            
                 if (response[0]=='S' || response[0]=='s')
                     entry.ZipErrorAction = ZipErrorAction.Skip;
                 else if (response[0]=='R' || response[0]=='r')
                     entry.ZipErrorAction = ZipErrorAction.Retry;
                 else if (response[0]=='T' || response[0]=='t')
                     entry.ZipErrorAction = ZipErrorAction.Throw;
             }
            
             public void SaveTheFile()
             {
               string directoryToZip = "fodder";
               string directoryInArchive = "files";
               string zipFileToCreate = "Archive.zip";
               using (var zip = new ZipFile())
               {
                 // set the event handler before adding any entries
                 zip.ZipError += MyZipError;
                 zip.AddDirectory(directoryToZip, directoryInArchive);
                 zip.Save(zipFileToCreate);
               }
             }
             </code><code lang="VB">
             Private Sub MyZipError(ByVal sender As Object, ByVal e As Ionic.Zip.ZipErrorEventArgs)
                 ' At this point, the application could prompt the user for an action to take.
                 ' But in this case, this application will simply automatically skip the file, in case of error.
                 Console.WriteLine("Zip Error,  entry {0}", e.CurrentEntry.FileName)
                 Console.WriteLine("   Exception: {0}", e.exception)
                 ' set the desired ZipErrorAction on the CurrentEntry to communicate that to DotNetZip
                 e.CurrentEntry.ZipErrorAction = Zip.ZipErrorAction.Skip
             End Sub
            
             Public Sub SaveTheFile()
                 Dim directoryToZip As String = "fodder"
                 Dim directoryInArchive As String = "files"
                 Dim zipFileToCreate as String = "Archive.zip"
                 Using zipArchive As ZipFile = New ZipFile
                     ' set the event handler before adding any entries
                     AddHandler zipArchive.ZipError, AddressOf MyZipError
                     zipArchive.AddDirectory(directoryToZip, directoryInArchive)
                     zipArchive.Save(zipFileToCreate)
                 End Using
             End Sub
            
             </code></example>
            <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String)">
            <summary>
             Extracts all of the items in the zip archive, to the specified path in the
             filesystem.  The path can be relative or fully-qualified.
             </summary>
            <remarks>
                <para>
               This method will extract all entries in the <c>ZipFile</c> to the
               specified path.
             </para>
                <para>
               If an extraction of a file from the zip archive would overwrite an
               existing file in the filesystem, the action taken is dictated by the
               ExtractExistingFile property, which overrides any setting you may have
               made on individual ZipEntry instances.  By default, if you have not
               set that property on the <c>ZipFile</c> instance, the entry will not
               be extracted, the existing file will not be overwritten and an
               exception will be thrown. To change this, set the property, or use the
               <see cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String,Ionic.Zip.ExtractExistingFileAction)" /> overload that allows you to
               specify an ExtractExistingFileAction parameter.
             </para>
                <para>
               The action to take when an extract would overwrite an existing file
               applies to all entries.  If you want to set this on a per-entry basis,
               then you must use one of the <see cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract</see> methods.
             </para>
                <para>
               This method will send verbose output messages to the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" />, if it is set on the <c>ZipFile</c>
               instance.
             </para>
                <para>
             You may wish to take advantage of the <c>ExtractProgress</c> event.
             </para>
                <para>
               About timestamps: When extracting a file entry from a zip archive, the
               extracted file gets the last modified time of the entry as stored in
               the archive. The archive may also store extended file timestamp
               information, including last accessed and created times. If these are
               present in the <c>ZipEntry</c>, then the extracted file will also get
               these times.
             </para>
                <para>
               A Directory entry is somewhat different. It will get the times as
               described for a file entry, but, if there are file entries in the zip
               archive that, when extracted, appear in the just-created directory,
               then when those file entries are extracted, the last modified and last
               accessed times of the directory will change, as a side effect.  The
               result is that after an extraction of a directory and a number of
               files within the directory, the last modified and last accessed
               timestamps on the directory will reflect the time that the last file
               was extracted into the directory, rather than the time stored in the
               zip archive for the directory.
             </para>
                <para>
               To compensate, when extracting an archive with <c>ExtractAll</c>,
               DotNetZip will extract all the file and directory entries as described
               above, but it will then make a second pass on the directories, and
               reset the times on the directories to reflect what is stored in the
               zip archive.
             </para>
                <para>
               This compensation is performed only within the context of an
               <c>ExtractAll</c>. If you call <c>ZipEntry.Extract</c> on a directory
               entry, the timestamps on directory in the filesystem will reflect the
               times stored in the zip.  If you then call <c>ZipEntry.Extract</c> on
               a file entry, which is extracted into the directory, the timestamps on
               the directory will be updated to the current time.
             </para>
            </remarks>
            <example>
               This example extracts all the entries in a zip archive file, to the
               specified target directory.  The extraction will overwrite any
               existing files silently.
            
             <code>
             String TargetDirectory= "unpack";
             using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
             {
                 zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently;
                 zip.ExtractAll(TargetDirectory);
             }
             </code><code lang="VB">
             Dim TargetDirectory As String = "unpack"
             Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                 zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently
                 zip.ExtractAll(TargetDirectory)
             End Using
             </code></example>
            <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress" />
            <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />
            <param name="path">
               The path to which the contents of the zipfile will be extracted.
               The path can be relative or fully-qualified.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String,Ionic.Zip.ExtractExistingFileAction)">
            <summary>
             Extracts all of the items in the zip archive, to the specified path in the
             filesystem, using the specified behavior when extraction would overwrite an
             existing file.
             </summary>
            <remarks>
                <para>
             This method will extract all entries in the <c>ZipFile</c> to the specified
             path.  For an extraction that would overwrite an existing file, the behavior
             is dictated by <paramref name="extractExistingFile" />, which overrides any
             setting you may have made on individual ZipEntry instances.
             </para>
                <para>
             The action to take when an extract would overwrite an existing file
             applies to all entries.  If you want to set this on a per-entry basis,
             then you must use <see cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" /> or one of the similar methods.
             </para>
                <para>
             Calling this method is equivalent to setting the <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" /> property and then calling <see cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String)" />.
             </para>
                <para>
             This method will send verbose output messages to the
             <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" />, if it is set on the <c>ZipFile</c> instance.
             </para>
            </remarks>
            <example>
             This example extracts all the entries in a zip archive file, to the
             specified target directory.  It does not overwrite any existing files.
             <code>
             String TargetDirectory= "c:\\unpack";
             using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
             {
               zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite);
             }
             </code><code lang="VB">
             Dim TargetDirectory As String = "c:\unpack"
             Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                 zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite)
             End Using
             </code></example>
            <param name="path">
             The path to which the contents of the zipfile will be extracted.
             The path can be relative or fully-qualified.
             </param>
            <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String)">
            <summary>
             Reads a zip file archive and returns the instance.
             </summary>
            <remarks>
                <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the
             <c>IBM437</c> codepage.
             </para>
            </remarks>
            <exception cref="T:System.Exception">
             Thrown if the <c>ZipFile</c> cannot be read. The implementation of this method
             relies on <c>System.IO.File.OpenRead</c>, which can throw a variety of exceptions,
             including specific exceptions if a file is not found, an unauthorized access
             exception, exceptions for poorly formatted filenames, and so on.
             </exception>
            <param name="fileName">
             The name of the zip archive to open.  This can be a fully-qualified or relative
             pathname.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)" />.
            
             <returns>The instance read from the zip archive.</returns></member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">
            <summary>
               Reads a zip file archive from the named filesystem file using the
               specified options.
             </summary>
            <remarks>
                <para>
               This version of the <c>Read()</c> method allows the caller to pass
               in a <c>TextWriter</c> an <c>Encoding</c>, via an instance of the
               <c>ReadOptions</c> class.  The <c>ZipFile</c> is read in using the
               specified encoding for entries where UTF-8 encoding is not
               explicitly specified.
             </para>
            </remarks>
            <example>
                <para>
               This example shows how to read a zip file using the Big-5 Chinese
               code page (950), and extract each entry in the zip file, while
               sending status messages out to the Console.
             </para>
                <para>
               For this code to work as intended, the zipfile must have been
               created using the big5 code page (CP950). This is typical, for
               example, when using WinRar on a machine with CP950 set as the
               default code page.  In that case, the names of entries within the
               Zip archive will be stored in that code page, and reading the zip
               archive must be done using that code page.  If the application did
               not use the correct code page in ZipFile.Read(), then names of
               entries within the zip archive would not be correctly retrieved.
             </para>
                <code lang="C#">
             string zipToExtract = "MyArchive.zip";
             string extractDirectory = "extract";
             var options = new ReadOptions
             {
               StatusMessageWriter = System.Console.Out,
               Encoding = System.Text.Encoding.GetEncoding(950)
             };
             using (ZipFile zip = ZipFile.Read(zipToExtract, options))
             {
               foreach (ZipEntry e in zip)
               {
                  e.Extract(extractDirectory);
               }
             }
             </code>
                <code lang="VB">
             Dim zipToExtract as String = "MyArchive.zip"
             Dim extractDirectory as String = "extract"
             Dim options as New ReadOptions
             options.Encoding = System.Text.Encoding.GetEncoding(950)
             options.StatusMessageWriter = System.Console.Out
             Using zip As ZipFile = ZipFile.Read(zipToExtract, options)
                 Dim e As ZipEntry
                 For Each e In zip
                  e.Extract(extractDirectory)
                 Next
             End Using
             </code>
            </example>
            <example>
                <para>
               This example shows how to read a zip file using the default
               code page, to remove entries that have a modified date before a given threshold,
               sending status messages out to a <c>StringWriter</c>.
             </para>
                <code lang="C#">
             var options = new ReadOptions
             {
               StatusMessageWriter = new System.IO.StringWriter()
             };
             using (ZipFile zip =  ZipFile.Read("PackedDocuments.zip", options))
             {
               var Threshold = new DateTime(2007,7,4);
               // We cannot remove the entry from the list, within the context of
               // an enumeration of said list.
               // So we add the doomed entry to a list to be removed later.
               // pass 1: mark the entries for removal
               var MarkedEntries = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                   MarkedEntries.Add(e);
               }
               // pass 2: actually remove the entry.
               foreach (ZipEntry zombie in MarkedEntries)
                  zip.RemoveEntry(zombie);
               zip.Comment = "This archive has been updated.";
               zip.Save();
             }
             // can now use contents of sw, eg store in an audit log
             </code>
                <code lang="VB">
             Dim options as New ReadOptions
             options.StatusMessageWriter = New System.IO.StringWriter
             Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip", options)
                 Dim Threshold As New DateTime(2007, 7, 4)
                 ' We cannot remove the entry from the list, within the context of
                 ' an enumeration of said list.
                 ' So we add the doomed entry to a list to be removed later.
                 ' pass 1: mark the entries for removal
                 Dim MarkedEntries As New System.Collections.Generic.List(Of ZipEntry)
                 Dim e As ZipEntry
                 For Each e In zip
                     If (e.LastModified &lt; Threshold) Then
                         MarkedEntries.Add(e)
                     End If
                 Next
                 ' pass 2: actually remove the entry.
                 Dim zombie As ZipEntry
                 For Each zombie In MarkedEntries
                     zip.RemoveEntry(zombie)
                 Next
                 zip.Comment = "This archive has been updated."
                 zip.Save
             End Using
             ' can now use contents of sw, eg store in an audit log
             </code>
            </example>
            <exception cref="T:System.Exception">
               Thrown if the zipfile cannot be read. The implementation of
               this method relies on <c>System.IO.File.OpenRead</c>, which
               can throw a variety of exceptions, including specific
               exceptions if a file is not found, an unauthorized access
               exception, exceptions for poorly formatted filenames, and so
               on.
             </exception>
            <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            <param name="options">
             The set of options to use when reading the zip file.
             </param>
            <returns>The ZipFile instance read from the zip archive.</returns>
            <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
            <summary>
             Reads a zip file archive using the specified text encoding,  the specified
             TextWriter for status messages, and the specified ReadProgress event handler,
             and returns the instance.
             </summary>
            <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            <param name="readProgress">
             An event handler for Read operations.
             </param>
            <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages
             during operations on the zip archive.  A console application may wish to
             pass <c>System.Console.Out</c> to get messages on the Console. A graphical
             or headless application may wish to capture the messages in a different
             <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
             </param>
            <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </param>
            <returns>The instance read from the zip archive.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream)">
            <summary>
               Reads a zip archive from a stream.
             </summary>
            <remarks>
                <para>
               When reading from a file, it's probably easier to just use
               <see cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">ZipFile.Read(String, ReadOptions)</see>.  This
               overload is useful when when the zip archive content is
               available from an already-open stream. The stream must be
               open and readable and seekable when calling this method.  The
               stream is left open when the reading is completed.
             </para>
                <para>
               Using this overload, the stream is read using the default
               <c>System.Text.Encoding</c>, which is the <c>IBM437</c>
               codepage. If you want to specify the encoding to use when
               reading the zipfile content, see
               <see cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)">ZipFile.Read(Stream, ReadOptions)</see>.  This
             </para>
                <para>
               Reading of zip content begins at the current position in the
               stream.  This means if you have a stream that concatenates
               regular data and zip data, if you position the open, readable
               stream at the start of the zip data, you will be able to read
               the zip archive using this constructor, or any of the ZipFile
               constructors that accept a <see cref="T:System.IO.Stream" /> as
               input. Some examples of where this might be useful: the zip
               content is concatenated at the end of a regular EXE file, as
               some self-extracting archives do.  (Note: SFX files produced
               by DotNetZip do not work this way; they can be read as normal
               ZIP files). Another example might be a stream being read from
               a database, where the zip content is embedded within an
               aggregate stream of data.
             </para>
            </remarks>
            <example>
                <para>
               This example shows how to Read zip content from a stream, and
               extract one entry into a different stream. In this example,
               the filename "NameOfEntryInArchive.doc", refers only to the
               name of the entry within the zip archive.  A file by that
               name is not created in the filesystem.  The I/O is done
               strictly with the given streams.
             </para>
                <code>
             using (ZipFile zip = ZipFile.Read(InputStream))
             {
                zip.Extract("NameOfEntryInArchive.doc", OutputStream);
             }
             </code>
                <code lang="VB">
             Using zip as ZipFile = ZipFile.Read(InputStream)
                zip.Extract("NameOfEntryInArchive.doc", OutputStream)
             End Using
             </code>
            </example>
            <param name="zipStream">the stream containing the zip data.</param>
            <returns>The ZipFile instance read from the stream</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)">
            <summary>
               Reads a zip file archive from the given stream using the
               specified options.
             </summary>
            <remarks>
                <para>
               When reading from a file, it's probably easier to just use
               <see cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">ZipFile.Read(String, ReadOptions)</see>.  This
               overload is useful when when the zip archive content is
               available from an already-open stream. The stream must be
               open and readable and seekable when calling this method.  The
               stream is left open when the reading is completed.
             </para>
                <para>
               Reading of zip content begins at the current position in the
               stream.  This means if you have a stream that concatenates
               regular data and zip data, if you position the open, readable
               stream at the start of the zip data, you will be able to read
               the zip archive using this constructor, or any of the ZipFile
               constructors that accept a <see cref="T:System.IO.Stream" /> as
               input. Some examples of where this might be useful: the zip
               content is concatenated at the end of a regular EXE file, as
               some self-extracting archives do.  (Note: SFX files produced
               by DotNetZip do not work this way; they can be read as normal
               ZIP files). Another example might be a stream being read from
               a database, where the zip content is embedded within an
               aggregate stream of data.
             </para>
            </remarks>
            <param name="zipStream">the stream containing the zip data.</param>
            <param name="options">
               The set of options to use when reading the zip file.
             </param>
            <exception cref="T:System.Exception">
               Thrown if the zip archive cannot be read.
             </exception>
            <returns>The ZipFile instance read from the stream.</returns>
            <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
            <summary>
             Reads a zip archive from a stream, using the specified text Encoding, the
             specified TextWriter for status messages,
             and the specified ReadProgress event handler.
             </summary>
            <remarks>
                <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream" /> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
            </remarks>
            <param name="zipStream">the stream containing the zip data.</param>
            <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written
             during operations on the <c>ZipFile</c>.  For example, in a console
             application, System.Console.Out works, and will get a message for each entry
             added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
             are written.
             </param>
            <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8
             encoding bit set.  Be careful specifying the encoding.  If the value you use
             here is not the same as the Encoding used when the zip archive was created
             (possibly by a different archiver) you will get unexpected results and
             possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
             property for more information.
             </param>
            <param name="readProgress">
             An event handler for Read operations.
             </param>
            <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String)">
            <summary>
             Checks the given file to see if it appears to be a valid zip file.
             </summary>
            <remarks>
                <para>
               Calling this method is equivalent to calling <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)" /> with the testExtract parameter set to false.
             </para>
            </remarks>
            <param name="fileName">The file to check.</param>
            <returns>true if the file appears to be a zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)">
            <summary>
             Checks a file to see if it is a valid zip file.
             </summary>
            <remarks>
                <para>
               This method opens the specified zip file, reads in the zip archive,
               verifying the ZIP metadata as it reads.
             </para>
                <para>
               If everything succeeds, then the method returns true.  If anything fails -
               for example if an incorrect signature or CRC is found, indicating a
               corrupt file, the the method returns false.  This method also returns
               false for a file that does not exist.
             </para>
                <para>
               If <paramref name="testExtract" /> is true, as part of its check, this
               method reads in the content for each entry, expands it, and checks CRCs.
               This provides an additional check beyond verifying the zip header and
               directory data.
             </para>
                <para>
               If <paramref name="testExtract" /> is true, and if any of the zip entries
               are protected with a password, this method will return false.  If you want
               to verify a <c>ZipFile</c> that has entries which are protected with a
               password, you will need to do that manually.
             </para>
            </remarks>
            <param name="fileName">The zip file to check.</param>
            <param name="testExtract">true if the caller wants to extract each entry.</param>
            <returns>true if the file contains a valid zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.IO.Stream,System.Boolean)">
            <summary>
             Checks a stream to see if it contains a valid zip archive.
             </summary>
            <remarks>
                <para>
             This method reads the zip archive contained in the specified stream, verifying
             the ZIP metadata as it reads.  If testExtract is true, this method also extracts
             each entry in the archive, dumping all the bits into <see cref="F:System.IO.Stream.Null" />.
             </para>
                <para>
             If everything succeeds, then the method returns true.  If anything fails -
             for example if an incorrect signature or CRC is found, indicating a corrupt
             file, the the method returns false.  This method also returns false for a
             file that does not exist.
             </para>
                <para>
             If <c>testExtract</c> is true, this method reads in the content for each
             entry, expands it, and checks CRCs.  This provides an additional check
             beyond verifying the zip header data.
             </para>
                <para>
             If <c>testExtract</c> is true, and if any of the zip entries are protected
             with a password, this method will return false.  If you want to verify a
             ZipFile that has entries which are protected with a password, you will need
             to do that manually.
             </para>
            </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)" />
            <param name="stream">The stream to check.</param>
            <param name="testExtract">true if the caller wants to extract each entry.</param>
            <returns>true if the stream contains a valid zip archive.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.DeleteFileWithRetry(System.String)">
            <summary>
               Delete file with retry on UnauthorizedAccessException.
             </summary>
            <remarks>
                <para>
                 When calling File.Delete() on a file that has been "recently"
                 created, the call sometimes fails with
                 UnauthorizedAccessException. This method simply retries the Delete 3
                 times with a sleep between tries.
               </para>
            </remarks>
            <param name="filename">the name of the file to be deleted</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save">
            <summary>
               Saves the Zip archive to a file, specified by the Name property of the
               <c>ZipFile</c>.
             </summary>
            <remarks>
                <para>
               The <c>ZipFile</c> instance is written to storage, typically a zip file
               in a filesystem, only when the caller calls <c>Save</c>.  In the typical
               case, the Save operation writes the zip content to a temporary file, and
               then renames the temporary file to the desired name. If necessary, this
               method will delete a pre-existing file before the rename.
             </para>
                <para>
               The <see cref="P:Ionic.Zip.ZipFile.Name" /> property is specified either explicitly,
               or implicitly using one of the parameterized ZipFile constructors.  For
               COM Automation clients, the <c>Name</c> property must be set explicitly,
               because COM Automation clients cannot call parameterized constructors.
             </para>
                <para>
               When using a filesystem file for the Zip output, it is possible to call
               <c>Save</c> multiple times on the <c>ZipFile</c> instance. With each
               call the zip content is re-written to the same output file.
             </para>
                <para>
               Data for entries that have been added to the <c>ZipFile</c> instance is
               written to the output when the <c>Save</c> method is called. This means
               that the input streams for those entries must be available at the time
               the application calls <c>Save</c>.  If, for example, the application
               adds entries with <c>AddEntry</c> using a dynamically-allocated
               <c>MemoryStream</c>, the memory stream must not have been disposed
               before the call to <c>Save</c>. See the <see cref="P:Ionic.Zip.ZipEntry.InputStream" /> property for more discussion of the
               availability requirements of the input stream for an entry, and an
               approach for providing just-in-time stream lifecycle management.
             </para>
            </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)" />
            <exception cref="T:Ionic.Zip.BadStateException">
               Thrown if you haven't specified a location or stream for saving the zip,
               either in the constructor or by setting the Name property, or if you try
               to save a regular zip archive to a filename with a .exe extension.
             </exception>
            <exception cref="T:System.OverflowException">
               Thrown if <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize" /> is non-zero, and the number
               of segments that would be generated for the spanned zip file during the
               save operation exceeds 99.  If this happens, you need to increase the
               segment size.
             </exception>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save(System.String)">
            <summary>
             Save the file to a new zipfile, with the given name.
             </summary>
            <remarks>
                <para>
             This method allows the application to explicitly specify the name of the zip
             file when saving. Use this when creating a new zip file, or when
             updating a zip archive.
             </para>
                <para>
             An application can also save a zip archive in several places by calling this
             method multiple times in succession, with different filenames.
             </para>
                <para>
             The <c>ZipFile</c> instance is written to storage, typically a zip file in a
             filesystem, only when the caller calls <c>Save</c>.  The Save operation writes
             the zip content to a temporary file, and then renames the temporary file
             to the desired name. If necessary, this method will delete a pre-existing file
             before the rename.
             </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
             Thrown if you specify a directory for the filename.
             </exception>
            <param name="fileName">
             The name of the zip archive to save to. Existing files will
             be overwritten with great prejudice.
             </param>
            <example>
             This example shows how to create and Save a zip file.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               zip.AddDirectory(@"c:\reports\January");
               zip.Save("January.zip");
             }
             </code><code lang="VB">
             Using zip As New ZipFile()
               zip.AddDirectory("c:\reports\January")
               zip.Save("January.zip")
             End Using
             </code></example>
            <example>
             This example shows how to update a zip file.
             <code>
             using (ZipFile zip = ZipFile.Read("ExistingArchive.zip"))
             {
               zip.AddFile("NewData.csv");
               zip.Save("UpdatedArchive.zip");
             }
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read("ExistingArchive.zip")
               zip.AddFile("NewData.csv")
               zip.Save("UpdatedArchive.zip")
             End Using
             </code></example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)">
            <summary>
               Save the zip archive to the specified stream.
             </summary>
            <remarks>
                <para>
               The <c>ZipFile</c> instance is written to storage - typically a zip file
               in a filesystem, but using this overload, the storage can be anything
               accessible via a writable stream - only when the caller calls <c>Save</c>.
             </para>
                <para>
               Use this method to save the zip content to a stream directly.  A common
               scenario is an ASP.NET application that dynamically generates a zip file
               and allows the browser to download it. The application can call
               <c>Save(Response.OutputStream)</c> to write a zipfile directly to the
               output stream, without creating a zip file on the disk on the ASP.NET
               server.
             </para>
                <para>
               Be careful when saving a file to a non-seekable stream, including
               <c>Response.OutputStream</c>. When DotNetZip writes to a non-seekable
               stream, the zip archive is formatted in such a way that may not be
               compatible with all zip tools on all platforms.  It's a perfectly legal
               and compliant zip file, but some people have reported problems opening
               files produced this way using the Mac OS archive utility.
             </para>
            </remarks>
            <example>
            
               This example saves the zipfile content into a MemoryStream, and
               then gets the array of bytes from that MemoryStream.
            
             <code lang="C#">
             using (var zip = new Ionic.Zip.ZipFile())
             {
                 zip.CompressionLevel= Ionic.Zlib.CompressionLevel.BestCompression;
                 zip.Password = "VerySecret.";
                 zip.Encryption = EncryptionAlgorithm.WinZipAes128;
                 zip.AddFile(sourceFileName);
                 MemoryStream output = new MemoryStream();
                 zip.Save(output);
            
                 byte[] zipbytes = output.ToArray();
             }
             </code></example>
            <example>
                <para>
               This example shows a pitfall you should avoid. DO NOT read
               from a stream, then try to save to the same stream.  DO
               NOT DO THIS:
             </para>
                <code lang="C#">
             using (var fs = new FileStream(filename, FileMode.Open))
             {
               using (var zip = Ionic.Zip.ZipFile.Read(inputStream))
               {
                 zip.AddEntry("Name1.txt", "this is the content");
                 zip.Save(inputStream);  // NO NO NO!!
               }
             }
             </code>
                <para>
               Better like this:
             </para>
                <code lang="C#">
             using (var zip = Ionic.Zip.ZipFile.Read(filename))
             {
                 zip.AddEntry("Name1.txt", "this is the content");
                 zip.Save();  // YES!
             }
             </code>
            </example>
            <param name="outputStream">
               The <c>System.IO.Stream</c> to write to. It must be
               writable. If you created the ZipFile instance by calling
               ZipFile.Read(), this stream must not be the same stream
               you passed to ZipFile.Read().
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)">
            <summary>
               Adds to the ZipFile a set of files from the current working directory on
               disk, that conform to the specified criteria.
             </summary>
            <remarks>
                <para>
               This method selects files from the the current working directory matching
               the specified criteria, and adds them to the ZipFile.
             </para>
                <para>
               Specify the criteria in statements of 3 elements: a noun, an operator, and
               a value.  Consider the string "name != *.doc" .  The noun is "name".  The
               operator is "!=", implying "Not Equal".  The value is "*.doc".  That
               criterion, in English, says "all files with a name that does not end in
               the .doc extension."
             </para>
                <para>
               Supported nouns include "name" (or "filename") for the filename; "atime",
               "mtime", and "ctime" for last access time, last modfied time, and created
               time of the file, respectively; "attributes" (or "attrs") for the file
               attributes; "size" (or "length") for the file length (uncompressed), and
               "type" for the type of object, either a file or a directory.  The
               "attributes", "name" and "type" nouns both support = and != as operators.
               The "size", "atime", "mtime", and "ctime" nouns support = and !=, and
               &gt;, &gt;=, &lt;, &lt;= as well. The times are taken to be expressed in
               local time.
             </para>
                <para>
             Specify values for the file attributes as a string with one or more of the
             characters H,R,S,A,I,L in any order, implying file attributes of Hidden,
             ReadOnly, System, Archive, NotContextIndexed, and ReparsePoint (symbolic
             link) respectively.
             </para>
                <para>
             To specify a time, use YYYY-MM-DD-HH:mm:ss or YYYY/MM/DD-HH:mm:ss as the
             format.  If you omit the HH:mm:ss portion, it is assumed to be 00:00:00
             (midnight).
             </para>
                <para>
             The value for a size criterion is expressed in integer quantities of bytes,
             kilobytes (use k or kb after the number), megabytes (m or mb), or gigabytes
             (g or gb).
             </para>
                <para>
             The value for a name is a pattern to match against the filename, potentially
             including wildcards.  The pattern follows CMD.exe glob rules: * implies one
             or more of any character, while ?  implies one character.  If the name
             pattern contains any slashes, it is matched to the entire filename,
             including the path; otherwise, it is matched against only the filename
             without the path.  This means a pattern of "*\*.*" matches all files one
             directory level deep, while a pattern of "*.*" matches all files in all
             directories.
             </para>
                <para>
             To specify a name pattern that includes spaces, use single quotes around the
             pattern.  A pattern of "'* *.*'" will match all files that have spaces in
             the filename.  The full criteria string for that would be "name = '* *.*'" .
             </para>
                <para>
             The value for a type criterion is either F (implying a file) or D (implying
             a directory).
             </para>
                <para>
             Some examples:
             </para>
                <list type="table">
                    <listheader>
                        <term>criteria</term>
                        <description>Files retrieved</description>
                    </listheader>
                    <item>
                        <term>name != *.xls </term>
                        <description>any file with an extension that is not .xls
                 </description>
                    </item>
                    <item>
                        <term>name = *.mp3 </term>
                        <description>any file with a .mp3 extension.
                 </description>
                    </item>
                    <item>
                        <term>*.mp3</term>
                        <description>(same as above) any file with a .mp3 extension.
                 </description>
                    </item>
                    <item>
                        <term>attributes = A </term>
                        <description>all files whose attributes include the Archive bit.
                 </description>
                    </item>
                    <item>
                        <term>attributes != H </term>
                        <description>all files whose attributes do not include the Hidden bit.
                 </description>
                    </item>
                    <item>
                        <term>mtime &gt; 2009-01-01</term>
                        <description>all files with a last modified time after January 1st, 2009.
                 </description>
                    </item>
                    <item>
                        <term>size &gt; 2gb</term>
                        <description>all files whose uncompressed size is greater than 2gb.
                 </description>
                    </item>
                    <item>
                        <term>type = D</term>
                        <description>all directories in the filesystem. </description>
                    </item>
                </list>
                <para>
             You can combine criteria with the conjunctions AND or OR. Using a string
             like "name = *.txt AND size &gt;= 100k" for the selectionCriteria retrieves
             entries whose names end in .txt, and whose uncompressed size is greater than
             or equal to 100 kilobytes.
             </para>
                <para>
             For more complex combinations of criteria, you can use parenthesis to group
             clauses in the boolean logic.  Without parenthesis, the precedence of the
             criterion atoms is determined by order of appearance.  Unlike the C#
             language, the AND conjunction does not take precendence over the logical OR.
             This is important only in strings that contain 3 or more criterion atoms.
             In other words, "name = *.txt and size &gt; 1000 or attributes = H" implies
             "((name = *.txt AND size &gt; 1000) OR attributes = H)" while "attributes =
             H OR name = *.txt and size &gt; 1000" evaluates to "((attributes = H OR name
             = *.txt) AND size &gt; 1000)".  When in doubt, use parenthesis.
             </para>
                <para>
             Using time properties requires some extra care. If you want to retrieve all
             entries that were last updated on 2009 February 14, specify a time range
             like so:"mtime &gt;= 2009-02-14 AND mtime &lt; 2009-02-15".  Read this to
             say: all files updated after 12:00am on February 14th, until 12:00am on
             February 15th.  You can use the same bracketing approach to specify any time
             period - a year, a month, a week, and so on.
             </para>
                <para>
             The syntax allows one special case: if you provide a string with no spaces, it is
             treated as a pattern to match for the filename.  Therefore a string like "*.xls"
             will be equivalent to specifying "name = *.xls".
             </para>
                <para>
             There is no logic in this method that insures that the file inclusion
             criteria are internally consistent.  For example, it's possible to specify
             criteria that says the file must have a size of less than 100 bytes, as well
             as a size that is greater than 1000 bytes. Obviously no file will ever
             satisfy such criteria, but this method does not detect such logical
             inconsistencies. The caller is responsible for insuring the criteria are
             sensible.
             </para>
                <para>
               Using this method, the file selection does not recurse into
               subdirectories, and the full path of the selected files is included in the
               entries added into the zip archive.  If you don't like these behaviors,
               see the other overloads of this method.
             </para>
            </remarks>
            <example>
             This example zips up all *.csv files in the current working directory.
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // To just match on filename wildcards,
                 // use the shorthand form of the selectionCriteria string.
                 zip.AddSelectedFiles("*.csv");
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 zip.AddSelectedFiles("*.csv")
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
            <param name="selectionCriteria">The criteria for file selection</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.Boolean)">
            <summary>
               Adds to the ZipFile a set of files from the disk that conform to the
               specified criteria, optionally recursing into subdirectories.
             </summary>
            <remarks>
                <para>
               This method selects files from the the current working directory matching
               the specified criteria, and adds them to the ZipFile.  If
               <c>recurseDirectories</c> is true, files are also selected from
               subdirectories, and the directory structure in the filesystem is
               reproduced in the zip archive, rooted at the current working directory.
             </para>
                <para>
               Using this method, the full path of the selected files is included in the
               entries added into the zip archive.  If you don't want this behavior, use
               one of the overloads of this method that allows the specification of a
               <c>directoryInArchive</c>.
             </para>
                <para>
               For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
            </remarks>
            <example>
            
               This example zips up all *.xml files in the current working directory, or any
               subdirectory, that are larger than 1mb.
            
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", true);
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
            <param name="selectionCriteria">The criteria for file selection</param>
            <param name="recurseDirectories">
               If true, the file selection will recurse into subdirectories.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)">
            <summary>
               Adds to the ZipFile a set of files from a specified directory in the
               filesystem, that conform to the specified criteria.
             </summary>
            <remarks>
                <para>
               This method selects files that conform to the specified criteria, from the
               the specified directory on disk, and adds them to the ZipFile.  The search
               does not recurse into subdirectores.
             </para>
                <para>
               Using this method, the full filesystem path of the files on disk is
               reproduced on the entries added to the zip file.  If you don't want this
               behavior, use one of the other overloads of this method.
             </para>
                <para>
               For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
            </remarks>
            <example>
            
               This example zips up all *.xml files larger than 1mb in the directory
               given by "d:\rawdata".
            
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", "d:\\rawdata");
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", "d:\rawdata)
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
            <param name="selectionCriteria">The criteria for file selection</param>
            <param name="directoryOnDisk">
             The name of the directory on the disk from which to select files.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.Boolean)">
            <summary>
               Adds to the ZipFile a set of files from the specified directory on disk,
               that conform to the specified criteria.
             </summary>
            <remarks>
                <para>
               This method selects files from the the specified disk directory matching
               the specified selection criteria, and adds them to the ZipFile.  If
               <c>recurseDirectories</c> is true, files are also selected from
               subdirectories.
             </para>
                <para>
               The full directory structure in the filesystem is reproduced on the
               entries added to the zip archive.  If you don't want this behavior, use
               one of the overloads of this method that allows the specification of a
               <c>directoryInArchive</c>.
             </para>
                <para>
               For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
            </remarks>
            <example>
            
               This example zips up all *.csv files in the "files" directory, or any
               subdirectory, that have been saved since 2009 February 14th.
            
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.csv  and  mtime &gt; 2009-02-14", "files", true);
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.csv  and  mtime &gt; 2009-02-14", "files", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
            <example>
               This example zips up all files in the current working
               directory, and all its child directories, except those in
               the <c>excludethis</c> subdirectory.
             <code lang="VB">
             Using Zip As ZipFile = New ZipFile(zipfile)
               Zip.AddSelectedFfiles("name != 'excludethis\*.*'", datapath, True)
               Zip.Save()
             End Using
             </code></example>
            <param name="selectionCriteria">The criteria for file selection</param>
            <param name="directoryOnDisk">
               The filesystem path from which to select files.
             </param>
            <param name="recurseDirectories">
               If true, the file selection will recurse into subdirectories.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String)">
            <summary>
               Adds to the ZipFile a selection of files from the specified directory on
               disk, that conform to the specified criteria, and using a specified root
               path for entries added to the zip archive.
             </summary>
            <remarks>
                <para>
               This method selects files from the specified disk directory matching the
               specified selection criteria, and adds those files to the ZipFile, using
               the specified directory path in the archive.  The search does not recurse
               into subdirectories.  For details on the syntax for the selectionCriteria
               parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
            </remarks>
            <example>
            
               This example zips up all *.psd files in the "photos" directory that have
               been saved since 2009 February 14th, and puts them all in a zip file,
               using the directory name of "content" in the zip archive itself. When the
               zip archive is unzipped, the folder containing the .psd files will be
               named "content".
            
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.psd  and  mtime &gt; 2009-02-14", "photos", "content");
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile
                 zip.AddSelectedFiles("name = *.psd  and  mtime &gt; 2009-02-14", "photos", "content")
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
            <param name="selectionCriteria">
               The criteria for selection of files to add to the <c>ZipFile</c>.
             </param>
            <param name="directoryOnDisk">
               The path to the directory in the filesystem from which to select files.
             </param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use to in place of the
               <c>directoryOnDisk</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               null (nothing in VB) will use the path on the file name, if any; in other
               words it would use <c>directoryOnDisk</c>, plus any subdirectory.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String,System.Boolean)">
            <summary>
               Adds to the ZipFile a selection of files from the specified directory on
               disk, that conform to the specified criteria, optionally recursing through
               subdirectories, and using a specified root path for entries added to the
               zip archive.
             </summary>
            <remarks>
               This method selects files from the specified disk directory that match the
               specified selection criteria, and adds those files to the ZipFile, using
               the specified directory path in the archive. If <c>recurseDirectories</c>
               is true, files are also selected from subdirectories, and the directory
               structure in the filesystem is reproduced in the zip archive, rooted at
               the directory specified by <c>directoryOnDisk</c>.  For details on the
               syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </remarks>
            <example>
            
               This example zips up all files that are NOT *.pst files, in the current
               working directory and any subdirectories.
            
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true);
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile
                 zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
            <param name="selectionCriteria">
               The criteria for selection of files to add to the <c>ZipFile</c>.
             </param>
            <param name="directoryOnDisk">
               The path to the directory in the filesystem from which to select files.
             </param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use to in place of the
               <c>directoryOnDisk</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               null (nothing in VB) will use the path on the file name, if any; in other
               words it would use <c>directoryOnDisk</c>, plus any subdirectory.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            <param name="recurseDirectories">
               If true, the method also scans subdirectories for files matching the
               criteria.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateSelectedFiles(System.String,System.String,System.String,System.Boolean)">
            <summary>
               Updates the ZipFile with a selection of files from the disk that conform
               to the specified criteria.
             </summary>
            <remarks>
               This method selects files from the specified disk directory that match the
               specified selection criteria, and Updates the <c>ZipFile</c> with those
               files, using the specified directory path in the archive. If
               <c>recurseDirectories</c> is true, files are also selected from
               subdirectories, and the directory structure in the filesystem is
               reproduced in the zip archive, rooted at the directory specified by
               <c>directoryOnDisk</c>.  For details on the syntax for the
               selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </remarks>
            <param name="selectionCriteria">
               The criteria for selection of files to add to the <c>ZipFile</c>.
             </param>
            <param name="directoryOnDisk">
               The path to the directory in the filesystem from which to select files.
             </param>
            <param name="directoryPathInArchive">
               Specifies a directory path to use to in place of the
               <c>directoryOnDisk</c>. This path may, or may not, correspond to a
               real directory in the current filesystem. If the files within the zip
               are later extracted, this is the path used for the extracted file.
               Passing null (nothing in VB) will use the path on the file name, if
               any; in other words it would use <c>directoryOnDisk</c>, plus any
               subdirectory.  Passing the empty string ("") will insert the item at
               the root path within the archive.
             </param>
            <param name="recurseDirectories">
               If true, the method also scans subdirectories for files matching the criteria.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String,System.Boolean)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.SelectEntries(System.String)">
            <summary>
             Retrieve entries from the zipfile by specified criteria.
             </summary>
            <remarks>
                <para>
             This method allows callers to retrieve the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
                <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
                <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
            </remarks>
            <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            <example>
             This example selects all the PhotoShop files from within an archive, and extracts them
             to the current working directory.
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var PhotoShopFiles = zip1.SelectEntries("*.psd");
                 foreach (ZipEntry psd in PhotoShopFiles)
                 {
                     psd.Extract();
                 }
             }
             </code><code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim PhotoShopFiles as ICollection(Of ZipEntry)
                 PhotoShopFiles = zip1.SelectEntries("*.psd")
                 Dim psd As ZipEntry
                 For Each psd In PhotoShopFiles
                     psd.Extract
                 Next
             End Using
             </code></example>
            <param name="selectionCriteria">the string that specifies which entries to select</param>
            <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.SelectEntries(System.String,System.String)">
            <summary>
             Retrieve entries from the zipfile by specified criteria.
             </summary>
            <remarks>
                <para>
             This method allows callers to retrieve the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
                <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
                <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
            </remarks>
            <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            <example>
                <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var UpdatedPhotoShopFiles = zip1.SelectEntries("*.psd", "UpdatedFiles");
                 foreach (ZipEntry e in UpdatedPhotoShopFiles)
                 {
                     // prompt for extract here
                     if (WantExtract(e.FileName))
                         e.Extract();
                 }
             }
             </code>
                <code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim UpdatedPhotoShopFiles As ICollection(Of ZipEntry) = zip1.SelectEntries("*.psd", "UpdatedFiles")
                 Dim e As ZipEntry
                 For Each e In UpdatedPhotoShopFiles
                     ' prompt for extract here
                     If Me.WantExtract(e.FileName) Then
                         e.Extract
                     End If
                 Next
             End Using
             </code>
            </example>
            <param name="selectionCriteria">the string that specifies which entries to select</param>
            <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)">
            <summary>
             Remove entries from the zipfile by specified criteria.
             </summary>
            <remarks>
                <para>
             This method allows callers to remove the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
                <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
                <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
            </remarks>
            <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            <example>
             This example removes all entries in a zip file that were modified prior to January 1st, 2008.
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 // remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01");
                 // don't forget to save the archive!
                 zip1.Save();
             }
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipFileName)
                 ' remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01")
                 ' do not forget to save the archive!
                 zip1.Save
             End Using
             </code></example>
            <param name="selectionCriteria">the string that specifies which entries to select</param>
            <returns>the number of entries removed</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String,System.String)">
            <summary>
             Remove entries from the zipfile by specified criteria, and within the specified
             path in the archive.
             </summary>
            <remarks>
                <para>
             This method allows callers to remove the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
                <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
                <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
            </remarks>
            <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            <example>
                <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 // remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents");
                 // a call to ZipFile.Save will make the modifications permanent
                 zip1.Save();
             }
             </code>
                <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipFileName)
                 ' remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents")
                 ' a call to ZipFile.Save will make the modifications permanent
                 zip1.Save
             End Using
             </code>
            </example>
            <param name="selectionCriteria">the string that specifies which entries to select</param>
            <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            <returns>the number of entries removed</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String)">
            <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            <remarks>
                <para>
             The entries are extracted into the current working directory.
             </para>
                <para>
             If any of the files to be extracted already exist, then the action taken is as
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property on the
             corresponding ZipEntry instance.  By default, the action taken in this case is to
             throw an exception.
             </para>
                <para>
             For information on the syntax of the selectionCriteria string,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
            </remarks>
            <example>
             This example shows how extract all XML files modified after 15 January 2009.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15");
             }
             </code></example>
            <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)">
            <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            <remarks>
                <para>
             The entries are extracted into the current working directory. When extraction would would
             overwrite an existing filesystem file, the action taken is as specified in the
             <paramref name="extractExistingFile" /> parameter.
             </para>
                <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
            </remarks>
            <example>
             This example shows how extract all XML files modified after 15 January 2009,
             overwriting any existing files.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15",
                                          ExtractExistingFileAction.OverwriteSilently);
             }
             </code></example>
            <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String)">
            <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            <remarks>
                <para>
             The entries are selected from the specified directory within the archive, and then
             extracted into the current working directory.
             </para>
                <para>
             If any of the files to be extracted already exist, then the action taken is as
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property on the
             corresponding ZipEntry instance.  By default, the action taken in this case is to
             throw an exception.
             </para>
                <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
            </remarks>
            <example>
             This example shows how extract all XML files modified after 15 January 2009,
             and writes them to the "unpack" directory.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15","unpack");
             }
             </code></example>
            <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String)">
            <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            <remarks>
                <para>
             The entries are extracted into the specified directory. If any of the files to be
             extracted already exist, an exception will be thrown.
             </para>
                <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
            </remarks>
            <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            <param name="directoryInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            <param name="extractDirectory">
             the directory on the disk into which to extract. It will be created
             if it does not exist.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)">
            <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            <remarks>
                <para>
             The entries are extracted into the specified directory. When extraction would would
             overwrite an existing filesystem file, the action taken is as specified in the
             <paramref name="extractExistingFile" /> parameter.
             </para>
                <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
            </remarks>
            <example>
             This example shows how extract all files  with an XML extension or with  a size larger than 100,000 bytes,
             and puts them in the unpack directory.  For any files that already exist in
             that destination directory, they will not be overwritten.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  or  size &gt; 100000",
                                          null,
                                          "unpack",
                                          ExtractExistingFileAction.DontOverwrite);
             }
             </code></example>
            <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            <param name="extractDirectory">
             The directory on the disk into which to extract. It will be created if it does not exist.
             </param>
            <param name="directoryPathInArchive">
             The directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#cctor">
            <summary>
            
            
            Static constructor for ZipFile
            </summary>
            <remarks>
            Code Pages 437 and 1252 for English are same
            Code Page 1252 Windows Latin 1 (ANSI) - <see href="https://msdn.microsoft.com/en-us/library/cc195054.aspx" />
            Code Page 437 MS-DOS Latin US - <see href="https://msdn.microsoft.com/en-us/library/cc195060.aspx" /></remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is numeric 437, also
            known as IBM437.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.GetEnumerator">
            <summary>
             Generic IEnumerator support, for use of a ZipFile in an enumeration.
             </summary>
            <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead
             it is implicitly called when you use a <see langword="foreach" /> loop in C#, or a
             <c>For Each</c> loop in VB.NET.
             </remarks>
            <example>
             This example reads a zipfile of a given name, then enumerates the
             entries in that zip file, and displays the information about each
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code><code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code></example>
            <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.GetNewEnum">
            <summary>
             An IEnumerator, for use of a ZipFile in a foreach construct.
             </summary>
            <remarks>
             This method is included for COM support.  An application generally does not call
             this method directly.  It is called implicitly by COM clients when enumerating
             the entries in the ZipFile instance.  In VBScript, this is done with a <c>For Each</c>
             statement.  In Javascript, this is done with <c>new Enumerator(zipfile)</c>.
             </remarks>
            <returns>
             The IEnumerator over the entries in the ZipFile.
             </returns>
        </member>
        <member name="T:Ionic.Zip.ComHelper">
            <summary>
            This class exposes a set of COM-accessible wrappers for static
            methods available on the ZipFile class.  You don't need this
            class unless you are using DotNetZip from a COM environment.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ComHelper.IsZipFile(System.String)">
            <summary>
             A wrapper for <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String)">ZipFile.IsZipFile(string)</see></summary>
            <param name="filename">The filename to of the zip file to check.</param>
            <returns>true if the file contains a valid zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ComHelper.IsZipFileWithExtract(System.String)">
            <summary>
             A wrapper for <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)">ZipFile.IsZipFile(string, bool)</see></summary>
            <remarks>
            We cannot use "overloaded" Method names in COM interop.
            So, here, we use a unique name.
            </remarks>
            <param name="filename">The filename to of the zip file to check.</param>
            <returns>true if the file contains a valid zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ComHelper.CheckZip(System.String)">
            <summary>
              A wrapper for <see cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)">ZipFile.CheckZip(string)</see></summary>
            <param name="filename">The filename to of the zip file to check.</param>
            <returns>true if the named zip file checks OK. Otherwise, false. </returns>
        </member>
        <member name="M:Ionic.Zip.ComHelper.CheckZipPassword(System.String,System.String)">
            <summary>
              A COM-friendly wrapper for the static method <see cref="M:Ionic.Zip.ZipFile.CheckZipPassword(System.String,System.String)" />.
             </summary>
            <param name="filename">The filename to of the zip file to check.</param>
            <param name="password">The password to check.</param>
            <returns>true if the named zip file checks OK. Otherwise, false. </returns>
        </member>
        <member name="M:Ionic.Zip.ComHelper.FixZipDirectory(System.String)">
            <summary>
             A wrapper for <see cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)">ZipFile.FixZipDirectory(string)</see></summary>
            <param name="filename">The filename to of the zip file to fix.</param>
        </member>
        <member name="M:Ionic.Zip.ComHelper.GetZipLibraryVersion">
            <summary>
             A wrapper for <see cref="P:Ionic.Zip.ZipFile.LibraryVersion">ZipFile.LibraryVersion</see></summary>
            <returns>
             the version number on the DotNetZip assembly, formatted as a string.
            </returns>
        </member>
        <member name="T:Ionic.Zip.EncryptionAlgorithm">
            <summary>
             An enum that provides the various encryption algorithms supported by this
             library.
             </summary>
            <remarks>
                <para>
                    <c>PkzipWeak</c> implies the use of Zip 2.0 encryption, which is known to be
               weak and subvertible.
             </para>
                <para>
               A note on interoperability: Values of <c>PkzipWeak</c> and <c>None</c> are
               specified in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's zip
               specification</see>, and are considered to be "standard".  Zip archives
               produced using these options will be interoperable with many other zip tools
               and libraries, including Windows Explorer.
             </para>
                <para>
               Values of <c>WinZipAes128</c> and <c>WinZipAes256</c> are not part of the Zip
               specification, but rather imply the use of a vendor-specific extension from
               WinZip. If you want to produce interoperable Zip archives, do not use these
               values.  For example, if you produce a zip archive using WinZipAes256, you
               will be able to open it in Windows Explorer on Windows XP and Vista, but you
               will not be able to extract entries; trying this will lead to an "unspecified
               error". For this reason, some people have said that a zip archive that uses
               WinZip's AES encryption is not actually a zip archive at all.  A zip archive
               produced this way will be readable with the WinZip tool (Version 11 and
               beyond).
             </para>
                <para>
               There are other third-party tools and libraries, both commercial and
               otherwise, that support WinZip's AES encryption. These will be able to read
               AES-encrypted zip archives produced by DotNetZip, and conversely applications
               that use DotNetZip to read zip archives will be able to read AES-encrypted
               archives produced by those tools or libraries.  Consult the documentation for
               those other tools and libraries to find out if WinZip's AES encryption is
               supported.
             </para>
                <para>
               In case you care: According to <see href="http://www.winzip.com/aes_info.htm">the WinZip specification</see>, the
               actual AES key used is derived from the <see cref="P:Ionic.Zip.ZipEntry.Password" /> via an
               algorithm that complies with <see href="http://www.ietf.org/rfc/rfc2898.txt">RFC 2898</see>, using an iteration
               count of 1000.  The algorithm is sometimes referred to as PBKDF2, which stands
               for "Password Based Key Derivation Function #2".
             </para>
                <para>
               A word about password strength and length: The AES encryption technology is
               very good, but any system is only as secure as the weakest link.  If you want
               to secure your data, be sure to use a password that is hard to guess.  To make
               it harder to guess (increase its "entropy"), you should make it longer.  If
               you use normal characters from an ASCII keyboard, a password of length 20 will
               be strong enough that it will be impossible to guess.  For more information on
               that, I'd encourage you to read <see href="http://www.redkestrel.co.uk/Articles/RandomPasswordStrength.html">this
               article.</see></para>
                <para>
               The WinZip AES algorithms are not supported with the version of DotNetZip that
               runs on the .NET Compact Framework.  This is because .NET CF lacks the
               HMACSHA1 class that is required for producing the archive.
             </para>
            </remarks>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption at all.
            </summary>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.PkzipWeak">
            <summary>
            Traditional or Classic pkzip encryption.
            </summary>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.WinZipAes128">
            <summary>
            WinZip AES encryption (128 key bits).
            </summary>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.WinZipAes256">
            <summary>
            WinZip AES encryption (256 key bits).
            </summary>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.Unsupported">
            <summary>
            An encryption algorithm that is not supported by DotNetZip.
            </summary>
        </member>
        <member name="T:Ionic.Zip.WriteDelegate">
            <summary>
               Delegate in which the application writes the <c>ZipEntry</c> content for the named entry.
             </summary>
            <param name="entryName">The name of the entry that must be written.</param>
            <param name="stream">The stream to which the entry data should be written.</param>
            <remarks>
               When you add an entry and specify a <c>WriteDelegate</c>, via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)" />, the application
               code provides the logic that writes the entry data directly into the zip file.
             </remarks>
            <example>
            
             This example shows how to define a WriteDelegate that obtains a DataSet, and then
             writes the XML for the DataSet into the zip archive.  There's no need to
             save the XML to a disk file first.
            
             <code lang="C#">
             private void WriteEntry (String filename, Stream output)
             {
                 DataSet ds1 = ObtainDataSet();
                 ds1.WriteXml(output);
             }
            
             private void Run()
             {
                 using (var zip = new ZipFile())
                 {
                     zip.AddEntry(zipEntryName, WriteEntry);
                     zip.Save(zipFileName);
                 }
             }
             </code><code lang="vb">
             Private Sub WriteEntry (ByVal filename As String, ByVal output As Stream)
                 DataSet ds1 = ObtainDataSet()
                 ds1.WriteXml(stream)
             End Sub
            
             Public Sub Run()
                 Using zip = New ZipFile
                     zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
                     zip.Save(zipFileName)
                 End Using
             End Sub
             </code></example>
            <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)" />
        </member>
        <member name="T:Ionic.Zip.OpenDelegate">
            <summary>
               Delegate in which the application opens the stream, just-in-time, for the named entry.
             </summary>
            <param name="entryName">
             The name of the ZipEntry that the application should open the stream for.
             </param>
            <remarks>
               When you add an entry via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />, the application code provides the logic that
               opens and closes the stream for the given ZipEntry.
             </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />
        </member>
        <member name="T:Ionic.Zip.CloseDelegate">
            <summary>
               Delegate in which the application closes the stream, just-in-time, for the named entry.
             </summary>
            <param name="entryName">
             The name of the ZipEntry that the application should close the stream for.
             </param>
            <param name="stream">The stream to be closed.</param>
            <remarks>
               When you add an entry via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />, the application code provides the logic that
               opens and closes the stream for the given ZipEntry.
             </remarks>
            <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />
        </member>
        <member name="T:Ionic.Zip.SetCompressionCallback">
            <summary>
               Delegate for the callback by which the application tells the
               library the CompressionLevel to use for a file.
             </summary>
            <remarks>
                <para>
               Using this callback, the application can, for example, specify that
               previously-compressed files (.mp3, .png, .docx, etc) should use a
               <c>CompressionLevel</c> of <c>None</c>, or can set the compression level based
               on any other factor.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.SetCompression" />
        </member>
        <member name="T:Ionic.Zip.ZipProgressEventType">
            <summary>
              In an EventArgs type, indicates which sort of progress event is being
              reported.
            </summary>
            <remarks>
              There are events for reading, events for saving, and events for
              extracting. This enumeration allows a single EventArgs type to be sued to
              describe one of multiple subevents. For example, a SaveProgress event is
              invoked before, after, and during the saving of a single entry.  The value
              of an enum with this type, specifies which event is being triggered.  The
              same applies to Extraction, Reading and Adding events.
            </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_Started">
            <summary>
            Indicates that a Add() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_AfterAddEntry">
            <summary>
            Indicates that an individual entry in the archive has been added.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_Completed">
            <summary>
            Indicates that a Add() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Started">
            <summary>
            Indicates that a Read() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_BeforeReadEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be read.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_AfterReadEntry">
            <summary>
            Indicates that an individual entry in the archive has just been read.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Completed">
            <summary>
            Indicates that a Read() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_ArchiveBytesRead">
            <summary>
            The given event reports the number of bytes read so far
            during a Read() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Started">
            <summary>
            Indicates that a Save() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be written.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
            <summary>
            Indicates that an individual entry in the archive has just been saved.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Completed">
            <summary>
            Indicates that a Save() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterSaveTempArchive">
            <summary>
            Indicates that the zip archive has been created in a
            temporary location during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeRenameTempArchive">
            <summary>
            Indicates that the temporary file is about to be renamed to the final archive
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterRenameTempArchive">
            <summary>
            Indicates that the temporary file is has just been renamed to the final archive
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterCompileSelfExtractor">
            <summary>
            Indicates that the self-extracting archive has been compiled
            during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
            <summary>
            The given event is reporting the number of source bytes that have run through the compressor so far
            during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractEntry">
            <summary>
            Indicates that an entry is about to be extracted.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractEntry">
            <summary>
            Indicates that an entry has just been extracted.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite">
            <summary>
              Indicates that extraction of an entry would overwrite an existing
              filesystem file. You must use
              <see cref="F:Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
              ExtractExistingFileAction.InvokeExtractProgressEvent</see> in the call
              to <c>ZipEntry.Extract()</c> in order to receive this event.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_EntryBytesWritten">
            <summary>
              The given event is reporting the number of bytes written so far for
              the current entry during an Extract() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractAll">
            <summary>
            Indicates that an ExtractAll operation is about to begin.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractAll">
            <summary>
            Indicates that an ExtractAll operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Error_Saving">
            <summary>
            Indicates that an error has occurred while saving a zip file.
            This generally means the file cannot be opened, because it has been
            removed, or because it is locked by another process.  It can also
            mean that the file cannot be Read, because of a range lock conflict.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipProgressEventArgs">
            <summary>
            Provides information about the progress of a save, read, or extract operation.
            This is a base class; you will probably use one of the classes derived from this one.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.EntriesTotal">
            <summary>
            The total number of entries to be saved or extracted.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.CurrentEntry">
            <summary>
            The name of the last entry saved or extracted.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.Cancel">
            <summary>
            In an event handler, set this to cancel the save or extract
            operation that is in progress.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.EventType">
            <summary>
            The type of event being reported.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.ArchiveName">
            <summary>
            Returns the archive name associated to this event.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.BytesTransferred">
            <summary>
            The number of bytes read or written so far for this entry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.TotalBytesToTransfer">
            <summary>
            Total number of bytes that will be read or written for this entry.
            This number will be -1 if the value cannot be determined.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ReadProgressEventArgs">
            <summary>
            Provides information about the progress of a Read operation.
            </summary>
        </member>
        <member name="T:Ionic.Zip.AddProgressEventArgs">
            <summary>
            Provides information about the progress of a Add operation.
            </summary>
        </member>
        <member name="T:Ionic.Zip.SaveProgressEventArgs">
            <summary>
            Provides information about the progress of a save operation.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SaveProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry)">
            <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesSaved">Number of entries that have been saved.</param>
            <param name="entry">The entry involved in the event.</param>
        </member>
        <member name="P:Ionic.Zip.SaveProgressEventArgs.EntriesSaved">
            <summary>
            Number of entries saved so far.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ExtractProgressEventArgs">
            <summary>
            Provides information about the progress of the extract operation.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ExtractProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry,System.String)">
            <summary>
            Constructor for the ExtractProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesExtracted">Number of entries that have been extracted.</param>
            <param name="entry">The entry involved in the event.</param>
            <param name="extractLocation">The location to which entries are extracted.</param>
        </member>
        <member name="P:Ionic.Zip.ExtractProgressEventArgs.EntriesExtracted">
            <summary>
            Number of entries extracted so far.  This is set only if the
            EventType is Extracting_BeforeExtractEntry or Extracting_AfterExtractEntry, and
            the Extract() is occurring witin the scope of a call to ExtractAll().
            </summary>
        </member>
        <member name="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation">
            <summary>
            Returns the extraction target location, a filesystem path.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipErrorEventArgs">
            <summary>
            Provides information about the an error that occurred while zipping.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipErrorEventArgs.Exception">
            <summary>
            Returns the exception that occurred, if any.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipErrorEventArgs.FileName">
            <summary>
            Returns the name of the file that caused the exception, if any.
            </summary>
        </member>
        <member name="T:Ionic.Zip.BadPasswordException">
            <summary>
            Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
            with an incorrect password.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadReadException">
            <summary>
            Indicates that a read was attempted on a stream, and bad or incomplete data was
            received.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadCrcException">
            <summary>
            Issued when an CRC check fails upon extracting an entry from a zip archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.SfxGenerationException">
            <summary>
            Issued when errors occur saving a self-extracting archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadStateException">
            <summary>
            Indicates that an operation was attempted on a ZipFile which was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile
            which has no filename set, you can get this exception.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.ZipException">
            <summary>
            Base class for all exceptions defined by and throw by the Zip library.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.ExtractExistingFileAction">
            <summary>
             An enum for the options when extracting an entry would overwrite an existing file. 
             </summary>
            <remarks>
                <para>
                 This enum describes the actions that the library can take when an
                 <c>Extract()</c> or <c>ExtractWithPassword()</c> method is called to extract an
                 entry to a filesystem, and the extraction would overwrite an existing filesystem
                 file.
               </para>
            </remarks>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.Throw">
            <summary>
            Throw an exception when extraction would overwrite an existing file. (For
            COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.OverwriteSilently">
            <summary>
            When extraction would overwrite an existing file, overwrite the file silently.
            The overwrite will happen even if the target file is marked as read-only.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.DoNotOverwrite">
            <summary>
            When extraction would overwrite an existing file, don't overwrite the file, silently. 
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
            <summary>
            When extraction would overwrite an existing file, invoke the ExtractProgress
            event, using an event type of <see cref="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite" />.  In
            this way, the application can decide, just-in-time, whether to overwrite the
            file. For example, a GUI application may wish to pop up a dialog to allow
            the user to choose. You may want to examine the <see cref="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation" /> property before making
            the decision. If, after your processing in the Extract progress event, you
            want to NOT extract the file, set <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
            on the <c>ZipProgressEventArgs.CurrentEntry</c> to <c>DoNotOverwrite</c>.
            If you do want to extract the file, set <c>ZipEntry.ExtractExistingFile</c>
            to <c>OverwriteSilently</c>.  If you want to cancel the Extraction, set
            <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
            DoNotOverwrite in that a cancel will not extract any further entries, if
            there are any.  (For COM clients, the value of this enum is a 3.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.SharedUtilities">
            <summary>
            Collects general purpose utility methods.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.GetFileLength(System.String)">
            private null constructor
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.NormalizePathForUseInZipFile(System.String)">
            <summary>
            Utility routine for transforming path names from filesystem format (on Windows that means backslashes) to
            a format suitable for use within zipfiles. This means trimming the volume letter and colon (if any) And
            swapping backslashes for forward slashes.
            </summary>
            <param name="pathName">source path.</param>
            <returns>transformed path</returns>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.SanitizePath(System.String)">
            <summary>
            Sanitize paths in zip files. This means making sure that relative paths in a zip file don't go outside
            the top directory. Entries like something/../../../../Temp/evil.txt get sanitized to Temp/evil.txt
            when extracting
            </summary>
            <param name="path">A path with forward slashes as directory separator</param>
            <returns>sanitized path</returns>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.FindSignature(System.IO.Stream,System.Int32)">
            <summary>
               Finds a signature in the zip stream. This is useful for finding
               the end of a zip entry, for example, or the beginning of the next ZipEntry.
             </summary>
            <remarks>
                <para>
                 Scans through 64k at a time.
               </para>
                <para>
                 If the method fails to find the requested signature, the stream Position
                 after completion of this method is unchanged. If the method succeeds in
                 finding the requested signature, the stream position after completion is
                 direct AFTER the signature found in the stream.
               </para>
            </remarks>
            <param name="stream">The stream to search</param>
            <param name="SignatureToFind">The 4-byte signature to find</param>
            <returns>The number of bytes read</returns>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.CreateAndOpenUniqueTempFile(System.String,System.IO.Stream@,System.String@)">
            <summary>
              Create a pseudo-random filename, suitable for use as a temporary
              file, and open it.
            </summary>
            <remarks>
                <para>
              The System.IO.Path.GetRandomFileName() method is not available on
              the Compact Framework, so this library provides its own substitute
              on NETCF.
            </para>
                <para>
              This method produces a filename of the form
              DotNetZip-xxxxxxxx.tmp, where xxxxxxxx is replaced by randomly
              chosen characters, and creates that file.
            </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.ReadWithRetry(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.String)">
            <summary>
            Workitem 7889: handle ERROR_LOCK_VIOLATION during read
            </summary>
            <remarks>
            This could be gracefully handled with an extension attribute, but
            This assembly is built for .NET 2.0, so I cannot use them.
            </remarks>
        </member>
        <member name="T:Ionic.Zip.CountingStream">
            <summary>
              A decorator stream. It wraps another stream, and performs bookkeeping
              to keep track of the stream Position.
            </summary>
            <remarks>
                <para>
                In some cases, it is not possible to get the Position of a stream, let's
                say, on a write-only output stream like ASP.NET's
                <c>Response.OutputStream</c>, or on a different write-only stream
                provided as the destination for the zip by the application.  In this
                case, programmers can use this counting stream to count the bytes read
                or written.
              </para>
                <para>
                Consider the scenario of an application that saves a self-extracting
                archive (SFX), that uses a custom SFX stub.
              </para>
                <para>
                Saving to a filesystem file, the application would open the
                filesystem file (getting a <c>FileStream</c>), save the custom sfx stub
                into it, and then call <c>ZipFile.Save()</c>, specifying the same
                FileStream. <c>ZipFile.Save()</c> does the right thing for the zipentry
                offsets, by inquiring the Position of the <c>FileStream</c> before writing
                any data, and then adding that initial offset into any ZipEntry
                offsets in the zip directory. Everything works fine.
              </para>
                <para>
                Now suppose the application is an ASPNET application and it saves
                directly to <c>Response.OutputStream</c>. It's not possible for DotNetZip to
                inquire the <c>Position</c>, so the offsets for the SFX will be wrong.
              </para>
                <para>
                The workaround is for the application to use this class to wrap
                <c>HttpResponse.OutputStream</c>, then write the SFX stub and the ZipFile
                into that wrapper stream. Because <c>ZipFile.Save()</c> can inquire the
                <c>Position</c>, it will then do the right thing with the offsets.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.CountingStream.#ctor(System.IO.Stream)">
            <summary>
            The constructor.
            </summary>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="P:Ionic.Zip.CountingStream.WrappedStream">
            <summary>
              Gets the wrapped stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.BytesWritten">
            <summary>
              The count of bytes written out to the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.BytesRead">
            <summary>
              the count of bytes that have been read from the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Adjust(System.Int64)">
            <summary>
                Adjust the byte count on the stream.
             </summary>
            <param name="delta">
               the number of bytes to subtract from the count.
             </param>
            <remarks>
                <para>
                 Subtract delta from the count of bytes written to the stream.
                 This is necessary when seeking back, and writing additional data,
                 as happens in some cases when saving Zip files.
               </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              The read method.
            </summary>
            <param name="buffer">The buffer to hold the data read from the stream.</param>
            <param name="offset">the offset within the buffer to copy the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
            <returns>the number of bytes read, after decryption and decompression.</returns>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Write data into the stream.
            </summary>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="P:Ionic.Zip.CountingStream.CanRead">
            <summary>
              Whether the stream can be read.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.CanSeek">
            <summary>
              Whether it is possible to call Seek() on the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.CanWrite">
            <summary>
              Whether it is possible to call Write() on the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Flush">
            <summary>
              Flushes the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.Length">
            <summary>
              The length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.ComputedPosition">
            <summary>
              Returns the sum of number of bytes written, plus the initial
              offset before writing.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.Position">
            <summary>
              The Position of the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Seek in the stream.
            </summary>
            <param name="offset">the offset point to seek to</param>
            <param name="origin">the reference point from which to seek</param>
            <returns>The new position</returns>
        </member>
        <member name="M:Ionic.Zip.CountingStream.SetLength(System.Int64)">
            <summary>
               Set the length of the underlying stream.  Be careful with this!
             </summary>
            <param name="value">the length to set on the underlying stream.</param>
        </member>
        <member name="T:Ionic.Zip.WinZipAesCrypto">
            <summary>
               This is a helper class supporting WinZip AES encryption.
               This class is intended for use only by the DotNetZip library.
             </summary>
            <remarks>
               Most uses of the DotNetZip library will not involve direct calls into
               the WinZipAesCrypto class.  Instead, the WinZipAesCrypto class is
               instantiated and used by the ZipEntry() class when WinZip AES
               encryption or decryption on an entry is employed.
             </remarks>
        </member>
        <member name="T:Ionic.Zip.WinZipAesCipherStream">
            <summary>
               A stream that encrypts as it writes, or decrypts as it reads.  The
               Crypto is AES in CTR (counter) mode, which is compatible with the AES
               encryption employed by WinZip 12.0.
             </summary>
            <remarks>
                <para>
                 The AES/CTR encryption protocol used by WinZip works like this:
            
                   - start with a counter, initialized to zero.
            
                   - to encrypt, take the data by 16-byte blocks. For each block:
                     - apply the transform to the counter
                     - increement the counter
                     - XOR the result of the transform with the plaintext to
                       get the ciphertext.
                     - compute the mac on the encrypted bytes
                   - when finished with all blocks, store the computed MAC.
            
                   - to decrypt, take the data by 16-byte blocks. For each block:
                     - compute the mac on the encrypted bytes,
                     - apply the transform to the counter
                     - increement the counter
                     - XOR the result of the transform with the ciphertext to
                       get the plaintext.
                   - when finished with all blocks, compare the computed MAC against
                     the stored MAC
            
               </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.WinZipAesCipherStream.#ctor(System.IO.Stream,Ionic.Zip.WinZipAesCrypto,System.Int64,Ionic.Zip.CryptoMode)">
            <summary>
            The constructor.
            </summary>
            <param name="s">The underlying stream</param>
            <param name="mode">To either encrypt or decrypt.</param>
            <param name="cryptoParams">The pre-initialized WinZipAesCrypto object.</param>
            <param name="length">The maximum number of bytes to read from the stream.</param>
        </member>
        <member name="P:Ionic.Zip.WinZipAesCipherStream.FinalAuthentication">
            <summary>
            Returns the final HMAC-SHA1-80 for the data that was encrypted.
            </summary>
        </member>
        <member name="M:Ionic.Zip.WinZipAesCipherStream.Close">
            <summary>
              Close the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.WinZipAesCipherStream.CanRead">
            <summary>
            Returns true if the stream can be read.
            </summary>
        </member>
        <member name="P:Ionic.Zip.WinZipAesCipherStream.CanSeek">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.WinZipAesCipherStream.CanWrite">
            <summary>
            Returns true if the CryptoMode is Encrypt.
            </summary>
        </member>
        <member name="M:Ionic.Zip.WinZipAesCipherStream.Flush">
            <summary>
            Flush the content in the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.WinZipAesCipherStream.Length">
            <summary>
            Getting this property throws a NotImplementedException.
            </summary>
        </member>
        <member name="P:Ionic.Zip.WinZipAesCipherStream.Position">
            <summary>
            Getting or Setting this property throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:Ionic.Zip.WinZipAesCipherStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:Ionic.Zip.WinZipAesCipherStream.SetLength(System.Int64)">
            <summary>
            This method throws a NotImplementedException.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipCrypto">
            <summary>
               This class implements the "traditional" or "classic" PKZip encryption,
               which today is considered to be weak. On the other hand it is
               ubiquitous. This class is intended for use only by the DotNetZip
               library.
             </summary>
            <remarks>
               Most uses of the DotNetZip library will not involve direct calls into
               the ZipCrypto class.  Instead, the ZipCrypto class is instantiated and
               used by the ZipEntry() class when encryption or decryption on an entry
               is employed.  If for some reason you really wanted to use a weak
               encryption algorithm in some other application, you might use this
               library.  But you would be much better off using one of the built-in
               strong encryption libraries in the .NET Framework, like the AES
               algorithm or SHA.
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.#ctor">
            <summary>
               The default constructor for ZipCrypto.
             </summary>
            <remarks>
               This class is intended for internal use by the library only. It's
               probably not useful to you. Seriously.  Stop reading this
               documentation.  It's a waste of your time.  Go do something else.
               Check the football scores. Go get an ice cream with a friend.
               Seriously.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipCrypto.MagicByte">
            <summary>
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            end decrypt_byte
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
            <summary>
               Call this method on a cipher text to render the plaintext. You must
               first initialize the cipher with a call to InitCipher.
             </summary>
            <example>
                <code>
                 var cipher = new ZipCrypto();
                 cipher.InitCipher(Password);
                 // Decrypt the header.  This has a side effect of "further initializing the
                 // encryption keys" in the traditional zip encryption.
                 byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
               </code>
            </example>
            <param name="cipherText">The encrypted buffer.</param>
            <param name="length">
               The number of bytes to encrypt.
               Should be less than or equal to CipherText.Length.
             </param>
            <returns>The plaintext.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
            <summary>
               This is the converse of DecryptMessage.  It encrypts the plaintext
               and produces a ciphertext.
             </summary>
            <param name="plainText">The plain text buffer.</param>
            <param name="length">
               The number of bytes to encrypt.
               Should be less than or equal to plainText.Length.
             </param>
            <returns>The ciphertext.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.InitCipher(System.String)">
            <summary>
               This initializes the cipher with the given password.
               See AppNote.txt for details.
             </summary>
            <param name="passphrase">
               The passphrase for encrypting or decrypting with this cipher.
             </param>
            <remarks>
                <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
            
             Then, initialize the keys with a password:
            
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             end loop
            
             Where update_keys() is defined as:
            
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             end update_keys
            
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
                <para>
               After the keys are initialized, then you can use the cipher to
               encrypt the plaintext.
             </para>
                <para>
               Essentially we encrypt the password with the keys, then discard the
               ciphertext for the password. This initializes the keys for later use.
             </para>
            </remarks>
        </member>
        <member name="T:Ionic.Zip.ZipCipherStream">
            <summary>
              A Stream for reading and concurrently decrypting data from a zip file,
              or for writing and concurrently encrypting data to a zip file.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipCipherStream.#ctor(System.IO.Stream,Ionic.Zip.ZipCrypto,Ionic.Zip.CryptoMode)">
            <summary>  The constructor. </summary>
            <param name="s">The underlying stream</param>
            <param name="mode">To either encrypt or decrypt.</param>
            <param name="cipher">The pre-initialized ZipCrypto object.</param>
        </member>
        <member name="T:Ionic.Zip.ZipEntry">
            <summary>
            Represents a single entry in a ZipFile. Typically, applications get a ZipEntry
            by enumerating the entries within a ZipFile, or by adding an entry to a ZipFile.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AttributesIndicateDirectory">
            <summary>
            True if the referenced entry is a directory.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Info">
            <summary>
            Provides a human-readable string with information about the ZipEntry.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ReadDirEntry(Ionic.Zip.ZipFile,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
               Reads one entry from the zip directory structure in the zip file.
             </summary>
            <param name="zf">
               The zipfile for which a directory entry will be read.  From this param, the
               method gets the ReadStream and the expected text encoding
               (ProvisionalAlternateEncoding) which is used if the entry is not marked
               UTF-8.
             </param>
            <param name="previouslySeen">
               a list of previously seen entry names; used to prevent duplicates.
             </param>
            <returns>the entry read from the archive.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.IsNotValidZipDirEntrySig(System.Int32)">
            <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry.
            </summary>
            <param name="signature">the candidate 4-byte signature value.</param>
            <returns>true, if the signature is valid according to the PKWare spec.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>
            Applications should never need to call this directly.  It is exposed to
            support COM Automation environments.
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.LastModified">
            <summary>
               The time and date at which the file indicated by the <c>ZipEntry</c> was
               last modified.
             </summary>
            <remarks>
                <para>
               The DotNetZip library sets the LastModified value for an entry, equal to
               the Last Modified time of the file in the filesystem.  If an entry is
               added from a stream, the library uses <c>System.DateTime.Now</c> for this
               value, for the given entry.
             </para>
                <para>
               This property allows the application to retrieve and possibly set the
               LastModified value on an entry, to an arbitrary value.  <see cref="T:System.DateTime" /> values with a <see cref="T:System.DateTimeKind" />
               setting of <c>DateTimeKind.Unspecified</c> are taken to be expressed as
               <c>DateTimeKind.Local</c>.
             </para>
                <para>
               Be aware that because of the way <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
               Zip specification</see> describes how times are stored in the zip file,
               the full precision of the <c>System.DateTime</c> datatype is not stored
               for the last modified time when saving zip files.  For more information on
               how times are formatted, see the PKZip specification.
             </para>
                <para>
               The actual last modified time of a file can be stored in multiple ways in
               the zip file, and they are not mutually exclusive:
             </para>
                <list type="bullet">
                    <item>
                 In the so-called "DOS" format, which has a 2-second precision. Values
                 are rounded to the nearest even second. For example, if the time on the
                 file is 12:34:43, then it will be stored as 12:34:44. This first value
                 is accessible via the <c>LastModified</c> property. This value is always
                 present in the metadata for each zip entry.  In some cases the value is
                 invalid, or zero.
               </item>
                    <item>
                 In the so-called "Windows" or "NTFS" format, as an 8-byte integer
                 quantity expressed as the number of 1/10 milliseconds (in other words
                 the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
                 format is how Windows represents file times.  This time is accessible
                 via the <c>ModifiedTime</c> property.
               </item>
                    <item>
                 In the "Unix" format, a 4-byte quantity specifying the number of seconds since
                 January 1, 1970 UTC.
               </item>
                    <item>
                 In an older format, now deprecated but still used by some current
                 tools. This format is also a 4-byte quantity specifying the number of
                 seconds since January 1, 1970 UTC.
               </item>
                </list>
                <para>
               Zip tools and libraries will always at least handle (read or write) the
               DOS time, and may also handle the other time formats.  Keep in mind that
               while the names refer to particular operating systems, there is nothing in
               the time formats themselves that prevents their use on other operating
               systems.
             </para>
                <para>
               When reading ZIP files, the DotNetZip library reads the Windows-formatted
               time, if it is stored in the entry, and sets both <c>LastModified</c> and
               <c>ModifiedTime</c> to that value. When writing ZIP files, the DotNetZip
               library by default will write both time quantities. It can also emit the
               Unix-formatted time if desired (See <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />.)
             </para>
                <para>
               The last modified time of the file created upon a call to
               <c>ZipEntry.Extract()</c> may be adjusted during extraction to compensate
               for differences in how the .NET Base Class Library deals with daylight
               saving time (DST) versus how the Windows filesystem deals with daylight
               saving time.  Raymond Chen <see href="http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx">provides
               some good context</see>.
             </para>
                <para>
               In a nutshell: Daylight savings time rules change regularly.  In 2007, for
               example, the inception week of DST changed.  In 1977, DST was in place all
               year round. In 1945, likewise.  And so on.  Win32 does not attempt to
               guess which time zone rules were in effect at the time in question.  It
               will render a time as "standard time" and allow the app to change to DST
               as necessary.  .NET makes a different choice.
             </para>
                <para>
               Compare the output of FileInfo.LastWriteTime.ToString("f") with what you
               see in the Windows Explorer property sheet for a file that was last
               written to on the other side of the DST transition. For example, suppose
               the file was last modified on October 17, 2003, during DST but DST is not
               currently in effect. Explorer's file properties reports Thursday, October
               17, 2003, 8:45:38 AM, but .NETs FileInfo reports Thursday, October 17,
               2003, 9:45 AM.
             </para>
                <para>
               Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note: Pacific
               STANDARD Time. Even though October 17 of that year occurred during Pacific
               Daylight Time, Win32 displays the time as standard time because that's
               what time it is NOW.
             </para>
                <para>
               .NET BCL assumes that the current DST rules were in place at the time in
               question.  So, .NET says, "Well, if the rules in effect now were also in
               effect on October 17, 2003, then that would be daylight time" so it
               displays "Thursday, October 17, 2003, 9:45 AM PDT" - daylight time.
             </para>
                <para>
               So .NET gives a value which is more intuitively correct, but is also
               potentially incorrect, and which is not invertible. Win32 gives a value
               which is intuitively incorrect, but is strictly correct.
             </para>
                <para>
               Because of this funkiness, this library adds one hour to the LastModified
               time on the extracted file, if necessary.  That is to say, if the time in
               question had occurred in what the .NET Base Class Library assumed to be
               DST. This assumption may be wrong given the constantly changing DST rules,
               but it is the best we can do.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.DontEmitLastModified">
            <summary>
            Ability to set Last Modified DOS time to zero
            (for using with EmitTimesInWindowsFormatWhenSaving+EmitTimesInUnixFormatWhenSaving setted to false)
            some flasher hardware use as marker of first binary
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ModifiedTime">
            <summary>
             Last Modified time for the file represented by the entry.
             </summary>
            <remarks>
                <para>
               This value corresponds to the "last modified" time in the NTFS file times
               as described in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>.  When getting this property, the value may be
               different from <see cref="P:Ionic.Zip.ZipEntry.LastModified" />.  When setting the property,
               the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property also gets set, but with a lower
               precision.
             </para>
                <para>
               Let me explain. It's going to take a while, so get
               comfortable. Originally, waaaaay back in 1989 when the ZIP specification
               was originally described by the esteemed Mr. Phil Katz, the dominant
               operating system of the time was MS-DOS. MSDOS stored file times with a
               2-second precision, because, c'mon, <em>who is ever going to need better
               resolution than THAT?</em> And so ZIP files, regardless of the platform on
               which the zip file was created, store file times in exactly <see href="http://www.vsft.com/hal/dostime.htm">the same format that DOS used
               in 1989</see>.
             </para>
                <para>
               Since then, the ZIP spec has evolved, but the internal format for file
               timestamps remains the same.  Despite the fact that the way times are
               stored in a zip file is rooted in DOS heritage, any program on any
               operating system can format a time in this way, and most zip tools and
               libraries DO - they round file times to the nearest even second and store
               it just like DOS did 25+ years ago.
             </para>
                <para>
               PKWare extended the ZIP specification to allow a zip file to store what
               are called "NTFS Times" and "Unix(tm) times" for a file.  These are the
               <em>last write</em>, <em>last access</em>, and <em>file creation</em>
               times of a particular file. These metadata are not actually specific
               to NTFS or Unix. They are tracked for each file by NTFS and by various
               Unix filesystems, but they are also tracked by other filesystems, too.
               The key point is that the times are <em>formatted in the zip file</em>
               in the same way that NTFS formats the time (ticks since win32 epoch),
               or in the same way that Unix formats the time (seconds since Unix
               epoch). As with the DOS time, any tool or library running on any
               operating system is capable of formatting a time in one of these ways
               and embedding it into the zip file.
             </para>
                <para>
               These extended times are higher precision quantities than the DOS time.
               As described above, the (DOS) LastModified has a precision of 2 seconds.
               The Unix time is stored with a precision of 1 second. The NTFS time is
               stored with a precision of 0.0000001 seconds. The quantities are easily
               convertible, except for the loss of precision you may incur.
             </para>
                <para>
               A zip archive can store the {C,A,M} times in NTFS format, in Unix format,
               or not at all.  Often a tool running on Unix or Mac will embed the times
               in Unix format (1 second precision), while WinZip running on Windows might
               embed the times in NTFS format (precision of of 0.0000001 seconds).  When
               reading a zip file with these "extended" times, in either format,
               DotNetZip represents the values with the
               <c>ModifiedTime</c>, <c>AccessedTime</c> and <c>CreationTime</c>
               properties on the <c>ZipEntry</c>.
             </para>
                <para>
               While any zip application or library, regardless of the platform it
               runs on, could use any of the time formats allowed by the ZIP
               specification, not all zip tools or libraries do support all these
               formats.  Storing the higher-precision times for each entry is
               optional for zip files, and many tools and libraries don't use the
               higher precision quantities at all. The old DOS time, represented by
               <see cref="P:Ionic.Zip.ZipEntry.LastModified" />, is guaranteed to be present, though it
               sometimes unset.
             </para>
                <para>
               Ok, getting back to the question about how the <c>LastModified</c>
               property relates to this <c>ModifiedTime</c>
               property... <c>LastModified</c> is always set, while
               <c>ModifiedTime</c> is not. (The other times stored in the <em>NTFS
               times extension</em>, <c>CreationTime</c> and <c>AccessedTime</c> also
               may not be set on an entry that is read from an existing zip file.)
               When reading a zip file, then <c>LastModified</c> takes the DOS time
               that is stored with the file. If the DOS time has been stored as zero
               in the zipfile, then this library will use <c>DateTime.Now</c> for the
               <c>LastModified</c> value.  If the ZIP file was created by an evolved
               tool, then there will also be higher precision NTFS or Unix times in
               the zip file.  In that case, this library will read those times, and
               set <c>LastModified</c> and <c>ModifiedTime</c> to the same value, the
               one corresponding to the last write time of the file.  If there are no
               higher precision times stored for the entry, then <c>ModifiedTime</c>
               remains unset (likewise <c>AccessedTime</c> and <c>CreationTime</c>),
               and <c>LastModified</c> keeps its DOS time.
             </para>
                <para>
               When creating zip files with this library, by default the extended time
               properties (<c>ModifiedTime</c>, <c>AccessedTime</c>, and
               <c>CreationTime</c>) are set on the ZipEntry instance, and these data are
               stored in the zip archive for each entry, in NTFS format. If you add an
               entry from an actual filesystem file, then the entry gets the actual file
               times for that file, to NTFS-level precision.  If you add an entry from a
               stream, or a string, then the times get the value <c>DateTime.Now</c>.  In
               this case <c>LastModified</c> and <c>ModifiedTime</c> will be identical,
               to 2 seconds of precision.  You can explicitly set the
               <c>CreationTime</c>, <c>AccessedTime</c>, and <c>ModifiedTime</c> of an
               entry using the property setters.  If you want to set all of those
               quantities, it's more efficient to use the <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" /> method.  Those
               changes are not made permanent in the zip file until you call <see cref="M:Ionic.Zip.ZipFile.Save" /> or one of its cousins.
             </para>
                <para>
               When creating a zip file, you can override the default behavior of
               this library for formatting times in the zip file, disabling the
               embedding of file times in NTFS format or enabling the storage of file
               times in Unix format, or both.  You may want to do this, for example,
               when creating a zip file on Windows, that will be consumed on a Mac,
               by an application that is not hip to the "NTFS times" format. To do
               this, use the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" /> and
               <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" /> properties.  A valid zip
               file may store the file times in both formats.  But, there are no
               guarantees that a program running on Mac or Linux will gracefully
               handle the NTFS-formatted times when Unix times are present, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. DotNetZip will always do something
               reasonable; other libraries or tools may not. When in doubt, test.
             </para>
                <para>
               I'll bet you didn't think one person could type so much about time, eh?
               And reading it was so enjoyable, too!  Well, in appreciation, <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">maybe you
               should donate</see>?
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime" />
            <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime" />
            <seealso cref="P:Ionic.Zip.ZipEntry.LastModified" />
            <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AccessedTime">
            <summary>
            Last Access time for the file represented by the entry.
            </summary>
            <remarks>
            This value may or may not be meaningful.  If the <c>ZipEntry</c> was read from an existing
            Zip archive, this information may not be available. For an explanation of why, see
            <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />.
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />
            <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime" />
            <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CreationTime">
            <summary>
             The file creation time for the file represented by the entry.
             </summary>
            <remarks>
             This value may or may not be meaningful.  If the <c>ZipEntry</c> was read
             from an existing zip archive, and the creation time was not set on the entry
             when the zip file was created, then this property may be meaningless. For an
             explanation of why, see <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />.
             </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />
            <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime" />
            <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />
        </member>
        <member name="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)">
            <summary>
               Sets the NTFS Creation, Access, and Modified times for the given entry.
             </summary>
            <remarks>
                <para>
               When adding an entry from a file or directory, the Creation, Access, and
               Modified times for the given entry are automatically set from the
               filesystem values. When adding an entry from a stream or string, the
               values are implicitly set to DateTime.Now.  The application may wish to
               set these values to some arbitrary value, before saving the archive, and
               can do so using the various setters.  If you want to set all of the times,
               this method is more efficient.
             </para>
                <para>
               The values you set here will be retrievable with the <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />, <see cref="P:Ionic.Zip.ZipEntry.CreationTime" /> and <see cref="P:Ionic.Zip.ZipEntry.AccessedTime" /> properties.
             </para>
                <para>
               When this method is called, if both <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" /> and <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" /> are false, then the
               <c>EmitTimesInWindowsFormatWhenSaving</c> flag is automatically set.
             </para>
                <para>
               DateTime values provided here without a DateTimeKind are assumed to be Local Time.
             </para>
            </remarks>
            <param name="created">the creation time of the entry.</param>
            <param name="accessed">the last access time of the entry.</param>
            <param name="modified">the last modified time of the entry.</param>
            <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
            <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
            <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime" />
            <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime" />
            <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving">
            <summary>
               Specifies whether the Creation, Access, and Modified times for the given
               entry will be emitted in "Windows format" when the zip archive is saved.
             </summary>
            <remarks>
                <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entry should or should not be stored
               in the zip archive in the format used by Windows. The default value of
               this property is <c>true</c>.
             </para>
                <para>
               When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime" />), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />), and Modified
               (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />) times for the given entry are automatically
               set from the filesystem values. When adding an entry from a stream or
               string, all three values are implicitly set to DateTime.Now.  Applications
               can also explicitly set those times by calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
             </para>
                <para>
                    <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since Jan 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since January 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455.
             </para>
                <para>
               Not all zip tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Although the time values are
               easily convertible, subject to a loss of precision, some tools and
               libraries may be able to read only one or the other. DotNetZip can read or
               write times in either or both formats.
             </para>
                <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime" />.
             </para>
                <para>
               This property is not mutually exclusive from the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" /> property.  It is
               possible that a zip entry can embed the timestamps in both forms, one
               form, or neither.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle NTFS Formatted times, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. When in doubt, test.
             </para>
                <para>
               Normally you will use the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">ZipFile.EmitTimesInWindowsFormatWhenSaving</see>
               property, to specify the behavior for all entries in a zip, rather than
               the property on each individual entry.
             </para>
            </remarks>
            <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />
            <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
            <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime" />
            <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime" />
            <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving">
            <summary>
               Specifies whether the Creation, Access, and Modified times for the given
               entry will be emitted in "Unix(tm) format" when the zip archive is saved.
             </summary>
            <remarks>
                <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entry should or should not be stored
               in the zip archive in the format used by Unix. By default this flag is
               <c>false</c>, meaning the Unix-format times are not stored in the zip
               archive.
             </para>
                <para>
               When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime" />), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />), and Modified
               (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />) times for the given entry are automatically
               set from the filesystem values. When adding an entry from a stream or
               string, all three values are implicitly set to DateTime.Now.  Applications
               can also explicitly set those times by calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
             </para>
                <para>
                    <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since Jan 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455.
             </para>
                <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Although the time values are
               easily convertible, subject to a loss of precision, some tools and
               libraries may be able to read only one or the other. DotNetZip can read or
               write times in either or both formats.
             </para>
                <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime" />, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime" />.
             </para>
                <para>
               This property is not mutually exclusive from the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" /> property.  It is
               possible that a zip entry can embed the timestamps in both forms, one
               form, or neither.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle NTFS Formatted times, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. When in doubt, test.
             </para>
                <para>
               Normally you will use the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">ZipFile.EmitTimesInUnixFormatWhenSaving</see>
               property, to specify the behavior for all entries, rather than the
               property on each individual entry.
             </para>
            </remarks>
            <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />
            <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
            <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving" />
            <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime" />
            <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime" />
            <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Timestamp">
            <summary>
             The type of timestamp attached to the ZipEntry.
             </summary>
            <remarks>
             This property is valid only for a ZipEntry that was read from a zip archive.
             It indicates the type of timestamp attached to the entry.
             </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
            <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Attributes">
            <summary>
               The file attributes for the entry.
             </summary>
            <remarks>
                <para>
               The <see cref="T:System.IO.FileAttributes">attributes</see> in NTFS include
               ReadOnly, Archive, Hidden, System, and Indexed.  When adding a
               <c>ZipEntry</c> to a ZipFile, these attributes are set implicitly when
               adding an entry from the filesystem.  When adding an entry from a stream
               or string, the Attributes are not set implicitly.  Regardless of the way
               an entry was added to a <c>ZipFile</c>, you can set the attributes
               explicitly if you like.
             </para>
                <para>
               When reading a <c>ZipEntry</c> from a <c>ZipFile</c>, the attributes are
               set according to the data stored in the <c>ZipFile</c>. If you extract the
               entry from the archive to a filesystem file, DotNetZip will set the
               attributes on the resulting file accordingly.
             </para>
                <para>
               The attributes can be set explicitly by the application.  For example the
               application may wish to set the <c>FileAttributes.ReadOnly</c> bit for all
               entries added to an archive, so that on unpack, this attribute will be set
               on the extracted file.  Any changes you make to this property are made
               permanent only when you call a <c>Save()</c> method on the <c>ZipFile</c>
               instance that contains the ZipEntry.
             </para>
                <para>
               For example, an application may wish to zip up a directory and set the
               ReadOnly bit on every file in the archive, so that upon later extraction,
               the resulting files will be marked as ReadOnly.  Not every extraction tool
               respects these attributes, but if you unpack with DotNetZip, as for
               example in a self-extracting archive, then the attributes will be set as
               they are stored in the <c>ZipFile</c>.
             </para>
                <para>
               These attributes may not be interesting or useful if the resulting archive
               is extracted on a non-Windows platform.  How these attributes get used
               upon extraction depends on the platform and tool used.
             </para>
                <para>
               This property is only partially supported in the Silverlight version
               of the library: applications can read attributes on entries within
               ZipFiles. But extracting entries within Silverlight will not set the
               attributes on the extracted files.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.LocalFileName">
            <summary>
               The name of the filesystem file, referred to by the ZipEntry.
             </summary>
            <remarks>
                <para>
                This property specifies the thing-to-be-zipped on disk, and is set only
                when the <c>ZipEntry</c> is being created from a filesystem file.  If the
                <c>ZipFile</c> is instantiated by reading an existing .zip archive, then
                the LocalFileName will be <c>null</c> (<c>Nothing</c> in VB).
              </para>
                <para>
                When it is set, the value of this property may be different than <see cref="P:Ionic.Zip.ZipEntry.FileName" />, which is the path used in the archive itself.  If you
                call <c>Zip.AddFile("foop.txt", AlternativeDirectory)</c>, then the path
                used for the <c>ZipEntry</c> within the zip archive will be different
                than this path.
              </para>
                <para>
               If the entry is being added from a stream, then this is null (Nothing in VB).
              </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.FileName" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.FileName">
            <summary>
               The name of the file contained in the ZipEntry.
             </summary>
            <remarks>
                <para>
               This is the name of the entry in the <c>ZipFile</c> itself.  When creating
               a zip archive, if the <c>ZipEntry</c> has been created from a filesystem
               file, via a call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" /> or <see cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />, or a related overload, the value
               of this property is derived from the name of that file. The
               <c>FileName</c> property does not include drive letters, and may include a
               different directory path, depending on the value of the
               <c>directoryPathInArchive</c> parameter used when adding the entry into
               the <c>ZipFile</c>.
             </para>
                <para>
               In some cases there is no related filesystem file - for example when a
               <c>ZipEntry</c> is created using <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)" /> or one of the similar overloads.  In this case, the value of
               this property is derived from the fileName and the directory path passed
               to that method.
             </para>
                <para>
               When reading a zip file, this property takes the value of the entry name
               as stored in the zip file. If you extract such an entry, the extracted
               file will take the name given by this property.
             </para>
                <para>
               Applications can set this property when creating new zip archives or when
               reading existing archives. When setting this property, the actual value
               that is set will replace backslashes with forward slashes, in accordance
               with <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>, for compatibility with Unix(tm) and ... get
               this.... Amiga!
             </para>
                <para>
               If an application reads a <c>ZipFile</c> via <see cref="M:Ionic.Zip.ZipFile.Read(System.String)" /> or a related overload, and then explicitly
               sets the FileName on an entry contained within the <c>ZipFile</c>, and
               then calls <see cref="M:Ionic.Zip.ZipFile.Save" />, the application will effectively
               rename the entry within the zip archive.
             </para>
                <para>
               If an application sets the value of <c>FileName</c>, then calls
               <c>Extract()</c> on the entry, the entry is extracted to a file using the
               newly set value as the filename.  The <c>FileName</c> value is made
               permanent in the zip archive only <em>after</em> a call to one of the
               <c>ZipFile.Save()</c> methods on the <c>ZipFile</c> that contains the
               ZipEntry.
             </para>
                <para>
               If an application attempts to set the <c>FileName</c> to a value that
               would result in a duplicate entry in the <c>ZipFile</c>, an exception is
               thrown.
             </para>
                <para>
               When a <c>ZipEntry</c> is contained within a <c>ZipFile</c>, applications
               cannot rename the entry within the context of a <c>foreach</c> (<c>For
               Each</c> in VB) loop, because of the way the <c>ZipFile</c> stores
               entries.  If you need to enumerate through all the entries and rename one
               or more of them, use <see cref="P:Ionic.Zip.ZipFile.EntriesSorted">ZipFile.EntriesSorted</see> as the
               collection.  See also, <see cref="M:Ionic.Zip.ZipFile.GetEnumerator">ZipFile.GetEnumerator()</see>.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.InputStream">
            <summary>
             The stream that provides content for the ZipEntry.
             </summary>
            <remarks>
                <para>
               The application can use this property to set the input stream for an
               entry on a just-in-time basis. Imagine a scenario where the application
               creates a <c>ZipFile</c> comprised of content obtained from hundreds of
               files, via calls to <c>AddFile()</c>. The DotNetZip library opens streams
               on these files on a just-in-time basis, only when writing the entry out to
               an external store within the scope of a <c>ZipFile.Save()</c> call.  Only
               one input stream is opened at a time, as each entry is being written out.
             </para>
                <para>
               Now imagine a different application that creates a <c>ZipFile</c>
               with content obtained from hundreds of streams, added through <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)" />.  Normally the
               application would supply an open stream to that call.  But when large
               numbers of streams are being added, this can mean many open streams at one
               time, unnecessarily.
             </para>
                <para>
               To avoid this, call <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" /> and specify delegates that open and close the stream at
               the time of Save.
             </para>
                <para>
               Setting the value of this property when the entry was not added from a
               stream (for example, when the <c>ZipEntry</c> was added with <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" /> or <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />, or when the entry was added by
               reading an existing zip archive) will throw an exception.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.InputStreamWasJitProvided">
            <summary>
               A flag indicating whether the InputStream was provided Just-in-time.
             </summary>
            <remarks>
                <para>
               When creating a zip archive, an application can obtain content for one or
               more of the <c>ZipEntry</c> instances from streams, using the <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)" /> method.  At the time
               of calling that method, the application can supply null as the value of
               the stream parameter.  By doing so, the application indicates to the
               library that it will provide a stream for the entry on a just-in-time
               basis, at the time one of the <c>ZipFile.Save()</c> methods is called and
               the data for the various entries are being compressed and written out.
             </para>
                <para>
               In this case, the application can set the <see cref="P:Ionic.Zip.ZipEntry.InputStream" />
               property, typically within the SaveProgress event (event type: <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry" />) for that entry.
             </para>
                <para>
               The application will later want to call Close() and Dispose() on that
               stream.  In the SaveProgress event, when the event type is <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry" />, the application can
               do so.  This flag indicates that the stream has been provided by the
               application on a just-in-time basis and that it is the application's
               responsibility to call Close/Dispose on that stream.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.InputStream" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Source">
            <summary>
            An enum indicating the source of the ZipEntry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.VersionNeeded">
            <summary>
             The version of the zip engine needed to read the ZipEntry.
             </summary>
            <remarks>
                <para>
               This is a readonly property, indicating the version of <a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</a> that the extracting tool or library must support to
               extract the given entry.  Generally higher versions indicate newer
               features.  Older zip engines obviously won't know about new features, and
               won't be able to extract entries that depend on those newer features.
             </para>
                <list type="table">
                    <listheader>
                        <term>value</term>
                        <description>Features</description>
                    </listheader>
                    <item>
                        <term>20</term>
                        <description>a basic Zip Entry, potentially using PKZIP encryption.
             </description>
                    </item>
                    <item>
                        <term>45</term>
                        <description>The ZIP64 extension is used on the entry.
             </description>
                    </item>
                    <item>
                        <term>46</term>
                        <description> File is compressed using BZIP2 compression*</description>
                    </item>
                    <item>
                        <term>50</term>
                        <description> File is encrypted using PkWare's DES, 3DES, (broken) RC2 or RC4</description>
                    </item>
                    <item>
                        <term>51</term>
                        <description> File is encrypted using PKWare's AES encryption or corrected RC2 encryption.</description>
                    </item>
                    <item>
                        <term>52</term>
                        <description> File is encrypted using corrected RC2-64 encryption**</description>
                    </item>
                    <item>
                        <term>61</term>
                        <description> File is encrypted using non-OAEP key wrapping***</description>
                    </item>
                    <item>
                        <term>63</term>
                        <description> File is compressed using LZMA, PPMd+, Blowfish, or Twofish</description>
                    </item>
                </list>
                <para>
               There are other values possible, not listed here. DotNetZip supports
               regular PKZip encryption, and ZIP64 extensions.  DotNetZip cannot extract
               entries that require a zip engine higher than 45.
             </para>
                <para>
               This value is set upon reading an existing zip file, or after saving a zip
               archive.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Comment">
            <summary>
             The comment attached to the ZipEntry.
             </summary>
            <remarks>
                <para>
               Each entry in a zip file can optionally have a comment associated to
               it. The comment might be displayed by a zip tool during extraction, for
               example.
             </para>
                <para>
               By default, the <c>Comment</c> is encoded in IBM437 code page. You can
               specify an alternative with <see cref="P:Ionic.Zip.ZipEntry.AlternateEncoding" /> and
              <see cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage" />.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.AlternateEncoding" />
            <seealso cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.RequiresZip64">
            <summary>
             Indicates whether the entry requires ZIP64 extensions.
             </summary>
            <remarks>
                <para>
               This property is null (Nothing in VB) until a <c>Save()</c> method on the
               containing <see cref="T:Ionic.Zip.ZipFile" /> instance has been called. The property is
               non-null (<c>HasValue</c> is true) only after a <c>Save()</c> method has
               been called.
             </para>
                <para>
               After the containing <c>ZipFile</c> has been saved, the Value of this
               property is true if any of the following three conditions holds: the
               uncompressed size of the entry is larger than 0xFFFFFFFF; the compressed
               size of the entry is larger than 0xFFFFFFFF; the relative offset of the
               entry within the zip archive is larger than 0xFFFFFFFF.  These quantities
               are not known until a <c>Save()</c> is attempted on the zip archive and
               the compression is applied.
             </para>
                <para>
               If none of the three conditions holds, then the <c>Value</c> is false.
             </para>
                <para>
               A <c>Value</c> of false does not indicate that the entry, as saved in the
               zip archive, does not use ZIP64.  It merely indicates that ZIP64 is
               <em>not required</em>.  An entry may use ZIP64 even when not required if
               the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property on the containing
               <c>ZipFile</c> instance is set to <see cref="F:Ionic.Zip.Zip64Option.Always" />, or if
               the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property on the containing
               <c>ZipFile</c> instance is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" />
               and the output stream was not seekable.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.OutputUsedZip64" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.OutputUsedZip64">
            <summary>
               Indicates whether the entry actually used ZIP64 extensions, as it was most
               recently written to the output file or stream.
             </summary>
            <remarks>
                <para>
               This Nullable property is null (Nothing in VB) until a <c>Save()</c>
               method on the containing <see cref="T:Ionic.Zip.ZipFile" /> instance has been
               called. <c>HasValue</c> is true only after a <c>Save()</c> method has been
               called.
             </para>
                <para>
               The value of this property for a particular <c>ZipEntry</c> may change
               over successive calls to <c>Save()</c> methods on the containing ZipFile,
               even if the file that corresponds to the <c>ZipEntry</c> does not. This
               may happen if other entries contained in the <c>ZipFile</c> expand,
               causing the offset for this particular entry to exceed 0xFFFFFFFF.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.RequiresZip64" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.BitField">
            <summary>
               The bitfield for the entry as defined in the zip spec. You probably
               never need to look at this.
             </summary>
            <remarks>
                <para>
               You probably do not need to concern yourself with the contents of this
               property, but in case you do:
             </para>
                <list type="table">
                    <listheader>
                        <term>bit</term>
                        <description>meaning</description>
                    </listheader>
                    <item>
                        <term>0</term>
                        <description>set if encryption is used.</description>
                    </item>
                    <item>
                        <term>1-2</term>
                        <description>
             set to determine whether normal, max, fast deflation.  DotNetZip library
             always leaves these bits unset when writing (indicating "normal"
             deflation"), but can read an entry with any value here.
             </description>
                    </item>
                    <item>
                        <term>3</term>
                        <description>
             Indicates that the Crc32, Compressed and Uncompressed sizes are zero in the
             local header.  This bit gets set on an entry during writing a zip file, when
             it is saved to a non-seekable output stream.
             </description>
                    </item>
                    <item>
                        <term>4</term>
                        <description>reserved for "enhanced deflating". This library doesn't do enhanced deflating.</description>
                    </item>
                    <item>
                        <term>5</term>
                        <description>set to indicate the zip is compressed patched data.  This library doesn't do that.</description>
                    </item>
                    <item>
                        <term>6</term>
                        <description>
             set if PKWare's strong encryption is used (must also set bit 1 if bit 6 is
             set). This bit is not set if WinZip's AES encryption is set.</description>
                    </item>
                    <item>
                        <term>7</term>
                        <description>not used</description>
                    </item>
                    <item>
                        <term>8</term>
                        <description>not used</description>
                    </item>
                    <item>
                        <term>9</term>
                        <description>not used</description>
                    </item>
                    <item>
                        <term>10</term>
                        <description>not used</description>
                    </item>
                    <item>
                        <term>11</term>
                        <description>
             Language encoding flag (EFS).  If this bit is set, the filename and comment
             fields for this file must be encoded using UTF-8. This library currently
             does not support UTF-8.
             </description>
                    </item>
                    <item>
                        <term>12</term>
                        <description>Reserved by PKWARE for enhanced compression.</description>
                    </item>
                    <item>
                        <term>13</term>
                        <description>
               Used when encrypting the Central Directory to indicate selected data
               values in the Local Header are masked to hide their actual values.  See
               the section in <a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</a> describing the Strong Encryption Specification for
               details.
             </description>
                    </item>
                    <item>
                        <term>14</term>
                        <description>Reserved by PKWARE.</description>
                    </item>
                    <item>
                        <term>15</term>
                        <description>Reserved by PKWARE.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionMethod">
            <summary>
               The compression method employed for this ZipEntry.
             </summary>
            <remarks>
                <para>
                    <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               Zip specification</see> allows a variety of compression methods.  This
               library supports just two: 0x08 = Deflate.  0x00 = Store (no compression),
               for reading or writing.
             </para>
                <para>
               When reading an entry from an existing zipfile, the value you retrieve
               here indicates the compression method used on the entry by the original
               creator of the zip.  When writing a zipfile, you can specify either 0x08
               (Deflate) or 0x00 (None).  If you try setting something else, you will get
               an exception.
             </para>
                <para>
               You may wish to set <c>CompressionMethod</c> to <c>CompressionMethod.None</c> (0)
               when zipping already-compressed data like a jpg, png, or mp3 file.
               This can save time and cpu cycles.
             </para>
                <para>
               When setting this property on a <c>ZipEntry</c> that is read from an
               existing zip file, calling <c>ZipFile.Save()</c> will cause the new
               CompressionMethod to be used on the entry in the newly saved zip file.
             </para>
                <para>
               Setting this property may have the side effect of modifying the
               <c>CompressionLevel</c> property. If you set the <c>CompressionMethod</c> to a
               value other than <c>None</c>, and <c>CompressionLevel</c> is previously
               set to <c>None</c>, then <c>CompressionLevel</c> will be set to
               <c>Default</c>.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod" />
            <example>
               In this example, the first entry added to the zip archive uses the default
               behavior - compression is used where it makes sense.  The second entry,
               the MP3 file, is added to the archive without being compressed.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToCreate))
             {
               ZipEntry e1= zip.AddFile(@"notes\Readme.txt");
               ZipEntry e2= zip.AddFile(@"music\StopThisTrain.mp3");
               e2.CompressionMethod = CompressionMethod.None;
               zip.Save();
             }
             </code><code lang="VB">
             Using zip As New ZipFile(ZipFileToCreate)
               zip.AddFile("notes\Readme.txt")
               Dim e2 as ZipEntry = zip.AddFile("music\StopThisTrain.mp3")
               e2.CompressionMethod = CompressionMethod.None
               zip.Save
             End Using
             </code></example>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionLevel">
            <summary>
               Sets the compression level to be used for the entry when saving the zip
               archive. This applies only for CompressionMethod = DEFLATE.
             </summary>
            <remarks>
                <para>
                When using the DEFLATE compression method, Varying the compression
                level used on entries can affect the size-vs-speed tradeoff when
                compression and decompressing data streams or files.
              </para>
                <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
                <para>
                When setting this property on a <c>ZipEntry</c> that is read from an
                existing zip file, calling <c>ZipFile.Save()</c> will cause the new
                <c>CompressionLevel</c> to be used on the entry in the newly saved zip file.
              </para>
                <para>
                Setting this property may have the side effect of modifying the
                <c>CompressionMethod</c> property. If you set the <c>CompressionLevel</c>
                to a value other than <c>None</c>, <c>CompressionMethod</c> will be set
                to <c>Deflate</c>, if it was previously <c>None</c>.
              </para>
                <para>
                Setting this property has no effect if the <c>CompressionMethod</c> is something
                other than <c>Deflate</c> or <c>None</c>.
              </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressedSize">
            <summary>
               The compressed size of the file, in bytes, within the zip archive.
             </summary>
            <remarks>
               When reading a <c>ZipFile</c>, this value is read in from the existing
               zip file. When creating or updating a <c>ZipFile</c>, the compressed
               size is computed during compression.  Therefore the value on a
               <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
               overloads) in that case.
             </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.UncompressedSize" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UncompressedSize">
            <summary>
               The size of the file, in bytes, before compression, or after extraction.
             </summary>
            <remarks>
               When reading a <c>ZipFile</c>, this value is read in from the existing
               zip file. When creating or updating a <c>ZipFile</c>, the uncompressed
               size is computed during compression.  Therefore the value on a
               <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
               overloads) in that case.
             </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.CompressedSize" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionRatio">
            <summary>
             The ratio of compressed size to uncompressed size of the ZipEntry.
             </summary>
            <remarks>
                <para>
               This is a ratio of the compressed size to the uncompressed size of the
               entry, expressed as a double in the range of 0 to 100+. A value of 100
               indicates no compression at all.  It could be higher than 100 when the
               compression algorithm actually inflates the data, as may occur for small
               files, or uncompressible data that is encrypted.
             </para>
                <para>
               You could format it for presentation to a user via a format string of
               "{3,5:F0}%" to see it as a percentage.
             </para>
                <para>
               If the size of the original uncompressed file is 0, implying a
               denominator of 0, the return value will be zero.
             </para>
                <para>
               This property is valid after reading in an existing zip file, or after
               saving the <c>ZipFile</c> that contains the ZipEntry. You cannot know the
               effect of a compression transform until you try it.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Crc">
            <summary>
             The 32-bit CRC (Cyclic Redundancy Check) on the contents of the ZipEntry.
             </summary>
            <remarks>
                <para> You probably don't need to concern yourself with this. It is used
             internally by DotNetZip to verify files or streams upon extraction.  </para>
                <para> The value is a <see href="http://en.wikipedia.org/wiki/CRC32">32-bit
             CRC</see> using 0xEDB88320 for the polynomial. This is the same CRC-32 used in
             PNG, MPEG-2, and other protocols and formats.  It is a read-only property; when
             creating a Zip archive, the CRC for each entry is set only after a call to
             <c>Save()</c> on the containing ZipFile. When reading an existing zip file, the value
             of this property reflects the stored CRC for the entry.  </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IsDirectory">
            <summary>
            True if the entry is a directory (not a file).
            This is a readonly property on the entry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UsesEncryption">
            <summary>
             A derived property that is <c>true</c> if the entry uses encryption.
             </summary>
            <remarks>
                <para>
               This is a readonly property on the entry.  When reading a zip file,
               the value for the <c>ZipEntry</c> is determined by the data read
               from the zip file.  After saving a ZipFile, the value of this
               property for each <c>ZipEntry</c> indicates whether encryption was
               actually used (which will have been true if the <see cref="P:Ionic.Zip.ZipEntry.Password" /> was set and the <see cref="P:Ionic.Zip.ZipEntry.Encryption" /> property
               was something other than <see cref="F:Ionic.Zip.EncryptionAlgorithm.None" />.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Encryption">
            <summary>
               Set this to specify which encryption algorithm to use for the entry when
               saving it to a zip archive.
             </summary>
            <remarks>
                <para>
               Set this property in order to encrypt the entry when the <c>ZipFile</c> is
               saved. When setting this property, you must also set a <see cref="P:Ionic.Zip.ZipEntry.Password" /> on the entry.  If you set a value other than <see cref="F:Ionic.Zip.EncryptionAlgorithm.None" /> on this property and do not set a
               <c>Password</c> then the entry will not be encrypted. The <c>ZipEntry</c>
               data is encrypted as the <c>ZipFile</c> is saved, when you call <see cref="M:Ionic.Zip.ZipFile.Save" /> or one of its cousins on the containing
               <c>ZipFile</c> instance. You do not need to specify the <c>Encryption</c>
               when extracting entries from an archive.
             </para>
                <para>
               The Zip specification from PKWare defines a set of encryption algorithms,
               and the data formats for the zip archive that support them, and PKWare
               supports those algorithms in the tools it produces. Other vendors of tools
               and libraries, such as WinZip or Xceed, typically support <em>a
               subset</em> of the algorithms specified by PKWare. These tools can
               sometimes support additional different encryption algorithms and data
               formats, not specified by PKWare. The AES Encryption specified and
               supported by WinZip is the most popular example. This library supports a
               subset of the complete set of algorithms specified by PKWare and other
               vendors.
             </para>
                <para>
               There is no common, ubiquitous multi-vendor standard for strong encryption
               within zip files. There is broad support for so-called "traditional" Zip
               encryption, sometimes called Zip 2.0 encryption, as <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specified
               by PKWare</see>, but this encryption is considered weak and
               breakable. This library currently supports the Zip 2.0 "weak" encryption,
               and also a stronger WinZip-compatible AES encryption, using either 128-bit
               or 256-bit key strength. If you want DotNetZip to support an algorithm
               that is not currently supported, call the author of this library and maybe
               we can talk business.
             </para>
                <para>
               The <see cref="T:Ionic.Zip.ZipFile" /> class also has a <see cref="P:Ionic.Zip.ZipFile.Encryption" /> property.  In most cases you will use
               <em>that</em> property when setting encryption. This property takes
               precedence over any <c>Encryption</c> set on the <c>ZipFile</c> itself.
               Typically, you would use the per-entry Encryption when most entries in the
               zip archive use one encryption algorithm, and a few entries use a
               different one.  If all entries in the zip file use the same Encryption,
               then it is simpler to just set this property on the ZipFile itself, when
               creating a zip archive.
             </para>
                <para>
               Some comments on updating archives: If you read a <c>ZipFile</c>, you can
               modify the Encryption on an encrypted entry: you can remove encryption
               from an entry that was encrypted; you can encrypt an entry that was not
               encrypted previously; or, you can change the encryption algorithm.  The
               changes in encryption are not made permanent until you call Save() on the
               <c>ZipFile</c>.  To effect changes in encryption, the entry content is
               streamed through several transformations, depending on the modification
               the application has requested. For example if the entry is not encrypted
               and the application sets <c>Encryption</c> to <c>PkzipWeak</c>, then at
               the time of <c>Save()</c>, the original entry is read and decompressed,
               then re-compressed and encrypted.  Conversely, if the original entry is
               encrypted with <c>PkzipWeak</c> encryption, and the application sets the
               <c>Encryption</c> property to <c>WinZipAes128</c>, then at the time of
               <c>Save()</c>, the original entry is decrypted via PKZIP encryption and
               decompressed, then re-compressed and re-encrypted with AES.  This all
               happens automatically within the library, but it can be time-consuming for
               large entries.
             </para>
                <para>
               Additionally, when updating archives, it is not possible to change the
               password when changing the encryption algorithm.  To change both the
               algorithm and the password, you need to Save() the zipfile twice.  First
               set the <c>Encryption</c> to None, then call <c>Save()</c>.  Then set the
               <c>Encryption</c> to the new value (not "None"), then call <c>Save()</c>
               once again.
             </para>
                <para>
               The WinZip AES encryption algorithms are not supported on the .NET Compact
               Framework.
             </para>
            </remarks>
            <example>
                <para>
               This example creates a zip archive that uses encryption, and then extracts
               entries from the archive.  When creating the zip archive, the ReadMe.txt
               file is zipped without using a password or encryption.  The other file
               uses encryption.
             </para>
                <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt")
                 ZipEntry e1= zip.AddFile("2008-Regional-Sales-Report.pdf");
                 e1.Encryption= EncryptionAlgorithm.WinZipAes256;
                 e1.Password= "Top.Secret.No.Peeking!";
                 zip.Save("EncryptedArchive.zip");
             }
            
             // Extract a zip archive that uses AES Encryption.
             // You do not need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 // Specify the password that is used during extraction, for
                 // all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.ExtractAll("extractDirectory");
             }
             </code>
                <code lang="VB">
             ' Create a zip that uses Encryption.
             Using zip As New ZipFile()
                 zip.AddFile("ReadMe.txt")
                 Dim e1 as ZipEntry
                 e1= zip.AddFile("2008-Regional-Sales-Report.pdf")
                 e1.Encryption= EncryptionAlgorithm.WinZipAes256
                 e1.Password= "Top.Secret.No.Peeking!"
                 zip.Save("EncryptedArchive.zip")
             End Using
            
             ' Extract a zip archive that uses AES Encryption.
             ' You do not need to specify the algorithm during extraction.
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 ' Specify the password that is used during extraction, for
                 ' all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.ExtractAll("extractDirectory")
             End Using
             </code>
            </example>
            <exception cref="T:System.InvalidOperationException">
             Thrown in the setter if EncryptionAlgorithm.Unsupported is specified.
             </exception>
            <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
            <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Password">
            <summary>
             The Password to be used when encrypting a <c>ZipEntry</c> upon
             <c>ZipFile.Save()</c>, or when decrypting an entry upon Extract().
             </summary>
            <remarks>
                <para>
               This is a write-only property on the entry. Set this to request that the
               entry be encrypted when writing the zip archive, or set it to specify the
               password to be used when extracting an existing entry that is encrypted.
             </para>
                <para>
               The password set here is implicitly used to encrypt the entry during the
               <see cref="M:Ionic.Zip.ZipFile.Save" /> operation, or to decrypt during the <see cref="M:Ionic.Zip.ZipEntry.Extract" /> or <see cref="M:Ionic.Zip.ZipEntry.OpenReader" /> operation.  If you set
               the Password on a <c>ZipEntry</c> after calling <c>Save()</c>, there is no
               effect.
             </para>
                <para>
               Consider setting the <see cref="P:Ionic.Zip.ZipEntry.Encryption" /> property when using a
               password. Answering concerns that the standard password protection
               supported by all zip tools is weak, WinZip has extended the ZIP
               specification with a way to use AES Encryption to protect entries in the
               Zip file. Unlike the "PKZIP 2.0" encryption specified in the PKZIP
               specification, <see href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES
               Encryption</see> uses a standard, strong, tested, encryption
               algorithm. DotNetZip can create zip archives that use WinZip-compatible
               AES encryption, if you set the <see cref="P:Ionic.Zip.ZipEntry.Encryption" /> property. But,
               archives created that use AES encryption may not be readable by all other
               tools and libraries. For example, Windows Explorer cannot read a
               "compressed folder" (a zip file) that uses AES encryption, though it can
               read a zip file that uses "PKZIP encryption."
             </para>
                <para>
               The <see cref="T:Ionic.Zip.ZipFile" /> class also has a <see cref="P:Ionic.Zip.ZipFile.Password" />
               property.  This property takes precedence over any password set on the
               ZipFile itself.  Typically, you would use the per-entry Password when most
               entries in the zip archive use one password, and a few entries use a
               different password.  If all entries in the zip file use the same password,
               then it is simpler to just set this property on the ZipFile itself,
               whether creating a zip archive or extracting a zip archive.
             </para>
                <para>
               Some comments on updating archives: If you read a <c>ZipFile</c>, you
               cannot modify the password on any encrypted entry, except by extracting
               the entry with the original password (if any), removing the original entry
               via <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)" />, and then adding a new
               entry with a new Password.
             </para>
                <para>
               For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the Password property on that <c>ZipEntry</c> and then
               calling <c>Save()</c> on the <c>ZipFile</c> does not update the password
               on that entry in the archive.  Neither is an exception thrown. Instead,
               what happens during the <c>Save()</c> is the existing entry is copied
               through to the new zip archive, in its original encrypted form. Upon
               re-reading that archive, the entry can be decrypted with its original
               password.
             </para>
                <para>
               If you read a ZipFile, and there is an un-encrypted entry, you can set the
               <c>Password</c> on the entry and then call Save() on the ZipFile, and get
               encryption on that entry.
             </para>
            </remarks>
            <example>
                <para>
               This example creates a zip file with two entries, and then extracts the
               entries from the zip file.  When creating the zip file, the two files are
               added to the zip file using password protection. Each entry uses a
               different password.  During extraction, each file is extracted with the
               appropriate password.
             </para>
                <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 ZipEntry entry;
                 entry= zip.AddFile("Declaration.txt");
                 entry.Password= "123456!";
                 entry = zip.AddFile("Report.xls");
                 entry.Password= "1Secret!";
                 zip.Save("EncryptedArchive.zip");
             }
            
             // extract entries that use encryption
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 ZipEntry entry;
                 entry = zip["Declaration.txt"];
                 entry.Password = "123456!";
                 entry.Extract("extractDir");
                 entry = zip["Report.xls"];
                 entry.Password = "1Secret!";
                 entry.Extract("extractDir");
             }
            
             </code>
                <code lang="VB">
             Using zip As New ZipFile
                 Dim entry as ZipEntry
                 entry= zip.AddFile("Declaration.txt")
                 entry.Password= "123456!"
                 entry = zip.AddFile("Report.xls")
                 entry.Password= "1Secret!"
                 zip.Save("EncryptedArchive.zip")
             End Using
            
            
             ' extract entries that use encryption
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 Dim entry as ZipEntry
                 entry = zip("Declaration.txt")
                 entry.Password = "123456!"
                 entry.Extract("extractDir")
                 entry = zip("Report.xls")
                 entry.Password = "1Secret!"
                 entry.Extract("extractDir")
             End Using
            
             </code>
            </example>
            <seealso cref="P:Ionic.Zip.ZipEntry.Encryption" />
            <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ExtractExistingFile">
            <summary>
             The action the library should take when extracting a file that already exists.
             </summary>
            <remarks>
                <para>
                 This property affects the behavior of the Extract methods (one of the
                 <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
                 extraction would would overwrite an existing filesystem file. If you do
                 not set this property, the library throws an exception when extracting
                 an entry would overwrite an existing file.
               </para>
                <para>
                 This property has no effect when extracting to a stream, or when the file to be
                 extracted does not already exist.
               </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />
            <example>
               This example shows how to set the <c>ExtractExistingFile</c> property in
               an <c>ExtractProgress</c> event, in response to user input. The
               <c>ExtractProgress</c> event is invoked if and only if the
               <c>ExtractExistingFile</c> property was previously set to
               <c>ExtractExistingFileAction.InvokeExtractProgressEvent</c>.
             <code lang="C#">
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
                     Console.WriteLine("extract {0} ", e.CurrentEntry.FileName);
            
                 else if (e.EventType == ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite)
                 {
                     ZipEntry entry = e.CurrentEntry;
                     string response = null;
                     // Ask the user if he wants overwrite the file
                     do
                     {
                         Console.Write("Overwrite {0} in {1} ? (y/n/C) ", entry.FileName, e.ExtractLocation);
                         response = Console.ReadLine();
                         Console.WriteLine();
            
                     } while (response != null &amp;&amp; response[0]!='Y' &amp;&amp;
                              response[0]!='N' &amp;&amp; response[0]!='C');
            
                     if  (response[0]=='C')
                         e.Cancel = true;
                     else if (response[0]=='Y')
                         entry.ExtractExistingFile = ExtractExistingFileAction.OverwriteSilently;
                     else
                         entry.ExtractExistingFile= ExtractExistingFileAction.DoNotOverwrite;
                 }
             }
             </code></example>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ZipErrorAction">
            <summary>
               The action to take when an error is encountered while
               opening or reading files as they are saved into a zip archive.
             </summary>
            <remarks>
                <para>
                 Errors can occur within a call to <see cref="M:Ionic.Zip.ZipFile.Save">ZipFile.Save</see>, as the various files contained
                 in a ZipFile are being saved into the zip archive.  During the
                 <c>Save</c>, DotNetZip will perform a <c>File.Open</c> on the file
                 associated to the ZipEntry, and then will read the entire contents of
                 the file as it is zipped. Either the open or the Read may fail, because
                 of lock conflicts or other reasons.  Using this property, you can
                 specify the action to take when such errors occur.
              </para>
                <para>
                 Typically you will NOT set this property on individual ZipEntry
                 instances.  Instead, you will set the <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction">ZipFile.ZipErrorAction</see> property on
                 the ZipFile instance, before adding any entries to the
                 <c>ZipFile</c>. If you do this, errors encountered on behalf of any of
                 the entries in the ZipFile will be handled the same way.
              </para>
                <para>
                 But, if you use a <see cref="E:Ionic.Zip.ZipFile.ZipError" /> handler, you will want
                 to set this property on the <c>ZipEntry</c> within the handler, to
                 communicate back to DotNetZip what you would like to do with the
                 particular error.
              </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction" />
            <seealso cref="E:Ionic.Zip.ZipFile.ZipError" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IncludedInMostRecentSave">
            <summary>
            Indicates whether the entry was included in the most recent save.
            </summary>
            <remarks>
            An entry can be excluded or skipped from a save if there is an error
            opening or reading the entry.
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.SetCompression">
            <summary>
               A callback that allows the application to specify the compression to use
               for a given entry that is about to be added to the zip archive.
             </summary>
            <remarks>
                <para>
               See <see cref="P:Ionic.Zip.ZipFile.SetCompression" /></para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UseUnicodeAsNecessary">
            <summary>
               Set to indicate whether to use UTF-8 encoding for filenames and comments.
             </summary>
            <remarks>
                <para>
               If this flag is set, the comment and filename for the entry will be
               encoded with UTF-8, as described in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>, if necessary. "Necessary" means, the filename or
               entry comment (if any) cannot be reflexively encoded and decoded using the
               default code page, IBM437.
             </para>
                <para>
               Setting this flag to true is equivalent to setting <see cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding" /> to <c>System.Text.Encoding.UTF8</c>.
             </para>
                <para>
               This flag has no effect or relation to the text encoding used within the
               file itself.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding">
            <summary>
               The text encoding to use for the FileName and Comment on this ZipEntry,
               when the default encoding is insufficient.
             </summary>
            <remarks>
                <para>
               Don't use this property.  See <see cref="P:Ionic.Zip.ZipEntry.AlternateEncoding" />.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AlternateEncoding">
            <summary>
              Specifies the alternate text encoding used by this ZipEntry
            </summary>
            <remarks>
                <para>
                The default text encoding used in Zip files for encoding filenames and
                comments is IBM437, which is something like a superset of ASCII.  In
                cases where this is insufficient, applications can specify an
                alternate encoding.
              </para>
                <para>
                When creating a zip file, the usage of the alternate encoding is
                governed by the <see cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage" /> property.
                Typically you would set both properties to tell DotNetZip to employ an
                encoding that is not IBM437 in the zipfile you are creating.
              </para>
                <para>
                Keep in mind that because the ZIP specification states that the only
                valid encodings to use are IBM437 and UTF-8, if you use something
                other than that, then zip tools and libraries may not be able to
                successfully read the zip archive you generate.
              </para>
                <para>
                The zip specification states that applications should presume that
                IBM437 is in use, except when a special bit is set, which indicates
                UTF-8. There is no way to specify an arbitrary code page, within the
                zip file itself. When you create a zip file encoded with gb2312 or
                ibm861 or anything other than IBM437 or UTF-8, then the application
                that reads the zip file needs to "know" which code page to use. In
                some cases, the code page used when reading is chosen implicitly. For
                example, WinRar uses the ambient code page for the host desktop
                operating system. The pitfall here is that if you create a zip in
                Copenhagen and send it to Tokyo, the reader of the zipfile may not be
                able to decode successfully.
              </para>
            </remarks>
            <example>
              This example shows how to create a zipfile encoded with a
              language-specific encoding:
            <code>
              using (var zip = new ZipFile())
              {
                 zip.AlternateEnoding = System.Text.Encoding.GetEncoding("ibm861");
                 zip.AlternateEnodingUsage = ZipOption.Always;
                 zip.AddFileS(arrayOfFiles);
                 zip.Save("Myarchive-Encoded-in-IBM861.zip");
              }
            </code></example>
            <seealso cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage">
            <summary>
              Describes if and when this instance should apply
              AlternateEncoding to encode the FileName and Comment, when
              saving.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IsText">
            <summary>
               Indicates whether an entry is marked as a text file. Be careful when
               using on this property. Unless you have a good reason, you should
               probably ignore this property.
             </summary>
            <remarks>
                <para>
               The ZIP format includes a provision for specifying whether an entry in
               the zip archive is a text or binary file.  This property exposes that
               metadata item. Be careful when using this property: It's not clear
               that this property as a firm meaning, across tools and libraries.
             </para>
                <para>
               To be clear, when reading a zip file, the property value may or may
               not be set, and its value may or may not be valid.  Not all entries
               that you may think of as "text" entries will be so marked, and entries
               marked as "text" are not guaranteed in any way to be text entries.
               Whether the value is set and set correctly depends entirely on the
               application that produced the zip file.
             </para>
                <para>
               There are many zip tools available, and when creating zip files, some
               of them "respect" the IsText metadata field, and some of them do not.
               Unfortunately, even when an application tries to do "the right thing",
               it's not always clear what "the right thing" is.
             </para>
                <para>
               There's no firm definition of just what it means to be "a text file",
               and the zip specification does not help in this regard. Twenty years
               ago, text was ASCII, each byte was less than 127. IsText meant, all
               bytes in the file were less than 127.  These days, it is not the case
               that all text files have all bytes less than 127.  Any unicode file
               may have bytes that are above 0x7f.  The zip specification has nothing
               to say on this topic. Therefore, it's not clear what IsText really
               means.
             </para>
                <para>
               This property merely tells a reading application what is stored in the
               metadata for an entry, without guaranteeing its validity or its
               meaning.
             </para>
                <para>
               When DotNetZip is used to create a zipfile, it attempts to set this
               field "correctly." For example, if a file ends in ".txt", this field
               will be set. Your application may override that default setting.  When
               writing a zip file, you must set the property before calling
               <c>Save()</c> on the ZipFile.
             </para>
                <para>
               When reading a zip file, a more general way to decide just what kind
               of file is contained in a particular entry is to use the file type
               database stored in the operating system.  The operating system stores
               a table that says, a file with .jpg extension is a JPG image file, a
               file with a .xml extension is an XML document, a file with a .txt is a
               pure ASCII text document, and so on.  To get this information on
               Windows, <see href="http://www.codeproject.com/KB/cs/GetFileTypeAndIcon.aspx"> you
               need to read and parse the registry.</see></para>
            </remarks>
            <example>
                <code>
             using (var zip = new ZipFile())
             {
                 var e = zip.UpdateFile("Descriptions.mme", "");
                 e.IsText = true;
                 zip.Save(zipPath);
             }
             </code>
                <code lang="VB">
             Using zip As New ZipFile
                 Dim e2 as ZipEntry = zip.AddFile("Descriptions.mme", "")
                 e.IsText= True
                 zip.Save(zipPath)
             End Using
             </code>
            </example>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract">
            <summary>
               Extract the entry to the filesystem, starting at the current
               working directory.
             </summary>
            <overloads>
               This method has a bunch of overloads! One of them is sure to
               be the right one for you... If you don't like these, check
               out the <c>ExtractWithPassword()</c> methods.
             </overloads>
            <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
            <seealso cref="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)" />
            <remarks>
                <para>
               This method extracts an entry from a zip file into the current
               working directory.  The path of the entry as extracted is the full
               path as specified in the zip archive, relative to the current
               working directory.  After the file is extracted successfully, the
               file attributes and timestamps are set.
             </para>
                <para>
               The action taken when extraction an entry would overwrite an
               existing file is determined by the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property.
             </para>
                <para>
               Within the call to <c>Extract()</c>, the content for the entry is
               written into a filesystem file, and then the last modified time of the
               file is set according to the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property on
               the entry. See the remarks the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property for
               some details about the last modified time.
             </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)">
            <summary>
               Extract the entry to a file in the filesystem, using the specified
               behavior when extraction would overwrite an existing file.
             </summary>
            <remarks>
                <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
               details about how the last modified time of the file is set after
               extraction.
             </para>
            </remarks>
            <param name="extractExistingFile">
               The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)">
            <summary>
               Extracts the entry to the specified stream.
             </summary>
            <remarks>
                <para>
               The caller can specify any write-able stream, for example a <see cref="T:System.IO.FileStream" />, a <see cref="T:System.IO.MemoryStream" />, or ASP.NET's
               <c>Response.OutputStream</c>.  The content will be decrypted and
               decompressed as necessary. If the entry is encrypted and no password
               is provided, this method will throw.
             </para>
                <para>
               The position on the stream is not reset by this method before it extracts.
               You may want to call stream.Seek() before calling ZipEntry.Extract().
             </para>
            </remarks>
            <param name="stream">
               the stream to which the entry should be extracted.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.String)">
            <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory.
             </summary>
            <param name="baseDirectory">the pathname of the base directory</param>
            <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
            <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" />
            <example>
             This example extracts only the entries in a zip file that are .txt files,
             into a directory called "textfiles".
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                 {
                   zip[s1].Extract("textfiles");
                 }
               }
             }
             </code><code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code></example>
            <remarks>
                <para>
               Using this method, existing entries in the filesystem will not be
               overwritten. If you would like to force the overwrite of existing
               files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property, or call
               <see cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" />.
             </para>
                <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
               details about how the last modified time of the created file is set.
             </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)">
            <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified behavior when extraction would
               overwrite an existing file.
             </summary>
            <remarks>
                <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
               details about how the last modified time of the created file is set.
             </para>
            </remarks>
            <example>
                <code lang="C#">
             String sZipPath = "Airborne.zip";
             String sFilePath = "Readme.txt";
             String sRootFolder = "Digado";
             using (ZipFile zip = ZipFile.Read(sZipPath))
             {
               if (zip.EntryFileNames.Contains(sFilePath))
               {
                 // use the string indexer on the zip file
                 zip[sFileName].Extract(sRootFolder,
                                        ExtractExistingFileAction.OverwriteSilently);
               }
             }
             </code>
                <code lang="VB">
             Dim sZipPath as String = "Airborne.zip"
             Dim sFilePath As String = "Readme.txt"
             Dim sRootFolder As String = "Digado"
             Using zip As ZipFile = ZipFile.Read(sZipPath)
               If zip.EntryFileNames.Contains(sFilePath)
                 ' use the string indexer on the zip file
                 zip(sFilePath).Extract(sRootFolder, _
                                        ExtractExistingFileAction.OverwriteSilently)
               End If
             End Using
             </code>
            </example>
            <param name="baseDirectory">the pathname of the base directory</param>
            <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String)">
            <summary>
               Extract the entry to the filesystem, using the current working directory
               and the specified password.
             </summary>
            <overloads>
               This method has a bunch of overloads! One of them is sure to be
               the right one for you...
             </overloads>
            <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
            <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)" />
            <remarks>
                <para>
               Existing entries in the filesystem will not be overwritten. If you
               would like to force the overwrite of existing files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />property, or call
               <see cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)" />.
             </para>
                <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property for some
               details about how the "last modified" time of the created file is
               set.
             </para>
            </remarks>
            <example>
               In this example, entries that use encryption are extracted using a
               particular password.
             <code>
             using (var zip = ZipFile.Read(FilePath))
             {
                 foreach (ZipEntry e in zip)
                 {
                     if (e.UsesEncryption)
                         e.ExtractWithPassword("Secret!");
                     else
                         e.Extract();
                 }
             }
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
                 Dim e As ZipEntry
                 For Each e In zip
                     If (e.UsesEncryption)
                       e.ExtractWithPassword("Secret!")
                     Else
                       e.Extract
                     End If
                 Next
             End Using
             </code></example>
            <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,System.String)">
            <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified password.
             </summary>
            <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
            <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)" />
            <remarks>
                <para>
               Existing entries in the filesystem will not be overwritten. If you
               would like to force the overwrite of existing files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />property, or call
               <see cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)" />.
             </para>
                <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
               details about how the last modified time of the created file is set.
             </para>
            </remarks>
            <param name="baseDirectory">The pathname of the base directory.</param>
            <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)">
            <summary>
               Extract the entry to a file in the filesystem, relative to the
               current directory, using the specified behavior when extraction
               would overwrite an existing file.
             </summary>
            <remarks>
                <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
               details about how the last modified time of the created file is set.
             </para>
            </remarks>
            <param name="password">The Password to use for decrypting the entry.</param>
            <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)">
            <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified behavior when extraction would
               overwrite an existing file.
             </summary>
            <remarks>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some
               details about how the last modified time of the created file is set.
             </remarks>
            <param name="baseDirectory">the pathname of the base directory</param>
            <param name="extractExistingFile">The action to take if extraction would
             overwrite an existing file.</param>
            <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.IO.Stream,System.String)">
            <summary>
               Extracts the entry to the specified stream, using the specified
               Password.  For example, the caller could extract to Console.Out, or
               to a MemoryStream.
             </summary>
            <remarks>
                <para>
               The caller can specify any write-able stream, for example a <see cref="T:System.IO.FileStream" />, a <see cref="T:System.IO.MemoryStream" />, or ASP.NET's
               <c>Response.OutputStream</c>.  The content will be decrypted and
               decompressed as necessary. If the entry is encrypted and no password
               is provided, this method will throw.
             </para>
                <para>
               The position on the stream is not reset by this method before it extracts.
               You may want to call stream.Seek() before calling ZipEntry.Extract().
             </para>
            </remarks>
            <param name="stream">
               the stream to which the entry should be extracted.
             </param>
            <param name="password">
               The password to use for decrypting the entry.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.OpenReader">
            <summary>
               Opens a readable stream corresponding to the zip entry in the
               archive.  The stream decompresses and decrypts as necessary, as it
               is read.
             </summary>
            <remarks>
                <para>
               DotNetZip offers a variety of ways to extract entries from a zip
               file.  This method allows an application to extract an entry by
               reading a <see cref="T:System.IO.Stream" />.
             </para>
                <para>
               The return value is of type <see cref="T:Ionic.Crc.CrcCalculatorStream" />.  Use it as you would any
               stream for reading.  When an application calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> on that stream, it will
               receive data from the zip entry that is decrypted and decompressed
               as necessary.
             </para>
                <para>
                    <c>CrcCalculatorStream</c> adds one additional feature: it keeps a
               CRC32 checksum on the bytes of the stream as it is read.  The CRC
               value is available in the <see cref="P:Ionic.Crc.CrcCalculatorStream.Crc" /> property on the
               <c>CrcCalculatorStream</c>.  When the read is complete, your
               application
               <em>should</em> check this CRC against the <see cref="P:Ionic.Zip.ZipEntry.Crc" />
               property on the <c>ZipEntry</c> to validate the content of the
               ZipEntry. You don't have to validate the entry using the CRC, but
               you should, to verify integrity. Check the example for how to do
               this.
             </para>
                <para>
               If the entry is protected with a password, then you need to provide
               a password prior to calling <see cref="M:Ionic.Zip.ZipEntry.OpenReader" />, either by
               setting the <see cref="P:Ionic.Zip.ZipEntry.Password" /> property on the entry, or the
               <see cref="P:Ionic.Zip.ZipFile.Password" /> property on the <c>ZipFile</c>
               itself. Or, you can use <see cref="M:Ionic.Zip.ZipEntry.OpenReader(System.String)" />, the
               overload of OpenReader that accepts a password parameter.
             </para>
                <para>
               If you want to extract entry data into a write-able stream that is
               already opened, like a <see cref="T:System.IO.FileStream" />, do not
               use this method. Instead, use <see cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)" />.
             </para>
                <para>
               Your application may use only one stream created by OpenReader() at
               a time, and you should not call other Extract methods before
               completing your reads on a stream obtained from OpenReader().  This
               is because there is really only one source stream for the compressed
               content.  A call to OpenReader() seeks in the source stream, to the
               beginning of the compressed content.  A subsequent call to
               OpenReader() on a different entry will seek to a different position
               in the source stream, as will a call to Extract() or one of its
               overloads.  This will corrupt the state for the decompressing stream
               from the original call to OpenReader().
             </para>
                <para>
                The <c>OpenReader()</c> method works only when the ZipEntry is
                obtained from an instance of <c>ZipFile</c>. This method will throw
                an exception if the ZipEntry is obtained from a <see cref="T:Ionic.Zip.ZipInputStream" />.
             </para>
            </remarks>
            <example>
               This example shows how to open a zip archive, then read in a named
               entry via a stream. After the read loop is complete, the code
               compares the calculated during the read loop with the expected CRC
               on the <c>ZipEntry</c>, to verify the extraction.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               ZipEntry e1= zip["Elevation.mp3"];
               using (Ionic.Zlib.CrcCalculatorStream s = e1.OpenReader())
               {
                 byte[] buffer = new byte[4096];
                 int n, totalBytesRead= 0;
                 do {
                   n = s.Read(buffer,0, buffer.Length);
                   totalBytesRead+=n;
                 } while (n&gt;0);
                  if (s.Crc32 != e1.Crc32)
                   throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
                  if (totalBytesRead != e1.UncompressedSize)
                   throw new Exception(string.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
               }
             }
             </code><code lang="VB">
               Using zip As New ZipFile(ZipFileToRead)
                   Dim e1 As ZipEntry = zip.Item("Elevation.mp3")
                   Using s As Ionic.Zlib.CrcCalculatorStream = e1.OpenReader
                       Dim n As Integer
                       Dim buffer As Byte() = New Byte(4096) {}
                       Dim totalBytesRead As Integer = 0
                       Do
                           n = s.Read(buffer, 0, buffer.Length)
                           totalBytesRead = (totalBytesRead + n)
                       Loop While (n &gt; 0)
                       If (s.Crc32 &lt;&gt; e1.Crc32) Then
                           Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
                       End If
                       If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
                           Throw New Exception(String.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
                       End If
                   End Using
               End Using
             </code></example>
            <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)" />
            <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.OpenReader(System.String)">
            <summary>
               Opens a readable stream for an encrypted zip entry in the archive.
               The stream decompresses and decrypts as necessary, as it is read.
             </summary>
            <remarks>
                <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipEntry.OpenReader" /> method for
               full details. This overload allows the application to specify a
               password for the <c>ZipEntry</c> to be read.
             </para>
            </remarks>
            <param name="password">The password to use for decrypting the entry.</param>
            <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.InternalExtractToBaseDir(System.String,System.String,Ionic.Zip.ZipContainer,Ionic.Zip.ZipEntrySource,System.String)">
            <summary>
            Pass in either basedir or s, but not both.
            In other words, you can extract to a stream or to a directory (filesystem), but not both!
            The Password param is required for encrypted entries.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.InternalExtractToStream(System.IO.Stream,System.String,Ionic.Zip.ZipContainer,Ionic.Zip.ZipEntrySource,System.String)">
            <summary>
            Extract to a stream
            In other words, you can extract to a stream or to a directory (filesystem), but not both!
            The Password param is required for encrypted entries.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.IsDoneWithOutputToBaseDir(System.String,System.String@)">
            <summary>
            Validates that the args are consistent; returning whether the caller can return
            because it's done, or not (caller should continue)
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.IsDoneWithOutputToStream">
            <summary>
            Validates that the args are consistent; returning whether the caller can return
            because it's done, or not (caller should continue)
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ReadEntry(Ionic.Zip.ZipContainer,System.Boolean)">
            <summary>
              Reads one <c>ZipEntry</c> from the given stream.  The content for
              the entry does not get decompressed or decrypted.  This method
              basically reads metadata, and seeks.
            </summary>
            <param name="zc">the ZipContainer this entry belongs to.</param>
            <param name="first">
              true of this is the first entry being read from the stream.
            </param>
            <returns>the <c>ZipEntry</c> read from the stream.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.FindExtraFieldSegment(System.Byte[],System.Int32,System.UInt16)">
            <summary>
              Finds a particular segment in the given extra field.
              This is used when modifying a previously-generated
              extra field, in particular when removing the AES crypto
              segment in the extra field.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ProcessExtraField(System.IO.Stream,System.Int16)">
            <summary>
              At current cursor position in the stream, read the extra
              field, and set the properties on the ZipEntry instance
              appropriately.  This can be called when processing the
              Extra field in the Central Directory, or in the local
              header.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.GetEncodedFileNameBytes">
            <summary>
              generate and return a byte array that encodes the filename
              for the entry.
            </summary>
            <remarks>
                <para>
                side effects: generate and store into _CommentBytes the
                byte array for any comment attached to the entry. Also
                sets _actualEncoding to indicate the actual encoding
                used. The same encoding is used for both filename and
                comment.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.PrepSourceStream">
            <summary>
               Stores the position of the entry source stream, or, if the position is
               already stored, seeks to that position.
             </summary>
            <remarks>
                <para>
               This method is called in prep for reading the source stream.  If PKZIP
               encryption is used, then we need to calc the CRC32 before doing the
               encryption, because the CRC is used in the 12th byte of the PKZIP
               encryption header.  So, we need to be able to seek backward in the source
               when saving the ZipEntry. This method is called from the place that
               calculates the CRC, and also from the method that does the encryption of
               the file data.
             </para>
                <para>
               The first time through, this method sets the _sourceStreamOriginalPosition
               field. Subsequent calls to this method seek to that position.
             </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.CopyMetaData(Ionic.Zip.ZipEntry)">
            <summary>
            Copy metadata that may have been changed by the app.  We do this when
            resetting the zipFile instance.  If the app calls Save() on a ZipFile, then
            tries to party on that file some more, we may need to Reset() it , which
            means re-reading the entries and then copying the metadata.  I think.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.SetInputAndFigureFileLength(System.IO.Stream@)">
            <summary>
              Set the input stream and get its length, if possible.  The length is
              used for progress updates, AND, to allow an optimization in case of
              a stream/file of zero length. In that case we skip the Encrypt and
              compression Stream. (like DeflateStream or BZip2OutputStream)
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.PrepOutputStream(System.IO.Stream,System.Int64,Ionic.Zip.CountingStream@,System.IO.Stream@,System.IO.Stream@,Ionic.Crc.CrcCalculatorStream@)">
            <summary>
              Prepare the given stream for output - wrap it in a CountingStream, and
              then in a CRC stream, and an encryptor and deflator as appropriate.
            </summary>
            <remarks>
                <para>
                Previously this was used in ZipEntry.Write(), but in an effort to
                introduce some efficiencies in that method I've refactored to put the
                code inline.  This method still gets called by ZipOutputStream.
              </para>
            </remarks>
        </member>
        <member name="T:Ionic.Zip.ZipEntryTimestamp">
            <summary>
               An enum that specifies the type of timestamp available on the ZipEntry.
             </summary>
            <remarks>
                <para>
               The last modified time of a file can be stored in multiple ways in
               a zip file, and they are not mutually exclusive:
             </para>
                <list type="bullet">
                    <item>
                 In the so-called "DOS" format, which has a 2-second precision. Values
                 are rounded to the nearest even second. For example, if the time on the
                 file is 12:34:43, then it will be stored as 12:34:44. This first value
                 is accessible via the <c>LastModified</c> property. This value is always
                 present in the metadata for each zip entry.  In some cases the value is
                 invalid, or zero.
               </item>
                    <item>
                 In the so-called "Windows" or "NTFS" format, as an 8-byte integer
                 quantity expressed as the number of 1/10 milliseconds (in other words
                 the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
                 format is how Windows represents file times.  This time is accessible
                 via the <c>ModifiedTime</c> property.
               </item>
                    <item>
                 In the "Unix" format, a 4-byte quantity specifying the number of seconds since
                 January 1, 1970 UTC.
               </item>
                    <item>
                 In an older format, now deprecated but still used by some current
                 tools. This format is also a 4-byte quantity specifying the number of
                 seconds since January 1, 1970 UTC.
               </item>
                </list>
                <para>
               This bit field describes which of the formats were found in a <c>ZipEntry</c> that was read.
             </para>
            </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.None">
            <summary>
            Default value.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.DOS">
            <summary>
            A DOS timestamp with 2-second precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.Windows">
            <summary>
            A Windows timestamp with 100-ns precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.Unix">
            <summary>
            A Unix timestamp with 1-second precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.InfoZip1">
            <summary>
            A Unix timestamp with 1-second precision, stored in InfoZip v1 format.  This
            format is outdated and is supported for reading archives only.
            </summary>
        </member>
        <member name="T:Ionic.Zip.CompressionMethod">
            <summary>
               The method of compression to use for a particular ZipEntry.
             </summary>
            <remarks>
                <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
               ZIP Specification</see> describes a number of distinct
               cmopression methods that can be used within a zip
               file. DotNetZip supports a subset of them.
             </remarks>
        </member>
        <member name="F:Ionic.Zip.CompressionMethod.None">
            <summary>
            No compression at all. For COM environments, the value is 0 (zero).
            </summary>
        </member>
        <member name="F:Ionic.Zip.CompressionMethod.Deflate">
            <summary>
              DEFLATE compression, as described in <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC
              1951</see>.  This is the "normal" compression used in zip
              files. For COM environments, the value is 8.
            </summary>
        </member>
        <member name="F:Ionic.Zip.CompressionMethod.BZip2">
            <summary>
              BZip2 compression, a compression algorithm developed by Julian Seward.
              For COM environments, the value is 12.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipEntrySource">
            <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.None">
            <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.FileSystem">
            <summary>
            The entry was instantiated by calling AddFile() or another method that 
            added an entry from the filesystem.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.Stream">
            <summary>
            The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)" /> or
            <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)" /> .
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.ZipFile">
            <summary>
            The ZipEntry was instantiated by reading a zipfile.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.WriteDelegate">
            <summary>
            The content for the ZipEntry will be or was provided by the WriteDelegate.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.JitStream">
            <summary>
            The content for the ZipEntry will be obtained from the stream dispensed by the <c>OpenDelegate</c>.
            The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.ZipOutputStream">
            <summary>
            The content for the ZipEntry will be or was obtained from a <c>ZipOutputStream</c>.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipErrorAction">
            <summary>
             An enum providing the options when an error occurs during opening or reading
             of a file or directory that is being saved to a zip file. 
             </summary>
            <remarks>
                <para>
                This enum describes the actions that the library can take when an error occurs
                opening or reading a file, as it is being saved into a Zip archive. 
              </para>
                <para>
                 In some cases an error will occur when DotNetZip tries to open a file to be
                 added to the zip archive.  In other cases, an error might occur after the
                 file has been successfully opened, while DotNetZip is reading the file.
              </para>
                <para>
                The first problem might occur when calling AddDirectory() on a directory
                that contains a Clipper .dbf file; the file is locked by Clipper and
                cannot be opened by another process. An example of the second problem is
                the ERROR_LOCK_VIOLATION that results when a file is opened by another
                process, but not locked, and a range lock has been taken on the file.
                Microsoft Outlook takes range locks on .PST files.
              </para>
            </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Throw">
            <summary>
            Throw an exception when an error occurs while zipping.  This is the default
            behavior.  (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Skip">
            <summary>
            When an error occurs during zipping, for example a file cannot be opened,
            skip the file causing the error, and continue zipping.  (For COM clients,
            this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Retry">
            <summary>
            When an error occurs during zipping, for example a file cannot be opened,
            retry the operation that caused the error. Be careful with this option. If
            the error is not temporary, the library will retry forever.  (For COM
            clients, this is a 2.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.InvokeErrorEvent">
            <summary>
            When an error occurs, invoke the zipError event.  The event type used is
            <see cref="F:Ionic.Zip.ZipProgressEventType.Error_Saving" />.  A typical use of this option:
            a GUI application may wish to pop up a dialog to allow the user to view the
            error that occurred, and choose an appropriate action.  After your
            processing in the error event, if you want to skip the file, set <see cref="P:Ionic.Zip.ZipEntry.ZipErrorAction" /> on the
            <c>ZipProgressEventArgs.CurrentEntry</c> to <c>Skip</c>.  If you want the
            exception to be thrown, set <c>ZipErrorAction</c> on the <c>CurrentEntry</c>
            to <c>Throw</c>.  If you want to cancel the zip, set
            <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
            Skip in that a cancel will not save any further entries, if there are any.
            (For COM clients, the value of this enum is a 3.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.Zip64Option">
            <summary>
               Options for using ZIP64 extensions when saving zip archives.
             </summary>
            <remarks>
                <para>
               Designed many years ago, the <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">original zip
               specification from PKWARE</see> allowed for 32-bit quantities for the
               compressed and uncompressed sizes of zip entries, as well as a 32-bit quantity
               for specifying the length of the zip archive itself, and a maximum of 65535
               entries.  These limits are now regularly exceeded in many backup and archival
               scenarios.  Recently, PKWare added extensions to the original zip spec, called
               "ZIP64 extensions", to raise those limitations.  This property governs whether
               DotNetZip will use those extensions when writing zip archives. The use of
               these extensions is optional and explicit in DotNetZip because, despite the
               status of ZIP64 as a bona fide standard, many other zip tools and libraries do
               not support ZIP64, and therefore a zip file with ZIP64 extensions may be
               unreadable by some of those other tools.
             </para>
                <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.Always" /> to always use ZIP64
               extensions when saving, regardless of whether your zip archive needs it.
               Suppose you add 5 files, each under 100k, to a ZipFile. If you specify Always
               for this flag, you will get a ZIP64 archive, though the archive does not need
               to use ZIP64 because none of the original zip limits had been exceeded.
             </para>
                <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.Never" /> to tell the DotNetZip
               library to never use ZIP64 extensions.  This is useful for maximum
               compatibility and interoperability, at the expense of the capability of
               handling large files or large archives.  NB: Windows Explorer in Windows XP
               and Windows Vista cannot currently extract files from a zip64 archive, so if
               you want to guarantee that a zip archive produced by this library will work in
               Windows Explorer, use <c>Never</c>. If you set this property to <see cref="F:Ionic.Zip.Zip64Option.Never" />, and your application creates a zip that would
               exceed one of the Zip limits, the library will throw an exception while saving
               the zip file.
             </para>
                <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> to tell the
               DotNetZip library to use the ZIP64 extensions when required by the
               entry. After the file is compressed, the original and compressed sizes are
               checked, and if they exceed the limits described above, then zip64 can be
               used. That is the general idea, but there is an additional wrinkle when saving
               to a non-seekable device, like the ASP.NET <c>Response.OutputStream</c>, or
               <c>Console.Out</c>.  When using non-seekable streams for output, the entry
               header - which indicates whether zip64 is in use - is emitted before it is
               known if zip64 is necessary.  It is only after all entries have been saved
               that it can be known if ZIP64 will be required.  On seekable output streams,
               after saving all entries, the library can seek backward and re-emit the zip
               file header to be consistent with the actual ZIP64 requirement.  But using a
               non-seekable output stream, the library cannot seek backward, so the header
               can never be changed. In other words, the archive's use of ZIP64 extensions is
               not alterable after the header is emitted.  Therefore, when saving to
               non-seekable streams, using <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> is the same
               as using <see cref="F:Ionic.Zip.Zip64Option.Always" />: it will always produce a zip
               archive that uses ZIP64 extensions.
             </para>
            </remarks>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Default">
            <summary>
            The default behavior, which is "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Never">
            <summary>
            Do not use ZIP64 extensions when writing zip archives.
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.AsNecessary">
            <summary>
            Use ZIP64 extensions when writing zip archives, as necessary.
            For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole
            exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Always">
            <summary>
            Always use ZIP64 extensions when writing zip archives, even when unnecessary.
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipOption">
            <summary>
             An enum representing the values on a three-way toggle switch
             for various options in the library. This might be used to
             specify whether to employ a particular text encoding, or to use
             ZIP64 extensions, or some other option.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Default">
            <summary>
            The default behavior. This is the same as "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Never">
            <summary>
            Never use the associated option.
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.AsNecessary">
            <summary>
            Use the associated behavior "as necessary."
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Always">
            <summary>
            Use the associated behavior Always, whether necessary or not.
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ReadOptions">
            <summary>
               A class for collecting the various options that can be used when
               Reading zip files for extraction or update.
             </summary>
            <remarks>
                <para>
                 When reading a zip file, there are several options an
                 application can set, to modify how the file is read, or what
                 the library does while reading.  This class collects those
                 options into one container.
               </para>
                <para>
                 Pass an instance of the <c>ReadOptions</c> class into the
                 <c>ZipFile.Read()</c> method.
               </para>
                <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)" />.
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)" />.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.ReadProgress">
            <summary>
            An event handler for Read operations.  When opening large zip
            archives, you may want to display a progress bar or other
            indicator of status progress while reading.  This parameter
            allows you to specify a ReadProgress Event Handler directly.
            When you call <c>Read()</c>, the progress event is invoked as
            necessary.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.StatusMessageWriter">
            <summary>
            The <c>System.IO.TextWriter</c> to use for writing verbose status messages
            during operations on the zip archive.  A console application may wish to
            pass <c>System.Console.Out</c> to get messages on the Console. A graphical
            or headless application may wish to capture the messages in a different
            <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.Encoding">
            <summary>
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
        </member>
        <member name="T:Ionic.Zip.ZipInputStream">
            <summary>
               Provides a stream metaphor for reading zip files.
             </summary>
            <remarks>
                <para>
               This class provides an alternative programming model for reading zip files to
               the one enabled by the <see cref="T:Ionic.Zip.ZipFile" /> class.  Use this when reading zip
               files, as an alternative to the <see cref="T:Ionic.Zip.ZipFile" /> class, when you would
               like to use a Stream class to read the file.
             </para>
                <para>
               Some application designs require a readable stream for input. This stream can
               be used to read a zip file, and extract entries.
             </para>
                <para>
               Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
               to read and extract zip files.  Both of them support many of the common zip
               features, including Unicode, different compression levels, and ZIP64.  The
               programming models differ. For example, when extracting entries via calls to
               the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
               <c>ZipInputStream</c> class, the caller is responsible for creating the file,
               writing the bytes into the file, setting the attributes on the file, and
               setting the created, last modified, and last accessed timestamps on the
               file. All of these things are done automatically by a call to <see cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract()</see>.  For this reason, the
               <c>ZipInputStream</c> is generally recommended for when your application wants
               to extract the data, without storing that data into a file.
             </para>
                <para>
               Aside from the obvious differences in programming model, there are some
               differences in capability between the <c>ZipFile</c> class and the
               <c>ZipInputStream</c> class.
             </para>
                <list type="bullet">
                    <item>
                        <c>ZipFile</c> can be used to create or update zip files, or read and
                 extract zip files. <c>ZipInputStream</c> can be used only to read and
                 extract zip files. If you want to use a stream to create zip files, check
                 out the <see cref="T:Ionic.Zip.ZipOutputStream" />.
               </item>
                    <item>
                        <c>ZipInputStream</c> cannot read segmented or spanned
                 zip files.
               </item>
                    <item>
                        <c>ZipInputStream</c> will not read Zip file comments.
               </item>
                    <item>
                 When reading larger files, <c>ZipInputStream</c> will always underperform
                 <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
                 zip file, while the <c>ZipFile</c> class reads the central directory of the
                 zip file.
               </item>
                </list>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)">
            <summary>
               Create a <c>ZipInputStream</c>, wrapping it around an existing stream.
             </summary>
            <remarks>
                <para>
               While the <see cref="T:Ionic.Zip.ZipFile" /> class is generally easier
               to use, this class provides an alternative to those
               applications that want to read from a zipfile directly,
               using a <see cref="T:System.IO.Stream" />.
             </para>
                <para>
               Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
               to read and extract zip files.  Both of them support many of the common zip
               features, including Unicode, different compression levels, and ZIP64.  The
               programming models differ. For example, when extracting entries via calls to
               the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
               <c>ZipInputStream</c> class, the caller is responsible for creating the file,
               writing the bytes into the file, setting the attributes on the file, and
               setting the created, last modified, and last accessed timestamps on the
               file. All of these things are done automatically by a call to <see cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract()</see>.  For this reason, the
               <c>ZipInputStream</c> is generally recommended for when your application wants
               to extract the data, without storing that data into a file.
             </para>
                <para>
               Aside from the obvious differences in programming model, there are some
               differences in capability between the <c>ZipFile</c> class and the
               <c>ZipInputStream</c> class.
             </para>
                <list type="bullet">
                    <item>
                        <c>ZipFile</c> can be used to create or update zip files, or read and extract
               zip files. <c>ZipInputStream</c> can be used only to read and extract zip
                 files. If you want to use a stream to create zip files, check out the <see cref="T:Ionic.Zip.ZipOutputStream" />.
               </item>
                    <item>
                        <c>ZipInputStream</c> cannot read segmented or spanned
                 zip files.
               </item>
                    <item>
                        <c>ZipInputStream</c> will not read Zip file comments.
               </item>
                    <item>
                 When reading larger files, <c>ZipInputStream</c> will always underperform
                 <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
                 zip file, while the <c>ZipFile</c> class reads the central directory of the
                 zip file.
               </item>
                </list>
            </remarks>
            <param name="stream">
               The stream to read. It must be readable. This stream will be closed at
               the time the <c>ZipInputStream</c> is closed.
             </param>
            <example>
            
               This example shows how to read a zip file, and extract entries, using the
               <c>ZipInputStream</c> class.
            
             <code lang="C#">
             private void Unzip()
             {
                 byte[] buffer= new byte[2048];
                 int n;
                 using (var raw = File.Open(inputFileName, FileMode.Open, FileAccess.Read))
                 {
                     using (var input= new ZipInputStream(raw))
                     {
                         ZipEntry e;
                         while (( e = input.GetNextEntry()) != null)
                         {
                             if (e.IsDirectory) continue;
                             string outputPath = Path.Combine(extractDir, e.FileName);
                             using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                             {
                                 while ((n= input.Read(buffer, 0, buffer.Length)) &gt; 0)
                                 {
                                     output.Write(buffer,0,n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Private Sub UnZip()
                 Dim inputFileName As String = "MyArchive.zip"
                 Dim extractDir As String = "extract"
                 Dim buffer As Byte() = New Byte(2048) {}
                 Using raw As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read)
                     Using input As ZipInputStream = New ZipInputStream(raw)
                         Dim e As ZipEntry
                         Do While (Not e = input.GetNextEntry Is Nothing)
                             If Not e.IsDirectory Then
                                 Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
                                                                        FileMode.Create, FileAccess.ReadWrite)
                                     Dim n As Integer
                                     Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
                                         output.Write(buffer, 0, n)
                                     Loop
                                 End Using
                             End If
                         Loop
                     End Using
                 End Using
             End Sub
             </code></example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.String)">
            <summary>
               Create a <c>ZipInputStream</c>, given the name of an existing zip file.
             </summary>
            <remarks>
                <para>
               This constructor opens a <c>FileStream</c> for the given zipfile, and
               wraps a <c>ZipInputStream</c> around that.  See the documentation for the
               <see cref="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)" /> constructor for full details.
             </para>
                <para>
               While the <see cref="T:Ionic.Zip.ZipFile" /> class is generally easier
               to use, this class provides an alternative to those
               applications that want to read from a zipfile directly,
               using a <see cref="T:System.IO.Stream" />.
             </para>
            </remarks>
            <param name="fileName">
               The name of the filesystem file to read.
             </param>
            <example>
            
               This example shows how to read a zip file, and extract entries, using the
               <c>ZipInputStream</c> class.
            
             <code lang="C#">
             private void Unzip()
             {
                 byte[] buffer= new byte[2048];
                 int n;
                 using (var input= new ZipInputStream(inputFileName))
                 {
                     ZipEntry e;
                     while (( e = input.GetNextEntry()) != null)
                     {
                         if (e.IsDirectory) continue;
                         string outputPath = Path.Combine(extractDir, e.FileName);
                         using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                         {
                             while ((n= input.Read(buffer, 0, buffer.Length)) &gt; 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Private Sub UnZip()
                 Dim inputFileName As String = "MyArchive.zip"
                 Dim extractDir As String = "extract"
                 Dim buffer As Byte() = New Byte(2048) {}
                 Using input As ZipInputStream = New ZipInputStream(inputFileName)
                     Dim e As ZipEntry
                     Do While (Not e = input.GetNextEntry Is Nothing)
                         If Not e.IsDirectory Then
                             Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
                                                                    FileMode.Create, FileAccess.ReadWrite)
                                 Dim n As Integer
                                 Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
                                     output.Write(buffer, 0, n)
                                 Loop
                             End Using
                         End If
                     Loop
                 End Using
             End Sub
             </code></example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
               Create a <c>ZipInputStream</c>, explicitly specifying whether to
               keep the underlying stream open.
             </summary>
            <remarks>
               See the documentation for the <see cref="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)">ZipInputStream(Stream)</see>
               constructor for a discussion of the class, and an example of how to use the class.
             </remarks>
            <param name="stream">
               The stream to read from. It must be readable.
             </param>
            <param name="leaveOpen">
               true if the application would like the stream
               to remain open after the <c>ZipInputStream</c> has been closed.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <remarks>
                <para>
                This can be useful for debugging purposes.
              </para>
            </remarks>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.ProvisionalAlternateEncoding">
            <summary>
               The text encoding to use when reading entries into the zip archive, for
               those entries whose filenames or comments cannot be encoded with the
               default (IBM437) encoding.
             </summary>
            <remarks>
                <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
                <para>
               When using DotNetZip to read zip archives that use something other than
               UTF-8 or IBM437, set this property to specify the code page to use when
               reading encoded filenames and comments for each <c>ZipEntry</c> in the zip
               file.
             </para>
                <para>
               This property is "provisional". When the entry in the zip archive is not
               explicitly marked as using UTF-8, then IBM437 is used to decode filenames
               and comments. If a loss of data would result from using IBM436 -
               specifically when encoding and decoding is not reflexive - the codepage
               specified here is used. It is possible, therefore, to have a given entry
               with a <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with
               the specified "provisional" codepage.
             </para>
                <para>
               When a zip file uses an arbitrary, non-UTF8 code page for encoding, there
               is no standard way for the reader application - whether DotNetZip, WinZip,
               WinRar, or something else - to know which codepage has been used for the
               entries. Readers of zip files are not able to inspect the zip file and
               determine the codepage that was used for the entries contained within it.
               It is left to the application or user to determine the necessary codepage
               when reading zip files encoded this way.  If you use an incorrect codepage
               when reading a zipfile, you will get entries with filenames that are
               incorrect, and the incorrect filenames may even contain characters that
               are not legal for use within filenames in Windows. Extracting entries with
               illegal characters in the filenames will lead to exceptions. It's too bad,
               but this is just the way things are with code pages in zip files. Caveat
               Emptor.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CodecBufferSize">
            <summary>
               Size of the work buffer to use for the ZLIB codec during decompression.
             </summary>
            <remarks>
               Setting this affects the performance and memory efficiency of compression
               and decompression.  For larger files, setting this to a larger size may
               improve performance, but the exact numbers vary depending on available
               memory, and a bunch of other variables. I don't have good firm
               recommendations on how to set it.  You'll have to test it yourself. Or
               just leave it alone and accept the default.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Password">
            <summary>
               Sets the password to be used on the <c>ZipInputStream</c> instance.
             </summary>
            <remarks>
                <para>
               When reading a zip archive, this password is used to read and decrypt the
               entries that are encrypted within the zip file. When entries within a zip
               file use different passwords, set the appropriate password for the entry
               before the first call to <c>Read()</c> for each entry.
             </para>
                <para>
               When reading an entry that is not encrypted, the value of this property is
               ignored.
             </para>
            </remarks>
            <example>
            
               This example uses the ZipInputStream to read and extract entries from a
               zip file, using a potentially different password for each entry.
            
             <code lang="C#">
             byte[] buffer= new byte[2048];
             int n;
             using (var raw = File.Open(_inputFileName, FileMode.Open, FileAccess.Read ))
             {
                 using (var input= new ZipInputStream(raw))
                 {
                     ZipEntry e;
                     while (( e = input.GetNextEntry()) != null)
                     {
                         input.Password = PasswordForEntry(e.FileName);
                         if (e.IsDirectory) continue;
                         string outputPath = Path.Combine(_extractDir, e.FileName);
                         using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                         {
                             while ((n= input.Read(buffer,0,buffer.Length)) &gt; 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
            
             </code></example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
               Read the data from the stream into the buffer.
             </summary>
            <remarks>
                <para>
               The data for the zipentry will be decrypted and uncompressed, as
               necessary, before being copied into the buffer.
             </para>
                <para>
               You must set the <see cref="P:Ionic.Zip.ZipInputStream.Password" /> property before calling
               <c>Read()</c> the first time for an encrypted entry.  To determine if an
               entry is encrypted and requires a password, check the <see cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</see> property.
             </para>
            </remarks>
            <param name="buffer">The buffer to hold the data read from the stream.</param>
            <param name="offset">the offset within the buffer to copy the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
            <returns>the number of bytes read, after decryption and decompression.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.GetNextEntry">
            <summary>
               Read the next entry from the zip file.
             </summary>
            <remarks>
                <para>
               Call this method just before calling <see cref="M:Ionic.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)" />,
               to position the pointer in the zip file to the next entry that can be
               read.  Subsequent calls to <c>Read()</c>, will decrypt and decompress the
               data in the zip file, until <c>Read()</c> returns 0.
             </para>
                <para>
               Each time you call <c>GetNextEntry()</c>, the pointer in the wrapped
               stream is moved to the next entry in the zip file.  If you call <see cref="M:Ionic.Zip.ZipInputStream.Seek(System.Int64,System.IO.SeekOrigin)" />, and thus re-position the pointer within
               the file, you will need to call <c>GetNextEntry()</c> again, to insure
               that the file pointer is positioned at the beginning of a zip entry.
             </para>
                <para>
               This method returns the <c>ZipEntry</c>. Using a stream approach, you will
               read the raw bytes for an entry in a zip file via calls to <c>Read()</c>.
               Alternatively, you can extract an entry into a file, or a stream, by
               calling <see cref="M:Ionic.Zip.ZipEntry.Extract" />, or one of its siblings.
             </para>
            </remarks>
            <returns>
               The <c>ZipEntry</c> read. Returns null (or Nothing in VB) if there are no more
               entries in the zip file.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Dispose(System.Boolean)">
            <summary>
               Dispose the stream.
             </summary>
            <remarks>
                <para>
               This method disposes the ZipInputStream.  It may also close the
               underlying stream, depending on which constructor was used.
             </para>
                <para>
               Typically the application will call <c>Dispose()</c> implicitly, via
               a <c>using</c> statement in C#, or a <c>Using</c> statement in VB.
             </para>
                <para>
                 Application code won't call this code directly.  This method may
                 be invoked in two distinct scenarios.  If disposing == true, the
                 method has been called directly or indirectly by a user's code,
                 for example via the public Dispose() method. In this case, both
                 managed and unmanaged resources can be referenced and disposed.
                 If disposing == false, the method has been called by the runtime
                 from inside the object finalizer and this method should not
                 reference other objects; in that case only unmanaged resources
                 must be referenced or disposed.
               </para>
            </remarks>
            <param name="disposing">
               true if the Dispose method was invoked by user code.
             </param>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanRead">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanSeek">
            <summary>
            Returns the value of <c>CanSeek</c> for the underlying (wrapped) stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanWrite">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Length">
            <summary>
            Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Position">
            <summary>
            Gets or sets the position of the underlying stream.
            </summary>
            <remarks>
            Setting the position is equivalent to calling <c>Seek(value, SeekOrigin.Begin)</c>.
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Flush">
            <summary>
            This is a no-op.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">ignored</param>
            <param name="offset">ignored</param>
            <param name="count">ignored</param>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
               This method seeks in the underlying stream.
             </summary>
            <remarks>
                <para>
               Call this method if you want to seek around within the zip file for random access.
             </para>
                <para>
               Applications can intermix calls to <c>Seek()</c> with calls to <see cref="M:Ionic.Zip.ZipInputStream.GetNextEntry" />.  After a call to <c>Seek()</c>,
               <c>GetNextEntry()</c> will get the next <c>ZipEntry</c> that falls after
               the current position in the input stream. You're on your own for finding
               out just where to seek in the stream, to get to the various entries.
             </para>
            </remarks>
            <param name="offset">the offset point to seek to</param>
            <param name="origin">the reference point from which to seek</param>
            <returns>The new position</returns>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">ignored</param>
        </member>
        <member name="T:Ionic.Zip.ZipOutputStream">
            <summary>
               Provides a stream metaphor for generating zip files.
             </summary>
            <remarks>
                <para>
               This class writes zip files, as defined in the <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
               for zip files described by PKWare</see>.  The compression for this
               implementation is provided by a managed-code version of Zlib, included with
               DotNetZip in the classes in the Ionic.Zlib namespace.
             </para>
                <para>
               This class provides an alternative programming model to the one enabled by the
               <see cref="T:Ionic.Zip.ZipFile" /> class. Use this when creating zip files, as an
               alternative to the <see cref="T:Ionic.Zip.ZipFile" /> class, when you would like to use a
               <c>Stream</c> type to write the zip file.
             </para>
                <para>
               Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can be used
               to create zip files. Both of them support many of the common zip features,
               including Unicode, different compression levels, and ZIP64.   They provide
               very similar performance when creating zip files.
             </para>
                <para>
               The <c>ZipFile</c> class is generally easier to use than
               <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
               example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
               <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
               responsible for opening the file, reading the bytes from the file, writing
               those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
               <c>ZipEntry</c>, and setting the created, last modified, and last accessed
               timestamps on the zip entry. All of these things are done automatically by a
               call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">ZipFile.AddFile()</see>.
               For this reason, the <c>ZipOutputStream</c> is generally recommended for use
               only when your application emits arbitrary data, not necessarily data from a
               filesystem file, directly into a zip file, and does so using a <c>Stream</c>
               metaphor.
             </para>
                <para>
               Aside from the differences in programming model, there are other
               differences in capability between the two classes.
             </para>
                <list type="bullet">
                    <item>
                        <c>ZipFile</c> can be used to read and extract zip files, in addition to
                 creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
                 to use a stream to read zip files, check out the <see cref="T:Ionic.Zip.ZipInputStream" /> class.
               </item>
                    <item>
                        <c>ZipOutputStream</c> does not support the creation of segmented or spanned
                 zip files.
               </item>
                    <item>
                        <c>ZipOutputStream</c> cannot produce a self-extracting archive.
               </item>
                </list>
                <para>
               Be aware that the <c>ZipOutputStream</c> class implements the <see cref="T:System.IDisposable" /> interface.  In order for
               <c>ZipOutputStream</c> to produce a valid zip file, you use use it within
               a using clause (<c>Using</c> in VB), or call the <c>Dispose()</c> method
               explicitly.  See the examples for how to employ a using clause.
             </para>
                <para>
               Also, a note regarding compression performance: On the desktop .NET
               Framework, DotNetZip can use a multi-threaded compression implementation
               that provides significant speed increases on large files, over 300k or so,
               at the cost of increased memory use at runtime.  (The output of the
               compression is almost exactly the same size).  But, the multi-threaded
               approach incurs a performance hit on smaller files. There's no way for the
               ZipOutputStream to know whether parallel compression will be beneficial,
               because the ZipOutputStream does not know how much data you will write
               through the stream.  You may wish to set the <see cref="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold" /> property to zero, if you are compressing
               large files through <c>ZipOutputStream</c>.  This will cause parallel
               compression to be used, always.
             </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream)">
            <summary>
               Create a ZipOutputStream, wrapping an existing stream.
             </summary>
            <remarks>
                <para>
               The <see cref="T:Ionic.Zip.ZipFile" /> class is generally easier to use when creating
               zip files. The ZipOutputStream offers a different metaphor for creating a
               zip file, based on the <see cref="T:System.IO.Stream" /> class.
             </para>
            </remarks>
            <param name="stream">
             The stream to wrap. It must be writable. This stream will be closed at
             the time the ZipOutputStream is closed.
             </param>
            <example>
            
               This example shows how to create a zip file, using the
               ZipOutputStream class.
            
             <code lang="C#">
             private void Zipup()
             {
                 if (filesToZip.Count == 0)
                 {
                     System.Console.WriteLine("Nothing to do.");
                     return;
                 }
            
                 using (var raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
                 {
                     using (var output= new ZipOutputStream(raw))
                     {
                         output.Password = "VerySecret!";
                         output.Encryption = EncryptionAlgorithm.WinZipAes256;
            
                         foreach (string inputFileName in filesToZip)
                         {
                             System.Console.WriteLine("file: {0}", inputFileName);
            
                             output.PutNextEntry(inputFileName);
                             using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Write ))
                             {
                                 byte[] buffer= new byte[2048];
                                 int n;
                                 while ((n= input.Read(buffer,0,buffer.Length)) &gt; 0)
                                 {
                                     output.Write(buffer,0,n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Private Sub Zipup()
                 Dim outputFileName As String = "XmlData.zip"
                 Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
                 If (filesToZip.Length = 0) Then
                     Console.WriteLine("Nothing to do.")
                 Else
                     Using raw As FileStream = File.Open(outputFileName, FileMode.Create, FileAccess.ReadWrite)
                         Using output As ZipOutputStream = New ZipOutputStream(raw)
                             output.Password = "VerySecret!"
                             output.Encryption = EncryptionAlgorithm.WinZipAes256
                             Dim inputFileName As String
                             For Each inputFileName In filesToZip
                                 Console.WriteLine("file: {0}", inputFileName)
                                 output.PutNextEntry(inputFileName)
                                 Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                                     Dim n As Integer
                                     Dim buffer As Byte() = New Byte(2048) {}
                                     Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
                                         output.Write(buffer, 0, n)
                                     Loop
                                 End Using
                             Next
                         End Using
                     End Using
                 End If
             End Sub
             </code></example>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.String)">
            <summary>
               Create a ZipOutputStream that writes to a filesystem file.
             </summary>
            <remarks>
               The <see cref="T:Ionic.Zip.ZipFile" /> class is generally easier to use when creating
               zip files. The ZipOutputStream offers a different metaphor for creating a
               zip file, based on the <see cref="T:System.IO.Stream" /> class.
             </remarks>
            <param name="fileName">
               The name of the zip file to create.
             </param>
            <example>
            
               This example shows how to create a zip file, using the
               ZipOutputStream class.
            
             <code lang="C#">
             private void Zipup()
             {
                 if (filesToZip.Count == 0)
                 {
                     System.Console.WriteLine("Nothing to do.");
                     return;
                 }
            
                 using (var output= new ZipOutputStream(outputFileName))
                 {
                     output.Password = "VerySecret!";
                     output.Encryption = EncryptionAlgorithm.WinZipAes256;
            
                     foreach (string inputFileName in filesToZip)
                     {
                         System.Console.WriteLine("file: {0}", inputFileName);
            
                         output.PutNextEntry(inputFileName);
                         using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read,
                                                      FileShare.Read | FileShare.Write ))
                         {
                             byte[] buffer= new byte[2048];
                             int n;
                             while ((n= input.Read(buffer,0,buffer.Length)) &gt; 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Private Sub Zipup()
                 Dim outputFileName As String = "XmlData.zip"
                 Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
                 If (filesToZip.Length = 0) Then
                     Console.WriteLine("Nothing to do.")
                 Else
                     Using output As ZipOutputStream = New ZipOutputStream(outputFileName)
                         output.Password = "VerySecret!"
                         output.Encryption = EncryptionAlgorithm.WinZipAes256
                         Dim inputFileName As String
                         For Each inputFileName In filesToZip
                             Console.WriteLine("file: {0}", inputFileName)
                             output.PutNextEntry(inputFileName)
                             Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                                 Dim n As Integer
                                 Dim buffer As Byte() = New Byte(2048) {}
                                 Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
                                     output.Write(buffer, 0, n)
                                 Loop
                             End Using
                         Next
                     End Using
                 End If
             End Sub
             </code></example>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
               Create a ZipOutputStream.
             </summary>
            <remarks>
               See the documentation for the <see cref="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream)">ZipOutputStream(Stream)</see>
               constructor for an example.
             </remarks>
            <param name="stream">
               The stream to wrap. It must be writable.
             </param>
            <param name="leaveOpen">
               true if the application would like the stream
               to remain open after the <c>ZipOutputStream</c> has been closed.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <remarks>
                <para>
                This can be useful for debugging purposes.
              </para>
            </remarks>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Password">
            <summary>
               Sets the password to be used on the <c>ZipOutputStream</c> instance.
             </summary>
            <remarks>
                <para>
               When writing a zip archive, this password is applied to the entries, not
               to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
               written to the <c>ZipOutputStream</c>.
             </para>
                <para>
               Using a password does not encrypt or protect the "directory" of the
               archive - the list of entries contained in the archive.  If you set the
               <c>Password</c> property, the password actually applies to individual
               entries that are added to the archive, subsequent to the setting of this
               property.  The list of filenames in the archive that is eventually created
               will appear in clear text, but the contents of the individual files are
               encrypted.  This is how Zip encryption works.
             </para>
                <para>
               If you set this property, and then add a set of entries to the archive via
               calls to <c>PutNextEntry</c>, then each entry is encrypted with that
               password.  You may also want to change the password between adding
               different entries. If you set the password, add an entry, then set the
               password to <c>null</c> (<c>Nothing</c> in VB), and add another entry, the
               first entry is encrypted and the second is not.
             </para>
                <para>
               When setting the <c>Password</c>, you may also want to explicitly set the <see cref="P:Ionic.Zip.ZipOutputStream.Encryption" /> property, to specify how to encrypt the entries added
               to the ZipFile.  If you set the <c>Password</c> to a non-null value and do not
               set <see cref="P:Ionic.Zip.ZipOutputStream.Encryption" />, then PKZip 2.0 ("Weak") encryption is used.
               This encryption is relatively weak but is very interoperable. If
               you set the password to a <c>null</c> value (<c>Nothing</c> in VB),
               <c>Encryption</c> is reset to None.
             </para>
                <para>
               Special case: if you wrap a ZipOutputStream around a non-seekable stream,
               and use encryption, and emit an entry of zero bytes, the <c>Close()</c> or
               <c>PutNextEntry()</c> following the entry will throw an exception.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Encryption">
            <summary>
               The Encryption to use for entries added to the <c>ZipOutputStream</c>.
             </summary>
            <remarks>
                <para>
               The specified Encryption is applied to the entries subsequently
               written to the <c>ZipOutputStream</c> instance.
             </para>
                <para>
               If you set this to something other than
               EncryptionAlgorithm.None, you will also need to set the
               <see cref="P:Ionic.Zip.ZipOutputStream.Password" /> to a non-null, non-empty value in
               order to actually get encryption on the entry.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipOutputStream.Password">ZipOutputStream.Password</seealso>
            <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CodecBufferSize">
            <summary>
               Size of the work buffer to use for the ZLIB codec during compression.
             </summary>
            <remarks>
               Setting this may affect performance.  For larger files, setting this to a
               larger size may improve performance, but I'm not sure.  Sorry, I don't
               currently have good recommendations on how to set it.  You can test it if
               you like.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Strategy">
            <summary>
               The compression strategy to use for all entries.
             </summary>
            <remarks>
               Set the Strategy used by the ZLIB-compatible compressor, when compressing
               data for the entries in the zip archive. Different compression strategies
               work better on different sorts of data. The strategy parameter can affect
               the compression ratio and the speed of compression but not the correctness
               of the compresssion.  For more information see <see cref="T:Ionic.Zlib.CompressionStrategy" />.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Timestamp">
            <summary>
               The type of timestamp attached to the ZipEntry.
             </summary>
            <remarks>
               Set this in order to specify the kind of timestamp that should be emitted
               into the zip file for each entry.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CompressionLevel">
            <summary>
               Sets the compression level to be used for entries subsequently added to
               the zip archive.
             </summary>
            <remarks>
                <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
                <para>
                As with some other properties on the <c>ZipOutputStream</c> class, like <see cref="P:Ionic.Zip.ZipOutputStream.Password" />, and <see cref="P:Ionic.Zip.ZipOutputStream.Encryption" />,
                setting this property on a <c>ZipOutputStream</c>
                instance will cause the specified <c>CompressionLevel</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry" /> items that are subsequently added to the
                <c>ZipOutputStream</c> instance.
              </para>
                <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CompressionMethod">
            <summary>
              The compression method used on each entry added to the ZipOutputStream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Comment">
            <summary>
               A comment attached to the zip archive.
             </summary>
            <remarks>
                <para>
               The application sets this property to specify a comment to be embedded
               into the generated zip archive.
             </para>
                <para>
               According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see>, the comment is not encrypted, even if there is a
               password set on the zip file.
             </para>
                <para>
               The specification does not describe how to indicate the encoding used
               on a comment string. Many "compliant" zip tools and libraries use
               IBM437 as the code page for comments; DotNetZip, too, follows that
               practice.  On the other hand, there are situations where you want a
               Comment to be encoded with something else, for example using code page
               950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
               comment following the same procedure it follows for encoding
               filenames: (a) if <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage" /> is
               <c>Never</c>, it uses the default encoding (IBM437). (b) if <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage" /> is <c>Always</c>, it always uses the
               alternate encoding (<see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncoding" />). (c) if <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage" /> is <c>AsNecessary</c>, it uses the
               alternate encoding only if the default encoding is not sufficient for
               encoding the comment - in other words if decoding the result does not
               produce the original string.  This decision is taken at the time of
               the call to <c>ZipFile.Save()</c>.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.EnableZip64">
            <summary>
               Specify whether to use ZIP64 extensions when saving a zip archive.
             </summary>
            <remarks>
                <para>
               The default value for the property is <see cref="F:Ionic.Zip.Zip64Option.Never" />. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> is
               safest, in the sense that you will not get an Exception if a
               pre-ZIP64 limit is exceeded.
             </para>
                <para>
               You must set this property before calling <c>Write()</c>.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.OutputUsedZip64">
            <summary>
               Indicates whether ZIP64 extensions were used when saving the zip archive.
             </summary>
            <remarks>
               The value is defined only after the <c>ZipOutputStream</c> has been closed.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.IgnoreCase">
            <summary>
               Whether the ZipOutputStream should use case-insensitive comparisons when
               checking for uniqueness of zip entries.
             </summary>
            <remarks>
                <para>
               Though the zip specification doesn't prohibit zipfiles with duplicate
               entries, Sane zip files have no duplicates, and the DotNetZip library
               cannot create zip files with duplicate entries. If an application attempts
               to call <see cref="M:Ionic.Zip.ZipOutputStream.PutNextEntry(System.String)" /> with a name that duplicates one
               already used within the archive, the library will throw an Exception.
               </para>
                <para>
               This property allows the application to specify whether the
               ZipOutputStream instance considers ordinal case when checking for
               uniqueness of zip entries.
               </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.UseUnicodeAsNecessary">
            <summary>
               Indicates whether to encode entry filenames and entry comments using
               Unicode (UTF-8).
             </summary>
            <remarks>
                <para>
                    <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               PKWare zip specification</see> provides for encoding file names and file
               comments in either the IBM437 code page, or in UTF-8.  This flag selects
               the encoding according to that specification.  By default, this flag is
               false, and filenames and comments are encoded into the zip file in the
               IBM437 codepage.  Setting this flag to true will specify that filenames
               and comments that cannot be encoded with IBM437 will be encoded with
               UTF-8.
             </para>
                <para>
               Zip files created with strict adherence to the PKWare specification with
               respect to UTF-8 encoding can contain entries with filenames containing
               any combination of Unicode characters, including the full range of
               characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
               alphabets.  However, because at this time, the UTF-8 portion of the PKWare
               specification is not broadly supported by other zip libraries and
               utilities, such zip files may not be readable by your favorite zip tool or
               archiver. In other words, interoperability will decrease if you set this
               flag to true.
             </para>
                <para>
               In particular, Zip files created with strict adherence to the PKWare
               specification with respect to UTF-8 encoding will not work well with
               Explorer in Windows XP or Windows Vista, because Windows compressed
               folders, as far as I know, do not support UTF-8 in zip files.  Vista can
               read the zip files, but shows the filenames incorrectly. Unpacking from
               Windows Vista Explorer will result in filenames that have rubbish
               characters in place of the high-order UTF-8 bytes.
             </para>
                <para>
               Also, zip files that use UTF-8 encoding will not work well with Java
               applications that use the java.util.zip classes, as of v5.0 of the Java
               runtime. The Java runtime does not correctly implement the PKWare
               specification in this regard.
             </para>
                <para>
               As a result, we have the unfortunate situation that "correct" behavior by
               the DotNetZip library with regard to Unicode encoding of filenames during
               zip creation will result in zip files that are readable by strictly
               compliant and current tools (for example the most recent release of the
               commercial WinZip tool); but these zip files will not be readable by
               various other tools or libraries, including Windows Explorer.
             </para>
                <para>
               The DotNetZip library can read and write zip files with UTF8-encoded
               entries, according to the PKware spec.  If you use DotNetZip for both
               creating and reading the zip file, and you use UTF-8, there will be no
               loss of information in the filenames. For example, using a self-extractor
               created by this library will allow you to unpack files correctly with no
               loss of information in the filenames.
             </para>
                <para>
               If you do not set this flag, it will remain false.  If this flag is false,
               the <c>ZipOutputStream</c> will encode all filenames and comments using
               the IBM437 codepage.  This can cause "loss of information" on some
               filenames, but the resulting zipfile will be more interoperable with other
               utilities. As an example of the loss of information, diacritics can be
               lost.  The o-tilde character will be down-coded to plain o.  The c with a
               cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
               Likewise, the O-stroke character (Unicode 248), used in Danish and
               Norwegian, will be down-coded to plain o. Chinese characters cannot be
               represented in codepage IBM437; when using the default encoding, Chinese
               characters in filenames will be represented as ?. These are all examples
               of "information loss".
             </para>
                <para>
               The loss of information associated to the use of the IBM437 encoding is
               inconvenient, and can also lead to runtime errors. For example, using
               IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
               your application creates a <c>ZipOutputStream</c>, does not set the
               encoding, then adds two files, each with names of four Chinese characters
               each, this will result in a duplicate filename exception.  In the case
               where you add a single file with a name containing four Chinese
               characters, the zipfile will save properly, but extracting that file
               later, with any zip tool, will result in an error, because the question
               mark is not legal for use within filenames on Windows.  These are just a
               few examples of the problems associated to loss of information.
             </para>
                <para>
               This flag is independent of the encoding of the content within the entries
               in the zip file. Think of the zip file as a container - it supports an
               encoding.  Within the container are other "containers" - the file entries
               themselves.  The encoding within those entries is independent of the
               encoding of the zip archive container for those entries.
             </para>
                <para>
               Rather than specify the encoding in a binary fashion using this flag, an
               application can specify an arbitrary encoding via the <see cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding" /> property.  Setting the encoding
               explicitly when creating zip archives will result in non-compliant zip
               files that, curiously, are fairly interoperable.  The challenge is, the
               PKWare specification does not provide for a way to specify that an entry
               in a zip archive uses a code page that is neither IBM437 nor UTF-8.
               Therefore if you set the encoding explicitly when creating a zip archive,
               you must take care upon reading the zip archive to use the same code page.
               If you get it wrong, the behavior is undefined and may result in incorrect
               filenames, exceptions, stomach upset, hair loss, and acne.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding" />
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding">
            <summary>
               The text encoding to use when emitting entries into the zip archive, for
               those entries whose filenames or comments cannot be encoded with the
               default (IBM437) encoding.
             </summary>
            <remarks>
                <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
                <para>
               When using DotNetZip to write zip archives that will be read by one of
               these other archivers, set this property to specify the code page to use
               when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName" /> and <see cref="P:Ionic.Zip.ZipEntry.Comment" /> for each <c>ZipEntry</c> in the zip file, for
               values that cannot be encoded with the default codepage for zip files,
               IBM437.  This is why this property is "provisional".  In all cases, IBM437
               is used where possible, in other words, where no loss of data would
               result. It is possible, therefore, to have a given entry with a
               <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
               specified "provisional" codepage.
             </para>
                <para>
               Be aware that a zip file created after you've explicitly set the
               <c>ProvisionalAlternateEncoding</c> property to a value other than
               IBM437 may not be compliant to the PKWare specification, and may not be
               readable by compliant archivers.  On the other hand, many (most?)
               archivers are non-compliant and can read zip files created in arbitrary
               code pages.  The trick is to use or specify the proper codepage when
               reading the zip.
             </para>
                <para>
               When creating a zip archive using this library, it is possible to change
               the value of <c>ProvisionalAlternateEncoding</c> between each entry you
               add, and between adding entries and the call to <c>Close()</c>. Don't do
               this. It will likely result in a zipfile that is not readable.  For best
               interoperability, either leave <c>ProvisionalAlternateEncoding</c>
               alone, or specify it only once, before adding any entries to the
               <c>ZipOutputStream</c> instance.  There is one exception to this
               recommendation, described later.
             </para>
                <para>
               When using an arbitrary, non-UTF8 code page for encoding, there is no
               standard way for the creator application - whether DotNetZip, WinZip,
               WinRar, or something else - to formally specify in the zip file which
               codepage has been used for the entries. As a result, readers of zip files
               are not able to inspect the zip file and determine the codepage that was
               used for the entries contained within it.  It is left to the application
               or user to determine the necessary codepage when reading zip files encoded
               this way.  If you use an incorrect codepage when reading a zipfile, you
               will get entries with filenames that are incorrect, and the incorrect
               filenames may even contain characters that are not legal for use within
               filenames in Windows. Extracting entries with illegal characters in the
               filenames will lead to exceptions. It's too bad, but this is just the way
               things are with code pages in zip files. Caveat Emptor.
             </para>
                <para>
               One possible approach for specifying the code page for a given zip file is
               to describe the code page in a human-readable form in the Zip comment. For
               example, the comment may read "Entries in this archive are encoded in the
               Big5 code page".  For maximum interoperability, the zip comment in this
               case should be encoded in the default, IBM437 code page.  In this case,
               the zip comment is encoded using a different page than the filenames.  To
               do this, Specify <c>ProvisionalAlternateEncoding</c> to your desired
               region-specific code page, once before adding any entries, and then set
               the <see cref="P:Ionic.Zip.ZipOutputStream.Comment" /> property and reset
               <c>ProvisionalAlternateEncoding</c> to IBM437 before calling <c>Close()</c>.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.AlternateEncoding">
            <summary>
              A Text Encoding to use when encoding the filenames and comments for
              all the ZipEntry items, during a ZipFile.Save() operation.
            </summary>
            <remarks>
                <para>
                Whether the encoding specified here is used during the save depends
                on <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage" />.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage">
            <summary>
              A flag that tells if and when this instance should apply
              AlternateEncoding to encode the filenames and comments associated to
              of ZipEntry objects contained within this instance.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is numeric 437, also
            known as IBM437.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold">
            <summary>
               The size threshold for an entry, above which a parallel deflate is used.
             </summary>
            <remarks>
                <para>
                 DotNetZip will use multiple threads to compress any ZipEntry, when
                 the <c>CompressionMethod</c> is Deflate, and if the entry is
                 larger than the given size.  Zero means "always use parallel
                 deflate", while -1 means "never use parallel deflate".
               </para>
                <para>
                 If the entry size cannot be known before compression, as with any entry
                 added via a ZipOutputStream, then Parallel deflate will never be
                 performed, unless the value of this property is zero.
               </para>
                <para>
                 A parallel deflate operations will speed up the compression of
                 large files, on computers with multiple CPUs or multiple CPU
                 cores.  For files above 1mb, on a dual core or dual-cpu (2p)
                 machine, the time required to compress the file can be 70% of the
                 single-threaded deflate.  For very large files on 4p machines the
                 compression can be done in 30% of the normal time.  The downside
                 is that parallel deflate consumes extra memory during the deflate,
                 and the deflation is slightly less effective.
               </para>
                <para>
                 Parallel deflate tends to not be as effective as single-threaded deflate
                 because the original data stream is split into multiple independent
                 buffers, each of which is compressed in parallel.  But because they are
                 treated independently, there is no opportunity to share compression
                 dictionaries, and additional framing bytes must be added to the output
                 stream.  For that reason, a deflated stream may be slightly larger when
                 compressed using parallel deflate, as compared to a traditional
                 single-threaded deflate. For files of about 512k, the increase over the
                 normal deflate is as much as 5% of the total compressed size. For larger
                 files, the difference can be as small as 0.1%.
               </para>
                <para>
                 Multi-threaded compression does not give as much an advantage when using
                 Encryption. This is primarily because encryption tends to slow down
                 the entire pipeline. Also, multi-threaded compression gives less of an
                 advantage when using lower compression levels, for example <see cref="F:Ionic.Zlib.CompressionLevel.BestSpeed" />.  You may have to perform
                 some tests to determine the best approach for your situation.
               </para>
                <para>
                 The default value for this property is -1, which means parallel
                 compression will not be performed unless you set it to zero.
               </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ParallelDeflateMaxBufferPairs">
            <summary>
               The maximum number of buffer pairs to use when performing
               parallel compression.
             </summary>
            <remarks>
                <para>
               This property sets an upper limit on the number of memory
               buffer pairs to create when performing parallel
               compression.  The implementation of the parallel
               compression stream allocates multiple buffers to
               facilitate parallel compression.  As each buffer fills up,
               the stream uses <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see> to compress those
               buffers in a background threadpool thread. After a buffer
               is compressed, it is re-ordered and written to the output
               stream.
             </para>
                <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
                <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see cref="P:Ionic.Zip.ZipOutputStream.CodecBufferSize" />).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
                <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
                <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
                <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
                <para>
               The application can set this value at any time, but it is
               effective only if set before calling
               <c>ZipOutputStream.Write()</c> for the first time.
             </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold" />
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.ContainsEntry(System.String)">
            <summary>
               Returns true if an entry by the given name has already been written
               to the ZipOutputStream.
             </summary>
            <param name="name">
               The name of the entry to scan for.
             </param>
            <returns>
             true if an entry by the given name has already been written.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
               Write the data from the buffer to the stream.
             </summary>
            <remarks>
               As the application writes data into this stream, the data may be
               compressed and encrypted before being written out to the underlying
               stream, depending on the settings of the <see cref="P:Ionic.Zip.ZipOutputStream.CompressionLevel" />
               and the <see cref="P:Ionic.Zip.ZipOutputStream.Encryption" /> properties.
             </remarks>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.PutNextEntry(System.String)">
            <summary>
               Specify the name of the next entry that will be written to the zip file.
             </summary>
            <remarks>
                <para>
               Call this method just before calling <see cref="M:Ionic.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)" />, to
               specify the name of the entry that the next set of bytes written to
               the <c>ZipOutputStream</c> belongs to. All subsequent calls to <c>Write</c>,
               until the next call to <c>PutNextEntry</c>,
               will be inserted into the named entry in the zip file.
             </para>
                <para>
               If the <paramref name="entryName" /> used in <c>PutNextEntry()</c> ends in
               a slash, then the entry added is marked as a directory. Because directory
               entries do not contain data, a call to <c>Write()</c>, before an
               intervening additional call to <c>PutNextEntry()</c>, will throw an
               exception.
             </para>
                <para>
               If you don't call <c>Write()</c> between two calls to
               <c>PutNextEntry()</c>, the first entry is inserted into the zip file as a
               file of zero size.  This may be what you want.
             </para>
                <para>
               Because <c>PutNextEntry()</c> closes out the prior entry, if any, this
               method may throw if there is a problem with the prior entry.
             </para>
                <para>
               This method returns the <c>ZipEntry</c>.  You can modify public properties
               on the <c>ZipEntry</c>, such as <see cref="P:Ionic.Zip.ZipEntry.Encryption" />, <see cref="P:Ionic.Zip.ZipEntry.Password" />, and so on, until the first call to
               <c>ZipOutputStream.Write()</c>, or until the next call to
               <c>PutNextEntry()</c>.  If you modify the <c>ZipEntry</c><em>after</em>
               having called <c>Write()</c>, you may get a runtime exception, or you may
               silently get an invalid zip archive.
             </para>
            </remarks>
            <example>
            
               This example shows how to create a zip file, using the
               <c>ZipOutputStream</c> class.
            
             <code>
             private void Zipup()
             {
                 using (FileStream fs raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
                 {
                     using (var output= new ZipOutputStream(fs))
                     {
                         output.Password = "VerySecret!";
                         output.Encryption = EncryptionAlgorithm.WinZipAes256;
                         output.PutNextEntry("entry1.txt");
                         byte[] buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #1.");
                         output.Write(buffer,0,buffer.Length);
                         output.PutNextEntry("entry2.txt");  // this will be zero length
                         output.PutNextEntry("entry3.txt");
                         buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #3.");
                         output.Write(buffer,0,buffer.Length);
                     }
                 }
             }
             </code></example>
            <param name="entryName">
               The name of the entry to be added, including any path to be used
               within the zip file.
             </param>
            <returns>
               The ZipEntry created.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Dispose(System.Boolean)">
            <summary>
             Dispose the stream
             </summary>
            <remarks>
                <para>
               This method writes the Zip Central directory, then closes the stream.  The
               application must call Dispose() (or Close) in order to produce a valid zip file.
             </para>
                <para>
               Typically the application will call <c>Dispose()</c> implicitly, via a <c>using</c>
               statement in C#, or a <c>Using</c> statement in VB.
             </para>
            </remarks>
            <param name="disposing">set this to true, always.</param>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanRead">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanSeek">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanWrite">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Length">
            <summary>
            Always returns a NotSupportedException.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Position">
            <summary>
            Setting this property always returns a NotSupportedException. Getting it
            returns the value of the Position on the underlying stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Flush">
            <summary>
            This is a no-op.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">ignored</param>
            <param name="offset">ignored</param>
            <param name="count">ignored</param>
            <returns>nothing</returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="offset">ignored</param>
            <param name="origin">ignored</param>
            <returns>nothing</returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">ignored</param>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.ForUpdate(System.String,System.UInt32)">
            <summary>
              Sort-of like a factory method, ForUpdate is used only when
              the application needs to update the zip entry metadata for
              a segmented zip file, when the starting segment is earlier
              than the ending segment, for a particular entry.
            </summary>
            <remarks>
                <para>
                The update is always contiguous, never rolls over.  As a
                result, this method doesn't need to return a ZSS; it can
                simply return a FileStream.  That's why it's "sort of"
                like a Factory method.
              </para>
                <para>
                Caller must Close/Dispose the stream object returned by
                this method.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipSegmentedStream.CurrentName">
            <summary>
              Name of the filesystem file corresponding to the current segment.
            </summary>
            <remarks>
                <para>
                The name is not always the name currently being used in the
                filesystem.  When rwMode is RwMode.Write, the filesystem file has a
                temporary name until the stream is closed or until the next segment is
                started.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="T:Ionic.LogicalConjunction">
            <summary>
            Enumerates the options for a logical conjunction. This enum is intended for use
            internally by the FileSelector class.
            </summary>
        </member>
        <member name="T:Ionic.FileSelector">
            <summary>
               FileSelector encapsulates logic that selects files from a source - a zip file
               or the filesystem - based on a set of criteria.  This class is used internally
               by the DotNetZip library, in particular for the AddSelectedFiles() methods.
               This class can also be used independently of the zip capability in DotNetZip.
             </summary>
            <remarks>
                <para>
               The FileSelector class is used internally by the ZipFile class for selecting
               files for inclusion into the ZipFile, when the <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" /> method, or one of
               its overloads, is called.  It's also used for the <see cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String)" /> methods.  Typically, an
               application that creates or manipulates Zip archives will not directly
               interact with the FileSelector class.
             </para>
                <para>
               Some applications may wish to use the FileSelector class directly, to
               select files from disk volumes based on a set of criteria, without creating or
               querying Zip archives.  The file selection criteria include: a pattern to
               match the filename; the last modified, created, or last accessed time of the
               file; the size of the file; and the attributes of the file.
             </para>
                <para>
               Consult the documentation for <see cref="P:Ionic.FileSelector.SelectionCriteria" />
               for more information on specifying the selection criteria.
             </para>
            </remarks>
        </member>
        <member name="M:Ionic.FileSelector.#ctor(System.String)">
            <summary>
               Constructor that allows the caller to specify file selection criteria.
             </summary>
            <remarks>
                <para>
               This constructor allows the caller to specify a set of criteria for
               selection of files.
             </para>
                <para>
               See <see cref="P:Ionic.FileSelector.SelectionCriteria" /> for a description of
               the syntax of the selectionCriteria string.
             </para>
                <para>
               By default the FileSelector will traverse NTFS Reparse Points.  To
               change this, use <see cref="M:Ionic.FileSelector.#ctor(System.String,System.Boolean)">FileSelector(String, bool)</see>.
             </para>
            </remarks>
            <param name="selectionCriteria">The criteria for file selection.</param>
        </member>
        <member name="M:Ionic.FileSelector.#ctor(System.String,System.Boolean)">
            <summary>
               Constructor that allows the caller to specify file selection criteria.
             </summary>
            <remarks>
                <para>
               This constructor allows the caller to specify a set of criteria for
               selection of files.
             </para>
                <para>
               See <see cref="P:Ionic.FileSelector.SelectionCriteria" /> for a description of
               the syntax of the selectionCriteria string.
             </para>
            </remarks>
            <param name="selectionCriteria">The criteria for file selection.</param>
            <param name="traverseDirectoryReparsePoints">
             whether to traverse NTFS reparse points (junctions).
             </param>
        </member>
        <member name="P:Ionic.FileSelector.SelectionCriteria">
            <summary>
               The string specifying which files to include when retrieving.
             </summary>
            <remarks>
                <para>
               Specify the criteria in statements of 3 elements: a noun, an operator,
               and a value.  Consider the string "name != *.doc" .  The noun is
               "name".  The operator is "!=", implying "Not Equal".  The value is
               "*.doc".  That criterion, in English, says "all files with a name that
               does not end in the .doc extension."
             </para>
                <para>
               Supported nouns include "name" (or "filename") for the filename;
               "atime", "mtime", and "ctime" for last access time, last modfied time,
               and created time of the file, respectively; "attributes" (or "attrs")
               for the file attributes; "size" (or "length") for the file length
               (uncompressed); and "type" for the type of object, either a file or a
               directory.  The "attributes", "type", and "name" nouns all support =
               and != as operators.  The "size", "atime", "mtime", and "ctime" nouns
               support = and !=, and &gt;, &gt;=, &lt;, &lt;= as well.  The times are
               taken to be expressed in local time.
             </para>
                <para>
               Specify values for the file attributes as a string with one or more of
               the characters H,R,S,A,I,L in any order, implying file attributes of
               Hidden, ReadOnly, System, Archive, NotContextIndexed, and ReparsePoint
               (symbolic link) respectively.
             </para>
                <para>
               To specify a time, use YYYY-MM-DD-HH:mm:ss or YYYY/MM/DD-HH:mm:ss as
               the format.  If you omit the HH:mm:ss portion, it is assumed to be
               00:00:00 (midnight).
             </para>
                <para>
               The value for a size criterion is expressed in integer quantities of
               bytes, kilobytes (use k or kb after the number), megabytes (m or mb),
               or gigabytes (g or gb).
             </para>
                <para>
               The value for a name is a pattern to match against the filename,
               potentially including wildcards.  The pattern follows CMD.exe glob
               rules: * implies one or more of any character, while ?  implies one
               character.  If the name pattern contains any slashes, it is matched to
               the entire filename, including the path; otherwise, it is matched
               against only the filename without the path.  This means a pattern of
               "*\*.*" matches all files one directory level deep, while a pattern of
               "*.*" matches all files in all directories.
             </para>
                <para>
               To specify a name pattern that includes spaces, use single quotes
               around the pattern.  A pattern of "'* *.*'" will match all files that
               have spaces in the filename.  The full criteria string for that would
               be "name = '* *.*'" .
             </para>
                <para>
               The value for a type criterion is either F (implying a file) or D
               (implying a directory).
             </para>
                <para>
               Some examples:
             </para>
                <list type="table">
                    <listheader>
                        <term>criteria</term>
                        <description>Files retrieved</description>
                    </listheader>
                    <item>
                        <term>name != *.xls </term>
                        <description>any file with an extension that is not .xls
                 </description>
                    </item>
                    <item>
                        <term>name = *.mp3 </term>
                        <description>any file with a .mp3 extension.
                 </description>
                    </item>
                    <item>
                        <term>*.mp3</term>
                        <description>(same as above) any file with a .mp3 extension.
                 </description>
                    </item>
                    <item>
                        <term>attributes = A </term>
                        <description>all files whose attributes include the Archive bit.
                 </description>
                    </item>
                    <item>
                        <term>attributes != H </term>
                        <description>all files whose attributes do not include the Hidden bit.
                 </description>
                    </item>
                    <item>
                        <term>mtime &gt; 2009-01-01</term>
                        <description>all files with a last modified time after January 1st, 2009.
                 </description>
                    </item>
                    <item>
                        <term>ctime &gt; 2009/01/01-03:00:00</term>
                        <description>all files with a created time after 3am (local time),
                 on January 1st, 2009.
                 </description>
                    </item>
                    <item>
                        <term>size &gt; 2gb</term>
                        <description>all files whose uncompressed size is greater than 2gb.
                 </description>
                    </item>
                    <item>
                        <term>type = D</term>
                        <description>all directories in the filesystem. </description>
                    </item>
                </list>
                <para>
               You can combine criteria with the conjunctions AND, OR, and XOR. Using
               a string like "name = *.txt AND size &gt;= 100k" for the
               selectionCriteria retrieves entries whose names end in .txt, and whose
               uncompressed size is greater than or equal to 100 kilobytes.
             </para>
                <para>
               For more complex combinations of criteria, you can use parenthesis to
               group clauses in the boolean logic.  Absent parenthesis, the
               precedence of the criterion atoms is determined by order of
               appearance.  Unlike the C# language, the AND conjunction does not take
               precendence over the logical OR.  This is important only in strings
               that contain 3 or more criterion atoms.  In other words, "name = *.txt
               and size &gt; 1000 or attributes = H" implies "((name = *.txt AND size
               &gt; 1000) OR attributes = H)" while "attributes = H OR name = *.txt
               and size &gt; 1000" evaluates to "((attributes = H OR name = *.txt)
               AND size &gt; 1000)".  When in doubt, use parenthesis.
             </para>
                <para>
               Using time properties requires some extra care. If you want to
               retrieve all entries that were last updated on 2009 February 14,
               specify "mtime &gt;= 2009-02-14 AND mtime &lt; 2009-02-15".  Read this
               to say: all files updated after 12:00am on February 14th, until
               12:00am on February 15th.  You can use the same bracketing approach to
               specify any time period - a year, a month, a week, and so on.
             </para>
                <para>
               The syntax allows one special case: if you provide a string with no
               spaces, it is treated as a pattern to match for the filename.
               Therefore a string like "*.xls" will be equivalent to specifying "name
               = *.xls".  This "shorthand" notation does not work with compound
               criteria.
             </para>
                <para>
               There is no logic in this class that insures that the inclusion
               criteria are internally consistent.  For example, it's possible to
               specify criteria that says the file must have a size of less than 100
               bytes, as well as a size that is greater than 1000 bytes.  Obviously
               no file will ever satisfy such criteria, but this class does not check
               for or detect such inconsistencies.
             </para>
            </remarks>
            <exception cref="T:System.Exception">
               Thrown in the setter if the value has an invalid syntax.
             </exception>
        </member>
        <member name="P:Ionic.FileSelector.TraverseReparsePoints">
            <summary>
             Indicates whether searches will traverse NTFS reparse points, like Junctions.
            </summary>
        </member>
        <member name="M:Ionic.FileSelector.ToString">
            <summary>
            Returns a string representation of the FileSelector object.
            </summary>
            <returns>The string representation of the boolean logic statement of the file
            selection criteria for this instance. </returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectFiles(System.String)">
            <summary>
               Returns the names of the files in the specified directory
               that fit the selection criteria specified in the FileSelector.
             </summary>
            <remarks>
               This is equivalent to calling <see cref="M:Ionic.FileSelector.SelectFiles(System.String,System.Boolean)" />
               with recurseDirectories = false.
             </remarks>
            <param name="directory">
               The name of the directory over which to apply the FileSelector
               criteria.
             </param>
            <returns>
               A collection of strings containing fully-qualified pathnames of files
               that match the criteria specified in the FileSelector instance.
             </returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectFiles(System.String,System.Boolean)">
            <summary>
               Returns the names of the files in the specified directory that fit the
               selection criteria specified in the FileSelector, optionally recursing
               through subdirectories.
             </summary>
            <remarks>
               This method applies the file selection criteria contained in the
               FileSelector to the files contained in the given directory, and
               returns the names of files that conform to the criteria.
             </remarks>
            <param name="directory">
               The name of the directory over which to apply the FileSelector
               criteria.
             </param>
            <param name="recurseDirectories">
               Whether to recurse through subdirectories when applying the file
               selection criteria.
             </param>
            <returns>
               A collection of strings containing fully-qualified pathnames of files
               that match the criteria specified in the FileSelector instance.
             </returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectEntries(Ionic.Zip.ZipFile)">
            <summary>
             Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
             </summary>
            <remarks>
                <para>
             This method applies the criteria set in the FileSelector instance (as described in
             the <see cref="P:Ionic.FileSelector.SelectionCriteria" />) to the specified ZipFile.  Using this
             method, for example, you can retrieve all entries from the given ZipFile that
             have filenames ending in .txt.
             </para>
                <para>
             Normally, applications would not call this method directly.  This method is used
             by the ZipFile class.
             </para>
                <para>
             Using the appropriate SelectionCriteria, you can retrieve entries based on size,
             time, and attributes. See <see cref="P:Ionic.FileSelector.SelectionCriteria" /> for a
             description of the syntax of the SelectionCriteria string.
             </para>
            </remarks>
            <param name="zip">The ZipFile from which to retrieve entries.</param>
            <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectEntries(Ionic.Zip.ZipFile,System.String)">
            <summary>
             Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
             </summary>
            <remarks>
                <para>
             This method applies the criteria set in the FileSelector instance (as described in
             the <see cref="P:Ionic.FileSelector.SelectionCriteria" />) to the specified ZipFile.  Using this
             method, for example, you can retrieve all entries from the given ZipFile that
             have filenames ending in .txt.
             </para>
                <para>
             Normally, applications would not call this method directly.  This method is used
             by the ZipFile class.
             </para>
                <para>
             This overload allows the selection of ZipEntry instances from the ZipFile to be restricted
             to entries contained within a particular directory in the ZipFile.
             </para>
                <para>
             Using the appropriate SelectionCriteria, you can retrieve entries based on size,
             time, and attributes. See <see cref="P:Ionic.FileSelector.SelectionCriteria" /> for a
             description of the syntax of the SelectionCriteria string.
             </para>
            </remarks>
            <param name="zip">The ZipFile from which to retrieve entries.</param>
            <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
        </member>
        <member name="T:Ionic.EnumUtil">
            <summary>
            Summary description for EnumUtil.
            </summary>
        </member>
        <member name="M:Ionic.EnumUtil.GetDescription(System.Enum)">
            <summary>
              Returns the value of the DescriptionAttribute if the specified Enum
              value has one.  If not, returns the ToString() representation of the
              Enum value.
            </summary>
            <param name="value">The Enum to get the description for</param>
            <returns />
        </member>
        <member name="M:Ionic.EnumUtil.Parse(System.Type,System.String)">
            <summary>
              Converts the string representation of the name or numeric value of one
              or more enumerated constants to an equivalent enumerated object.
              Note: use the DescriptionAttribute on enum values to enable this.
            </summary>
            <param name="enumType">The System.Type of the enumeration.</param>
            <param name="stringRepresentation">
              A string containing the name or value to convert.
            </param>
            <returns />
        </member>
        <member name="M:Ionic.EnumUtil.Parse(System.Type,System.String,System.Boolean)">
            <summary>
              Converts the string representation of the name or numeric value of one
              or more enumerated constants to an equivalent enumerated object.  A
              parameter specified whether the operation is case-sensitive.  Note:
              use the DescriptionAttribute on enum values to enable this.
            </summary>
            <param name="enumType">The System.Type of the enumeration.</param>
            <param name="stringRepresentation">
              A string containing the name or value to convert.
            </param>
            <param name="ignoreCase">
              Whether the operation is case-sensitive or not.</param>
            <returns />
        </member>
        <member name="T:Ionic.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name="b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
                <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name="b">the byte to include into the CRC.  </param>
            <param name="n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name="reverseBits">
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
                <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
            <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
            <param name="polynomial">
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
            <param name="reverseBits">
               specify true if the instance should reverse data bits.
             </param>
            <remarks>
                <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
                <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="T:Ionic.Crc.CrcCalculatorStream">
            <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read,
             or on all bytes written.
             </summary>
            <remarks>
                <para>
             This class can be used to verify the CRC of a ZipEntry when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either read, or write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
                <para>
             This class is intended primarily for use internally by the
             DotNetZip library.
             </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
                <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().  The stream uses the default CRC32
                algorithm, which implies a polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              The constructor allows the caller to specify how to handle the
              underlying stream at close.
            </summary>
            <remarks>
                <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read.
            </summary>
            <remarks>
                <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
                <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close().
            </summary>
            <remarks>
                <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean,Ionic.Crc.CRC32)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close(), and the CRC32 instance to use.
            </summary>
            <remarks>
                <para>
                The stream uses the specified CRC32 instance, which allows the
                application to specify how the CRC gets calculated.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
            <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.TotalBytesSlurped">
            <summary>
               Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            <remarks>
               This is either the total number of bytes read, or the total number of
               bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Crc">
            <summary>
              Provides the current CRC for all blocks slurped in.
            </summary>
            <remarks>
                <para>
                The running total of the CRC is kept as data is written or read
                through the stream.  read this property after all reads or writes to
                get an accurate CRC for the entire stream.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.LeaveOpen">
            <summary>
              Indicates whether the underlying stream will be left open when the
              <c>CrcCalculatorStream</c> is Closed.
            </summary>
            <remarks>
                <para>
                Set this at any point before calling <see cref="M:Ionic.Crc.CrcCalculatorStream.Close" />.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanSeek">
            <summary>
              Indicates whether the stream supports seeking.
            </summary>
            <remarks>
                <para>
                Always returns false.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Length">
            <summary>
              Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Position">
            <summary>
              The getter for this property returns the total bytes read.
              If you use the setter, it will throw
            <see cref="T:System.NotSupportedException" />.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeking is not supported on this stream. This method always throws
            <see cref="T:System.NotSupportedException" /></summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            This method always throws
            <see cref="T:System.NotSupportedException" /></summary>
            <param name="value">N/A</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Close">
            <summary>
            Closes the stream.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.DeflateStream">
            <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            <remarks>
                <para>
               The DeflateStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream" />.  It adds DEFLATE compression or decompression to any
               stream.
             </para>
                <para>
               Using this stream, applications can compress or decompress data via stream
               <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
               can occur through either reading or writing. The compression format used is
               DEFLATE, which is documented in <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
               Compressed Data Format Specification version 1.3.".
             </para>
                <para>
               This class is similar to <see cref="T:Ionic.Zlib.ZlibStream" />, except that
               <c>ZlibStream</c> adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
               1950 - ZLIB</see> framing bytes to a compressed stream when compressing, or
               expects the RFC1950 framing bytes when decompressing. The <c>DeflateStream</c>
               does not.
             </para>
            </remarks>
            <seealso cref="T:Ionic.Zlib.ZlibStream" />
            <seealso cref="T:Ionic.Zlib.GZipStream" />
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
            <summary>
               Create a DeflateStream using the specified CompressionMode.
             </summary>
            <remarks>
               When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
               the default compression level. The "captive" stream will be closed when
               the DeflateStream is closed.
             </remarks>
            <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code></example>
            <param name="stream">The stream which will be read or written.</param>
            <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
            <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            <remarks>
                <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.  The "captive" stream will be closed when the DeflateStream is
               closed.
             </para>
            </remarks>
            <example>
            
               This example uses a DeflateStream to compress data from a file, and writes
               the compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress,
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code></example>
            <param name="stream">The stream to be read or written while deflating or inflating.</param>
            <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
            <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            <remarks>
                <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen" /> parameter to leave the stream open.
             </para>
                <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
                <para>
               See the other overloads of this constructor for example code.
             </para>
            </remarks>
            <param name="stream">
               The stream which will be read or written. This is called the
               "captive" stream in other places in this documentation.
             </param>
            <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            <remarks>
                <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
                <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream" /> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen" /> parameter
               to leave the stream open.
             </para>
            </remarks>
            <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code><code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code></example>
            <param name="stream">The stream which will be read or written.</param>
            <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
            <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.BufferSize">
            <summary>
               The size of the working buffer for the compression codec.
             </summary>
            <remarks>
                <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
                <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Strategy">
            <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
                <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
                <para>
                Application code won't call this code directly.  This method may be
                invoked in two distinct scenarios.  If disposing == true, the method
                has been called directly or indirectly by a user's code, for example
                via the public Dispose() method. In this case, both managed and
                unmanaged resources can be referenced and disposed.  If disposing ==
                false, the method has been called by the runtime from inside the
                object finalizer and this method should not reference other objects;
                in that case only unmanaged resources must be referenced or
                disposed.
              </para>
            </remarks>
            <param name="disposing">
              true if the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Position">
            <summary>
             The position of the stream pointer.
             </summary>
            <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException" />. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Read data from the stream.
             </summary>
            <remarks>
                <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
                <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            </remarks>
            <param name="buffer">The buffer into which the read data should be placed.</param>
            <param name="offset">the offset within that data array to put the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
               Write data to the stream.
             </summary>
            <remarks>
                <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
                <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            </remarks>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">
            <summary>
               Compress a string into a byte array using DEFLATE (RFC 1951).
             </summary>
            <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])" />.
             </remarks>
            <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
            <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
            <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)">GZipStream.CompressString(string)</seealso>
            <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)">ZlibStream.CompressString(string)</seealso>
            <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">
            <summary>
               Compress a byte array into a new byte array using DEFLATE.
             </summary>
            <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])" />.
             </remarks>
            <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(string)</seealso>
            <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
            <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">GZipStream.CompressBuffer(byte[])</seealso>
            <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">ZlibStream.CompressBuffer(byte[])</seealso>
            <param name="b">
               A buffer to compress.
             </param>
            <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">
            <summary>
               Uncompress a DEFLATE'd byte array into a single string.
             </summary>
            <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(String)</seealso>
            <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
            <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">GZipStream.UncompressString(byte[])</seealso>
            <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])">ZlibStream.UncompressString(byte[])</seealso>
            <param name="compressed">
               A buffer containing DEFLATE-compressed data.
             </param>
            <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">
            <summary>
               Uncompress a DEFLATE'd byte array into a byte array.
             </summary>
            <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
            <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
            <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">GZipStream.UncompressBuffer(byte[])</seealso>
            <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">ZlibStream.UncompressBuffer(byte[])</seealso>
            <param name="compressed">
               A buffer containing data that has been compressed with DEFLATE.
             </param>
            <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Ionic.Zlib.GZipStream">
            <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
            <remarks>
                <para>
               The <c>GZipStream</c> is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream" />. It adds GZIP compression or decompression to any
               stream.
             </para>
                <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
                <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
                <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
                <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
                <para>
               This class is similar to <see cref="T:Ionic.Zlib.ZlibStream" /> and <see cref="T:Ionic.Zlib.DeflateStream" />.
               <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="T:Ionic.Zlib.DeflateStream" />
               handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
            </remarks>
            <seealso cref="T:Ionic.Zlib.DeflateStream" />
            <seealso cref="T:Ionic.Zlib.ZlibStream" />
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Comment">
            <summary>
               The comment on the GZIP stream.
             </summary>
            <remarks>
                <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
                <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FileName">
            <summary>
               The FileName for the GZIP stream.
             </summary>
            <remarks>
                <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
                <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.GZipStream.LastModified">
            <summary>
               The last modified time for the GZIP stream.
             </summary>
            <remarks>
               GZIP allows the storage of a last modified time with each GZIP entry.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
            <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
            <remarks>
                <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
                <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            </remarks>
            <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code></example>
            <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n &gt; 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n &gt; 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  &gt; 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code></example>
            <param name="stream">The stream which will be read or written.</param>
            <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
            <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
            <remarks>
                <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            </remarks>
            <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code></example>
            <param name="stream">The stream to be read or written while deflating or inflating.</param>
            <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
            <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            <remarks>
                <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen" /> parameter to leave
               the stream open.
             </para>
                <para>
               The <see cref="T:Ionic.Zlib.CompressionMode" /> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
                <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)" />.
             </para>
                <para>
               See the other overloads of this constructor for example code.
             </para>
            </remarks>
            <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            <remarks>
                <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen" /> parameter to
               leave the stream open.
             </para>
                <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            </remarks>
            <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code></example>
            <param name="stream">The stream which will be read or written.</param>
            <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
            <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.BufferSize">
            <summary>
               The size of the working buffer for the compression codec.
             </summary>
            <remarks>
                <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
                <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
                <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
                <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Position">
            <summary>
               The position of the stream pointer.
             </summary>
            <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException" />. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
               Read and decompress data from the source stream.
             </summary>
            <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            <example>
                <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
            </example>
            <param name="buffer">The buffer into which the decompressed data should be placed.</param>
            <param name="offset">the offset within that data array to put the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
               Write data to the stream.
             </summary>
            <remarks>
                <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
                <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            </remarks>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressString(System.String)">
            <summary>
               Compress a string into a byte array using GZip.
             </summary>
            <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])" />.
             </remarks>
            <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])" />
            <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])" />
            <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">
            <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])" />.
             </remarks>
            <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)" />
            <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])" />
            <param name="b">
               A buffer to compress.
             </param>
            <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">
            <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)" />
            <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])" />
            <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
            <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])" />
            <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])" />
            <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Ionic.Zlib.ParallelDeflateOutputStream">
            <summary>
               A class for compressing streams using the
               Deflate algorithm with multiple threads.
             </summary>
            <remarks>
                <para>
               This class performs DEFLATE compression through writing.  For
               more information on the Deflate algorithm, see IETF RFC 1951,
               "DEFLATE Compressed Data Format Specification version 1.3."
             </para>
                <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream" />, except
               that this class is for compression only, and this implementation uses an
               approach that employs multiple worker threads to perform the DEFLATE.  On
               a multi-cpu or multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream, particularly
               for larger streams.  How large?  Anything over 10mb is a good candidate
               for parallel compression.
             </para>
                <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla DeflateStream, and also is less efficient as a compressor. For
               large files the size of the compressed data stream can be less than 1%
               larger than the size of a compressed data stream from the vanialla
               DeflateStream.  For smaller files the difference can be larger.  The
               difference will also be larger if you set the BufferSize to be lower than
               the default value.  Your mileage may vary. Finally, for small files, the
               ParallelDeflateOutputStream can be much slower than the vanilla
               DeflateStream, because of the overhead associated to using the thread
               pool.
             </para>
            </remarks>
            <seealso cref="T:Ionic.Zlib.DeflateStream" />
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)">
            <summary>
             Create a ParallelDeflateOutputStream.
             </summary>
            <remarks>
                <para>
               This stream compresses data written into it via the DEFLATE
               algorithm (see RFC 1951), and writes out the compressed byte stream.
             </para>
                <para>
               The instance will use the default compression level, the default
               buffer sizes and the default number of threads and buffers per
               thread.
             </para>
                <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream" />,
               except that this implementation uses an approach that employs
               multiple worker threads to perform the DEFLATE.  On a multi-cpu or
               multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream,
               particularly for larger streams.  How large?  Anything over 10mb is
               a good candidate for parallel compression.
             </para>
            </remarks>
            <example>
            
             This example shows how to use a ParallelDeflateOutputStream to compress
             data.  It reads a file, compresses it, and writes the compressed data to
             a second, output file.
            
             <code>
             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
             int n= -1;
             String outputFile = fileToCompress + ".compressed";
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new ParallelDeflateOutputStream(raw))
                     {
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Dim buffer As Byte() = New Byte(4096) {}
             Dim n As Integer = -1
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                     Using compressor As Stream = New ParallelDeflateOutputStream(raw)
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code></example>
            <param name="stream">The stream to which compressed data will be written.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel)">
            <summary>
              Create a ParallelDeflateOutputStream using the specified CompressionLevel.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)" />
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)" />
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)" />
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream using the specified
            CompressionLevel and CompressionStrategy, and specifying whether to
            leave the captive stream open when the ParallelDeflateOutputStream is
            closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)" />
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="strategy">
              By tweaking this parameter, you may be able to optimize the compression for
              data with particular characteristics.
            </param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Strategy">
            <summary>
               The ZLIB strategy to be used during compression.
             </summary>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.MaxBufferPairs">
            <summary>
               The maximum number of buffer pairs to use.
             </summary>
            <remarks>
                <para>
               This property sets an upper limit on the number of memory buffer
               pairs to create.  The implementation of this stream allocates
               multiple buffers to facilitate parallel compression.  As each buffer
               fills up, this stream uses <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see>
               to compress those buffers in a background threadpool thread. After a
               buffer is compressed, it is re-ordered and written to the output
               stream.
             </para>
                <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
                <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see cref="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize" />).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
                <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
                <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
                <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
                <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize">
            <summary>
               The size of the buffers used by the compressor threads.
             </summary>
            <remarks>
                <para>
               The default buffer size is 128k. The application can set this value
               at any time, but it is effective only before the first Write().
             </para>
                <para>
               Larger buffer sizes implies larger memory consumption but allows
               more efficient compression. Using smaller buffer sizes consumes less
               memory but may result in less effective compression.  For example,
               using the default buffer size of 128k, the compression delivered is
               within 1% of the compression delivered by the single-threaded <see cref="T:Ionic.Zlib.DeflateStream" />.  On the other hand, using a
               BufferSize of 8k can result in a compressed data stream that is 5%
               larger than that delivered by the single-threaded
               <c>DeflateStream</c>.  Excessively small buffer sizes can also cause
               the speed of the ParallelDeflateOutputStream to drop, because of
               larger thread scheduling overhead dealing with many many small
               buffers.
             </para>
                <para>
               The total amount of storage space allocated for buffering will be
               (N*S*2), where N is the number of buffer pairs, and S is the size of
               each buffer (this property). There are 2 buffers used by the
               compressor, one for input and one for output.  By default, DotNetZip
               allocates 4 buffer pairs per CPU core, so if your machine has 4
               cores, then the number of buffer pairs used will be 16. If you
               accept the default value of this property, 128k, then the
               ParallelDeflateOutputStream will use 16 * 2 * 128kb of buffer memory
               in total, or 4mb, in blocks of 128kb.  If you set this property to
               64kb, then the number will be 16 * 2 * 64kb of buffer memory, or
               2mb.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Crc32">
            <summary>
            The CRC32 for the data that was written out, prior to compression.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BytesProcessed">
            <summary>
            The total number of uncompressed bytes processed by the ParallelDeflateOutputStream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
               Write data to the stream.
             </summary>
            <remarks>
                <para>
               To use the ParallelDeflateOutputStream to compress data, create a
               ParallelDeflateOutputStream with CompressionMode.Compress, passing a
               writable output stream.  Then call Write() on that
               ParallelDeflateOutputStream, providing uncompressed data as input.  The
               data sent to the output stream will be the compressed form of the data
               written.
             </para>
                <para>
               To decompress data, use the <see cref="T:Ionic.Zlib.DeflateStream" /> class.
             </para>
            </remarks>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Close">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            You must call Close on the stream to guarantee that all of the data written in has
            been compressed, and the compressed data has been written out.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose">
            <summary>Dispose the object</summary>
            <remarks>
                <para>
                Because ParallelDeflateOutputStream is IDisposable, the
                application must call this method when finished using the instance.
              </para>
                <para>
                This method is generally called implicitly upon exit from
                a <c>using</c> scope in C# (<c>Using</c> in VB).
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose(System.Boolean)">
            <summary>The Dispose method</summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Reset(System.IO.Stream)">
            <summary>
               Resets the stream for use with another stream.
             </summary>
            <remarks>
               Because the ParallelDeflateOutputStream is expensive to create, it
               has been designed so that it can be recycled and re-used.  You have
               to call Close() on the stream first, then you can call Reset() on
               it, to use it again on another stream.
             </remarks>
            <param name="stream">
               The new output stream for this era.
             </param>
            <example>
                <code>
             ParallelDeflateOutputStream deflater = null;
             foreach (var inputFile in listOfFiles)
             {
                 string outputFile = inputFile + ".compressed";
                 using (System.IO.Stream input = System.IO.File.OpenRead(inputFile))
                 {
                     using (var outStream = System.IO.File.Create(outputFile))
                     {
                         if (deflater == null)
                             deflater = new ParallelDeflateOutputStream(outStream,
                                                                        CompressionLevel.Best,
                                                                        CompressionStrategy.Default,
                                                                        true);
                         deflater.Reset(outStream);
            
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             deflater.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            </example>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanRead">
            <summary>
            Indicates whether the stream supports Read operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanWrite">
            <summary>
            Indicates whether the stream supports Write operations.
            </summary>
            <remarks>
            Returns true if the provided stream is writable.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Length">
            <summary>
            Reading this property always throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Position">
            <summary>
            Returns the current position of the output stream.
            </summary>
            <remarks>
                <para>
                Because the output gets written by a background thread,
                the value may change asynchronously.  Setting this
                property always throws a NotSupportedException.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">
              The buffer into which data would be read, IF THIS METHOD
              ACTUALLY DID ANYTHING.
            </param>
            <param name="offset">
              The offset within that data array at which to insert the
              data that is read, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <param name="count">
              The number of bytes to write, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <returns>nothing.</returns>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="offset">
              The offset to seek to....
              IF THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <param name="origin">
              The reference specifying how to apply the offset....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <returns>nothing. It always throws.</returns>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="M:Ionic.Zlib.Tree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="T:Ionic.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
            <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            <param name="sourceTextReader">The source TextReader to read from</param>
            <param name="target">Contains the array of characteres read from the source TextReader.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to read from the source TextReader.</param>
            <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:Ionic.Zlib.Adler">
            <summary>
             Computes an Adler-32 checksum.
             </summary>
            <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            <exclude />
        </member>
        <member name="M:Ionic.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
                <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code></example>
        </member>
        <member name="T:Ionic.Zlib.ZlibCodec">
            <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor(Ionic.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
            <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            <remarks>
             By default, the ZLIB header defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
            <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Inflate(Ionic.Zlib.FlushType)">
            <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
            <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
            <example>
                <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
            </example>
            <param name="flush">The flush to use when inflating.</param>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
                <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32,System.Boolean)">
            <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Deflate(Ionic.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
                <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDeflateParams(Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="T:Ionic.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibStream">
            <summary>
             Represents a Zlib stream for compression or decompression.
             </summary>
            <remarks>
                <para>
             The ZlibStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream" />.  It adds ZLIB compression or decompression to any
             stream.
             </para>
                <para> Using this stream, applications can compress or decompress data via
             stream <c>Read()</c> and <c>Write()</c> operations.  Either compresssion or
             decompression can occur through either reading or writing. The compression
             format used is ZLIB, which is documented in <see href="http://www.ietf.org/rfc/rfc1950.txt">IETF RFC 1950</see>, "ZLIB Compressed
             Data Format Specification version 3.3". This implementation of ZLIB always uses
             DEFLATE as the compression method.  (see <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
             Compressed Data Format Specification version 1.3.") </para>
                <para>
             The ZLIB format allows for varying compression methods, window sizes, and dictionaries.
             This implementation always uses the DEFLATE compression method, a preset dictionary,
             and 15 window bits by default.
             </para>
                <para>
             This class is similar to <see cref="T:Ionic.Zlib.DeflateStream" />, except that it adds the
             RFC1950 header and trailer bytes to a compressed stream when compressing, or expects
             the RFC1950 header and trailer bytes when decompressing.  It is also similar to the
             <see cref="T:Ionic.Zlib.GZipStream" />.
             </para>
            </remarks>
            <seealso cref="T:Ionic.Zlib.DeflateStream" />
            <seealso cref="T:Ionic.Zlib.GZipStream" />
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
            <summary>
             Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>.
             </summary>
            <remarks>
                <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c>
               will use the default compression level. The "captive" stream will be
               closed when the <c>ZlibStream</c> is closed.
             </para>
            </remarks>
            <example>
             This example uses a <c>ZlibStream</c> to compress a file, and writes the
             compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code></example>
            <param name="stream">The stream which will be read or written.</param>
            <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
            <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
            <remarks>
                <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
               The "captive" stream will be closed when the <c>ZlibStream</c> is closed.
             </para>
            </remarks>
            <example>
               This example uses a <c>ZlibStream</c> to compress data from a file, and writes the
               compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                     Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code></example>
            <param name="stream">The stream to be read or written while deflating or inflating.</param>
            <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
            <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the captive stream should be left open after
               Deflation or Inflation.
             </summary>
            <remarks>
                <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c> will use
               the default compression level.
             </para>
                <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream" /> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen" /> parameter to leave the stream
               open.
             </para>
                <para>
             See the other overloads of this constructor for example code.
             </para>
            </remarks>
            <param name="stream">The stream which will be read or written. This is called the
             "captive" stream in other places in this documentation.</param>
            <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            <param name="leaveOpen">true if the application would like the stream to remain
             open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify
               whether the stream should be left open after Deflation or Inflation.
             </summary>
            <remarks>
                <para>
               This constructor allows the application to request that the captive
               stream remain open after the deflation or inflation occurs.  By
               default, after <c>Close()</c> is called on the stream, the captive
               stream is also closed. In some cases this is not desired, for example
               if the stream is a <see cref="T:System.IO.MemoryStream" /> that will be
               re-read after compression.  Specify true for the <paramref name="leaveOpen" /> parameter to leave the stream open.
             </para>
                <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.
             </para>
            </remarks>
            <example>
            
             This example shows how to use a ZlibStream to compress the data from a file,
             and store the result into another file. The filestream remains open to allow
             additional data to be written to it.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".zlib"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code><code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code></example>
            <param name="stream">The stream which will be read or written.</param>
            <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            <param name="leaveOpen">
             true if the application would like the stream to remain open after
             inflation/deflation.
             </param>
            <param name="level">
             A tuning knob to trade speed for effectiveness. This parameter is
             effective only when mode is <c>CompressionMode.Compress</c>.
             </param>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.BufferSize">
            <summary>
               The size of the working buffer for the compression codec.
             </summary>
            <remarks>
                <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes. The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
                <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
                <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
                <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotSupportedException" />.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.Position">
            <summary>
               The position of the stream pointer.
             </summary>
            <remarks>
               Setting this property always throws a <see cref="T:System.NotSupportedException" />. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Read data from the stream.
             </summary>
            <remarks>
                <para>
               If you wish to use the <c>ZlibStream</c> to compress data while reading,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               providing an uncompressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data read will be compressed.  If you wish to
               use the <c>ZlibStream</c> to decompress data while reading, you can create
               a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, providing a
               readable compressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data will be decompressed as it is read.
             </para>
                <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but
               not both.
             </para>
            </remarks>
            <param name="buffer">
             The buffer into which the read data should be placed.</param>
            <param name="offset">
             the offset within that data array to put the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
            <returns>the number of bytes read</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
             Calling this method always throws a <see cref="T:System.NotSupportedException" />.
             </summary>
            <param name="offset">
               The offset to seek to....
               IF THIS METHOD ACTUALLY DID ANYTHING.
             </param>
            <param name="origin">
               The reference specifying how to apply the offset....  IF
               THIS METHOD ACTUALLY DID ANYTHING.
             </param>
            <returns>nothing. This method always throws.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotSupportedException" />.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Write data to the stream.
             </summary>
            <remarks>
                <para>
               If you wish to use the <c>ZlibStream</c> to compress data while writing,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               and a writable output stream.  Then call <c>Write()</c> on that
               <c>ZlibStream</c>, providing uncompressed data as input.  The data sent to
               the output stream will be the compressed form of the data written.  If you
               wish to use the <c>ZlibStream</c> to decompress data while writing, you
               can create a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that stream,
               providing previously compressed data. The data sent to the output stream
               will be the decompressed form of the data written.
             </para>
                <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            </remarks>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.CompressString(System.String)">
            <summary>
               Compress a string into a byte array using ZLIB.
             </summary>
            <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])" />.
             </remarks>
            <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])" />
            <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])" />
            <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)" />
            <param name="s">
               A string to compress.  The string will first be encoded
               using UTF8, then compressed.
             </param>
            <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">
            <summary>
               Compress a byte array into a new byte array using ZLIB.
             </summary>
            <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])" />.
             </remarks>
            <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)" />
            <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])" />
            <param name="b">
             A buffer to compress.
             </param>
            <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])">
            <summary>
               Uncompress a ZLIB-compressed byte array into a single string.
             </summary>
            <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)" />
            <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])" />
            <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">
            <summary>
               Uncompress a ZLIB-compressed byte array into a byte array.
             </summary>
            <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])" />
            <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])" />
            <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:HtmlAgilityPack.Crc32">
            <summary>
            A utility class to compute CRC32.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.Crc32.CRC32Bytes(System.Byte[])">
            <summary>
            Compute a checksum for a given array of bytes.
            </summary>
            <param name="bytes">The array of bytes to compute the checksum for.</param>
            <returns>The computed checksum.</returns>
        </member>
        <member name="M:HtmlAgilityPack.Crc32.CRC32String(System.String)">
            <summary>
            Compute a checksum for a given string.
            </summary>
            <param name="text">The string to compute the checksum for.</param>
            <returns>The computed checksum.</returns>
        </member>
        <member name="T:HtmlAgilityPack.HtmlAttribute">
            <summary>
            Represents an HTML attribute.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.Line">
            <summary>
            Gets the line number of this attribute in the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.LinePosition">
            <summary>
            Gets the column number of this attribute in the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.ValueStartIndex">
            <summary>
            Gets the stream position of the value of this attribute in the document, relative to the start of the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.ValueLength">
            <summary>
            Gets the length of the value.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.Name">
            <summary>
            Gets the qualified name of the attribute.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.OriginalName">
            <summary>
            Name of attribute with original case
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.OwnerDocument">
            <summary>
            Gets the HTML document to which this attribute belongs.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.OwnerNode">
            <summary>
            Gets the HTML node to which this attribute belongs.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.QuoteType">
            <summary>
            Specifies what type of quote the data should be wrapped in
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.StreamPosition">
            <summary>
            Gets the stream position of this attribute in the document, relative to the start of the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.Value">
            <summary>
            Gets or sets the value of the attribute.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.DeEntitizeValue">
            <summary>
            Gets the DeEntitized value of the attribute.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttribute.XPath">
            <summary>
            Gets a valid XPath string that points to this Attribute
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttribute.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another attribute. Comparison is based on attributes' name.
            </summary>
            <param name="obj">An attribute to compare with this instance.</param>
            <returns>A 32-bit signed integer that indicates the relative order of the names comparison.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttribute.Clone">
            <summary>
            Creates a duplicate of this attribute.
            </summary>
            <returns>The cloned attribute.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttribute.Remove">
            <summary>
            Removes this attribute from it's parents collection
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.AttributeValueQuote">
            <summary>
            An Enum representing different types of Quotes used for surrounding attribute values
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.AttributeValueQuote.SingleQuote">
            <summary>
            A single quote mark '
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.AttributeValueQuote.DoubleQuote">
            <summary>
            A double quote mark "
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlAttributeCollection">
            <summary>
            Represents a combined list and collection of HTML nodes.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttributeCollection.Count">
            <summary>
            Gets the number of elements actually contained in the list.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttributeCollection.IsReadOnly">
            <summary>
            Gets readonly status of colelction
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttributeCollection.Item(System.Int32)">
            <summary>
            Gets the attribute at the specified index.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlAttributeCollection.Item(System.String)">
            <summary>
            Gets a given attribute from the list using its name.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Add(HtmlAgilityPack.HtmlAttribute)">
            <summary>
            Adds supplied item to collection
            </summary>
            <param name="item" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.System#Collections#Generic#ICollection{HtmlAgilityPack#HtmlAttribute}#Clear">
            <summary>
            Explicit clear
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Contains(HtmlAgilityPack.HtmlAttribute)">
            <summary>
            Retreives existence of supplied item
            </summary>
            <param name="item" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.CopyTo(HtmlAgilityPack.HtmlAttribute[],System.Int32)">
            <summary>
            Copies collection to array
            </summary>
            <param name="array" />
            <param name="arrayIndex" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.System#Collections#Generic#IEnumerable{HtmlAgilityPack#HtmlAttribute}#GetEnumerator">
            <summary>
            Get Explicit enumerator
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Explicit non-generic enumerator
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.IndexOf(HtmlAgilityPack.HtmlAttribute)">
            <summary>
            Retrieves the index for the supplied item, -1 if not found
            </summary>
            <param name="item" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Insert(System.Int32,HtmlAgilityPack.HtmlAttribute)">
            <summary>
            Inserts given item into collection at supplied index
            </summary>
            <param name="index" />
            <param name="item" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.System#Collections#Generic#ICollection{HtmlAgilityPack#HtmlAttribute}#Remove(HtmlAgilityPack.HtmlAttribute)">
            <summary>
            Explicit collection remove
            </summary>
            <param name="item" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.RemoveAt(System.Int32)">
            <summary>
            Removes the attribute at the specified index.
            </summary>
            <param name="index">The index of the attribute to remove.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Add(System.String,System.String)">
            <summary>
            Adds a new attribute to the collection with the given values
            </summary>
            <param name="name" />
            <param name="value" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Append(HtmlAgilityPack.HtmlAttribute)">
            <summary>
            Inserts the specified attribute as the last attribute in the collection.
            </summary>
            <param name="newAttribute">The attribute to insert. May not be null.</param>
            <returns>The appended attribute.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Append(System.String)">
            <summary>
            Creates and inserts a new attribute as the last attribute in the collection.
            </summary>
            <param name="name">The name of the attribute to insert.</param>
            <returns>The appended attribute.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Append(System.String,System.String)">
            <summary>
            Creates and inserts a new attribute as the last attribute in the collection.
            </summary>
            <param name="name">The name of the attribute to insert.</param>
            <param name="value">The value of the attribute to insert.</param>
            <returns>The appended attribute.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Contains(System.String)">
            <summary>
            Checks for existance of attribute with given name
            </summary>
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Prepend(HtmlAgilityPack.HtmlAttribute)">
            <summary>
            Inserts the specified attribute as the first node in the collection.
            </summary>
            <param name="newAttribute">The attribute to insert. May not be null.</param>
            <returns>The prepended attribute.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Remove(HtmlAgilityPack.HtmlAttribute)">
            <summary>
            Removes a given attribute from the list.
            </summary>
            <param name="attribute">The attribute to remove. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Remove(System.String)">
            <summary>
            Removes an attribute from the list, using its name. If there are more than one attributes with this name, they will all be removed.
            </summary>
            <param name="name">The attribute's name. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.RemoveAll">
            <summary>
            Remove all attributes in the list.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.AttributesWithName(System.String)">
            <summary>
            Returns all attributes with specified name. Handles case insentivity
            </summary>
            <param name="attributeName">Name of the attribute</param>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Remove">
            <summary>
            Removes all attributes from the collection
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlAttributeCollection.Clear">
            <summary>
            Clears the attribute collection
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlCommentNode">
            <summary>
            Represents an HTML comment.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlCommentNode.Comment">
            <summary>
            Gets or Sets the comment text of the node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlCommentNode.InnerHtml">
            <summary>
            Gets or Sets the HTML between the start and end tags of the object. In the case of a text node, it is equals to OuterHtml.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlCommentNode.OuterHtml">
            <summary>
            Gets or Sets the object and its content in HTML.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlDocument">
            <summary>
            Represents a complete HTML document.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.DisableBehavaiorTagP">
            <summary>True to disable, false to enable the behavaior tag p.</summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.DefaultBuilder">
            <summary>Default builder to use in the HtmlDocument constructor</summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.ParseExecuting">
            <summary>Action to execute before the Parse is executed</summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument._maxDepthLevel">
            <summary>
            Defines the max level we would go deep into the html document
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.Text">
            <summary>The HtmlDocument Text. Careful if you modify it.</summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.BackwardCompatibility">
            <summary>True to stay backward compatible with previous version of HAP. This option does not guarantee 100% compatibility.</summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionAddDebuggingAttributes">
            <summary>
            Adds Debugging attributes to node. Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionAutoCloseOnEnd">
            <summary>
            Defines if closing for non closed nodes must be done at the end or directly in the document.
            Setting this to true can actually change how browsers render the page. Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionCheckSyntax">
            <summary>
            Defines if non closed nodes will be checked at the end of parsing. Default is true.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionComputeChecksum">
            <summary>
            Defines if a checksum must be computed for the document while parsing. Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionEmptyCollection">
            <summary>
            Defines if SelectNodes method will return null or empty collection when no node matched the XPath expression.
            Setting this to true will return empty collection and false will return null. Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.DisableServerSideCode">
            <summary>True to disable, false to enable the server side code.</summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionDefaultStreamEncoding">
            <summary>
            Defines the default stream encoding to use. Default is System.Text.Encoding.Default.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionExtractErrorSourceText">
            <summary>
            Defines if source text must be extracted while parsing errors.
            If the document has a lot of errors, or cascading errors, parsing performance can be dramatically affected if set to true.
            Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionExtractErrorSourceTextMaxLength">
            <summary>
            Defines the maximum length of source text or parse errors. Default is 100.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionFixNestedTags">
            <summary>
            Defines if LI, TR, TH, TD tags must be partially fixed when nesting errors are detected. Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionOutputAsXml">
            <summary>
            Defines if output must conform to XML, instead of HTML. Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionPreserveXmlNamespaces">
            <summary>
            If used together with <see cref="F:HtmlAgilityPack.HtmlDocument.OptionOutputAsXml" /> and enabled, Xml namespaces in element names are preserved. Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionOutputOptimizeAttributeValues">
            <summary>
            Defines if attribute value output must be optimized (not bound with double quotes if it is possible). Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionOutputOriginalCase">
            <summary>
            Defines if name must be output with it's original case. Useful for asp.net tags and attributes. Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionOutputUpperCase">
            <summary>
            Defines if name must be output in uppercase. Default is false.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionReadEncoding">
            <summary>
            Defines if declared encoding must be read from the document.
            Declared encoding is determined using the meta http-equiv="content-type" content="text/html;charset=XXXXX" html node.
            Default is true.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionStopperNodeName">
            <summary>
            Defines the name of a node that will throw the StopperNodeException when found as an end node. Default is null.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionUseIdAttribute">
            <summary>
            Defines if the 'id' attribute must be specifically used. Default is true.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlDocument.OptionWriteEmptyNodes">
            <summary>
            Defines if empty nodes must be written as closed during output. Default is false.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.#ctor">
            <summary>
            Creates an instance of an HTML document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.ParsedText">
            <summary>Gets the parsed text.</summary>
            <value>The parsed text.</value>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.MaxDepthLevel">
            <summary>
            Defines the max level we would go deep into the html document. If this depth level is exceeded, and exception is
            thrown.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.CheckSum">
            <summary>
            Gets the document CRC32 checksum if OptionComputeChecksum was set to true before parsing, 0 otherwise.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.DeclaredEncoding">
            <summary>
            Gets the document's declared encoding.
            Declared encoding is determined using the meta http-equiv="content-type" content="text/html;charset=XXXXX" html node (pre-HTML5) or the meta charset="XXXXX" html node (HTML5).
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.DocumentNode">
            <summary>
            Gets the root node of the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.Encoding">
            <summary>
            Gets the document's output encoding.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.ParseErrors">
            <summary>
            Gets a list of parse errors found in the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.Remainder">
            <summary>
            Gets the remaining text.
            Will always be null if OptionStopperNodeName is null.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.RemainderOffset">
            <summary>
            Gets the offset of Remainder in the original Html text.
            If OptionStopperNodeName is null, this will return the length of the original Html text.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlDocument.StreamEncoding">
            <summary>
            Gets the document's stream encoding.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.GetXmlName(System.String)">
            <summary>
            Gets a valid XML name.
            </summary>
            <param name="name">Any text.</param>
            <returns>A string that is a valid XML name.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.HtmlEncode(System.String)">
            <summary>
            Applies HTML encoding to a specified string.
            </summary>
            <param name="html">The input string to encode. May not be null.</param>
            <returns>The encoded string.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.IsWhiteSpace(System.Int32)">
            <summary>
            Determines if the specified character is considered as a whitespace character.
            </summary>
            <param name="c">The character to check.</param>
            <returns>true if if the specified character is considered as a whitespace character.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.CreateAttribute(System.String)">
            <summary>
            Creates an HTML attribute with the specified name.
            </summary>
            <param name="name">The name of the attribute. May not be null.</param>
            <returns>The new HTML attribute.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.CreateAttribute(System.String,System.String)">
            <summary>
            Creates an HTML attribute with the specified name.
            </summary>
            <param name="name">The name of the attribute. May not be null.</param>
            <param name="value">The value of the attribute.</param>
            <returns>The new HTML attribute.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.CreateComment">
            <summary>
            Creates an HTML comment node.
            </summary>
            <returns>The new HTML comment node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.CreateComment(System.String)">
            <summary>
            Creates an HTML comment node with the specified comment text.
            </summary>
            <param name="comment">The comment text. May not be null.</param>
            <returns>The new HTML comment node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.CreateElement(System.String)">
            <summary>
            Creates an HTML element node with the specified name.
            </summary>
            <param name="name">The qualified name of the element. May not be null.</param>
            <returns>The new HTML node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.CreateTextNode">
            <summary>
            Creates an HTML text node.
            </summary>
            <returns>The new HTML text node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.CreateTextNode(System.String)">
            <summary>
            Creates an HTML text node with the specified text.
            </summary>
            <param name="text">The text of the node. May not be null.</param>
            <returns>The new HTML text node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.DetectEncoding(System.IO.Stream)">
            <summary>
            Detects the encoding of an HTML stream.
            </summary>
            <param name="stream">The input stream. May not be null.</param>
            <returns>The detected encoding.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.DetectEncoding(System.IO.Stream,System.Boolean)">
            <summary>
            Detects the encoding of an HTML stream.
            </summary>
            <param name="stream">The input stream. May not be null.</param>
            <param name="checkHtml">The html is checked.</param>
            <returns>The detected encoding.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.DetectEncoding(System.IO.TextReader)">
            <summary>
            Detects the encoding of an HTML text provided on a TextReader.
            </summary>
            <param name="reader">The TextReader used to feed the HTML. May not be null.</param>
            <returns>The detected encoding.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.DetectEncodingHtml(System.String)">
            <summary>
            Detects the encoding of an HTML text.
            </summary>
            <param name="html">The input html text. May not be null.</param>
            <returns>The detected encoding.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.GetElementbyId(System.String)">
            <summary>
            Gets the HTML node with the specified 'id' attribute value.
            </summary>
            <param name="id">The attribute id to match. May not be null.</param>
            <returns>The HTML node with the matching id or null if not found.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.IO.Stream)">
            <summary>
            Loads an HTML document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.IO.Stream,System.Boolean)">
            <summary>
            Loads an HTML document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Loads an HTML document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The character encoding to use.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>
            Loads an HTML document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Loads an HTML document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
            <param name="buffersize">The minimum buffer size.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.IO.TextReader)">
            <summary>
            Loads the HTML document from the specified TextReader.
            </summary>
            <param name="reader">The TextReader used to feed the HTML data into the document. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.LoadHtml(System.String)">
            <summary>
            Loads the HTML document from the specified string.
            </summary>
            <param name="html">String containing the HTML document to load. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Save(System.IO.Stream)">
            <summary>
            Saves the HTML document to the specified stream.
            </summary>
            <param name="outStream">The stream to which you want to save.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Save(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Saves the HTML document to the specified stream.
            </summary>
            <param name="outStream">The stream to which you want to save. May not be null.</param>
            <param name="encoding">The character encoding to use. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Save(System.IO.StreamWriter)">
            <summary>
            Saves the HTML document to the specified StreamWriter.
            </summary>
            <param name="writer">The StreamWriter to which you want to save.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Save(System.IO.TextWriter)">
            <summary>
            Saves the HTML document to the specified TextWriter.
            </summary>
            <param name="writer">The TextWriter to which you want to save. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Save(System.Xml.XmlWriter)">
            <summary>
            Saves the HTML document to the specified XmlWriter.
            </summary>
            <param name="writer">The XmlWriter to which you want to save.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.DetectEncodingAndLoad(System.String)">
            <summary>
            Detects the encoding of an HTML document from a file first, and then loads the file.
            </summary>
            <param name="path">The complete file path to be read.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.DetectEncodingAndLoad(System.String,System.Boolean)">
            <summary>
            Detects the encoding of an HTML document from a file first, and then loads the file.
            </summary>
            <param name="path">The complete file path to be read. May not be null.</param>
            <param name="detectEncoding">true to detect encoding, false otherwise.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.DetectEncoding(System.String)">
            <summary>
            Detects the encoding of an HTML file.
            </summary>
            <param name="path">Path for the file containing the HTML document to detect. May not be null.</param>
            <returns>The detected encoding.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.String)">
            <summary>
            Loads an HTML document from a file.
            </summary>
            <param name="path">The complete file path to be read. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.String,System.Boolean)">
            <summary>
            Loads an HTML document from a file.
            </summary>
            <param name="path">The complete file path to be read. May not be null.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.String,System.Text.Encoding)">
            <summary>
            Loads an HTML document from a file.
            </summary>
            <param name="path">The complete file path to be read. May not be null.</param>
            <param name="encoding">The character encoding to use. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.String,System.Text.Encoding,System.Boolean)">
            <summary>
            Loads an HTML document from a file.
            </summary>
            <param name="path">The complete file path to be read. May not be null.</param>
            <param name="encoding">The character encoding to use. May not be null.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Load(System.String,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Loads an HTML document from a file.
            </summary>
            <param name="path">The complete file path to be read. May not be null.</param>
            <param name="encoding">The character encoding to use. May not be null.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
            <param name="buffersize">The minimum buffer size.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Save(System.String)">
            <summary>
            Saves the mixed document to the specified file.
            </summary>
            <param name="filename">The location of the file where you want to save the document.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.Save(System.String,System.Text.Encoding)">
            <summary>
            Saves the mixed document to the specified file.
            </summary>
            <param name="filename">The location of the file where you want to save the document. May not be null.</param>
            <param name="encoding">The character encoding to use. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlDocument.CreateNavigator">
            <summary>
            Creates a new XPathNavigator object for navigating this HTML document.
            </summary>
            <returns>An XPathNavigator object. The XPathNavigator is positioned on the root of the document.</returns>
        </member>
        <member name="T:HtmlAgilityPack.HtmlElementFlag">
            <summary>
            Flags that describe the behavior of an Element node.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlElementFlag.CData">
            <summary>
            The node is a CDATA node.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlElementFlag.Empty">
            <summary>
            The node is empty. META or IMG are example of such nodes.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlElementFlag.Closed">
            <summary>
            The node will automatically be closed during parsing.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlElementFlag.CanOverlap">
            <summary>
            The node can overlap.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlEntity">
            <summary>
            A utility class to replace special characters by entities and vice-versa.
            Follows HTML 4.0 specification found at http://www.w3.org/TR/html4/sgml/entities.html
            Follows Additional specification found at https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references
            See also: https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlEntity.EntityName">
            <summary>
            A collection of entities indexed by name.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlEntity.EntityValue">
            <summary>
            A collection of entities indexed by value.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlEntity.DeEntitize(System.String)">
            <summary>
            Replace known entities by characters.
            </summary>
            <param name="text">The source text.</param>
            <returns>The result text.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlEntity.Entitize(HtmlAgilityPack.HtmlNode)">
            <summary>
            Clone and entitize an HtmlNode. This will affect attribute values and nodes' text. It will also entitize all child nodes.
            </summary>
            <param name="node">The node to entitize.</param>
            <returns>An entitized cloned node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlEntity.Entitize(System.String)">
            <summary>
            Replace characters above 127 by entities.
            </summary>
            <param name="text">The source text.</param>
            <returns>The result text.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlEntity.Entitize(System.String,System.Boolean)">
            <summary>
            Replace characters above 127 by entities.
            </summary>
            <param name="text">The source text.</param>
            <param name="useNames">If set to false, the function will not use known entities name. Default is true.</param>
            <returns>The result text.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlEntity.Entitize(System.String,System.Boolean,System.Boolean)">
            <summary>
            Replace characters above 127 by entities.
            </summary>
            <param name="text">The source text.</param>
            <param name="useNames">If set to false, the function will not use known entities name. Default is true.</param>
            <param name="entitizeQuotAmpAndLtGt">If set to true, the [quote], [ampersand], [lower than] and [greather than] characters will be entitized.</param>
            <returns>The result text</returns>
        </member>
        <member name="T:HtmlAgilityPack.HtmlNode">
            <summary>
            Represents an HTML node.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlNode.HtmlNodeTypeNameComment">
            <summary>
            Gets the name of a comment node. It is actually defined as '#comment'.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlNode.HtmlNodeTypeNameDocument">
            <summary>
            Gets the name of the document node. It is actually defined as '#document'.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlNode.HtmlNodeTypeNameText">
            <summary>
            Gets the name of a text node. It is actually defined as '#text'.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlNode.ElementsFlags">
            <summary>
            Gets a collection of flags that define specific behaviors for specific element nodes.
            The table contains a DictionaryEntry list with the lowercase tag name as the Key, and a combination of HtmlElementFlags as the Value.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.#cctor">
            <summary>
            Initialize HtmlNode. Builds a list of all tags that have special allowances
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.#ctor(HtmlAgilityPack.HtmlNodeType,HtmlAgilityPack.HtmlDocument,System.Int32)">
            <summary>
            Initializes HtmlNode, providing type, owner and where it exists in a collection
            </summary>
            <param name="type" />
            <param name="ownerdocument" />
            <param name="index" />
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.Attributes">
            <summary>
            Gets the collection of HTML attributes for this node. May not be null.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.ChildNodes">
            <summary>
            Gets all the children of the node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.Closed">
            <summary>
            Gets a value indicating if this node has been closed or not.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.ClosingAttributes">
            <summary>
            Gets the collection of HTML attributes for the closing tag. May not be null.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.EndNode">
            <summary>
            Gets the closing tag of the node, null if the node is self-closing.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.FirstChild">
            <summary>
            Gets the first child of the node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.HasAttributes">
            <summary>
            Gets a value indicating whether the current node has any attributes.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.HasChildNodes">
            <summary>
            Gets a value indicating whether this node has any child nodes.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.HasClosingAttributes">
            <summary>
            Gets a value indicating whether the current node has any attributes on the closing tag.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.Id">
            <summary>
            Gets or sets the value of the 'id' HTML attribute. The document must have been parsed using the OptionUseIdAttribute set to true.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.InnerHtml">
            <summary>
            Gets or Sets the HTML between the start and end tags of the object.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.InnerText">
            <summary>
            Gets or Sets the text between the start and end tags of the object.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.LastChild">
            <summary>
            Gets the last child of the node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.Line">
            <summary>
            Gets the line number of this node in the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.LinePosition">
            <summary>
            Gets the column number of this node in the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.InnerStartIndex">
            <summary>
            Gets the stream position of the area between the opening and closing tag of the node, relative to the start of the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.InnerLength">
            <summary>
            Gets the length of the area between the opening and closing tag of the node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.OuterLength">
            <summary>
            Gets the length of the entire node, opening and closing tag included.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.Name">
            <summary>
            Gets or sets this node's name.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.NextSibling">
            <summary>
            Gets the HTML node immediately following this element.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.NodeType">
            <summary>
            Gets the type of this node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.OriginalName">
            <summary>
            The original unaltered name of the tag
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.OuterHtml">
            <summary>
            Gets or Sets the object and its content in HTML.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.OwnerDocument">
            <summary>
            Gets the <see cref="T:HtmlAgilityPack.HtmlDocument" /> to which this node belongs.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.ParentNode">
            <summary>
            Gets the parent of this node (for nodes that can have parents).
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.PreviousSibling">
            <summary>
            Gets the node immediately preceding this node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.StreamPosition">
            <summary>
            Gets the stream position of this node in the document, relative to the start of the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNode.XPath">
            <summary>
            Gets a valid XPath string that points to this node
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.CanOverlapElement(System.String)">
            <summary>
            Determines if an element node can be kept overlapped.
            </summary>
            <param name="name">The name of the element node to check. May not be <c>null</c>.</param>
            <returns>true if the name is the name of an element node that can be kept overlapped, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.CreateNode(System.String)">
            <summary>
            Creates an HTML node from a string representing literal HTML.
            </summary>
            <param name="html">The HTML text.</param>
            <returns>The newly created node instance.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.IsCDataElement(System.String)">
            <summary>
            Determines if an element node is a CDATA element node.
            </summary>
            <param name="name">The name of the element node to check. May not be null.</param>
            <returns>true if the name is the name of a CDATA element node, false otherwise.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.IsClosedElement(System.String)">
            <summary>
            Determines if an element node is closed.
            </summary>
            <param name="name">The name of the element node to check. May not be null.</param>
            <returns>true if the name is the name of a closed element node, false otherwise.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.IsEmptyElement(System.String)">
            <summary>
            Determines if an element node is defined as empty.
            </summary>
            <param name="name">The name of the element node to check. May not be null.</param>
            <returns>true if the name is the name of an empty element node, false otherwise.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.IsOverlappedClosingElement(System.String)">
            <summary>
            Determines if a text corresponds to the closing tag of an node that can be kept overlapped.
            </summary>
            <param name="text">The text to check. May not be null.</param>
            <returns>true or false.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.Ancestors">
            <summary>
            Returns a collection of all ancestor nodes of this element.
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.Ancestors(System.String)">
            <summary>
            Get Ancestors with matching name
            </summary>
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.AncestorsAndSelf">
            <summary>
            Returns a collection of all ancestor nodes of this element.
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.AncestorsAndSelf(System.String)">
            <summary>
            Gets all anscestor nodes and the current node
            </summary>
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.AppendChild(HtmlAgilityPack.HtmlNode)">
            <summary>
            Adds the specified node to the end of the list of children of this node.
            </summary>
            <param name="newChild">The node to add. May not be null.</param>
            <returns>The node added.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.SetChildNodesId(HtmlAgilityPack.HtmlNode)">
            <summary>Sets child nodes identifier.</summary>
            <param name="chilNode">The chil node.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.AppendChildren(HtmlAgilityPack.HtmlNodeCollection)">
            <summary>
            Adds the specified node to the end of the list of children of this node.
            </summary>
            <param name="newChildren">The node list to add. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.ChildAttributes(System.String)">
            <summary>
            Gets all Attributes with name
            </summary>
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.Clone">
            <summary>
            Creates a duplicate of the node
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.CloneNode(System.String)">
            <summary>
            Creates a duplicate of the node and changes its name at the same time.
            </summary>
            <param name="newName">The new name of the cloned node. May not be <c>null</c>.</param>
            <returns>The cloned node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.CloneNode(System.String,System.Boolean)">
            <summary>
            Creates a duplicate of the node and changes its name at the same time.
            </summary>
            <param name="newName">The new name of the cloned node. May not be null.</param>
            <param name="deep">true to recursively clone the subtree under the specified node; false to clone only the node itself.</param>
            <returns>The cloned node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.CloneNode(System.Boolean)">
            <summary>
            Creates a duplicate of the node.
            </summary>
            <param name="deep">true to recursively clone the subtree under the specified node; false to clone only the node itself.</param>
            <returns>The cloned node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.CopyFrom(HtmlAgilityPack.HtmlNode)">
            <summary>
            Creates a duplicate of the node and the subtree under it.
            </summary>
            <param name="node">The node to duplicate. May not be <c>null</c>.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.CopyFrom(HtmlAgilityPack.HtmlNode,System.Boolean)">
            <summary>
            Creates a duplicate of the node.
            </summary>
            <param name="node">The node to duplicate. May not be <c>null</c>.</param>
            <param name="deep">true to recursively clone the subtree under the specified node, false to clone only the node itself.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.DescendantNodes(System.Int32)">
            <summary>
            Gets all Descendant nodes for this node and each of child nodes
            </summary>
            <param name="level">The depth level of the node to parse in the html tree</param>
            <returns>the current element as an HtmlNode</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.DescendantNodesAndSelf">
            <summary>
            Returns a collection of all descendant nodes of this element, in document order
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.Descendants">
            <summary>
            Gets all Descendant nodes in enumerated list
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.Descendants(System.Int32)">
            <summary>
            Gets all Descendant nodes in enumerated list
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.Descendants(System.String)">
            <summary>
            Get all descendant nodes with matching name
            </summary>
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.DescendantsAndSelf">
            <summary>
            Returns a collection of all descendant nodes of this element, in document order
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.DescendantsAndSelf(System.String)">
            <summary>
            Gets all descendant nodes including this node
            </summary>
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.Element(System.String)">
            <summary>
            Gets first generation child node matching name
            </summary>
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.Elements(System.String)">
            <summary>
            Gets matching first generation child nodes matching name
            </summary>
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.GetAttributeValue(System.String,System.String)">
            <summary>
            Helper method to get the value of an attribute of this node. If the attribute is not found, the default value will be returned.
            </summary>
            <param name="name">The name of the attribute to get. May not be <c>null</c>.</param>
            <param name="def">The default value to return if not found.</param>
            <returns>The value of the attribute if found, the default value if not found.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.GetAttributeValue(System.String,System.Int32)">
            <summary>
            Helper method to get the value of an attribute of this node. If the attribute is not found, the default value will be returned.
            </summary>
            <param name="name">The name of the attribute to get. May not be <c>null</c>.</param>
            <param name="def">The default value to return if not found.</param>
            <returns>The value of the attribute if found, the default value if not found.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.GetAttributeValue(System.String,System.Boolean)">
            <summary>
            Helper method to get the value of an attribute of this node. If the attribute is not found, the default value will be returned.
            </summary>
            <param name="name">The name of the attribute to get. May not be <c>null</c>.</param>
            <param name="def">The default value to return if not found.</param>
            <returns>The value of the attribute if found, the default value if not found.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.InsertAfter(HtmlAgilityPack.HtmlNode,HtmlAgilityPack.HtmlNode)">
            <summary>
            Inserts the specified node immediately after the specified reference node.
            </summary>
            <param name="newChild">The node to insert. May not be <c>null</c>.</param>
            <param name="refChild">The node that is the reference node. The newNode is placed after the refNode.</param>
            <returns>The node being inserted.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.InsertBefore(HtmlAgilityPack.HtmlNode,HtmlAgilityPack.HtmlNode)">
            <summary>
            Inserts the specified node immediately before the specified reference node.
            </summary>
            <param name="newChild">The node to insert. May not be <c>null</c>.</param>
            <param name="refChild">The node that is the reference node. The newChild is placed before this node.</param>
            <returns>The node being inserted.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.PrependChild(HtmlAgilityPack.HtmlNode)">
            <summary>
            Adds the specified node to the beginning of the list of children of this node.
            </summary>
            <param name="newChild">The node to add. May not be <c>null</c>.</param>
            <returns>The node added.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.PrependChildren(HtmlAgilityPack.HtmlNodeCollection)">
            <summary>
            Adds the specified node list to the beginning of the list of children of this node.
            </summary>
            <param name="newChildren">The node list to add. May not be <c>null</c>.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.Remove">
            <summary>
            Removes node from parent collection
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.RemoveAll">
            <summary>
            Removes all the children and/or attributes of the current node.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.RemoveAllChildren">
            <summary>
            Removes all the children of the current node.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.RemoveAllIDforNode(HtmlAgilityPack.HtmlNode)">
            <summary>Removes all id for node described by node.</summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.RemoveChild(HtmlAgilityPack.HtmlNode)">
            <summary>
            Removes the specified child node.
            </summary>
            <param name="oldChild">The node being removed. May not be <c>null</c>.</param>
            <returns>The node removed.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.RemoveChild(HtmlAgilityPack.HtmlNode,System.Boolean)">
            <summary>
            Removes the specified child node.
            </summary>
            <param name="oldChild">The node being removed. May not be <c>null</c>.</param>
            <param name="keepGrandChildren">true to keep grand children of the node, false otherwise.</param>
            <returns>The node removed.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.ReplaceChild(HtmlAgilityPack.HtmlNode,HtmlAgilityPack.HtmlNode)">
            <summary>
            Replaces the child node oldChild with newChild node.
            </summary>
            <param name="newChild">The new node to put in the child list.</param>
            <param name="oldChild">The node being replaced in the list.</param>
            <returns>The node replaced.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.SetAttributeValue(System.String,System.String)">
            <summary>
            Helper method to set the value of an attribute of this node. If the attribute is not found, it will be created automatically.
            </summary>
            <param name="name">The name of the attribute to set. May not be null.</param>
            <param name="value">The value for the attribute.</param>
            <returns>The corresponding attribute instance.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.WriteContentTo(System.IO.TextWriter,System.Int32)">
            <summary>
            Saves all the children of the node to the specified TextWriter.
            </summary>
            <param name="outText">The TextWriter to which you want to save.</param>
            <param name="level">Identifies the level we are in starting at root with 0</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.WriteContentTo">
            <summary>
            Saves all the children of the node to a string.
            </summary>
            <returns>The saved string.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.WriteTo(System.IO.TextWriter,System.Int32)">
            <summary>
            Saves the current node to the specified TextWriter.
            </summary>
            <param name="outText">The TextWriter to which you want to save.</param>
            <param name="level">identifies the level we are in starting at root with 0</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.WriteTo(System.Xml.XmlWriter)">
            <summary>
            Saves the current node to the specified XmlWriter.
            </summary>
            <param name="writer">The XmlWriter to which you want to save.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.WriteTo">
            <summary>
            Saves the current node to a string.
            </summary>
            <returns>The saved string.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.AddClass(System.String)">
            <summary>
            Adds one or more classes to this node.
            </summary>
            <param name="name">The node list to add. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.AddClass(System.String,System.Boolean)">
            <summary>
            Adds one or more classes to this node.
            </summary>
            <param name="name">The node list to add. May not be null.</param>
            <param name="throwError">true to throw Error if class name exists, false otherwise.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.RemoveClass">
            <summary>
            Removes the class attribute from the node.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.RemoveClass(System.Boolean)">
            <summary>
            Removes the class attribute from the node.
            </summary>
            <param name="throwError">true to throw Error if class name doesn't exist, false otherwise.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.RemoveClass(System.String)">
            <summary>
            Removes the specified class from the node.
            </summary>
            <param name="name">The class being removed. May not be <c>null</c>.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.RemoveClass(System.String,System.Boolean)">
            <summary>
            Removes the specified class from the node.
            </summary>
            <param name="name">The class being removed. May not be <c>null</c>.</param>
            <param name="throwError">true to throw Error if class name doesn't exist, false otherwise.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.ReplaceClass(System.String,System.String)">
            <summary>
            Replaces the class name oldClass with newClass name.
            </summary>
            <param name="newClass">The new class name.</param>
            <param name="oldClass">The class being replaced.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.ReplaceClass(System.String,System.String,System.Boolean)">
            <summary>
            Replaces the class name oldClass with newClass name.
            </summary>
            <param name="newClass">The new class name.</param>
            <param name="oldClass">The class being replaced.</param>
            <param name="throwError">true to throw Error if class name doesn't exist, false otherwise.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.GetClasses">
            <summary>Gets the CSS Class from the node.</summary>
            <returns>
                The CSS Class from the node
            </returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.HasClass(System.String)">
            <summary>Check if the node class has the parameter class.</summary>
            <param name="class">The class.</param>
            <returns>True if node class has the parameter class, false if not.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.GetEncapsulatedData``1(HtmlAgilityPack.HtmlDocument)">
            <summary>
            Fill an object and go through it's properties and fill them too.
            </summary>
            <typeparam name="T">Type of object to want to fill. It should have atleast one property that defined XPath.</typeparam>
            <param name="htmlDocument">If htmlDocument includes data , leave this parameter null. Else pass your specific htmldocument.</param>
            <returns>Returns an object of type T including Encapsulated data.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.GetEncapsulatedData(System.Type,HtmlAgilityPack.HtmlDocument)">
            <summary>
            Fill an object and go through it's properties and fill them too.
            </summary>
            <param name="targetType">Type of object to want to fill. It should have atleast one property that defined XPath.</param>
            <param name="htmlDocument">If htmlDocument includes data , leave this parameter null. Else pass your specific htmldocument.</param>
            <returns>Returns an object of type targetType including Encapsulated data.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.CreateNavigator">
            <summary>
            Creates a new XPathNavigator object for navigating this HTML node.
            </summary>
            <returns>An XPathNavigator object. The XPathNavigator is positioned on the node from which the method was called. It is not positioned on the root of the document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.CreateRootNavigator">
            <summary>
            Creates an XPathNavigator using the root of this document.
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.SelectNodes(System.String)">
            <summary>
            Selects a list of nodes matching the <see cref="P:HtmlAgilityPack.HtmlNode.XPath" /> expression.
            </summary>
            <param name="xpath">The XPath expression.</param>
            <returns>An <see cref="T:HtmlAgilityPack.HtmlNodeCollection" /> containing a collection of nodes matching the <see cref="P:HtmlAgilityPack.HtmlNode.XPath" /> query, or <c>null</c> if no node matched the XPath expression.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.SelectNodes(System.Xml.XPath.XPathExpression)">
            <summary>
            Selects a list of nodes matching the <see cref="P:HtmlAgilityPack.HtmlNode.XPath" /> expression.
            </summary>
            <param name="xpath">The XPath expression.</param>
            <returns>An <see cref="T:HtmlAgilityPack.HtmlNodeCollection" /> containing a collection of nodes matching the <see cref="P:HtmlAgilityPack.HtmlNode.XPath" /> query, or <c>null</c> if no node matched the XPath expression.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.SelectSingleNode(System.String)">
            <summary>
            Selects the first XmlNode that matches the XPath expression.
            </summary>
            <param name="xpath">The XPath expression. May not be null.</param>
            <returns>The first <see cref="T:HtmlAgilityPack.HtmlNode" /> that matches the XPath query or a null reference if no matching node was found.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNode.SelectSingleNode(System.Xml.XPath.XPathExpression)">
            <summary>
            Selects a list of nodes matching the <see cref="P:HtmlAgilityPack.HtmlNode.XPath" /> expression.
            </summary>
            <param name="xpath">The XPath expression.</param>
            <returns>An <see cref="T:HtmlAgilityPack.HtmlNodeCollection" /> containing a collection of nodes matching the <see cref="P:HtmlAgilityPack.HtmlNode.XPath" /> query, or <c>null</c> if no node matched the XPath expression.</returns>
        </member>
        <member name="T:HtmlAgilityPack.Tools">
            <summary>
            Includes tools that GetEncapsulatedData method uses them.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.Tools.IsDefinedAttribute(System.Type,System.Type)">
            <summary>
            Determine if a type define an attribute or not , supporting both .NetStandard and .NetFramework2.0
            </summary>
            <param name="type">Type you want to test it.</param>
            <param name="attributeType">Attribute that type must have or not.</param>
            <returns>If true , The type parameter define attributeType parameter.</returns>
        </member>
        <member name="M:HtmlAgilityPack.Tools.GetPropertiesDefinedXPath(System.Type)">
            <summary>
            Retrive properties of type that defined <see cref="T:HtmlAgilityPack.XPathAttribute" />.
            </summary>
            <param name="type">Type that you want to find it's XPath-Defined properties.</param>
            <returns>IEnumerable of property infos of a type , that defined specific attribute.</returns>
        </member>
        <member name="M:HtmlAgilityPack.Tools.IsIEnumerable(System.Reflection.PropertyInfo)">
            <summary>
            Determine if a <see cref="T:System.Reflection.PropertyInfo" /> has implemented <see cref="T:System.Collections.IEnumerable" /> BUT <see cref="T:System.String" /> is considered as NONE-IEnumerable !
            </summary>
            <param name="propertyInfo">The property info you want to test.</param>
            <returns>True if property info is IEnumerable.</returns>
        </member>
        <member name="M:HtmlAgilityPack.Tools.GetGenericTypes(System.Reflection.PropertyInfo)">
            <summary>
            Returns T type(first generic type) of <see cref="T:System.Collections.Generic.IEnumerable`1" /> or <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
            <param name="propertyInfo">IEnumerable-Implemented property</param>
            <returns>List of generic types.</returns>
        </member>
        <member name="M:HtmlAgilityPack.Tools.GetMethodByItsName(System.Type,System.String)">
            <summary>
            Find and Return a mehtod that defined in a class by it's name.
            </summary>
            <param name="type">Type of class include requested method.</param>
            <param name="methodName">Name of requested method as string.</param>
            <returns>Method info of requested method.</returns>
        </member>
        <member name="M:HtmlAgilityPack.Tools.CreateIListOfType(System.Type)">
            <summary>
            Create <see cref="T:System.Collections.IList" /> of given type.
            </summary>
            <param name="type">Type that you want to make a List of it.</param>
            <returns>Returns IList of given type.</returns>
        </member>
        <member name="M:HtmlAgilityPack.Tools.GetNodeValueBasedOnXPathReturnType``1(HtmlAgilityPack.HtmlNode,HtmlAgilityPack.XPathAttribute)">
            <summary>
            Returns the part of value of <see cref="T:HtmlAgilityPack.HtmlNode" /> you want as .
            </summary>
            <param name="htmlNode">A htmlNode instance.</param>
            <param name="xPathAttribute">Attribute that includes ReturnType</param>
            <returns>String that choosen from HtmlNode as result.</returns>
        </member>
        <member name="M:HtmlAgilityPack.Tools.GetNodesValuesBasedOnXPathReturnType(HtmlAgilityPack.HtmlNodeCollection,HtmlAgilityPack.XPathAttribute,System.Type)">
            <summary>
            Returns parts of values of <see cref="T:HtmlAgilityPack.HtmlNode" /> you want as <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
            <param name="htmlNodeCollection">
                <see cref="T:HtmlAgilityPack.HtmlNodeCollection" /> that you want to retrive each <see cref="T:HtmlAgilityPack.HtmlNode" /> value.</param>
            <param name="xPathAttribute">A <see cref="T:HtmlAgilityPack.XPathAttribute" /> instnce incules <see cref="T:HtmlAgilityPack.ReturnType" />.</param>
            <param name="listGenericType">Type of IList generic you want.</param>
            <returns />
        </member>
        <member name="T:HtmlAgilityPack.Tools.HAPFunc`2">
            <summary>
            Simulate Func method to use in Lambada Expression.
            </summary>
            <typeparam name="T" />
            <typeparam name="TResult" />
            <param name="arg" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.Tools.HAPWhere``1(System.Collections.Generic.IEnumerable{``0},HtmlAgilityPack.Tools.HAPFunc{``0,System.Boolean})">
            <summary>
            This method works like Where method in LINQ.
            </summary>
            <typeparam name="TSource" />
            <param name="source" />
            <param name="predicate" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.Tools.IsInstantiable(System.Type)">
            <summary>
            Check if the type can instantiated.
            </summary>
            <param name="type" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.Tools.CountOfIEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns count of elements stored in IEnumerable of T
            </summary>
            <typeparam name="T" />
            <param name="source" />
            <returns />
        </member>
        <member name="T:HtmlAgilityPack.ReturnType">
            <summary>
            Specify which part of <see cref="T:HtmlAgilityPack.HtmlNode" /> is requested.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HasXPathAttribute">
            <summary>
            Just mark and flag classes to show they have properties that defined <see cref="T:HtmlAgilityPack.XPathAttribute" />.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.XPathAttribute">
            <summary>
            Includes XPath and <see cref="P:HtmlAgilityPack.XPathAttribute.NodeReturnType" />. XPath for finding html tags and <see cref="P:HtmlAgilityPack.XPathAttribute.NodeReturnType" /> for specify which part of <see cref="T:HtmlAgilityPack.HtmlNode" /> you want to return.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlNodeCollection">
            <summary>
            Represents a combined list and collection of HTML nodes.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.#ctor(HtmlAgilityPack.HtmlNode)">
            <summary>
            Initialize the HtmlNodeCollection with the base parent node
            </summary>
            <param name="parentnode">The base node of the collection</param>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeCollection.Item(HtmlAgilityPack.HtmlNode)">
            <summary>
            Gets a given node from the list.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeCollection.Item(System.String)">
            <summary>
            Get node with tag name
            </summary>
            <param name="nodeName" />
            <returns />
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeCollection.Count">
            <summary>
            Gets the number of elements actually contained in the list.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeCollection.IsReadOnly">
            <summary>
            Is collection read only
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeCollection.Item(System.Int32)">
            <summary>
            Gets the node at the specified index.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Add(HtmlAgilityPack.HtmlNode)">
            <summary>
            Add node to the collection
            </summary>
            <param name="node" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Add(HtmlAgilityPack.HtmlNode,System.Boolean)">
            <summary>
            Add node to the collection
            </summary>
            <param name="node" />
            <param name="setParent" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Clear">
            <summary>
            Clears out the collection of HtmlNodes. Removes each nodes reference to parentnode, nextnode and prevnode
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Contains(HtmlAgilityPack.HtmlNode)">
            <summary>
            Gets existence of node in collection
            </summary>
            <param name="item" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.CopyTo(HtmlAgilityPack.HtmlNode[],System.Int32)">
            <summary>
            Copy collection to array
            </summary>
            <param name="array" />
            <param name="arrayIndex" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.System#Collections#Generic#IEnumerable{HtmlAgilityPack#HtmlNode}#GetEnumerator">
            <summary>
            Get Enumerator
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get Explicit Enumerator
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.IndexOf(HtmlAgilityPack.HtmlNode)">
            <summary>
            Get index of node
            </summary>
            <param name="item" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Insert(System.Int32,HtmlAgilityPack.HtmlNode)">
            <summary>
            Insert node at index
            </summary>
            <param name="index" />
            <param name="node" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Remove(HtmlAgilityPack.HtmlNode)">
            <summary>
            Remove node
            </summary>
            <param name="item" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.RemoveAt(System.Int32)">
            <summary>
            Remove <see cref="T:HtmlAgilityPack.HtmlNode" /> at index
            </summary>
            <param name="index" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.FindFirst(HtmlAgilityPack.HtmlNodeCollection,System.String)">
            <summary>
            Get first instance of node in supplied collection
            </summary>
            <param name="items" />
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Append(HtmlAgilityPack.HtmlNode)">
            <summary>
            Add node to the end of the collection
            </summary>
            <param name="node" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.FindFirst(System.String)">
            <summary>
            Get first instance of node with name
            </summary>
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.GetNodeIndex(HtmlAgilityPack.HtmlNode)">
            <summary>
            Get index of node
            </summary>
            <param name="node" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Prepend(HtmlAgilityPack.HtmlNode)">
            <summary>
            Add node to the beginning of the collection
            </summary>
            <param name="node" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Remove(System.Int32)">
            <summary>
            Remove node at index
            </summary>
            <param name="index" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Replace(System.Int32,HtmlAgilityPack.HtmlNode)">
            <summary>
            Replace node at index
            </summary>
            <param name="index" />
            <param name="node" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Descendants">
            <summary>
            Get all node descended from this collection
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Descendants(System.String)">
            <summary>
            Get all node descended from this collection with matching name
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Elements">
            <summary>
            Gets all first generation elements in collection
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Elements(System.String)">
            <summary>
            Gets all first generation elements matching name
            </summary>
            <param name="name" />
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeCollection.Nodes">
            <summary>
            All first generation nodes in collection
            </summary>
            <returns />
        </member>
        <member name="T:HtmlAgilityPack.HtmlNodeNavigator">
            <summary>
            Represents an HTML navigator on an HTML document seen as a data store.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The character encoding to use.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
            <param name="buffersize">The minimum buffer size.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a TextReader.
            </summary>
            <param name="reader">The TextReader used to feed the HTML data into the document.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.String)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a file.
            </summary>
            <param name="path">The complete file path to be read.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a file.
            </summary>
            <param name="path">The complete file path to be read.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a file.
            </summary>
            <param name="path">The complete file path to be read.</param>
            <param name="encoding">The character encoding to use.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.String,System.Text.Encoding,System.Boolean)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a file.
            </summary>
            <param name="path">The complete file path to be read.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance of the HtmlNavigator and loads an HTML document from a file.
            </summary>
            <param name="path">The complete file path to be read.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
            <param name="buffersize">The minimum buffer size.</param>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.BaseURI">
            <summary>
            Gets the base URI for the current node.
            Always returns string.Empty in the case of HtmlNavigator implementation.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.CurrentDocument">
            <summary>
            Gets the current HTML document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.CurrentNode">
            <summary>
            Gets the current HTML node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.HasAttributes">
            <summary>
            Gets a value indicating whether the current node has child nodes.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.HasChildren">
            <summary>
            Gets a value indicating whether the current node has child nodes.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.IsEmptyElement">
            <summary>
            Gets a value indicating whether the current node is an empty element.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.LocalName">
            <summary>
            Gets the name of the current HTML node without the namespace prefix.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.Name">
            <summary>
            Gets the qualified name of the current node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.NamespaceURI">
            <summary>
            Gets the namespace URI (as defined in the W3C Namespace Specification) of the current node.
            Always returns string.Empty in the case of HtmlNavigator implementation.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.NameTable">
            <summary>
            Gets the <see cref="T:System.Xml.XmlNameTable" /> associated with this implementation.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.NodeType">
            <summary>
            Gets the type of the current node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.Prefix">
            <summary>
            Gets the prefix associated with the current node.
            Always returns string.Empty in the case of HtmlNavigator implementation.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.Value">
            <summary>
            Gets the text value of the current node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlNodeNavigator.XmlLang">
            <summary>
            Gets the xml:lang scope for the current node.
            Always returns string.Empty in the case of HtmlNavigator implementation.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.Clone">
            <summary>
            Creates a new HtmlNavigator positioned at the same node as this HtmlNavigator.
            </summary>
            <returns>A new HtmlNavigator object positioned at the same node as the original HtmlNavigator.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.GetAttribute(System.String,System.String)">
            <summary>
            Gets the value of the HTML attribute with the specified LocalName and NamespaceURI.
            </summary>
            <param name="localName">The local name of the HTML attribute.</param>
            <param name="namespaceURI">The namespace URI of the attribute. Unsupported with the HtmlNavigator implementation.</param>
            <returns>The value of the specified HTML attribute. String.Empty or null if a matching attribute is not found or if the navigator is not positioned on an element node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.GetNamespace(System.String)">
            <summary>
            Returns the value of the namespace node corresponding to the specified local name.
            Always returns string.Empty for the HtmlNavigator implementation.
            </summary>
            <param name="name">The local name of the namespace node.</param>
            <returns>Always returns string.Empty for the HtmlNavigator implementation.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.IsSamePosition(System.Xml.XPath.XPathNavigator)">
            <summary>
            Determines whether the current HtmlNavigator is at the same position as the specified HtmlNavigator.
            </summary>
            <param name="other">The HtmlNavigator that you want to compare against.</param>
            <returns>true if the two navigators have the same position, otherwise, false.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveTo(System.Xml.XPath.XPathNavigator)">
            <summary>
            Moves to the same position as the specified HtmlNavigator.
            </summary>
            <param name="other">The HtmlNavigator positioned on the node that you want to move to.</param>
            <returns>true if successful, otherwise false. If false, the position of the navigator is unchanged.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToAttribute(System.String,System.String)">
            <summary>
            Moves to the HTML attribute with matching LocalName and NamespaceURI.
            </summary>
            <param name="localName">The local name of the HTML attribute.</param>
            <param name="namespaceURI">The namespace URI of the attribute. Unsupported with the HtmlNavigator implementation.</param>
            <returns>true if the HTML attribute is found, otherwise, false. If false, the position of the navigator does not change.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToFirst">
            <summary>
            Moves to the first sibling of the current node.
            </summary>
            <returns>true if the navigator is successful moving to the first sibling node, false if there is no first sibling or if the navigator is currently positioned on an attribute node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToFirstAttribute">
            <summary>
            Moves to the first HTML attribute.
            </summary>
            <returns>true if the navigator is successful moving to the first HTML attribute, otherwise, false.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToFirstChild">
            <summary>
            Moves to the first child of the current node.
            </summary>
            <returns>true if there is a first child node, otherwise false.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToFirstNamespace(System.Xml.XPath.XPathNamespaceScope)">
            <summary>
            Moves the XPathNavigator to the first namespace node of the current element.
            Always returns false for the HtmlNavigator implementation.
            </summary>
            <param name="scope">An XPathNamespaceScope value describing the namespace scope.</param>
            <returns>Always returns false for the HtmlNavigator implementation.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToId(System.String)">
            <summary>
            Moves to the node that has an attribute of type ID whose value matches the specified string.
            </summary>
            <param name="id">A string representing the ID value of the node to which you want to move. This argument does not need to be atomized.</param>
            <returns>true if the move was successful, otherwise false. If false, the position of the navigator is unchanged.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToNamespace(System.String)">
            <summary>
            Moves the XPathNavigator to the namespace node with the specified local name. 
            Always returns false for the HtmlNavigator implementation.
            </summary>
            <param name="name">The local name of the namespace node.</param>
            <returns>Always returns false for the HtmlNavigator implementation.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToNext">
            <summary>
            Moves to the next sibling of the current node.
            </summary>
            <returns>true if the navigator is successful moving to the next sibling node, false if there are no more siblings or if the navigator is currently positioned on an attribute node. If false, the position of the navigator is unchanged.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToNextAttribute">
            <summary>
            Moves to the next HTML attribute.
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToNextNamespace(System.Xml.XPath.XPathNamespaceScope)">
            <summary>
            Moves the XPathNavigator to the next namespace node.
            Always returns falsefor the HtmlNavigator implementation.
            </summary>
            <param name="scope">An XPathNamespaceScope value describing the namespace scope.</param>
            <returns>Always returns false for the HtmlNavigator implementation.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToParent">
            <summary>
            Moves to the parent of the current node.
            </summary>
            <returns>true if there is a parent node, otherwise false.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToPrevious">
            <summary>
            Moves to the previous sibling of the current node.
            </summary>
            <returns>true if the navigator is successful moving to the previous sibling node, false if there is no previous sibling or if the navigator is currently positioned on an attribute node.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlNodeNavigator.MoveToRoot">
            <summary>
            Moves to the root node to which the current node belongs.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlNodeType">
            <summary>
            Represents the type of a node.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlNodeType.Document">
            <summary>
            The root of a document.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlNodeType.Element">
            <summary>
            An HTML element.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlNodeType.Comment">
            <summary>
            An HTML comment.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlNodeType.Text">
            <summary>
            A text node is always the child of an element or a document node.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlParseError">
            <summary>
            Represents a parsing error found during document parsing.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlParseError.Code">
            <summary>
            Gets the type of error.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlParseError.Line">
            <summary>
            Gets the line number of this error in the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlParseError.LinePosition">
            <summary>
            Gets the column number of this error in the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlParseError.Reason">
            <summary>
            Gets a description for the error.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlParseError.SourceText">
            <summary>
            Gets the the full text of the line containing the error.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlParseError.StreamPosition">
            <summary>
            Gets the absolute stream position of this error in the document, relative to the start of the document.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlParseErrorCode">
            <summary>
            Represents the type of parsing error.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlParseErrorCode.TagNotClosed">
            <summary>
            A tag was not closed.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlParseErrorCode.TagNotOpened">
            <summary>
            A tag was not opened.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlParseErrorCode.CharsetMismatch">
            <summary>
            There is a charset mismatch between stream and declared (META) encoding.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlParseErrorCode.EndTagNotRequired">
            <summary>
            An end tag was not required.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlParseErrorCode.EndTagInvalidHere">
            <summary>
            An end tag is invalid at this position.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlTextNode">
            <summary>
            Represents an HTML text node.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlTextNode.InnerHtml">
            <summary>
            Gets or Sets the HTML between the start and end tags of the object. In the case of a text node, it is equals to OuterHtml.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlTextNode.OuterHtml">
            <summary>
            Gets or Sets the object and its content in HTML.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlTextNode.Text">
            <summary>
            Gets or Sets the text of the node.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlWeb">
            <summary>
            A utility class to get HTML document from HTTP.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlWeb.PostResponseHandler">
            <summary>
            Represents the method that will handle the PostResponse event.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlWeb.PreHandleDocumentHandler">
            <summary>
            Represents the method that will handle the PreHandleDocument event.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.HtmlWeb.PreRequestHandler">
            <summary>
            Represents the method that will handle the PreRequest event.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlWeb.PostResponse">
            <summary>
            Occurs after an HTTP request has been executed.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlWeb.PreHandleDocument">
            <summary>
            Occurs before an HTML document is handled.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.HtmlWeb.PreRequest">
            <summary>
            Occurs before an HTTP request is executed.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.AutoDetectEncoding">
            <summary>
            Gets or Sets a value indicating if document encoding must be automatically detected.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.OverrideEncoding">
            <summary>
            Gets or sets the Encoding used to override the response stream from any web request
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.CacheOnly">
            <summary>
            Gets or Sets a value indicating whether to get document only from the cache.
            If this is set to true and document is not found in the cache, nothing will be loaded.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.UsingCacheIfExists">
            <summary>
            Gets or Sets a value indicating whether to get document from the cache if exists, otherwise from the web
            A value indicating whether to get document from the cache if exists, otherwise from the web
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.CachePath">
            <summary>
            Gets or Sets the cache path. If null, no caching mechanism will be used.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.FromCache">
            <summary>
            Gets a value indicating if the last document was retrieved from the cache.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.RequestDuration">
            <summary>
            Gets the last request duration in milliseconds.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.ResponseUri">
            <summary>
            Gets the URI of the Internet resource that actually responded to the request.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.StatusCode">
            <summary>
            Gets the last request status.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.StreamBufferSize">
            <summary>
            Gets or Sets the size of the buffer used for memory operations.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.UseCookies">
            <summary>
            Gets or Sets a value indicating if cookies will be stored.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.CaptureRedirect">
            <summary>Gets or sets a value indicating whether redirect should be captured instead of the current location.</summary>
            <value>True if capture redirect, false if not.</value>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.UserAgent">
            <summary>
            Gets or Sets the User Agent HTTP 1.1 header sent on any webrequest
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.UsingCache">
            <summary>
            Gets or Sets a value indicating whether the caching mechanisms should be used or not.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.GetContentTypeForExtension(System.String,System.String)">
            <summary>
            Gets the MIME content type for a given path extension.
            </summary>
            <param name="extension">The input path extension.</param>
            <param name="def">The default content type to return if any error occurs.</param>
            <returns>The path extension's MIME content type.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.GetExtensionForContentType(System.String,System.String)">
            <summary>
            Gets the path extension for a given MIME content type.
            </summary>
            <param name="contentType">The input MIME content type.</param>
            <param name="def">The default path extension to return if any error occurs.</param>
            <returns>The MIME content type's path extension.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.CreateInstance(System.String,System.Type)">
            <summary>
            Creates an instance of the given type from the specified Internet resource.
            </summary>
            <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="type">The requested type.</param>
            <returns>An newly created instance.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Get(System.String,System.String)">
            <summary>
            Gets an HTML document from an Internet resource and saves it to the specified file.
            </summary>
            <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="path">The location of the file where you want to save the document.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Get(System.String,System.String,System.Net.WebProxy,System.Net.NetworkCredential)">
            <summary>
            Gets an HTML document from an Internet resource and saves it to the specified file. - Proxy aware
            </summary>
            <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="path">The location of the file where you want to save the document.</param>
            <param name="proxy" />
            <param name="credentials" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Get(System.String,System.String,System.String)">
            <summary>
            Gets an HTML document from an Internet resource and saves it to the specified file.
            </summary>
            <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="path">The location of the file where you want to save the document.</param>
            <param name="method">The HTTP method used to open the connection, such as GET, POST, PUT, or PROPFIND.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Get(System.String,System.String,System.Net.WebProxy,System.Net.NetworkCredential,System.String)">
            <summary>
            Gets an HTML document from an Internet resource and saves it to the specified file.  Understands Proxies
            </summary>
            <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="path">The location of the file where you want to save the document.</param>
            <param name="credentials" />
            <param name="method">The HTTP method used to open the connection, such as GET, POST, PUT, or PROPFIND.</param>
            <param name="proxy" />
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.GetCachePath(System.Uri)">
            <summary>
            Gets the cache file path for a specified url.
            </summary>
            <param name="uri">The url fo which to retrieve the cache path. May not be null.</param>
            <returns>The cache file path.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Load(System.String)">
            <summary>
            Gets an HTML document from an Internet resource.
            </summary>
            <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Load(System.Uri)">
            <summary>
            Gets an HTML document from an Internet resource.
            </summary>
            <param name="uri">The requested Uri, such as new Uri("http://Myserver/Mypath/Myfile.asp").</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Load(System.String,System.String,System.Int32,System.String,System.String)">
            <summary>
            Gets an HTML document from an Internet resource.
            </summary>
            <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="proxyHost">Host to use for Proxy</param>
            <param name="proxyPort">Port the Proxy is on</param>
            <param name="userId">User Id for Authentication</param>
            <param name="password">Password for Authentication</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Load(System.Uri,System.String,System.Int32,System.String,System.String)">
            <summary>
            Gets an HTML document from an Internet resource.
            </summary>
            <param name="uri">The requested Uri, such as new Uri("http://Myserver/Mypath/Myfile.asp").</param>
            <param name="proxyHost">Host to use for Proxy</param>
            <param name="proxyPort">Port the Proxy is on</param>
            <param name="userId">User Id for Authentication</param>
            <param name="password">Password for Authentication</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Load(System.String,System.String)">
            <summary>
            Loads an HTML document from an Internet resource.
            </summary>
            <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="method">The HTTP method used to open the connection, such as GET, POST, PUT, or PROPFIND.</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Load(System.Uri,System.String)">
            <summary>
            Loads an HTML document from an Internet resource.
            </summary>
            <param name="uri">The requested URL, such as new Uri("http://Myserver/Mypath/Myfile.asp").</param>
            <param name="method">The HTTP method used to open the connection, such as GET, POST, PUT, or PROPFIND.</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Load(System.String,System.String,System.Net.WebProxy,System.Net.NetworkCredential)">
            <summary>
            Loads an HTML document from an Internet resource.
            </summary>
            <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="method">The HTTP method used to open the connection, such as GET, POST, PUT, or PROPFIND.</param>
            <param name="proxy">Proxy to use with this request</param>
            <param name="credentials">Credentials to use when authenticating</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.Load(System.Uri,System.String,System.Net.WebProxy,System.Net.NetworkCredential)">
            <summary>
            Loads an HTML document from an Internet resource.
            </summary>
            <param name="uri">The requested Uri, such as new Uri("http://Myserver/Mypath/Myfile.asp").</param>
            <param name="method">The HTTP method used to open the connection, such as GET, POST, PUT, or PROPFIND.</param>
            <param name="proxy">Proxy to use with this request</param>
            <param name="credentials">Credentials to use when authenticating</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.LoadHtmlAsXml(System.String,System.Xml.XmlTextWriter)">
            <summary>
            Loads an HTML document from an Internet resource and saves it to the specified XmlTextWriter.
            </summary>
            <param name="htmlUrl">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="writer">The XmlTextWriter to which you want to save to.</param>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.BrowserTimeout">
            <summary>Gets or sets the web browser timeout.</summary>
        </member>
        <member name="P:HtmlAgilityPack.HtmlWeb.BrowserDelay">
            <summary>Gets or sets the web browser delay.</summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.LoadFromBrowser(System.String)">
            <summary>Loads HTML using a WebBrowser and Application.DoEvents.</summary>
            <exception cref="T:System.Exception">Thrown when an exception error condition occurs.</exception>
            <param name="url">The requested URL, such as "http://html-agility-pack.net/".</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.LoadFromBrowser(System.String,System.Func{System.String,System.Boolean})">
            <summary>Loads HTML using a WebBrowser and Application.DoEvents.</summary>
            <exception cref="T:System.Exception">Thrown when an exception error condition occurs.</exception>
            <param name="url">The requested URL, such as "http://html-agility-pack.net/".</param>
            <param name="isBrowserScriptCompleted">(Optional) Check if the browser script has all been run and completed.</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.LoadFromBrowser(System.String,System.Func{System.Object,System.Boolean})">
            <summary>Loads HTML using a WebBrowser and Application.DoEvents.</summary>
            <exception cref="T:System.Exception">Thrown when an exception error condition occurs.</exception>
            <param name="url">The requested URL, such as "http://html-agility-pack.net/".</param>
            <param name="isBrowserScriptCompleted">(Optional) Check if the browser script has all been run and completed.</param>
            <returns>A new HTML document.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.CreateInstance(System.String,System.String,System.Xml.Xsl.XsltArgumentList,System.Type)">
            <summary>
            Creates an instance of the given type from the specified Internet resource.
            </summary>
            <param name="htmlUrl">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="xsltUrl">The URL that specifies the XSLT stylesheet to load.</param>
            <param name="xsltArgs">An <see cref="T:System.Xml.Xsl.XsltArgumentList" /> containing the namespace-qualified arguments used as input to the transform.</param>
            <param name="type">The requested type.</param>
            <returns>An newly created instance.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.CreateInstance(System.String,System.String,System.Xml.Xsl.XsltArgumentList,System.Type,System.String)">
            <summary>
            Creates an instance of the given type from the specified Internet resource.
            </summary>
            <param name="htmlUrl">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="xsltUrl">The URL that specifies the XSLT stylesheet to load.</param>
            <param name="xsltArgs">An <see cref="T:System.Xml.Xsl.XsltArgumentList" /> containing the namespace-qualified arguments used as input to the transform.</param>
            <param name="type">The requested type.</param>
            <param name="xmlPath">A file path where the temporary XML before transformation will be saved. Mostly used for debugging purposes.</param>
            <returns>An newly created instance.</returns>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.LoadHtmlAsXml(System.String,System.String,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlTextWriter)">
            <summary>
            Loads an HTML document from an Internet resource and saves it to the specified XmlTextWriter, after an XSLT transformation.
            </summary>
            <param name="htmlUrl">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
            <param name="xsltUrl">The URL that specifies the XSLT stylesheet to load.</param>
            <param name="xsltArgs">An XsltArgumentList containing the namespace-qualified arguments used as input to the transform.</param>
            <param name="writer">The XmlTextWriter to which you want to save.</param>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWeb.LoadHtmlAsXml(System.String,System.String,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlTextWriter,System.String)">
            <summary>
            Loads an HTML document from an Internet resource and saves it to the specified XmlTextWriter, after an XSLT transformation.
            </summary>
            <param name="htmlUrl">The requested URL, such as "http://Myserver/Mypath/Myfile.asp". May not be null.</param>
            <param name="xsltUrl">The URL that specifies the XSLT stylesheet to load.</param>
            <param name="xsltArgs">An XsltArgumentList containing the namespace-qualified arguments used as input to the transform.</param>
            <param name="writer">The XmlTextWriter to which you want to save.</param>
            <param name="xmlPath">A file path where the temporary XML before transformation will be saved. Mostly used for debugging purposes.</param>
        </member>
        <member name="T:HtmlAgilityPack.PermissionHelper">
            <summary>
            Wraps getting AppDomain permissions
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.PermissionHelper.GetIsRegistryAvailable">
            <summary>
            Checks to see if Registry access is available to the caller
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.PermissionHelper.GetIsDnsAvailable">
            <summary>
            Checks to see if DNS information is available to the caller
            </summary>
            <returns />
        </member>
        <member name="T:HtmlAgilityPack.IPermissionHelper">
            <summary>
            An interface for getting permissions of the running application
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.IPermissionHelper.GetIsRegistryAvailable">
            <summary>
            Checks to see if Registry access is available to the caller
            </summary>
            <returns />
        </member>
        <member name="M:HtmlAgilityPack.IPermissionHelper.GetIsDnsAvailable">
            <summary>
            Checks to see if DNS information is available to the caller
            </summary>
            <returns />
        </member>
        <member name="T:HtmlAgilityPack.HtmlWebException">
            <summary>
            Represents an exception thrown by the HtmlWeb utility class.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.HtmlWebException.#ctor(System.String)">
            <summary>
            Creates an instance of the HtmlWebException.
            </summary>
            <param name="message">The exception's message.</param>
        </member>
        <member name="T:HtmlAgilityPack.MixedCodeDocument">
            <summary>
            Represents a document with mixed code and text. ASP, ASPX, JSP, are good example of such documents.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.MixedCodeDocument.TokenCodeEnd">
            <summary>
            Gets or sets the token representing code end.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.MixedCodeDocument.TokenCodeStart">
            <summary>
            Gets or sets the token representing code start.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.MixedCodeDocument.TokenDirective">
            <summary>
            Gets or sets the token representing code directive.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.MixedCodeDocument.TokenResponseWrite">
            <summary>
            Gets or sets the token representing response write directive.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.#ctor">
            <summary>
            Creates a mixed code document instance.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocument.Code">
            <summary>
            Gets the code represented by the mixed code document seen as a template.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocument.CodeFragments">
            <summary>
            Gets the list of code fragments in the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocument.Fragments">
            <summary>
            Gets the list of all fragments in the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocument.StreamEncoding">
            <summary>
            Gets the encoding of the stream used to read the document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocument.TextFragments">
            <summary>
            Gets the list of text fragments in the document.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.CreateCodeFragment">
            <summary>
            Create a code fragment instances.
            </summary>
            <returns>The newly created code fragment instance.</returns>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.CreateTextFragment">
            <summary>
            Create a text fragment instances.
            </summary>
            <returns>The newly created text fragment instance.</returns>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.IO.Stream)">
            <summary>
            Loads a mixed code document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.IO.Stream,System.Boolean)">
            <summary>
            Loads a mixed code document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Loads a mixed code document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The character encoding to use.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>
            Loads a mixed code document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Loads a mixed code document from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
            <param name="buffersize">The minimum buffer size.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.String)">
            <summary>
            Loads a mixed code document from a file.
            </summary>
            <param name="path">The complete file path to be read.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.String,System.Boolean)">
            <summary>
            Loads a mixed code document from a file.
            </summary>
            <param name="path">The complete file path to be read.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.String,System.Text.Encoding)">
            <summary>
            Loads a mixed code document from a file.
            </summary>
            <param name="path">The complete file path to be read.</param>
            <param name="encoding">The character encoding to use.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.String,System.Text.Encoding,System.Boolean)">
            <summary>
            Loads a mixed code document from a file.
            </summary>
            <param name="path">The complete file path to be read.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.String,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Loads a mixed code document from a file.
            </summary>
            <param name="path">The complete file path to be read.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
            <param name="buffersize">The minimum buffer size.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Load(System.IO.TextReader)">
            <summary>
            Loads the mixed code document from the specified TextReader.
            </summary>
            <param name="reader">The TextReader used to feed the HTML data into the document.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.LoadHtml(System.String)">
            <summary>
            Loads a mixed document from a text
            </summary>
            <param name="html">The text to load.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Save(System.IO.Stream)">
            <summary>
            Saves the mixed document to the specified stream.
            </summary>
            <param name="outStream">The stream to which you want to save.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Save(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Saves the mixed document to the specified stream.
            </summary>
            <param name="outStream">The stream to which you want to save.</param>
            <param name="encoding">The character encoding to use.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Save(System.String)">
            <summary>
            Saves the mixed document to the specified file.
            </summary>
            <param name="filename">The location of the file where you want to save the document.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Save(System.String,System.Text.Encoding)">
            <summary>
            Saves the mixed document to the specified file.
            </summary>
            <param name="filename">The location of the file where you want to save the document.</param>
            <param name="encoding">The character encoding to use.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Save(System.IO.StreamWriter)">
            <summary>
            Saves the mixed document to the specified StreamWriter.
            </summary>
            <param name="writer">The StreamWriter to which you want to save.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocument.Save(System.IO.TextWriter)">
            <summary>
            Saves the mixed document to the specified TextWriter.
            </summary>
            <param name="writer">The TextWriter to which you want to save.</param>
        </member>
        <member name="T:HtmlAgilityPack.MixedCodeDocumentCodeFragment">
            <summary>
            Represents a fragment of code in a mixed code document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentCodeFragment.Code">
            <summary>
            Gets the fragment code text.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.MixedCodeDocumentFragment">
            <summary>
            Represents a base class for fragments in a mixed code document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentFragment.FragmentText">
            <summary>
            Gets the fragement text.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentFragment.FragmentType">
            <summary>
            Gets the type of fragment.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentFragment.Line">
            <summary>
            Gets the line number of the fragment.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentFragment.LinePosition">
            <summary>
            Gets the line position (column) of the fragment.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentFragment.StreamPosition">
            <summary>
            Gets the fragment position in the document's stream.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.MixedCodeDocumentFragmentList">
            <summary>
            Represents a list of mixed code fragments.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentFragmentList.Doc">
            <summary>
             Gets the Document
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentFragmentList.Count">
            <summary>
            Gets the number of fragments contained in the list.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentFragmentList.Item(System.Int32)">
            <summary>
            Gets a fragment from the list using its index.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocumentFragmentList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator that can iterate through the fragment list.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocumentFragmentList.Append(HtmlAgilityPack.MixedCodeDocumentFragment)">
            <summary>
            Appends a fragment to the list of fragments.
            </summary>
            <param name="newFragment">The fragment to append. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocumentFragmentList.GetEnumerator">
            <summary>
            Gets an enumerator that can iterate through the fragment list.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocumentFragmentList.Prepend(HtmlAgilityPack.MixedCodeDocumentFragment)">
            <summary>
            Prepends a fragment to the list of fragments.
            </summary>
            <param name="newFragment">The fragment to append. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocumentFragmentList.Remove(HtmlAgilityPack.MixedCodeDocumentFragment)">
            <summary>
            Remove a fragment from the list of fragments. If this fragment was not in the list, an exception will be raised.
            </summary>
            <param name="fragment">The fragment to remove. May not be null.</param>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocumentFragmentList.RemoveAll">
            <summary>
            Remove all fragments from the list.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocumentFragmentList.RemoveAt(System.Int32)">
            <summary>
            Remove a fragment from the list of fragments, using its index in the list.
            </summary>
            <param name="index">The index of the fragment to remove.</param>
        </member>
        <member name="T:HtmlAgilityPack.MixedCodeDocumentFragmentList.MixedCodeDocumentFragmentEnumerator">
            <summary>
            Represents a fragment enumerator.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentFragmentList.MixedCodeDocumentFragmentEnumerator.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentFragmentList.MixedCodeDocumentFragmentEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the collection.
            </summary>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocumentFragmentList.MixedCodeDocumentFragmentEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:HtmlAgilityPack.MixedCodeDocumentFragmentList.MixedCodeDocumentFragmentEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.MixedCodeDocumentFragmentType">
            <summary>
            Represents the type of fragment in a mixed code document.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.MixedCodeDocumentFragmentType.Code">
            <summary>
            The fragment contains code.
            </summary>
        </member>
        <member name="F:HtmlAgilityPack.MixedCodeDocumentFragmentType.Text">
            <summary>
            The fragment contains text.
            </summary>
        </member>
        <member name="T:HtmlAgilityPack.MixedCodeDocumentTextFragment">
            <summary>
            Represents a fragment of text in a mixed code document.
            </summary>
        </member>
        <member name="P:HtmlAgilityPack.MixedCodeDocumentTextFragment.Text">
            <summary>
            Gets the fragment text.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Legend">
            <summary>
            Represents a legend of a chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.ChartObject">
            <summary>
            Base class for all chart classes.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.DocumentObject">
            <summary>
            Base class for all chart classes.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObject.#ctor">
            <summary>
            Initializes a new instance of the DocumentObject class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObject.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the DocumentObject class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObject.Clone">
            <summary>
            Creates a deep copy of the DocumentObject. The parent of the new object is null.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObject.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DocumentObject.parent">
            <summary />
        </member>
        <member name="P:PdfSharp.Charting.DocumentObject.Parent">
            <summary>
            Gets the parent object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.ChartObject.#ctor">
            <summary>
            Initializes a new instance of the ChartObject class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.ChartObject.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the ChartObject class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Legend.#ctor">
            <summary>
            Initializes a new instance of the Legend class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Legend.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the Legend class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Legend.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Legend.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Legend.LineFormat">
            <summary>
            Gets the line format of the legend's border.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Legend.Font">
            <summary>
            Gets the font of the legend.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Legend.Docking">
            <summary>
            Gets or sets the docking type.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Font">
            <summary>
            Font represents the formatting of characters in a paragraph.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Font.#ctor">
            <summary>
            Initializes a new instance of the Font class that can be used as a template.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Font.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the Font class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Font.#ctor(System.String,PdfSharp.Drawing.XUnit)">
            <summary>
            Initializes a new instance of the Font class with the specified name and size.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Font.Clone">
            <summary>
            Creates a copy of the Font.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Font.Name">
            <summary>
            Gets or sets the name of the font.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Font.Size">
            <summary>
            Gets or sets the size of the font.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Font.Bold">
            <summary>
            Gets or sets the bold property.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Font.Italic">
            <summary>
            Gets or sets the italic property.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Font.Underline">
            <summary>
            Gets or sets the underline property.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Font.Color">
            <summary>
            Gets or sets the color property.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Font.Superscript">
            <summary>
            Gets or sets the superscript property.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Font.Subscript">
            <summary>
            Gets or sets the subscript property.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.FontProperties">
            <summary>
            Specifies the properties for the font.
            FOR INTERNAL USE ONLY.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Axis">
            <summary>
            This class represents an axis in a chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Axis.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the Axis class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Axis.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Axis.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.Title">
            <summary>
            Gets the title of the axis.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.MinimumScale">
            <summary>
            Gets or sets the minimum value of the axis.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.MaximumScale">
            <summary>
            Gets or sets the maximum value of the axis.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.MajorTick">
            <summary>
            Gets or sets the interval of the primary tick.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.MinorTick">
            <summary>
            Gets or sets the interval of the secondary tick.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.MajorTickMark">
            <summary>
            Gets or sets the type of the primary tick mark.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.MinorTickMark">
            <summary>
            Gets or sets the type of the secondary tick mark.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.TickLabels">
            <summary>
            Gets the label of the primary tick.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.LineFormat">
            <summary>
            Gets the format of the axis line.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.MajorGridlines">
            <summary>
            Gets the primary gridline object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.MinorGridlines">
            <summary>
            Gets the secondary gridline object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.HasMajorGridlines">
            <summary>
            Gets or sets, whether the axis has a primary gridline object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Axis.HasMinorGridlines">
            <summary>
            Gets or sets, whether the axis has a secondary gridline object.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.BarStackedPlotAreaRenderer">
            <summary>
            Represents a plot area renderer of stacked bars, i. e. all bars are drawn one on another.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.BarPlotAreaRenderer">
            <summary>
            Represents a plot area renderer for bars.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PlotAreaRenderer">
            <summary>
            Base class for all plot area renderers.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.Renderer">
            <summary>
            Base class of all renderers.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.Renderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the Renderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.Renderer.Init">
            <summary>
            Derived renderer should return an initialized and renderer specific rendererInfo,
            e. g. XAxisRenderer returns an new instance of AxisRendererInfo class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.Renderer.Format">
            <summary>
            Layouts and calculates the space used by the renderer's drawing item.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.Renderer.Draw">
            <summary>
            Draws the item.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.Renderer.rendererParms">
            <summary>
            Holds all necessary rendering information.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.PlotAreaRenderer.DefaultLineWidth">
            <summary>
            Represents the default line width for the plot area's border.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the PlotAreaRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PlotAreaRenderer.Init">
            <summary>
            Returns an initialized PlotAreaRendererInfo.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PlotAreaRenderer.InitLineFormat(PdfSharp.Charting.Renderers.PlotAreaRendererInfo)">
            <summary>
            Initializes the plot area's line format common to all derived plot area renderers.
            If line format is given all uninitialized values will be set.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PlotAreaRenderer.InitFillFormat(PdfSharp.Charting.Renderers.PlotAreaRendererInfo)">
            <summary>
            Initializes the plot area's fill format common to all derived plot area renderers.
            If fill format is given all uninitialized values will be set.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarPlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the BarPlotAreaRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarPlotAreaRenderer.Format">
            <summary>
            Layouts and calculates the space for each bar.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarPlotAreaRenderer.Draw">
            <summary>
            Draws the content of the bar plot area.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarPlotAreaRenderer.CalcBars">
            <summary>
            Calculates the position, width and height of each bar of all series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarPlotAreaRenderer.IsDataInside(System.Double,System.Double,System.Double)">
            <summary>
            If yValue is within the range from yMin to yMax returns true, otherwise false.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarStackedPlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the BarStackedPlotAreaRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarStackedPlotAreaRenderer.CalcBars">
            <summary>
            Calculates the position, width and height of each bar of all series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarStackedPlotAreaRenderer.IsDataInside(System.Double,System.Double,System.Double)">
            <summary>
            If yValue is within the range from yMin to yMax returns true, otherwise false.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.XSeriesElements">
            <summary>
            Represents the collection of the value in an XSeries.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.DocumentObjectCollection">
            <summary>
            Base class of all collections.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.#ctor">
            <summary>
            Initializes a new instance of the DocumentObjectCollection class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the DocumentObjectCollection class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the ArrayList or a portion of it to a one-dimensional array.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.Clear">
            <summary>
            Removes all elements from the collection.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.InsertObject(System.Int32,PdfSharp.Charting.DocumentObject)">
            <summary>
            Inserts an element into the collection at the specified position.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.IndexOf(PdfSharp.Charting.DocumentObject)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.RemoveObjectAt(System.Int32)">
            <summary>
            Removes the element at the specified index.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.Add(PdfSharp.Charting.DocumentObject)">
            <summary>
            Adds the specified document object to the collection.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DocumentObjectCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:PdfSharp.Charting.DocumentObjectCollection.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.DocumentObjectCollection.Count">
            <summary>
            Gets the number of elements actually contained in the collection.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.DocumentObjectCollection.First">
            <summary>
            Gets the first value in the collection, if there is any, otherwise null.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.DocumentObjectCollection.LastObject">
            <summary>
            Gets the last element or null, if no such element exists.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeriesElements.#ctor">
            <summary>
            Initializes a new instance of the XSeriesElements class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeriesElements.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeriesElements.AddBlank">
            <summary>
            Adds a blank to the XSeries.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeriesElements.Add(System.String)">
            <summary>
            Adds a value to the XSeries.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeriesElements.Add(System.String[])">
            <summary>
            Adds an array of values to the XSeries.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PieClosedPlotAreaRenderer">
            <summary>
            Represents a closed pie plot area renderer.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PiePlotAreaRenderer">
            <summary>
            Represents the base for all pie plot area renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PiePlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the PiePlotAreaRenderer class
            with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PiePlotAreaRenderer.Format">
            <summary>
            Layouts and calculates the space used by the pie plot area.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PiePlotAreaRenderer.Draw">
            <summary>
            Draws the content of the pie plot area.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PiePlotAreaRenderer.CalcSectors">
            <summary>
            Calculates the specific positions for each sector.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieClosedPlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the PiePlotAreaRenderer class
            with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieClosedPlotAreaRenderer.CalcSectors">
            <summary>
            Calculate angles for each sector.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.TickLabels">
            <summary>
            Represents the format of the label of each value on the axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.TickLabels.#ctor">
            <summary>
            Initializes a new instance of the TickLabels class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.TickLabels.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the TickLabels class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.TickLabels.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.TickLabels.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.TickLabels.Format">
            <summary>
            Gets or sets the label's number format.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.TickLabels.Font">
            <summary>
            Gets the font of the label.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Underline">
            <summary>
            Specifies the underline type for the font.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Underline.None">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.Underline.Single">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.Underline.Words">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.Underline.Dotted">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.Underline.Dash">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.Underline.DotDash">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.Underline.DotDotDash">
            <summary />
        </member>
        <member name="T:PdfSharp.Charting.Renderers.XAxisRenderer">
            <summary>
            Represents the base class for all X axis renderer.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.AxisRenderer">
            <summary>
            Represents the base for all specialized axis renderer. Initialization common too all
            axis renderer should come here.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.AxisRenderer.DefaultLineWidth">
            <summary>
            Default width for a variety of lines.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.AxisRenderer.DefaultGridLineWidth">
            <summary>
            Default width for a gridlines.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.AxisRenderer.DefaultMajorTickMarkLineWidth">
            <summary>
            Default width for major tick marks.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.AxisRenderer.DefaultMinorTickMarkLineWidth">
            <summary>
            Default width for minor tick marks.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.AxisRenderer.DefaultMajorTickMarkWidth">
            <summary>
            Default width of major tick marks.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.AxisRenderer.DefaultMinorTickMarkWidth">
            <summary>
            Default width of minor tick marks.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.AxisRenderer.SpaceBetweenLabelAndTickmark">
            <summary>
            Default width of space between label and tick mark.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AxisRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the AxisRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AxisRenderer.InitAxisTitle(PdfSharp.Charting.Renderers.AxisRendererInfo,PdfSharp.Drawing.XFont)">
            <summary>
            Initializes the axis title of the rendererInfo. All missing font attributes will be taken
            from the specified defaultFont.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AxisRenderer.InitTickLabels(PdfSharp.Charting.Renderers.AxisRendererInfo,PdfSharp.Drawing.XFont)">
            <summary>
            Initializes the tick labels of the rendererInfo. All missing font attributes will be taken
            from the specified defaultFont.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AxisRenderer.InitAxisLineFormat(PdfSharp.Charting.Renderers.AxisRendererInfo)">
            <summary>
            Initializes the line format of the rendererInfo.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AxisRenderer.InitGridlines(PdfSharp.Charting.Renderers.AxisRendererInfo)">
            <summary>
            Initializes the gridlines of the rendererInfo.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.XAxisRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the XAxisRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.XAxisRenderer.GetDefaultTickLabelsFormat">
            <summary>
            Returns the default tick labels format string.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.RendererParameters">
            <summary>
            Represents the necessary data for chart rendering.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.RendererParameters.#ctor">
            <summary>
            Initializes a new instance of the RendererParameters class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.RendererParameters.#ctor(PdfSharp.Drawing.XGraphics,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the RendererParameters class with the specified graphics and
            coordinates.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.RendererParameters.#ctor(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XRect)">
            <summary>
            Initializes a new instance of the RendererParameters class with the specified graphics and
            rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.RendererParameters.Graphics">
            <summary>
            Gets or sets the graphics object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.RendererParameters.DrawingItem">
            <summary>
            Gets or sets the item to draw.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.RendererParameters.Box">
            <summary>
            Gets or sets the rectangle for the drawing item.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.RendererParameters.RendererInfo">
            <summary>
            Gets or sets the RendererInfo.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.MarkerRenderer">
            <summary>
            Represents a renderer for markers in line charts and legends.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.MarkerRenderer.Draw(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XPoint,PdfSharp.Charting.Renderers.MarkerRendererInfo)">
            <summary>
            Draws the marker given through rendererInfo at the specified position. Position specifies
            the center of the marker.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.TickMarkType">
            <summary>
            Determines the position where the Tickmarks will be rendered.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.TickMarkType.None">
            <summary>
            Tickmarks are not rendered.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.TickMarkType.Inside">
            <summary>
            Tickmarks are rendered inside the plot area.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.TickMarkType.Outside">
            <summary>
            Tickmarks are rendered outside the plot area.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.TickMarkType.Cross">
            <summary>
            Tickmarks are rendered inside and outside the plot area.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.VerticalYAxisRenderer">
            <summary>
            Represents a Y axis renderer used for charts of type Column2D or Line.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.YAxisRenderer">
            <summary>
            Represents the base class for all Y axis renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.YAxisRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the YAxisRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.YAxisRenderer.FineTuneYAxis(PdfSharp.Charting.Renderers.AxisRendererInfo,System.Double,System.Double)">
            <summary>
            Calculates optimal minimum/maximum scale and minor/major tick based on yMin and yMax.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.YAxisRenderer.GetDefaultTickLabelsFormat">
            <summary>
            Returns the default tick labels format string.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalYAxisRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the VerticalYAxisRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalYAxisRenderer.Init">
            <summary>
            Returns a initialized rendererInfo based on the Y axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalYAxisRenderer.Format">
            <summary>
            Calculates the space used for the Y axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalYAxisRenderer.Draw">
            <summary>
            Draws the vertical Y axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalYAxisRenderer.InitScale(PdfSharp.Charting.Renderers.AxisRendererInfo)">
            <summary>
            Calculates all values necessary for scaling the axis like minimum/maximum scale or
            minor/major tick.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalYAxisRenderer.GetTickMarkPos(PdfSharp.Charting.Renderers.AxisRendererInfo,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Gets the top and bottom position of the major and minor tick marks depending on the
            tick mark type.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalYAxisRenderer.CalcYAxis(System.Double@,System.Double@)">
            <summary>
            Determines the smallest and the largest number from all series of the chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.AreaPlotAreaRenderer">
            <summary>
            Represents a plot area renderer of areas.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnLikePlotAreaRenderer">
            <summary>
            Base class for all plot area renderers.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnLikePlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the ColumnLikePlotAreaRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnLikePlotAreaRenderer.Format">
            <summary>
            Layouts and calculates the space for column like plot areas.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AreaPlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the AreaPlotAreaRenderer class
            with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AreaPlotAreaRenderer.Draw">
            <summary>
            Draws the content of the area plot area.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.RendererInfo">
            <summary>
            Represents the base class of all renderer infos.
            Renderer infos are used to hold all necessary information and time consuming calculations
            between rendering cycles.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.AreaRendererInfo">
            <summary>
            Base class for all renderer infos which defines an area.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.AreaRendererInfo.X">
            <summary>
            Gets or sets the x coordinate of this rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.AreaRendererInfo.Y">
            <summary>
            Gets or sets the y coordinate of this rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.AreaRendererInfo.Width">
            <summary>
            Gets or sets the width of this rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.AreaRendererInfo.Height">
            <summary>
            Gets or sets the height of this rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.AreaRendererInfo.Size">
            <summary>
            Gets the area's size.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.AreaRendererInfo.Rect">
            <summary>
            Gets the area's rectangle.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ChartRendererInfo">
            <summary>
            A ChartRendererInfo stores information of all main parts of a chart like axis renderer info or
            plotarea renderer info.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.ChartRendererInfo.DefaultFont">
            <summary>
            Gets the chart's default font for rendering.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.ChartRendererInfo.DefaultDataLabelFont">
            <summary>
            Gets the chart's default font for rendering data labels.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.CombinationRendererInfo">
            <summary>
            A CombinationRendererInfo stores information for rendering combination of charts.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PointRendererInfo">
            <summary>
            PointRendererInfo is used to render one single data point which is part of a data series.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.SectorRendererInfo">
            <summary>
            Represents one sector of a series used by a pie chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnRendererInfo">
            <summary>
            Represents one data point of a series and the corresponding rectangle.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.DataLabelEntryRendererInfo">
            <summary>
            Stores rendering specific information for one data label entry.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.DataLabelRendererInfo">
            <summary>
            Stores data label specific rendering information.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.SeriesRendererInfo">
            <summary>
            SeriesRendererInfo holds all data series specific rendering information.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.SeriesRendererInfo.SumOfPoints">
            <summary>
            Gets the sum of all points in PointRendererInfo.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.MarkerRendererInfo">
            <summary>
            Represents a description of a marker for a line chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.AxisRendererInfo">
            <summary>
            An AxisRendererInfo holds all axis specific rendering information.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.AxisRendererInfo.X">
            <summary>
            Sets the x coordinate of the inner rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.AxisRendererInfo.Y">
            <summary>
            Sets the y coordinate of the inner rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.AxisRendererInfo.Height">
            <summary>
            Sets the height of the inner rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Renderers.AxisRendererInfo.Width">
            <summary>
            Sets the width of the inner rectangle.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.LegendEntryRendererInfo">
            <summary>
            Represents one description of a legend entry.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendEntryRendererInfo.MarkerSize">
            <summary>
            Size for the marker only.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendEntryRendererInfo.MarkerArea">
            <summary>
            Width for marker area. Extra spacing for line charts are considered.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendEntryRendererInfo.TextSize">
            <summary>
            Size for text area.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.LegendRendererInfo">
            <summary>
            Stores legend specific rendering information.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PlotAreaRendererInfo">
            <summary>
            Stores rendering information common to all plot area renderers.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.PlotAreaRendererInfo.matrix">
            <summary>
            Saves the plot area's matrix.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PlotAreaBorderRenderer">
            <summary>
            Represents the border renderer for plot areas.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PlotAreaBorderRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the PlotAreaBorderRenderer class with the specified
            renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PlotAreaBorderRenderer.Draw">
            <summary>
            Draws the border around the plot area.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PieLegendRenderer">
            <summary>
            Represents the legend renderer specific to pie charts.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.LegendRenderer">
            <summary>
            Represents the legend renderer for all chart types.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendRenderer.LeftPadding">
            <summary>
            Used to insert a padding on the left.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendRenderer.RightPadding">
            <summary>
            Used to insert a padding on the right.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendRenderer.TopPadding">
            <summary>
            Used to insert a padding at the top.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendRenderer.BottomPadding">
            <summary>
            Used to insert a padding at the bottom.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendRenderer.EntrySpacing">
            <summary>
            Used to insert a padding between entries.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendRenderer.DefaultLineWidth">
            <summary>
            Default line width used for the legend's border.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LegendRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the LegendRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LegendRenderer.Format">
            <summary>
            Layouts and calculates the space used by the legend.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LegendRenderer.Draw">
            <summary>
            Draws the legend.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieLegendRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the PieLegendRenderer class with the specified renderer
            parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieLegendRenderer.Init">
            <summary>
            Initializes the legend's renderer info. Each data point will be represented through
            a legend entry renderer info.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.LinePlotAreaRenderer">
            <summary>
            Renders the plot area used by line charts. 
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LinePlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the LinePlotAreaRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LinePlotAreaRenderer.Draw">
            <summary>
            Draws the content of the line plot area.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LinePlotAreaRenderer.DrawMarker(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XPoint[],PdfSharp.Charting.Renderers.SeriesRendererInfo)">
            <summary>
            Draws all markers given in rendererInfo at the positions specified by points.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.LineChartRenderer">
            <summary>
            Represents a line chart renderer.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnLikeChartRenderer">
            <summary>
            Represents column like chart renderer.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ChartRenderer">
            <summary>
            Represents the base class for all chart renderers.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.ChartRenderer.LegendSpacing">
            <summary>
            Used to separate the legend from the plot area.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ChartRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the ChartRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ChartRenderer.LayoutLegend">
            <summary>
            Calculates the space used by the legend and returns the remaining space available for the
            other parts of the chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.ChartRenderer.DefaultSeriesLineWidth">
            <summary>
            Represents the default width for all series lines, like borders in column/bar charts.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnLikeChartRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the ColumnLikeChartRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnLikeChartRenderer.CalcLayout">
            <summary>
            Calculates the chart layout.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineChartRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the LineChartRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineChartRenderer.Init">
            <summary>
            Returns an initialized and renderer specific rendererInfo.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineChartRenderer.Format">
            <summary>
            Layouts and calculates the space used by the line chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineChartRenderer.Draw">
            <summary>
            Draws the line chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineChartRenderer.InitSeriesRendererInfo">
            <summary>
            Initializes all necessary data to draw a series for a line chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineChartRenderer.InitSeries">
            <summary>
            Initializes all necessary data to draw a series for a line chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.LegendEntryRenderer">
            <summary>
            Represents the renderer for a legend entry.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendEntryRenderer.MarkerWidth">
            <summary>
            Absolute width for markers (including line) in point.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendEntryRenderer.MaxLegendMarkerWidth">
            <summary>
            Maximum legend marker width in point.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendEntryRenderer.MaxLegendMarkerHeight">
            <summary>
            Maximum legend marker height in point.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LegendEntryRenderer.SpacingBetweenMarkerAndText">
            <summary>
            Insert spacing between marker and text in point.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LegendEntryRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the LegendEntryRenderer class with the specified renderer
            parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LegendEntryRenderer.Format">
            <summary>
            Calculates the space used by the legend entry.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LegendEntryRenderer.Draw">
            <summary>
            Draws one legend entry.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnClusteredPlotAreaRenderer">
            <summary>
            Represents a plot area renderer of clustered columns, i. e. all columns are drawn side by side.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnPlotAreaRenderer">
            <summary>
            Represents a plot area renderer of clustered columns, i. e. all columns are drawn side by side.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnPlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the ColumnPlotAreaRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnPlotAreaRenderer.Format">
            <summary>
            Layouts and calculates the space for each column.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnPlotAreaRenderer.Draw">
            <summary>
            Draws the content of the column plot area.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnPlotAreaRenderer.CalcColumns">
            <summary>
            Calculates the position, width and height of each column of all series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnPlotAreaRenderer.IsDataInside(System.Double,System.Double,System.Double)">
            <summary>
            If yValue is within the range from yMin to yMax returns true, otherwise false.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnClusteredPlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the ColumnClusteredPlotAreaRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnClusteredPlotAreaRenderer.CalcColumns">
            <summary>
            Calculates the position, width and height of each column of all series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnClusteredPlotAreaRenderer.IsDataInside(System.Double,System.Double,System.Double)">
            <summary>
            If yValue is within the range from yMin to yMax returns true, otherwise false.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.BarClusteredLegendRenderer">
            <summary>
            Represents the legend renderer specific to bar charts.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnLikeLegendRenderer">
            <summary>
            Represents the legend renderer specific to charts like column, line, or bar.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnLikeLegendRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the ColumnLikeLegendRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnLikeLegendRenderer.Init">
            <summary>
            Initializes the legend's renderer info. Each data series will be represented through
            a legend entry renderer info.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarClusteredLegendRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the BarClusteredLegendRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarClusteredLegendRenderer.Draw">
            <summary>
            Draws the legend.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.BarChartRenderer">
            <summary>
            Represents a bar chart renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarChartRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the BarChartRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarChartRenderer.Init">
            <summary>
            Returns an initialized and renderer specific rendererInfo.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarChartRenderer.Format">
            <summary>
            Layouts and calculates the space used by the column chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarChartRenderer.Draw">
            <summary>
            Draws the column chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarChartRenderer.GetPlotAreaRenderer">
            <summary>
            Returns the specific plot area renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarChartRenderer.GetLegendRenderer">
            <summary>
            Returns the specific legend renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarChartRenderer.GetYAxisRenderer">
            <summary>
            Returns the specific plot area renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarChartRenderer.InitSeriesRendererInfo">
            <summary>
            Initializes all necessary data to draw all series for a column chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarChartRenderer.InitSeries">
            <summary>
            Initializes all necessary data to draw all series for a column chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.XValues">
            <summary>
            Represents the collection of values on the X-Axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XValues.#ctor">
            <summary>
            Initializes a new instance of the XValues class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XValues.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the XValues class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XValues.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XValues.AddXSeries">
            <summary>
            Adds a new XSeries to the collection.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.XValues.Item(System.Int32)">
            <summary>
            Gets an XSeries by its index.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.XSeries">
            <summary>
            Represents a series of data on the X-Axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeries.#ctor">
            <summary>
            Initializes a new instance of the XSeries class.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.XSeries.xSeriesElements">
            <summary>
            The actual value container of the XSeries.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeries.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeries.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeries.AddBlank">
            <summary>
            Adds a blank to the XSeries.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeries.Add(System.String)">
            <summary>
            Adds a value to the XSeries.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeries.Add(System.String[])">
            <summary>
            Adds an array of values to the XSeries.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XSeries.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns />
        </member>
        <member name="P:PdfSharp.Charting.XSeries.Item(System.Int32)">
            <summary>
            Gets the xvalue at the specified index.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.XSeries.Count">
            <summary>
            Gets the number of xvalues actually contained in the xseries.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.SeriesCollection">
            <summary>
            The collection of data series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.SeriesCollection.#ctor">
            <summary>
            Initializes a new instance of the SeriesCollection class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.SeriesCollection.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the SeriesCollection class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.SeriesCollection.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.SeriesCollection.AddSeries">
            <summary>
            Adds a new series to the collection.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.SeriesCollection.Item(System.Int32)">
            <summary>
            Gets a series by it's index.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Gridlines">
            <summary>
            Represents the gridlines on the axes.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Gridlines.#ctor">
            <summary>
            Initializes a new instance of the Gridlines class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Gridlines.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the Gridlines class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Gridlines.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Gridlines.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Gridlines.LineFormat">
            <summary>
            Gets the line format of the grid.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.CombinationChartRenderer">
            <summary>
            Represents a renderer for combinations of charts.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.CombinationChartRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the CombinationChartRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.CombinationChartRenderer.Init">
            <summary>
            Returns an initialized and renderer specific rendererInfo.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.CombinationChartRenderer.Format">
            <summary>
            Layouts and calculates the space used by the combination chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.CombinationChartRenderer.Draw">
            <summary>
            Draws the column chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.CombinationChartRenderer.InitSeriesRendererInfo">
            <summary>
            Initializes all necessary data to draw series for a combination chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.CombinationChartRenderer.DistributeSeries">
            <summary>
            Sort all series renderer info dependent on their chart type.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.AreaChartRenderer">
            <summary>
            Represents an area chart renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AreaChartRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the AreaChartRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AreaChartRenderer.Init">
            <summary>
            Returns an initialized and renderer specific rendererInfo.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AreaChartRenderer.Format">
            <summary>
            Layouts and calculates the space used by the line chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AreaChartRenderer.Draw">
            <summary>
            Draws the column chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AreaChartRenderer.InitSeriesRendererInfo">
            <summary>
            Initializes all necessary data to draw a series for a area chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AreaChartRenderer.InitSeries">
            <summary>
            Initializes all necessary data to draw a series for a area chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.XValue">
            <summary>
            Represents the actual value on the XSeries.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XValue.#ctor">
            <summary>
            Initializes a new instance of the XValue class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XValue.#ctor(System.String)">
            <summary>
            Initializes a new instance of the XValue class with the specified value.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.XValue.Value">
            <summary>
            The actual value of the XValue.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.XValue.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Series">
            <summary>
            Represents a series of data on the chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Series.#ctor">
            <summary>
            Initializes a new instance of the Series class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Series.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Series.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Series.AddBlank">
            <summary>
            Adds a blank to the series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Series.Add(System.Double)">
            <summary>
            Adds a real value to the series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Series.Add(System.Double[])">
            <summary>
            Adds an array of real values to the series.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.Elements">
            <summary>
            The actual value container of the series.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.Name">
            <summary>
            Gets or sets the name of the series which will be used in the legend.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.LineFormat">
            <summary>
            Gets the line format of the border of each data.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.FillFormat">
            <summary>
            Gets the background filling of the data.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.MarkerSize">
            <summary>
            Gets or sets the size of the marker in a line chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.MarkerStyle">
            <summary>
            Gets or sets the style of the marker in a line chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.MarkerForegroundColor">
            <summary>
            Gets or sets the foreground color of the marker in a line chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.MarkerBackgroundColor">
            <summary>
            Gets or sets the background color of the marker in a line chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.ChartType">
            <summary>
            Gets or sets the chart type of the series if it's intended to be different than the
            global chart type.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.DataLabel">
            <summary>
            Gets the DataLabel of the series.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.HasDataLabel">
            <summary>
            Gets or sets whether the series has a DataLabel.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Series.Count">
            <summary>
            Gets the element count of the series.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.PlotArea">
            <summary>
            Represents the area where the actual chart is drawn.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.PlotArea.#ctor">
            <summary>
            Initializes a new instance of the PlotArea class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.PlotArea.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the PlotArea class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.PlotArea.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.PlotArea.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.PlotArea.LineFormat">
            <summary>
            Gets the line format of the plot area's border.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.PlotArea.FillFormat">
            <summary>
            Gets the background filling of the plot area.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.PlotArea.LeftPadding">
            <summary>
            Gets or sets the left padding of the area.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.PlotArea.RightPadding">
            <summary>
            Gets or sets the right padding of the area.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.PlotArea.TopPadding">
            <summary>
            Gets or sets the top padding of the area.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.PlotArea.BottomPadding">
            <summary>
            Gets or sets the bottom padding of the area.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.AxisTitle">
            <summary>
            Represents the title of an axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.AxisTitle.#ctor">
            <summary>
            Initializes a new instance of the AxisTitle class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.AxisTitle.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the AxisTitle class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.AxisTitle.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.AxisTitle.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.AxisTitle.Caption">
            <summary>
            Gets or sets the caption of the title.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.AxisTitle.Font">
            <summary>
            Gets the font of the title.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.AxisTitle.Orientation">
            <summary>
            Gets or sets the orientation of the caption.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.AxisTitle.Alignment">
            <summary>
            Gets or sets the horizontal alignment of the caption.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.AxisTitle.VerticalAlignment">
            <summary>
            Gets or sets the vertical alignment of the caption.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PieChartRenderer">
            <summary>
            Represents a pie chart renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieChartRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the PieChartRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieChartRenderer.Init">
            <summary>
            Returns an initialized and renderer specific rendererInfo.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieChartRenderer.Format">
            <summary>
            Layouts and calculates the space used by the pie chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieChartRenderer.Draw">
            <summary>
            Draws the pie chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieChartRenderer.GetPlotAreaRenderer">
            <summary>
            Returns the specific plot area renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieChartRenderer.InitSeries(PdfSharp.Charting.Renderers.ChartRendererInfo)">
            <summary>
            Initializes all necessary data to draw a series for a pie chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.HorizontalXAxisRenderer">
            <summary>
            Represents an axis renderer used for charts of type Column2D or Line.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalXAxisRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the HorizontalXAxisRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalXAxisRenderer.Init">
            <summary>
            Returns an initialized rendererInfo based on the X axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalXAxisRenderer.Format">
            <summary>
            Calculates the space used for the X axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalXAxisRenderer.Draw">
            <summary>
            Draws the horizontal X axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalXAxisRenderer.CalculateXAxisValues(PdfSharp.Charting.Renderers.AxisRendererInfo)">
            <summary>
            Calculates the X axis describing values like minimum/maximum scale, major/minor tick and
            major/minor tick mark width.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalXAxisRenderer.InitXValues(PdfSharp.Charting.Renderers.AxisRendererInfo)">
            <summary>
            Initializes the rendererInfo's xvalues. If not set by the user xvalues will be simply numbers
            from minimum scale + 1 to maximum scale.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalXAxisRenderer.GetTickMarkPos(PdfSharp.Charting.Renderers.AxisRendererInfo,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Calculates the starting and ending y position for the minor and major tick marks.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.MarkerStyle">
            <summary>
            Symbols of a data point in a line chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.MarkerStyle.None">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.MarkerStyle.Circle">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.MarkerStyle.Dash">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.MarkerStyle.Diamond">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.MarkerStyle.Dot">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.MarkerStyle.Plus">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.MarkerStyle.Square">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.MarkerStyle.Star">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.MarkerStyle.Triangle">
            <summary />
        </member>
        <member name="F:PdfSharp.Charting.MarkerStyle.X">
            <summary />
        </member>
        <member name="T:PdfSharp.Charting.DockingType">
            <summary>
            Specifies the legend's position inside the chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DockingType.Top">
            <summary>
            Above the chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DockingType.Bottom">
            <summary>
            Below the chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DockingType.Left">
            <summary>
            Left from the chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DockingType.Right">
            <summary>
            Right from the chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.FillFormat">
            <summary>
            Defines the background filling of the shape.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.FillFormat.#ctor">
            <summary>
            Initializes a new instance of the FillFormat class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.FillFormat.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the FillFormat class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.FillFormat.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.FillFormat.Color">
            <summary>
            Gets or sets the color of the filling.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.FillFormat.Visible">
            <summary>
            Gets or sets a value indicating whether the background color should be visible.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.LineFormatRenderer">
            <summary>
            Represents a renderer specialized to draw lines in various styles, colors and widths.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineFormatRenderer.#ctor(PdfSharp.Drawing.XGraphics,PdfSharp.Charting.LineFormat,System.Double)">
            <summary>
            Initializes a new instance of the LineFormatRenderer class with the specified graphics, line format
            and default width.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineFormatRenderer.#ctor(PdfSharp.Drawing.XGraphics,PdfSharp.Charting.LineFormat)">
            <summary>
            Initializes a new instance of the LineFormatRenderer class with the specified graphics and
            line format.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineFormatRenderer.#ctor(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XPen)">
            <summary>
            Initializes a new instance of the LineFormatRenderer class with the specified graphics and pen.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineFormatRenderer.DrawLine(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Draws a line from point pt0 to point pt1.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineFormatRenderer.DrawRectangle(PdfSharp.Drawing.XRect)">
            <summary>
            Draws a line specified by rect.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineFormatRenderer.DrawPath(PdfSharp.Drawing.XGraphicsPath)">
            <summary>
            Draws a line specified by path.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LineFormatRenderer.gfx">
            <summary>
            Surface to draw the line.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LineFormatRenderer.pen">
            <summary>
            Pen used to draw the line.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnStackedPlotAreaRenderer">
            <summary>
            Represents a plot area renderer of stacked columns, i. e. all columns are drawn one on another.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnStackedPlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the ColumnStackedPlotAreaRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnStackedPlotAreaRenderer.CalcColumns">
            <summary>
            Calculates the position, width and height of each column of all series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnStackedPlotAreaRenderer.IsDataInside(System.Double,System.Double,System.Double)">
            <summary>
            Stacked columns are always inside.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.GridlinesRenderer">
            <summary>
            Base class for all renderers used to draw gridlines.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.GridlinesRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the GridlinesRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.DataLabelType">
            <summary>
            Determines the type of the data label.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DataLabelType.None">
            <summary>
            No DataLabel.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DataLabelType.Percent">
            <summary>
            Percentage of the data. For pie charts only.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DataLabelType.Value">
            <summary>
            Value of the data.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Chart">
            <summary>
            Represents charts with different types.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Chart.#ctor">
            <summary>
            Initializes a new instance of the Chart class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Chart.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the Chart class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Chart.#ctor(PdfSharp.Charting.ChartType)">
            <summary>
            Initializes a new instance of the Chart class with the specified chart type.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Chart.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Chart.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Chart.CheckAxis(PdfSharp.Charting.Axis)">
            <summary>
            Determines the type of the given axis.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.Type">
            <summary>
            Gets or sets the base type of the chart.
            ChartType of the series can be overwritten.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.Font">
            <summary>
            Gets or sets the font for the chart. This will be the default font for all objects which are
            part of the chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.Legend">
            <summary>
            Gets the legend of the chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.XAxis">
            <summary>
            Gets the X-Axis of the Chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.YAxis">
            <summary>
            Gets the Y-Axis of the Chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.ZAxis">
            <summary>
            Gets the Z-Axis of the Chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.SeriesCollection">
            <summary>
            Gets the collection of the data series.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.XValues">
            <summary>
            Gets the collection of the values written on the X-Axis.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.PlotArea">
            <summary>
            Gets the plot (drawing) area of the chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.DisplayBlanksAs">
            <summary>
            Gets or sets a value defining how blanks in the data series should be shown.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.DataLabel">
            <summary>
            Gets the DataLabel of the chart.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Chart.HasDataLabel">
            <summary>
            Gets or sets whether the chart has a DataLabel.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.WallRenderer">
            <summary>
            Represents a renderer for the plot area background.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.WallRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the WallRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.WallRenderer.Draw">
            <summary>
            Draws the wall.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.VerticalStackedYAxisRenderer">
            <summary>
            Represents a Y axis renderer used for charts of type Column2D or Line.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalStackedYAxisRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the VerticalYAxisRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalStackedYAxisRenderer.CalcYAxis(System.Double@,System.Double@)">
            <summary>
            Determines the sum of the smallest and the largest stacked column
            from all series of the chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.HorizontalYAxisRenderer">
            <summary>
            Represents a Y axis renderer used for charts of type Bar2D.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalYAxisRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the HorizontalYAxisRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalYAxisRenderer.Init">
            <summary>
            Returns a initialized rendererInfo based on the Y axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalYAxisRenderer.Format">
            <summary>
            Calculates the space used for the Y axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalYAxisRenderer.Draw">
            <summary>
            Draws the vertical Y axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalYAxisRenderer.InitScale(PdfSharp.Charting.Renderers.AxisRendererInfo)">
            <summary>
            Calculates all values necessary for scaling the axis like minimum/maximum scale or
            minor/major tick.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalYAxisRenderer.GetTickMarkPos(PdfSharp.Charting.Renderers.AxisRendererInfo,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Gets the top and bottom position of the major and minor tick marks depending on the
            tick mark type.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalYAxisRenderer.CalcYAxis(System.Double@,System.Double@)">
            <summary>
            Determines the smallest and the largest number from all series of the chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnLikeGridlinesRenderer">
            <summary>
            Represents gridlines used by column or line charts, i. e. X axis grid will be rendered
            from top to bottom and Y axis grid will be rendered from left to right of the plot area.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnLikeGridlinesRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the ColumnLikeGridlinesRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnLikeGridlinesRenderer.Draw">
            <summary>
            Draws the gridlines into the plot area.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnChartRenderer">
            <summary>
            Represents a column chart renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnChartRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the ColumnChartRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnChartRenderer.Init">
            <summary>
            Returns an initialized and renderer specific rendererInfo.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnChartRenderer.Format">
            <summary>
            Layouts and calculates the space used by the column chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnChartRenderer.Draw">
            <summary>
            Draws the column chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnChartRenderer.GetPlotAreaRenderer">
            <summary>
            Returns the specific plot area renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnChartRenderer.GetYAxisRenderer">
            <summary>
            Returns the specific y axis renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnChartRenderer.InitSeriesRendererInfo">
            <summary>
            Initializes all necessary data to draw all series for a column chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnChartRenderer.InitSeries">
            <summary>
            Initializes all necessary data to draw all series for a column chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnColors">
            <summary>
            Represents the predefined column/bar chart colors.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnColors.Item(System.Int32)">
            <summary>
            Gets the color for column/bar charts from the specified index.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.ColumnColors.seriesColors">
            <summary>
            Colors for column/bar charts taken from Excel.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.LineColors">
            <summary>
            Represents the predefined line chart colors.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.LineColors.Item(System.Int32)">
            <summary>
            Gets the color for line charts from the specified index.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.LineColors.lineColors">
            <summary>
            Colors for line charts taken from Excel.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PieColors">
            <summary>
            Represents the predefined pie chart colors.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieColors.Item(System.Int32)">
            <summary>
            Gets the color for pie charts from the specified index.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.Renderers.PieColors.sectorColors">
            <summary>
            Colors for pie charts taken from Excel.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.BarClusteredPlotAreaRenderer">
            <summary>
            Represents a plot area renderer of clustered bars, i. e. all bars are drawn side by side.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarClusteredPlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the BarClusteredPlotAreaRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarClusteredPlotAreaRenderer.CalcBars">
            <summary>
            Calculates the position, width and height of each bar of all series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarClusteredPlotAreaRenderer.IsDataInside(System.Double,System.Double,System.Double)">
            <summary>
            If yValue is within the range from yMin to yMax returns true, otherwise false.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.ChartType">
            <summary>
            Specifies with type of chart will be drawn.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.ChartType.Line">
            <summary>
            A line chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.ChartType.Column2D">
            <summary>
            A clustered 2d column chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.ChartType.ColumnStacked2D">
            <summary>
            A stacked 2d column chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.ChartType.Area2D">
            <summary>
            A 2d area chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.ChartType.Bar2D">
            <summary>
            A clustered 2d bar chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.ChartType.BarStacked2D">
            <summary>
            A stacked 2d bar chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.ChartType.Pie2D">
            <summary>
            A 2d pie chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.ChartType.PieExploded2D">
            <summary>
            An exploded 2d pie chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.BlankType">
            <summary>
            Determines how null values will be handled in a chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.BlankType.NotPlotted">
            <summary>
            Null value is not plotted.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.BlankType.Interpolated">
            <summary>
            Null value will be interpolated.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.BlankType.Zero">
            <summary>
            Null value will be handled as zero.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.DataLabel">
            <summary>
            Represents a DataLabel of a Series
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DataLabel.#ctor">
            <summary>
            Initializes a new instance of the DataLabel class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DataLabel.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the DataLabel class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DataLabel.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.DataLabel.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.DataLabel.Format">
            <summary>
            Gets or sets a numeric format string for the DataLabel.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.DataLabel.Font">
            <summary>
            Gets the Font for the DataLabel.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.DataLabel.Position">
            <summary>
            Gets or sets the position of the DataLabel.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.DataLabel.Type">
            <summary>
            Gets or sets the type of the DataLabel.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.ColumnDataLabelRenderer">
            <summary>
            Represents a data label renderer for column charts.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.DataLabelRenderer">
            <summary>
            Represents a data label renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.DataLabelRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the DataLabelRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.DataLabelRenderer.Init">
            <summary>
            Creates a data label rendererInfo.
            Does not return any renderer info.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.DataLabelRenderer.CalcPositions">
            <summary>
            Calculates the specific positions for each data label.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnDataLabelRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the ColumnDataLabelRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnDataLabelRenderer.Format">
            <summary>
            Calculates the space used by the data labels.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnDataLabelRenderer.Draw">
            <summary>
            Draws the data labels of the column chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.ColumnDataLabelRenderer.CalcPositions">
            <summary>
            Calculates the data label positions specific for column charts.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.PSCSR">
            <summary>
            The Pdf-Sharp-Charting-String-Resources.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.LineStyle">
            <summary>
            Specifies the line style of the LineFormat object.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.LineStyle.Single">
            <summary />
        </member>
        <member name="T:PdfSharp.Charting.Renderers.HorizontalStackedYAxisRenderer">
            <summary>
            Represents a Y axis renderer used for charts of type BarStacked2D.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalStackedYAxisRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the HorizontalStackedYAxisRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.HorizontalStackedYAxisRenderer.CalcYAxis(System.Double@,System.Double@)">
            <summary>
            Determines the sum of the smallest and the largest stacked bar
            from all series of the chart.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.BarGridlinesRenderer">
            <summary>
            Represents gridlines used by bar charts, i. e. X axis grid will be rendered
            from left to right and Y axis grid will be rendered from top to bottom of the plot area.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarGridlinesRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the BarGridlinesRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarGridlinesRenderer.Draw">
            <summary>
            Draws the gridlines into the plot area.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Point">
            <summary>
            Represents a formatted value on the data series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Point.#ctor">
            <summary>
            Initializes a new instance of the Point class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Point.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the Point class with a real value.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Point.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Point class with a real value.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Point.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Point.DeepCopy">
            <summary>
            Implements the deep copy of the object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Point.LineFormat">
            <summary>
            Gets the line format of the data point's border.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Point.FillFormat">
            <summary>
            Gets the filling format of the data point.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.Point.Value">
            <summary>
            The actual value of the data point.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.LineFormat">
            <summary>
            Defines the format of a line in a shape object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.LineFormat.#ctor">
            <summary>
            Initializes a new instance of the LineFormat class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.LineFormat.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the LineFormat class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.LineFormat.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.LineFormat.Visible">
            <summary>
            Gets or sets a value indicating whether the line should be visible.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.LineFormat.Width">
            <summary>
            Gets or sets the width of the line in XUnit.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.LineFormat.Color">
            <summary>
            Gets or sets the color of the line.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.LineFormat.DashStyle">
            <summary>
            Gets or sets the dash style of the line.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.LineFormat.Style">
            <summary>
            Gets or sets the style of the line.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.VerticalAlignment">
            <summary>
            Used to determine the vertical alignment of the axis title.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.VerticalAlignment.Top">
            <summary>
            Axis title will be top aligned.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.VerticalAlignment.Center">
            <summary>
            Axis title will be centered.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.VerticalAlignment.Bottom">
            <summary>
            Axis title will be bottom aligned.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.ChartFrame">
            <summary>
            Represents the frame which holds one or more charts.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.ChartFrame.#ctor">
            <summary>
            Initializes a new instance of the ChartFrame class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.ChartFrame.#ctor(PdfSharp.Drawing.XRect)">
            <summary>
            Initializes a new instance of the ChartFrame class with the specified rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.ChartFrame.Add(PdfSharp.Charting.Chart)">
            <summary>
            Adds a chart to the ChartFrame.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.ChartFrame.Draw(PdfSharp.Drawing.XGraphics)">
            <summary>
            Draws all charts inside the ChartFrame.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.ChartFrame.DrawChart(PdfSharp.Drawing.XGraphics)">
            <summary>
            Draws first chart only.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.ChartFrame.GetChartRenderer(PdfSharp.Charting.Chart,PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Returns the chart renderer appropriate for the chart.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.ChartFrame.chartList">
            <summary>
            Holds the charts which will be drawn inside the ChartFrame.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.ChartFrame.Location">
            <summary>
            Gets or sets the location of the ChartFrame.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.ChartFrame.Size">
            <summary>
            Gets or sets the size of the ChartFrame.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.SeriesElements">
            <summary>
            Represents the collection of the values in a data series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.SeriesElements.#ctor">
            <summary>
            Initializes a new instance of the SeriesElements class.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.SeriesElements.#ctor(PdfSharp.Charting.DocumentObject)">
            <summary>
            Initializes a new instance of the SeriesElements class with the specified parent.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.SeriesElements.Clone">
            <summary>
            Creates a deep copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.SeriesElements.AddBlank">
            <summary>
            Adds a blank to the series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.SeriesElements.Add(System.Double)">
            <summary>
            Adds a new point with a real value to the series.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.SeriesElements.Add(System.Double[])">
            <summary>
            Adds an array of new points with real values to the series.
            </summary>
        </member>
        <member name="P:PdfSharp.Charting.SeriesElements.Item(System.Int32)">
            <summary>
            Gets a point by it's index.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.Converter">
            <summary>
            Provides functions which converts Charting.DOM objects into PdfSharp.Drawing objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.Converter.ToXFont(PdfSharp.Charting.Font,PdfSharp.Drawing.XFont)">
            <summary>
            Creates a XFont based on the font. Missing attributes will be taken from the defaultFont
            parameter.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.Converter.ToXPen(PdfSharp.Charting.LineFormat,PdfSharp.Drawing.XColor,System.Double)">
            <summary>
            Creates a XPen based on the specified line format. If not specified color and width will be taken
            from the defaultColor and defaultWidth parameter.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.Converter.ToXPen(PdfSharp.Charting.LineFormat,PdfSharp.Drawing.XPen)">
            <summary>
            Creates a XPen based on the specified line format. If not specified color and width will be taken
            from the defaultPen parameter.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.Converter.ToXPen(PdfSharp.Charting.LineFormat,PdfSharp.Drawing.XColor,System.Double,PdfSharp.Drawing.XDashStyle)">
            <summary>
            Creates a XPen based on the specified line format. If not specified color, width and dash style
            will be taken from the defaultColor, defaultWidth and defaultDashStyle parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.Converter.ToXBrush(PdfSharp.Charting.FillFormat,PdfSharp.Drawing.XColor)">
            <summary>
            Creates a XBrush based on the specified fill format. If not specified, color will be taken
            from the defaultColor parameter.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.Converter.ToXBrush(PdfSharp.Charting.Font,PdfSharp.Drawing.XColor)">
            <summary>
            Creates a XBrush based on the specified font color. If not specified, color will be taken
            from the defaultColor parameter.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.DataLabelPosition">
            <summary>
            Determines where the data label will be positioned.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DataLabelPosition.Center">
            <summary>
            DataLabel will be centered inside the bar or pie.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DataLabelPosition.InsideBase">
            <summary>
            Inside the bar or pie at the origin.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DataLabelPosition.InsideEnd">
            <summary>
            Inside the bar or pie at the edge.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.DataLabelPosition.OutsideEnd">
            <summary>
            Outside the bar or pie.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.HorizontalAlignment">
            <summary>
            Used to determine the horizontal alignment of the axis title.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.HorizontalAlignment.Left">
            <summary>
            Axis title will be left aligned.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.HorizontalAlignment.Right">
            <summary>
            Axis title will be right aligned.
            </summary>
        </member>
        <member name="F:PdfSharp.Charting.HorizontalAlignment.Center">
            <summary>
            Axis title will be centered.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.VerticalXAxisRenderer">
            <summary>
            Represents an axis renderer used for charts of type Bar2D.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalXAxisRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the VerticalXAxisRenderer class with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalXAxisRenderer.Init">
            <summary>
            Returns an initialized rendererInfo based on the X axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalXAxisRenderer.Format">
            <summary>
            Calculates the space used for the X axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalXAxisRenderer.Draw">
            <summary>
            Draws the horizontal X axis.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalXAxisRenderer.CalculateXAxisValues(PdfSharp.Charting.Renderers.AxisRendererInfo)">
            <summary>
            Calculates the X axis describing values like minimum/maximum scale, major/minor tick and
            major/minor tick mark width.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalXAxisRenderer.InitXValues(PdfSharp.Charting.Renderers.AxisRendererInfo)">
            <summary>
            Initializes the rendererInfo's xvalues. If not set by the user xvalues will be simply numbers
            from minimum scale + 1 to maximum scale.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.VerticalXAxisRenderer.GetTickMarkPos(PdfSharp.Charting.Renderers.AxisRendererInfo,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Calculates the starting and ending y position for the minor and major tick marks.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PieExplodedPlotAreaRenderer">
            <summary>
            Represents a exploded pie plot area renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieExplodedPlotAreaRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the PieExplodedPlotAreaRenderer class
            with the specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieExplodedPlotAreaRenderer.CalcSectors">
            <summary>
            Calculate angles for each sector.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.PieDataLabelRenderer">
            <summary>
            Represents a data label renderer for pie charts.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieDataLabelRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the PieDataLabelRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieDataLabelRenderer.Format">
            <summary>
            Calculates the space used by the data labels.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieDataLabelRenderer.Draw">
            <summary>
            Draws the data labels of the pie chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.PieDataLabelRenderer.CalcPositions">
            <summary>
            Calculates the data label positions specific for pie charts.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.BarDataLabelRenderer">
            <summary>
            Represents a data label renderer for bar charts.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarDataLabelRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the BarDataLabelRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarDataLabelRenderer.Format">
            <summary>
            Calculates the space used by the data labels.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarDataLabelRenderer.Draw">
            <summary>
            Draws the data labels of the bar chart.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.BarDataLabelRenderer.CalcPositions">
            <summary>
            Calculates the data label positions specific for column charts.
            </summary>
        </member>
        <member name="T:PdfSharp.Charting.Renderers.AxisTitleRenderer">
            <summary>
            Represents a axis title renderer used for x and y axis titles.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AxisTitleRenderer.#ctor(PdfSharp.Charting.Renderers.RendererParameters)">
            <summary>
            Initializes a new instance of the AxisTitleRenderer class with the
            specified renderer parameters.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AxisTitleRenderer.Format">
            <summary>
            Calculates the space used for the axis title.
            </summary>
        </member>
        <member name="M:PdfSharp.Charting.Renderers.AxisTitleRenderer.Draw">
            <summary>
            Draws the axis title.
            </summary>
        </member>
        <member name="T:PdfSharp.PSSR">
            <summary>
            The Pdf-Sharp-String-Resources.
            </summary>
        </member>
        <member name="M:PdfSharp.PSSR.Format(PdfSharp.PSMsgID,System.Object[])">
            <summary>
            Loads the message from the resource associated with the enum type and formats it
            using 'String.Format'. Because this function is intended to be used during error
            handling it never raises an exception.
            </summary>
            <param name="id">The type of the parameter identifies the resource
            and the name of the enum identifies the message in the resource.</param>
            <param name="args">Parameters passed through 'String.Format'.</param>
            <returns>The formatted message.</returns>
        </member>
        <member name="M:PdfSharp.PSSR.GetString(PdfSharp.PSMsgID)">
            <summary>
            Gets the localized message identified by the specified DomMsgID.
            </summary>
        </member>
        <member name="M:PdfSharp.PSSR.TestResourceMessages">
            <summary>
            Writes all messages defined by PSMsgID.
            </summary>
        </member>
        <member name="P:PdfSharp.PSSR.ResMngr">
            <summary>
            Gets the resource manager for this module.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream">
            <summary>
            A special stream deflating or compressing the bytes that are
            written to it.  It uses a Deflater to perform actual deflating.<br />
            Authors of the original java version: Tom Tromey, Jochen Hoenicke 
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.buf">
            <summary>
            This buffer is used temporarily to retrieve the bytes from the
            deflater and write them to the underlying output stream.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.def">
            <summary>
            The deflater which is used to deflate the stream.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.baseOutputStream">
            <summary>
            Base stream the deflater depends on.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the current position of this stream to the given value. Not supported by this class!
            </summary>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.SetLength(System.Int64)">
            <summary>
            Sets the length of this stream to the given value. Not supported by this class!
            </summary>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.ReadByte">
            <summary>
            Read a byte from stream advancing position by one
            </summary>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a block of bytes from stream
            </summary>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Asynchronous reads are not supported a NotSupportedException is always thrown
            </summary>
            <param name="buffer" />
            <param name="offset" />
            <param name="count" />
            <param name="callback" />
            <param name="state" />
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Asynchronous writes arent supported, a NotSupportedException is always thrown
            </summary>
            <param name="buffer" />
            <param name="offset" />
            <param name="count" />
            <param name="callback" />
            <param name="state" />
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Deflate">
            <summary>
            Deflates everything in the input buffers.  This will call
            <code>def.deflate()</code> until all bytes from the input buffers
            are processed.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new DeflaterOutputStream with a default Deflater and default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,PdfSharp.SharpZipLib.Zip.Compression.Deflater)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
            <param name="defl">
            the underlying deflater.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,PdfSharp.SharpZipLib.Zip.Compression.Deflater,System.Int32)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            buffer size.
            </summary>
            <param name="baseOutputStream">
            The output stream where deflated output is written.
            </param>
            <param name="deflater">
            The underlying deflater to use
            </param>
            <param name="bufsize">
            The buffer size to use when deflating
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            bufsize is less than or equal to zero.
            </exception>
            <exception cref="T:System.ArgumentException">
            baseOutputStream does not support writing
            </exception>
            <exception cref="T:System.ArgumentNullException">
            deflater instance is null
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">
            <summary>
            Flushes the stream by calling flush() on the deflater and then
            on the underlying stream.  This ensures that all bytes are
            flushed.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish">
            <summary>
            Finishes the stream by calling finish() on the deflater. 
            </summary>
            <exception cref="T:PdfSharp.SharpZipLib.SharpZipBaseException">
            Not all input is deflated
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close">
            <summary>
            Calls finish() and closes the underlying
            stream when <see cref="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner" /> is true.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the compressed output stream.
            </summary>
            <param name="bval">
            The byte value.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes from an array to the compressed stream.
            </summary>
            <param name="buf">
            The byte array
            </param>
            <param name="off">
            The offset into the byte array where to start.
            </param>
            <param name="len">
            The number of bytes to write.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.EncryptByte">
            <summary>
            Encrypt a single byte 
            </summary>
            <returns>
            The encrypted value
            </returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.EncryptBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encrypt a block of data
            </summary>
            <param name="buffer">
            Data to encrypt.  NOTE the original contents of the buffer are lost
            </param>
            <param name="offset">
            Offset of first byte in buffer to encrypt
            </param>
            <param name="length">
            Number of bytes in buffer to encrypt
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.InitializePassword(System.String)">
            <summary>
            Initializes encryption keys based on given password
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.UpdateKeys(System.Byte)">
            <summary>
            Update encryption keys 
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close" /> will close the underlying stream also.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanPatchEntries">
            <summary>
            Allows client to determine if an entry can be patched after its added
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanRead">
            <summary>
            Gets value indicating stream can be read from
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanSeek">
            <summary>
            Gets a value indicating if seeking is supported for this stream
            This property always returns false
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanWrite">
            <summary>
            Get value indicating if this stream supports writing
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Length">
            <summary>
            Get current length of stream
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Position">
            <summary>
            The current position within the stream.
            Always throws a NotSupportedException
            </summary>
            <exception cref="T:System.NotSupportedException">Any attempt to set position</exception>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Password">
            <summary>
            Get/set the password used for encryption.  When null no encryption is performed
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Checksums.Adler32">
            <summary>
            Computes Adler32 checksum for a stream of data. An Adler32
            checksum is not as reliable as a CRC32 checksum, but a lot faster to
            compute.
            
            The specification for Adler32 may be found in RFC 1950.
            ZLIB Compressed Data Format Specification version 3.3)
            
            
            From that document:
            
                 "ADLER32 (Adler-32 checksum)
                  This contains a checksum value of the uncompressed data
                  (excluding any dictionary data) computed according to Adler-32
                  algorithm. This algorithm is a 32-bit extension and improvement
                  of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
                  standard.
            
                  Adler-32 is composed of two sums accumulated per byte: s1 is
                  the sum of all bytes, s2 is the sum of all s1 values. Both sums
                  are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
                  Adler-32 checksum is stored as s2*65536 + s1 in most-
                  significant-byte first (network) order."
            
             "8.2. The Adler-32 algorithm
            
               The Adler-32 algorithm is much faster than the CRC32 algorithm yet
               still provides an extremely low probability of undetected errors.
            
               The modulo on unsigned long accumulators can be delayed for 5552
               bytes, so the modulo operation time is negligible.  If the bytes
               are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
               and order sensitive, unlike the first sum, which is just a
               checksum.  That 65521 is prime is important to avoid a possible
               large class of two-byte errors that leave the check unchanged.
               (The Fletcher checksum uses 255, which is not prime and which also
               makes the Fletcher check insensitive to single byte changes 0 -
               255.)
            
               The sum s1 is initialized to 1 instead of zero to make the length
               of the sequence part of s2, so that the length does not have to be
               checked separately. (Any sequence of zeroes has a Fletcher
               checksum of zero.)"
            </summary>
            <see cref="T:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream" />
            <see cref="T:PdfSharp.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream" />
        </member>
        <member name="T:PdfSharp.SharpZipLib.Checksums.IChecksum">
            <summary>
            Interface to compute a data checksum used by checked input/output streams.
            A data checksum can be updated by one byte or with a byte array. After each
            update the value of the current checksum can be returned by calling
            <code>getValue</code>. The complete checksum object can also be reset
            so it can be used again with new data.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.IChecksum.Reset">
            <summary>
            Resets the data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.IChecksum.Update(System.Int32)">
            <summary>
            Adds one byte to the data checksum.
            </summary>
            <param name="bval">
            the data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.IChecksum.Update(System.Byte[])">
            <summary>
            Updates the data checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.IChecksum.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name="buf">
            the buffer which contains the data
            </param>
            <param name="off">
            the offset in the buffer where the data starts
            </param>
            <param name="len">
            the length of the data
            </param>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Checksums.IChecksum.Value">
            <summary>
            Returns the data checksum computed so far.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Checksums.Adler32.BASE">
            <summary>
            largest prime smaller than 65536
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.Adler32.#ctor">
            <summary>
            Creates a new instance of the <code>Adler32</code> class.
            The checksum starts off with a value of 1.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.Adler32.Reset">
            <summary>
            Resets the Adler32 checksum to the initial value.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.Adler32.Update(System.Int32)">
            <summary>
            Updates the checksum with the byte b.
            </summary>
            <param name="bval">
            the data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.Adler32.Update(System.Byte[])">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buf">
            an array of bytes
            </param>
            <param name="off">
            the start of the data used for this update
            </param>
            <param name="len">
            the number of bytes to use for this update
            </param>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Checksums.Adler32.Value">
            <summary>
            Returns the Adler32 data checksum computed so far.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfBooleanObject">
            <summary>
            Represents an indirect boolean value. This type is not used by PDFsharp. If it is imported from
            an external PDF file, the value is converted into a direct object.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfObject">
            <summary>
            Base class of all composite PDF objects.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfItem">
            <summary>
            The base class of all PDF objects and simple types.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItem.Clone">
            <summary>
            Creates a copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItem.Copy">
            <summary>
            Implements the copy mechanism. Must be overridden in derived classes.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfItem.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            When overridden in a derived class, appends a raw string representation of this object
            to the specified PdfWriter.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.#ctor(PdfSharp.Pdf.PdfObject)">
            <summary>
            Initializes a new instance from an existing object. Used for object type transformation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.Clone">
            <summary>
            Creates a copy of this object. The clone does not belong to a document, i.e. its owner and its iref are null.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.Copy">
            <summary>
            Implements the copy mechanism. Must be overridden in derived classes.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.SetObjectID(System.Int32,System.Int32)">
            <summary>
            Sets the object and generation number
            Setting the object identifier makes this object an indirect object, i.e. the object gets
            a PdfReference entry in the PdfReferenceTable.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.PrepareForSave">
            <summary>
            When overridden in a derived class, prepares the object to get saved.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Saves the stream position. 2nd Edition.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.DeepCopyClosure(PdfSharp.Pdf.PdfDocument,PdfSharp.Pdf.PdfObject)">
            <param name="owner">The document that owns the cloned objects.</param>
            <param name="externalObject">The root object to be cloned.</param>
            <returns>The clone of the root object</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.ImportClosure(PdfSharp.Pdf.Advanced.PdfImportedObjectTable,PdfSharp.Pdf.PdfDocument,PdfSharp.Pdf.PdfObject)">
            <param name="importedObjectTable">The imported object table of the owner for the external document.</param>
            <param name="owner">The document that owns the cloned objects.</param>
            <param name="externalObject">The root object to be cloned.</param>
            <returns>The clone of the root object</returns>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObject.FixUpObject(PdfSharp.Pdf.Advanced.PdfImportedObjectTable,PdfSharp.Pdf.PdfDocument,PdfSharp.Pdf.PdfObject)">
            <summary>
            Replace all indirect references to external objects by their cloned counterparts
            owned by the importer document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObject.Owner">
            <summary>
            Gets the PdfDocument this object belongs to.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObject.Document">
            <summary>
            Gets or sets the PdfDocument this object belongs to.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObject.IsIndirect">
            <summary>
            Indicates whether the object is an indirect object.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObject.Internals">
            <summary>
            Gets the PdfInternals object of this document, that grants access to some internal structures
            which are not part of the public interface of PdfDocument.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObject.ObjectID">
            <summary>
            Gets the object identifier. Returns PdfObjectID.Empty for direct objects.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObject.ObjectNumber">
            <summary>
            Gets the object number.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObject.GenerationNumber">
            <summary>
            Gets the generation number.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObject.Reference">
            <summary>
            Gets the indirect reference of this object. If the value is null, this object is a direct object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfBooleanObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfBooleanObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfBooleanObject.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfBooleanObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfBooleanObject.#ctor(PdfSharp.Pdf.PdfDocument,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfBooleanObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfBooleanObject.ToString">
            <summary>
            Returns "false" or "true".
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfBooleanObject.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the keyword «false» or «true».
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfBooleanObject.Value">
            <summary>
            Gets the value of this instance as boolean value.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfPageLayout">
            <summary>
            Specifies the page layout to be used by a viewer when the document is opened.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageLayout.SinglePage">
            <summary>
            Display one page at a time.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageLayout.OneColumn">
            <summary>
            Display the pages in one column.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageLayout.TwoColumnLeft">
            <summary>
            Display the pages in two columns, with oddnumbered pages on the left.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageLayout.TwoColumnRight">
            <summary>
            Display the pages in two columns, with oddnumbered pages on the right.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageLayout.TwoPageLeft">
            <summary>
            (PDF 1.5) Display the pages two at a time, with odd-numbered pages on the left.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageLayout.TwoPageRight">
            <summary>
            (PDF 1.5) Display the pages two at a time, with odd-numbered pages on the right.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.Symbol">
            <summary>
            Terminal symbols recognized by lexer.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Internal.RawEncoding">
            <summary>
            An encoder for raw strings. The raw encoding is simply the identity relation between
            charachters and bytes. PDFsharp internally works with raw encoded strings instead of
            byte arrays because strings are much more handy than byte arrays.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfType0Font">
            <summary>
            Represents a composite font. Used for Unicode encoding.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFont">
            <summary>
            Represents a PDF font.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionary">
            <summary>
            Represents a PDF dictionary object.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDictionary.elements">
            <summary>
            The elements of the dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfDictionary" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfDictionary" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Initializes a new instance from an existing dictionary. Used for object type transformation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.Clone">
            <summary>
            Creates a copy of this dictionary. Direct values are deep copied. Indirect references are not
            modified.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.Copy">
            <summary>
            This function is useful for importing objects from external documents. The returned object is not
            yet complete. irefs refer to external objects and directed objects are cloned but their document
            property is null. A cloned dictionary or array needs a 'fix-up' to be a valid object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.ToString">
            <summary>
            Returns a string with the content of this object in a readable form. Useful for debugging purposes only.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.WriteDictionaryElement(PdfSharp.Pdf.IO.PdfWriter,PdfSharp.Pdf.PdfName)">
            <summary>
            Writes a key/value pair of this dictionary. This function is intended to be overridden
            in derived classes.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.WriteDictionaryStream(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the stream of this dictionary. This function is intended to be overridden
            in a derived class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.CreateStream(System.Byte[])">
            <summary>
            Creates the stream of this dictionary and initializes it with the specified byte array.
            The function must not be called if the dictionary already has a stream.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.Elements">
            <summary>
            Gets the hashtable containing the elements of this dictionary.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.Stream">
            <summary>
            Gets or sets the PDF stream belonging to this dictionary. Returns null if the dictionary has
            no stream. To create the stream, call the CreateStream function.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.Meta">
            <summary>
            When overridden in a derived class, gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionary.DictionaryElements">
            <summary>
            Represents the interface to the elements of a PDF dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Clone">
            <summary>
            Creates a shallow copy of this object. The clone is not owned by a dictionary anymore.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.ChangeOwner(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Moves this instance to another dictionary during object type transformation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetBoolean(System.String,System.Boolean)">
            <summary>
            Converts the specified value to boolean.
            If the value not exists, the function returns false.
            If the value is not convertible, the function throws an InvalidCastException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetBoolean(System.String)">
            <summary>
            Converts the specified value to boolean.
            If the value not exists, the function returns false.
            If the value is not convertible, the function throws an InvalidCastException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetBoolean(System.String,System.Boolean)">
            <summary>
            Sets the entry to a direct boolean value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetInteger(System.String,System.Boolean)">
            <summary>
            Converts the specified value to integer.
            If the value not exists, the function returns 0.
            If the value is not convertible, the function throws an InvalidCastException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetInteger(System.String)">
            <summary>
            Converts the specified value to integer.
            If the value not exists, the function returns 0.
            If the value is not convertible, the function throws an InvalidCastException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetInteger(System.String,System.Int32)">
            <summary>
            Sets the entry to a direct integer value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetReal(System.String,System.Boolean)">
            <summary>
            Converts the specified value to double.
            If the value not exists, the function returns 0.
            If the value is not convertible, the function throws an InvalidCastException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetReal(System.String)">
            <summary>
            Converts the specified value to double.
            If the value not exists, the function returns 0.
            If the value is not convertible, the function throws an InvalidCastException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetReal(System.String,System.Double)">
            <summary>
            Sets the entry to a direct double value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetString(System.String,System.Boolean)">
            <summary>
            Converts the specified value to String.
            If the value not exists, the function returns the empty string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetString(System.String)">
            <summary>
            Converts the specified value to String.
            If the value not exists, the function returns the empty string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetString(System.String,System.String)">
            <summary>
            Sets the entry to a direct string value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetName(System.String)">
            <summary>
            Converts the specified value to a name.
            If the value not exists, the function returns the empty string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetName(System.String,System.String)">
            <summary>
            Sets the specified name value.
            If the value doesn't start with a slash, it is added automatically.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetRectangle(System.String,System.Boolean)">
            <summary>
            Converts the specified value to PdfRectangle.
            If the value not exists, the function returns an empty rectangle.
            If the value is not convertible, the function throws an InvalidCastException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetRectangle(System.String)">
            <summary>
            Converts the specified value to PdfRectangle.
            If the value not exists, the function returns an empty rectangle.
            If the value is not convertible, the function throws an InvalidCastException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetRectangle(System.String,PdfSharp.Pdf.PdfRectangle)">
            <summary>
            Sets the entry to a direct rectangle value, represented by an array with four values.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetMatrix(System.String,System.Boolean)">
            Converts the specified value to XMatrix.
            If the value not exists, the function returns an identity matrix.
            If the value is not convertible, the function throws an InvalidCastException.
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetMatrix(System.String)">
            Converts the specified value to XMatrix.
            If the value not exists, the function returns an identity matrix.
            If the value is not convertible, the function throws an InvalidCastException.
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetMatrix(System.String,PdfSharp.Drawing.XMatrix)">
            <summary>
            Sets the entry to a direct matrix value, represented by an array with six values.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetDateTime(System.String,System.DateTime)">
            <summary>
            Converts the specified value to DateTime.
            If the value not exists, the function returns the specified default value.
            If the value is not convertible, the function throws an InvalidCastException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetDateTime(System.String,System.DateTime)">
            <summary>
            Sets the entry to a direct datetime value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetValue(System.String,PdfSharp.Pdf.VCF)">
            <summary>
            Gets the value for the specified key. If the value does not exist, it is optionally created.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetValue(System.String)">
            <summary>
            Short cut for GetValue(key, VCF.None).
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetValueType(System.String)">
            <summary>
            Returns the type of the object to be created as value of the specified key.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetValue(System.String,PdfSharp.Pdf.PdfItem)">
            <summary>
            Sets the entry with the specified value. DON'T USE THIS FUNCTION - IT MAY BE REMOVED.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetIndirectObject(System.String)">
            <summary>
            Returns the indirect object if the value of the specified key is a PdfReference.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetObject(System.String)">
            <summary>
            Gets the PdfObject with the specified key, or null, if no such object exists. If the key refers to
            a reference, the referenced PdfObject is returned.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetDictionary(System.String)">
            <summary>
            Gets the PdfArray with the specified key, or null, if no such object exists. If the key refers to
            a reference, the referenced PdfDictionary is returned.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetArray(System.String)">
            <summary>
            Gets the PdfArray with the specified key, or null, if no such object exists. If the key refers to
            a reference, the referenced PdfArray is returned.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetReference(System.String)">
            <summary>
            Gets the PdfReference with the specified key, or null, if no such object exists.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetObject(System.String,PdfSharp.Pdf.PdfObject)">
            <summary>
            Sets the entry to the specified object. The object must not be an indirect object,
            otherwise an exception is raised.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SetReference(System.String,PdfSharp.Pdf.PdfObject)">
            <summary>
            Sets the entry as a reference to the specified object. The object must be an indirect object,
            otherwise an exception is raised.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Remove(System.String)">
            <summary>
            Removes the value with the specified key.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Remove(System.Collections.Generic.KeyValuePair{System.String,PdfSharp.Pdf.PdfItem})">
            <summary>
            Removes the value with the specified key.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Contains(System.String)">
            <summary>
            Determines whether the dictionary contains the specified name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.ContainsKey(System.String)">
            <summary>
            Determines whether the dictionary contains the specified name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Contains(System.Collections.Generic.KeyValuePair{System.String,PdfSharp.Pdf.PdfItem})">
            <summary>
            Determines whether the dictionary contains a specific value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Clear">
            <summary>
            Removes all elements from the dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Add(System.String,PdfSharp.Pdf.PdfItem)">
            <summary>
            Adds the specified value to the dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Add(System.Collections.Generic.KeyValuePair{System.String,PdfSharp.Pdf.PdfItem})">
            <summary>
            Adds an item to the dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.TryGetValue(System.String,PdfSharp.Pdf.PdfItem@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.DictionaryElements.CopyTo(System.Collections.Generic.KeyValuePair{System.String,PdfSharp.Pdf.PdfItem}[],System.Int32)">
            <summary>
            Copies the elements of the dictionary to an array, starting at a particular index.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Owner">
            <summary>
            Gets the dictionary that this elements object belongs to.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object is read-only.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Item(System.String)">
            <summary>
            Gets or sets an entry in the dictionary. The specified key must be a valid PDF name
            starting with a slash '/'. This property provides full access to the elements of the
            PDF dictionary. Wrong use can lead to errors or corrupt PDF files.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Item(PdfSharp.Pdf.PdfName)">
            <summary>
            Gets or sets an entry in the dictionary identified by a PdfName object.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.KeyNames">
            <summary>
            Gets all keys currently in use in this dictionary as an array of PdfName objects.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Keys">
            <summary>
            Get all keys currently in use in this dictionary as an array of string objects.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Values">
            <summary>
            Gets all values currently in use in this dictionary as an array of PdfItem objects.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.IsFixedSize">
            <summary>
            Return false.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.IsSynchronized">
            <summary>
            Return false.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.Count">
            <summary>
            Gets the number of elements contained in the dictionary.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.DictionaryElements.SyncRoot">
            <summary>
            The current implementation returns null.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionary.PdfStream">
            <summary>
            The PDF stream objects.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDictionary.PdfStream.owner">
            <summary>
            The dictionary the stream belongs to.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.PdfStream.#ctor(System.Byte[],PdfSharp.Pdf.PdfDictionary)">
            <summary>
            A .NET string can contain char(0) as a valid character.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.PdfStream.Clone">
            <summary>
            Clones this stream by creating a deep copy.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.PdfStream.SetOwner(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Moves this instance to another dictionary during object type transformation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.PdfStream.TryUnfilter">
            <summary>
            Tries to unfilter the bytes of the stream. If the stream is filtered and PDFsharp knows the filter
            algorithm, the stream content is replaced by its unfiltered value and the function returns true.
            Otherwise the content remains untouched and the function returns false.
            The function is useful for analyzing existing PDF files.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.PdfStream.Zip">
            <summary>
            Compresses the stream with the FlateDecode filter.
            If a filter is already defined, the function has no effect.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.PdfStream.ToString">
            <summary>
            Returns the stream content as a raw string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDictionary.PdfStream.RawEncode(System.String)">
            <summary>
            Converts a raw encoded string into a byte array.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.PdfStream.Length">
            <summary>
            Gets the length of the stream, i.e. the actual number of bytes in the stream.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.PdfStream.Value">
            <summary>
            Get or sets the bytes of the stream as they are, i.e. if one or more filters exists the bytes are
            not unfiltered.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDictionary.PdfStream.UnfilteredValue">
            <summary>
            Gets the value of the stream unfiltered. The stream content is not modified by this operation.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDictionary.PdfStream.Keys">
            <summary>
            Common keys for all streams.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.KeysBase">
            <summary>
            Base class for all dictionary Keys classes.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDictionary.PdfStream.Keys.Length">
            <summary>
            (Required) The number of bytes from the beginning of the line following the keyword
            stream to the last byte just before the keyword endstream. (There may be an additional
            EOL marker, preceding endstream, that is not included in the count and is not logically
            part of the stream data.)
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDictionary.PdfStream.Keys.Filter">
            <summary>
            (Optional) The name of a filter to be applied in processing the stream data found between
            the keywords stream and endstream, or an array of such names. Multiple filters should be
            specified in the order in which they are to be applied.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDictionary.PdfStream.Keys.DecodeParms">
            <summary>
            (Optional) A parameter dictionary or an array of such dictionaries, used by the filters
            specified by Filter. If there is only one filter and that filter has parameters, DecodeParms
            must be set to the filter’s parameter dictionary unless all the filter’s parameters have
            their default values, in which case the DecodeParms entry may be omitted. If there are 
            multiple filters and any of the filters has parameters set to nondefault values, DecodeParms
            must be an array with one entry for each filter: either the parameter dictionary for that
            filter, or the null object if that filter has no parameters (or if all of its parameters have
            their default values). If none of the filters have parameters, or if all their parameters
            have default values, the DecodeParms entry may be omitted.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDictionary.PdfStream.Keys.F">
            <summary>
            (Optional; PDF 1.2) The file containing the stream data. If this entry is present, the bytes
            between stream and endstream are ignored, the filters are specified by FFilter rather than
            Filter, and the filter parameters are specified by FDecodeParms rather than DecodeParms.
            However, the Length entry should still specify the number of those bytes. (Usually, there are
            no bytes and Length is 0.)
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDictionary.PdfStream.Keys.FFilter">
            <summary>
            (Optional; PDF 1.2) The name of a filter to be applied in processing the data found in the
            stream’s external file, or an array of such names. The same rules apply as for Filter.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDictionary.PdfStream.Keys.FDecodeParms">
            <summary>
            (Optional; PDF 1.2) A parameter dictionary, or an array of such dictionaries, used by the
            filters specified by FFilter. The same rules apply as for DecodeParms.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDictionary.PdfStream.Keys.DL">
            <summary>
            Optional; PDF 1.5) A non-negative integer representing the number of bytes in the decoded
            (defiltered) stream. It can be used to determine, for example, whether enough disk space is
            available to write a stream to a file.
            This value should be considered a hint only; for some stream filters, it may not be possible
            to determine this value precisely.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFont.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfFont" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFont.CreateEmbeddedFontSubsetName(System.String)">
            <summary>
            Adds a tag of exactly six uppercase letters to the font name 
            according to PDF Reference Section 5.5.3 'Font Subsets'
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFont.IsSymbolFont">
            <summary>
            Gets a value indicating whether this instance is symbol font.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFont.CMapInfo">
            <summary>
            Gets or sets the CMapInfo.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFont.ToUnicodeMap">
            <summary>
            Gets or sets ToUnicodeMap.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFont.Keys">
            <summary>
            Predefined keys common to all font dictionaries.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFont.Keys.Type">
            <summary>
            (Required) The type of PDF object that this dictionary describes;
            must be Font for a font dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFont.Keys.Subtype">
            <summary>
            (Required) The type of font.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFont.Keys.BaseFont">
            <summary>
            (Required) The PostScript name of the font.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFont.Keys.FontDescriptor">
            <summary>
            (Required except for the standard 14 fonts; must be an indirect reference)
            A font descriptor describing the font’s metrics other than its glyph widths.
            Note: For the standard 14 fonts, the entries FirstChar, LastChar, Widths, and 
            FontDescriptor must either all be present or all be absent. Ordinarily, they are
            absent; specifying them enables a standard font to be overridden.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfType0Font.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfType0Font.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfType0Font.Keys.Type">
            <summary>
            (Required) The type of PDF object that this dictionary describes;
            must be Font for a font dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfType0Font.Keys.Subtype">
            <summary>
            (Required) The type of font; must be Type0 for a Type 0 font.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfType0Font.Keys.BaseFont">
            <summary>
            (Required) The PostScript name of the font. In principle, this is an arbitrary
            name, since there is no font program associated directly with a Type 0 font
            dictionary. The conventions described here ensure maximum compatibility
            with existing Acrobat products.
            If the descendant is a Type 0 CIDFont, this name should be the concatenation
            of the CIDFont’s BaseFont name, a hyphen, and the CMap name given in the
            Encoding entry (or the CMapName entry in the CMap). If the descendant is a
            Type 2 CIDFont, this name should be the same as the CIDFont’s BaseFont name.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfType0Font.Keys.Encoding">
            <summary>
            (Required) The name of a predefined CMap, or a stream containing a CMap
            that maps character codes to font numbers and CIDs. If the descendant is a
            Type 2 CIDFont whose associated TrueType font program is not embedded
            in the PDF file, the Encoding entry must be a predefined CMap name.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfType0Font.Keys.DescendantFonts">
            <summary>
            (Required) A one-element array specifying the CIDFont dictionary that is the
            descendant of this Type 0 font.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfType0Font.Keys.ToUnicode">
            <summary>
            ((Optional) A stream containing a CMap file that maps character codes to
            Unicode values.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfType0Font.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Internal.Calc">
            <summary>
            Some static helper functions for calculations.
            </summary>
        </member>
        <member name="F:PdfSharp.Internal.Calc.Deg2Rad">
            <summary>
            Degree to radiant factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Internal.Calc.πHalf">
            <summary>
            Half of pi.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.Calc.PageSizeToSize(PdfSharp.PageSize)">
            <summary>
            Get page size in point from specified PageSize.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XSolidBrush">
            <summary>
            Defines a single color object used to fill shapes and draw text.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XBrush">
            <summary>
            Classes derived from this abstract base class define objects used to fill the 
            interiors of paths.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XBrush.op_Implicit(System.Drawing.Brush)~PdfSharp.Drawing.XBrush">
            <summary>
            Converts from a System.Drawing.Brush.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSolidBrush.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XSolidBrush" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSolidBrush.#ctor(PdfSharp.Drawing.XColor)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XSolidBrush" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSolidBrush.#ctor(PdfSharp.Drawing.XSolidBrush)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XSolidBrush" /> class.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XSolidBrush.Color">
            <summary>
            Gets or sets the color of this brush.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.IXGraphicsRenderer">
            <summary>
            Represents an abstract drawing surface for PdfPages.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.Clear(PdfSharp.Drawing.XColor)">
            <summary>
            Fills the entire drawing surface with the specified color.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawLine(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a straight line.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawLines(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[])">
            <summary>
            Draws a series of straight lines.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawBezier(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a Bézier spline.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawBeziers(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[])">
            <summary>
            Draws a series of Bézier splines.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[],System.Double)">
            <summary>
            Draws a cardinal spline.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawArc(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws an arc.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawRectangles(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect[])">
            <summary>
            Draws a series of rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawRoundedRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a rectangle with rounded corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawEllipse(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawPolygon(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a polygon.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawPie(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a pie.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint[],System.Double,PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a cardinal spline.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawPath(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XGraphicsPath)">
            <summary>
            Draws a graphical path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Draws a series of glyphs identified by the specified text and font.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.DrawImage(PdfSharp.Drawing.XImage,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws an image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.Save(PdfSharp.Drawing.XGraphicsState)">
            <summary>
            Saves the current graphics state without changing it.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.Restore(PdfSharp.Drawing.XGraphicsState)">
            <summary>
            Restores the specified graphics state.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.BeginContainer(PdfSharp.Drawing.XGraphicsContainer,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XGraphicsUnit)">
            <summary />
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.EndContainer(PdfSharp.Drawing.XGraphicsContainer)">
            <summary />
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.SetPageTransform(PdfSharp.Drawing.XPageDirection,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Sets all values that influence the page transformation.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.IXGraphicsRenderer.WriteComment(System.String)">
            <summary>
            Writes a comment to the output stream. Comments have no effect on the rendering of the output.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.IXGraphicsRenderer.Transform">
            <summary>
            Gets or sets the transformation matrix.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer">
            <summary>
            Represents a drawing surface for PdfPages.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.GraphicsStackLevelInitial">
            <summary>
            The q/Q nesting level is 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.GraphicsStackLevelPageSpace">
            <summary>
            The q/Q nesting level is 1.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.GraphicsStackLevelWorldSpace">
            <summary>
            The q/Q nesting level is 2.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.GetContent">
            <summary>
            Gets the content created by this renderer.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.DrawLine(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Strokes a single connection of two points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.DrawLines(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[])">
            <summary>
            Strokes a series of connected points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.Save(PdfSharp.Drawing.XGraphicsState)">
            <summary>
            Clones the current graphics state and push it on a stack.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.ResetClip">
            <summary>
            Sets the clip path empty. Only possible if graphic state level has the same value as it has when
            the first time SetClip was invoked.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.clipLevel">
            <summary>
            The nesting level of the PDF graphics state stack when the clip region was set to non empty.
            Because of the way PDF is made the clip region can only be reset at this level.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.WriteComment(System.String)">
            <summary>
            Writes a comment to the PDF content stream. May be useful for debugging purposes.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.AppendPartialArc(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,PdfSharp.Drawing.PathStart,PdfSharp.Drawing.XMatrix)">
            <summary>
            Appends one or up to five Bézier curves that interpolate the arc.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.Quatrant(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Gets the quadrant (0 through 3) of the specified angle. If the angle lies on an edge
            (0, 90, 180, etc.) the result depends on the details how the angle is used.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.AppendPartialArcQuadrant(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,PdfSharp.Drawing.PathStart,PdfSharp.Drawing.XMatrix)">
            <summary>
            Appends a Bézier curve for an arc within a quadrant.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.AppendCurveSegment(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint,System.Double)">
            <summary>
            Appends a Bézier curve for a cardinal spline through pt1 and pt2.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.AppendPath(System.Drawing.Drawing2D.GraphicsPath)">
            <summary>
            Appends the content of a GraphicsPath object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.BeginPage">
            <summary>
            Initializes the default view transformation, i.e. the transformation from the user page
            space to the PDF page space.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.EndPage">
            <summary>
            Ends the content stream, i.e. ends the text mode and balances the graphic state stack.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.BeginGraphic">
            <summary>
            Begins the graphic mode (i.e. ends the text mode).
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.Realize(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush)">
            <summary>
            Makes the specified pen and brush to the current graphics objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.Realize(PdfSharp.Drawing.XPen)">
            <summary>
            Makes the specified pen to the current graphics object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.Realize(PdfSharp.Drawing.XBrush)">
            <summary>
            Makes the specified brush to the current graphics object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.Realize(PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,System.Int32)">
            <summary>
            Makes the specified font and brush to the current graphics objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.Realize(PdfSharp.Drawing.XImage)">
            <summary>
            Makes the specified image to the current graphics object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.RealizeTransform">
            <summary>
            Realizes the current transformation matrix, if necessary.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.GetFontName(PdfSharp.Drawing.XFont,PdfSharp.Pdf.Advanced.PdfFont@)">
            <summary>
            Gets the resource name of the specified font within this page or form.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.GetImageName(PdfSharp.Drawing.XImage)">
            <summary>
            Gets the resource name of the specified image within this page or form.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.GetFormName(PdfSharp.Drawing.XForm)">
            <summary>
            Gets the resource name of the specified form within this page or form.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.SaveState">
            <summary>
            Saves the current graphical state.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.RestoreState">
            <summary>
            Restores the previous graphical state.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.gfxState">
            <summary>
            The current graphical state.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.gfxStateStack">
            <summary>
            The graphical state stack.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.defaultViewMatrix">
            <summary>
            The final transformation from the world space to the default page space.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.Owner">
            <summary>
            Gets the owning PdfDocument of this page or form.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.Resources">
            <summary>
            Gets the PdfResources of this page or form.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer.Size">
            <summary>
            Gets the size of this page or form.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.CodeType">
            <summary>
            Specifies the type of the bar code.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.CodeType.Code2of5Interleaved">
            <summary>
            The standard 2 of 5 interleaved bar code.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.CodeType.Code3of9Standard">
            <summary>
            The standard 3 of 9 bar code.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.CodeType.Omr">
            <summary>
            The OMR code.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.CodeType.DataMatrix">
            <summary>
            The data matrix code.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.OpCode">
            <summary>
            Represents a PDF content stream operator description.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.OpCode.#ctor(System.String,PdfSharp.Pdf.Content.Objects.OpCodeName,System.Int32,System.String,PdfSharp.Pdf.Content.Objects.OpCodeFlags,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Content.Objects.OpCode" /> class.
            </summary>
            <param name="name">The name.</param>
            <param name="opcodeName">The enum value of the operator.</param>
            <param name="operands">The number of operands.</param>
            <param name="postscript">The postscript equivalent, or null, if no such operation exists.</param>
            <param name="flags">The flags.</param>
            <param name="description">The description from Adobe PDF Reference.</param>
        </member>
        <member name="F:PdfSharp.Pdf.Content.Objects.OpCode.Name">
            <summary>
            The name of the operator.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Content.Objects.OpCode.OpCodeName">
            <summary>
            The enum value of the operator.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Content.Objects.OpCode.Operands">
            <summary>
            The number of operands. -1 indicates a variable number of operands.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Content.Objects.OpCode.Flags">
            <summary>
            The flags.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Content.Objects.OpCode.Postscript">
            <summary>
            The postscript equivalent, or null, if no such operation exists.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Content.Objects.OpCode.Description">
            <summary>
            The description from Adobe PDF Reference.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.OpCodes">
            <summary>
            Static class with all PDF op-codes.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.OpCodes.OperatorFromName(System.String)">
            <summary>
            Operators from name.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.OpCodes.#cctor">
            <summary>
            Initializes the <see cref="T:PdfSharp.Pdf.Content.Objects.OpCodes" /> class.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Content.Objects.OpCodes.ops">
            <summary>
            Array of all OpCodes.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.OpCodeFlags">
            <summary>
            Specifies the group of operations the op-code belongs to.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Content.Objects.OpCodeFlags.None">
            <summary />
        </member>
        <member name="F:PdfSharp.Pdf.Content.Objects.OpCodeFlags.TextOut">
            <summary />
        </member>
        <member name="T:PdfSharp.Internal.DoubleUtil">
            <summary>
            Some floating point utilities. Partially reflected from WPF, later equalized with original source code.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.AreClose(System.Double,System.Double)">
            <summary>
            Indicates whether the values are so close that they can be considered as equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.AreRoughlyEqual(System.Double,System.Double,System.Int32)">
            <summary>
            Indicates whether the values are so close that they can be considered as equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.AreClose(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Indicates whether the values are so close that they can be considered as equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.AreClose(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XRect)">
            <summary>
            Indicates whether the values are so close that they can be considered as equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.AreClose(PdfSharp.Drawing.XSize,PdfSharp.Drawing.XSize)">
            <summary>
            Indicates whether the values are so close that they can be considered as equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.AreClose(PdfSharp.Drawing.XVector,PdfSharp.Drawing.XVector)">
            <summary>
            Indicates whether the values are so close that they can be considered as equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.GreaterThan(System.Double,System.Double)">
            <summary>
            Indicates whether value1 is greater than value2 and the values are not close to each other.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.GreaterThanOrClose(System.Double,System.Double)">
            <summary>
            Indicates whether value1 is greater than value2 or the values are close to each other.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.LessThan(System.Double,System.Double)">
            <summary>
            Indicates whether value1 is less than value2 and the values are not close to each other.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.LessThanOrClose(System.Double,System.Double)">
            <summary>
            Indicates whether value1 is less than value2 or the values are close to each other.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.IsBetweenZeroAndOne(System.Double)">
            <summary>
            Indicates whether the value is between 0 and 1 or close to 0 or 1.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.IsNaN(System.Double)">
            <summary>
            Indicates whether the value is not a number.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.RectHasNaN(PdfSharp.Drawing.XRect)">
            <summary>
            Indicates whether at least one of the four rectangle values is not a number.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.IsOne(System.Double)">
            <summary>
            Indicates whether the value is 1 or close to 1.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.IsZero(System.Double)">
            <summary>
            Indicates whether the value is 0 or close to 0.
            </summary>
        </member>
        <member name="M:PdfSharp.Internal.DoubleUtil.DoubleToInt(System.Double)">
            <summary>
            Converts a double to integer.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.IRefFontTable">
            <summary>
            Represents an indirect reference to an existing font table in a font image.
            Used to create binary copies of an existing font table that is not modified.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.OpenTypeFontTable">
            <summary>
            Base class for all OpenType fonts.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.OpenTypeFontTable.Clone">
            <summary>
            Creates a deep copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.OpenTypeFontTable.PrepareForCompilation">
            <summary>
            When overridden in a derived class, prepares the font table to be compiled into its binary representation.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.OpenTypeFontTable.Write(PdfSharp.Fonts.OpenType.OpenTypeFontWriter)">
            <summary>
            When overridden in a derived class, converts the font into its binary representation.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.OpenTypeFontTable.CalcChecksum(System.Byte[])">
            <summary>
            Calculates the checksum of a table represented by its bytes.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.OpenType.OpenTypeFontTable.FontData">
            <summary>
            Gets the font image the table belongs to.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.IRefFontTable.PrepareForCompilation">
            <summary>
            Prepares the font table to be compiled into its binary representation.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.IRefFontTable.Write(PdfSharp.Fonts.OpenType.OpenTypeFontWriter)">
            <summary>
            Converts the font into its binary representation.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.GlyphDataTable">
            <summary>
            This table contains information that describes the glyphs in the font in the TrueType outline format.
            Information regarding the rasterizer (scaler) refers to the TrueType rasterizer. 
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.GlyphDataTable.Read">
            <summary>
            Converts the bytes in a handy representation
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.GlyphDataTable.GetGlyphData(System.Int32)">
            <summary>
            Gets the data of the specified glyph.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.GlyphDataTable.GetGlyphSize(System.Int32)">
            <summary>
            Gets the size of the byte array that defines the glyph.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.GlyphDataTable.GetOffset(System.Int32)">
            <summary>
            Gets the offset of the specified glyph relative to the first byte of the font image.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.GlyphDataTable.CompleteGlyphClosure(System.Collections.Generic.Dictionary{System.Int32,System.Object})">
            <summary>
            Adds for all composite glyphs the glyphs the composite one is made of.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.GlyphDataTable.AddCompositeGlyphs(System.Collections.Generic.Dictionary{System.Int32,System.Object},System.Int32)">
            <summary>
            If the specified glyph is a composite glyph add the glyphs it is made of to the glyph table.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.GlyphDataTable.PrepareForCompilation">
            <summary>
            Prepares the font table to be compiled into its binary representation.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.GlyphDataTable.Write(PdfSharp.Fonts.OpenType.OpenTypeFontWriter)">
            <summary>
            Converts the font into its binary representation.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman">
            <summary>
            This is the DeflaterHuffman class.
            
            This class is <i>not</i> thread safe.  This is inherent in the API, due
            to the split of deflate and setInput.
            
            Author of the original java version: Jochen Hoenicke
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.pending">
            <summary>
            Pending buffer to use
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.BitReverse(System.Int32)">
            <summary>
            Reverse the bits of a 16 bit value.
            </summary>
            <param name="toReverse">Value to reverse bits</param>
            <returns>Value with bits reversed</returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.#ctor(PdfSharp.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">Pending buffer to use</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Reset">
            <summary>
            Reset internal state
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.SendAllTrees(System.Int32)">
            <summary>
            Write all trees to pending buffer
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.CompressBlock">
            <summary>
            Compress current buffer writing data to pending buffer
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushStoredBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with no compression
            </summary>
            <param name="stored">Data to write</param>
            <param name="storedOffset">Index of first byte to write</param>
            <param name="storedLength">Count of bytes to write</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with compression
            </summary>
            <param name="stored">Data to flush</param>
            <param name="storedOffset">Index of first byte to flush</param>
            <param name="storedLength">Count of bytes to flush</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.IsFull">
            <summary>
            Get value indicating if internal buffer is full
            </summary>
            <returns>true if buffer is full</returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyLit(System.Int32)">
            <summary>
            Add literal to buffer
            </summary>
            <param name="lit" />
            <returns>Value indicating internal buffer is full</returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyDist(System.Int32,System.Int32)">
            <summary>
            Add distance code and length to literal and distance trees
            </summary>
            <param name="dist">Distance code</param>
            <param name="len">Length</param>
            <returns>Value indicating if internal buffer is full</returns>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree">
            <summary>
            Not documented
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.freqs">
            <summary>
            Not documented
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.length">
            <summary>
            Not documented
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.minNumCodes">
            <summary>
            Not documented
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.numCodes">
            <summary>
            Not documented
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.#ctor(PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman,System.Int32,System.Int32,System.Int32)">
            <summary>
            Not documented
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.Reset">
            <summary>
            Resets the internal state of the tree
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.WriteSymbol(System.Int32)">
            <summary>
            Not documented
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CheckEmpty">
            <summary>
            Check that at least one frequency is non-zero
            </summary>
            <exception cref="T:PdfSharp.SharpZipLib.SharpZipBaseException">
            No frequencies are non-zero
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.SetStaticCodes(System.Int16[],System.Byte[])">
            <summary>
            Set static codes and length
            </summary>
            <param name="stCodes">new codes</param>
            <param name="stLength">length for new codes</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.BuildCodes">
            <summary>
            Build dynamic codes and lengths
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.BuildTree">
            <summary>
            Not documented
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.GetEncodedLength">
            <summary>
            Get encoded length
            </summary>
            <returns>Encoded length, the sum of frequencies * lengths</returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CalcBLFreq(PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Not documented
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.WriteTree(PdfSharp.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Write tree values
            </summary>
            <param name="blTree">Tree to write</param>
        </member>
        <member name="T:PdfSharp.Pdf.DocumentState">
            <summary>
            Identifies the state of the document
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.DocumentState.Created">
            <summary>
            The document was created from scratch.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.DocumentState.Imported">
            <summary>
            The document was created by opening an existing PDF file.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.DocumentState.Disposed">
            <summary>
            The document is disposed.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfLinkAnnotation">
            <summary>
            Represents a link annotation.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfAnnotation">
            <summary>
            Represents the base class of all annotations.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfAnnotation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Annotations.PdfAnnotation" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfAnnotation.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Annotations.PdfAnnotation" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfAnnotation.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Annotations.PdfAnnotation" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfAnnotation.Delete">
            <summary>
            Removes an annotation from the document
            <seealso cref="M:PdfSharp.Pdf.Annotations.PdfAnnotations.Remove(PdfSharp.Pdf.Annotations.PdfAnnotation)" /></summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotation.Flags">
            <summary>
            Gets or sets the annotation flags of this instance.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotation.Parent">
            <summary>
            Gets or sets the PdfAnnotations object that this annotation belongs to.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotation.Rectangle">
            <summary>
            Gets or sets the annotation rectangle, defining the location of the annotation
            on the page in default user space units.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotation.Title">
            <summary>
            Gets or sets the text label to be displayed in the title bar of the annotation’s
            pop-up window when open and active. By convention, this entry identifies
            the user who added the annotation.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotation.Subject">
            <summary>
            Gets or sets text representing a short description of the subject being
            addressed by the annotation.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotation.Contents">
            <summary>
            Gets or sets the text to be displayed for the annotation or, if this type of
            annotation does not display text, an alternate description of the annotation’s
            contents in human-readable form.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotation.Color">
            <summary>
            Gets or sets the color representing the components of the annotation. If the color
            has an alpha value other than 1, it is ignored. Use property Opacity to get or set the
            opacity of an annotation.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotation.Opacity">
            <summary>
            Gets or sets the constant opacity value to be used in painting the annotation.
            This value applies to all visible elements of the annotation in its closed state
            (including its background and border) but not to the popup window that appears when
            the annotation is opened.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes; if present,
            must be Annot for an annotation dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.Subtype">
            <summary>
            (Required) The type of annotation that this dictionary describes.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.Rect">
            <summary>
            (Required) The annotation rectangle, defining the location of the annotation
            on the page in default user space units.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.Contents">
            <summary>
            (Optional) Text to be displayed for the annotation or, if this type of annotation
            does not display text, an alternate description of the annotation’s contents
            in human-readable form. In either case, this text is useful when
            extracting the document’s contents in support of accessibility to users with
            disabilities or for other purposes.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.NM">
            <summary>
            (Optional; PDF 1.4) The annotation name, a text string uniquely identifying it
            among all the annotations on its page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.M">
            <summary>
            (Optional; PDF 1.1) The date and time when the annotation was most recently
            modified. The preferred format is a date string, but viewer applications should be 
            prepared to accept and display a string in any format.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.F">
            <summary>
            (Optional; PDF 1.1) A set of flags specifying various characteristics of the annotation.
            Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.BS">
            <summary>
            (Optional; PDF 1.2) A border style dictionary specifying the characteristics of
            the annotation’s border.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.AP">
            <summary>
            (Optional; PDF 1.2) An appearance dictionary specifying how the annotation
            is presented visually on the page. Individual annotation handlers may ignore
            this entry and provide their own appearances.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.AS">
            <summary>
            (Required if the appearance dictionary AP contains one or more subdictionaries; PDF 1.2)
            The annotation’s appearance state, which selects the applicable appearance stream from 
            an appearance subdictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.Border">
            <summary>
            (Optional) An array specifying the characteristics of the annotation’s border.
            The border is specified as a rounded rectangle.
            In PDF 1.0, the array consists of three numbers defining the horizontal corner 
            radius, vertical corner radius, and border width, all in default user space units.
            If the corner radii are 0, the border has square (not rounded) corners; if the border 
            width is 0, no border is drawn.
            In PDF 1.1, the array may have a fourth element, an optional dash array defining a 
            pattern of dashes and gaps to be used in drawing the border. The dash array is 
            specified in the same format as in the line dash pattern parameter of the graphics state.
            For example, a Border value of [0 0 1 [3 2]] specifies a border 1 unit wide, with
            square corners, drawn with 3-unit dashes alternating with 2-unit gaps. Note that no
            dash phase is specified; the phase is assumed to be 0.
            Note: In PDF 1.2 or later, this entry may be ignored in favor of the BS entry.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.C">
            <summary>
            (Optional; PDF 1.1) An array of three numbers in the range 0.0 to 1.0, representing
            the components of a color in the DeviceRGB color space. This color is used for the
            following purposes:
            • The background of the annotation’s icon when closed
            • The title bar of the annotation’s pop-up window
            • The border of a link annotation
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.A">
            <summary>
            (Optional; PDF 1.1) An action to be performed when the annotation is activated.
            Note: This entry is not permitted in link annotations if a Dest entry is present.
            Also note that the A entry in movie annotations has a different meaning.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.T">
            <summary>
            (Optional; PDF 1.1) The text label to be displayed in the title bar of the annotation’s
            pop-up window when open and active. By convention, this entry identifies
            the user who added the annotation.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.Popup">
            <summary>
            (Optional; PDF 1.3) An indirect reference to a pop-up annotation for entering or
            editing the text associated with this annotation.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.CA">
            <summary>
            (Optional; PDF 1.4) The constant opacity value to be used in painting the annotation.
            This value applies to all visible elements of the annotation in its closed state
            (including its background and border) but not to the popup window that appears when
            the annotation is opened.
            The specified value is not used if the annotation has an appearance stream; in that
            case, the appearance stream must specify any transparency. (However, if the viewer
            regenerates the annotation’s appearance stream, it may incorporate the CA value
            into the stream’s content.)
            The implicit blend mode is Normal.
            Default value: 1.0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotation.Keys.Subj">
            <summary>
            (Optional; PDF 1.5) Text representing a short description of the subject being
            addressed by the annotation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Annotations.PdfLinkAnnotation" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Annotations.PdfLinkAnnotation" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.CreateDocumentLink(PdfSharp.Pdf.PdfRectangle,System.Int32)">
            <summary>
            Creates a link within the current document.
            </summary>
            <param name="rect">The link area in default page coordinates.</param>
            <param name="destinationPage">The one-based destination page number.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.CreateWebLink(PdfSharp.Pdf.PdfRectangle,System.String)">
            <summary>
            Creates a link to the web.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.CreateFileLink(PdfSharp.Pdf.PdfRectangle,System.String)">
            <summary>
            Creates a link to a file.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.Keys.Dest">
            <summary>
            (Optional; not permitted if an A entry is present) A destination to be displayed
            when the annotation is activated.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.Keys.H">
            <summary>
            (Optional; PDF 1.2) The annotation’s highlighting mode, the visual effect to be
            used when the mouse button is pressed or held down inside its active area:
            N (None) No highlighting.
            I (Invert) Invert the contents of the annotation rectangle.
            O (Outline) Invert the annotation’s border.
            P (Push) Display the annotation as if it were being pushed below the surface of the page.
            Default value: I.
            Note: In PDF 1.1, highlighting is always done by inverting colors inside the annotation rectangle.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.Keys.PA">
            <summary>
            (Optional; PDF 1.3) A URI action formerly associated with this annotation. When Web 
            Capture changes and annotation from a URI to a go-to action, it uses this entry to save 
            the data from the original URI action so that it can be changed back in case the target page for 
            the go-to action is subsequently deleted.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfLinkAnnotation.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfPageInheritableObjects">
            <summary>
            Represents a PDF page object.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfPageInheritableObjects.MediaBox">
            <summary />
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfNamedActionNames">
            <summary>
            Specifies the predefined PDF actions.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfNamedActionNames.NextPage">
            <summary>
            Go to next page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfNamedActionNames.PrevPage">
            <summary>
            Go to previous page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfNamedActionNames.FirstPage">
            <summary>
            Go to first page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfNamedActionNames.LastPage">
            <summary>
            Go to last page.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XPoint">
            <summary>
            Represents a pair of floating point x- and y-coordinates that defines a point
            in a two-dimensional plane.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the XPoint class with the specified coordinates.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.#ctor(System.Drawing.Point)">
            <summary>
            Initializes a new instance of the XPoint class with the specified point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.#ctor(System.Drawing.PointF)">
            <summary>
            Initializes a new instance of the XPoint class with the specified point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Equality(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Determines whether two points are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Inequality(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Determines whether two points are not equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.Equals(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Indicates whether the specified points are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.Equals(PdfSharp.Drawing.XPoint)">
            <summary>
            Indicates whether this instance and a specified point are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.Parse(System.String)">
            <summary>
            Parses the point from a string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.ParsePoints(System.String)">
            <summary>
            Parses an array of points from a string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.ToPointF">
            <summary>
            Converts this XPoint to a System.Drawing.Point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.ToString">
            <summary>
            Converts this XPoint to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.ToString(System.IFormatProvider)">
            <summary>
            Converts this XPoint to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts this XPoint to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.ConvertToString(System.String,System.IFormatProvider)">
            <summary>
            Implements ToString.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.Offset(System.Double,System.Double)">
            <summary>
            Offsets the x and y value of this point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Addition(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XVector)">
            <summary>
            Adds a point and a vector.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Addition(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XSize)">
            <summary>
            Adds a point and a size.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.Add(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XVector)">
            <summary>
            Adds a point and a vector.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Subtraction(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XVector)">
            <summary>
            Subtracts a vector from a point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.Subtract(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XVector)">
            <summary>
            Subtracts a vector from a point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Subtraction(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Subtracts a point from a point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Subtraction(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XSize)">
            <summary>
            Subtracts a size from a point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.Subtract(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Subtracts a point from a point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Multiply(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XMatrix)">
            <summary>
            Multiplies a point with a matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.Multiply(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XMatrix)">
            <summary>
            Multiplies a point with a matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Multiply(PdfSharp.Drawing.XPoint,System.Double)">
            <summary>
            Multiplies a point with a scalar value.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Multiply(System.Double,PdfSharp.Drawing.XPoint)">
            <summary>
            Multiplies a point with a scalar value.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Division(PdfSharp.Drawing.XPoint,System.Double)">
            <summary>
            Divides a point by a scalar value.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Explicit(PdfSharp.Drawing.XPoint)~PdfSharp.Drawing.XSize">
            <summary>
            Performs an explicit conversion from XPoint to XSize.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPoint.op_Explicit(PdfSharp.Drawing.XPoint)~PdfSharp.Drawing.XVector">
            <summary>
            Performs an explicit conversion from XPoint to XVector.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XPoint.Empty">
            <summary>
            For convergence with WPF use new XPoint(), not XPoint.Empty
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPoint.X">
            <summary>
            Gets the x-coordinate of this XPoint.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPoint.Y">
            <summary>
            Gets the x-coordinate of this XPoint.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPoint.IsEmpty">
            <summary>
            Indicates whether this XPoint is empty.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XFontMetrics">
            <summary>
            Collects information of a font.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.Name">
            <summary>
            Gets the font name.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.UnitsPerEm">
            <summary>
            Gets the ascent value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.Ascent">
            <summary>
            Gets the ascent value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.Descent">
            <summary>
            Gets the descent value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.AverageWidth">
            <summary>
            Gets the average width.
            </summary>
            <value>The average width.</value>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.CapHeight">
            <summary>
            Gets the height of capital letters.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.Leading">
            <summary>
            Gets the leading value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.MaxWidth">
            <summary>
            Gets the maximum width of a character.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.StemH">
            <summary>
            Gets an internal value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.StemV">
            <summary>
            Gets an internal value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontMetrics.XHeight">
            <summary>
            Gets the height of a character.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphicsUnit">
            <summary>
            Specifies the unit of measure.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicsUnit.Point">
            <summary>
            Specifies a printer's point (1/72 inch) as the unit of measure.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicsUnit.Inch">
            <summary>
            Specifies the inch (2.54 cm) as the unit of measure.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicsUnit.Millimeter">
            <summary>
            Specifies the millimeter as the unit of measure.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicsUnit.Centimeter">
            <summary>
            Specifies the centimeter as the unit of measure.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicsUnit.Presentation">
            <summary>
            Specifies a presentation point (1/96 inch) as the unit of measure.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphicsPdfPageOptions">
            <summary>
            Specifies how the content of an existing PDF page and new content is combined.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicsPdfPageOptions.Append">
            <summary>
            The new content is inserted behind the old content and any subsequent drawing in done above the existing graphic.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicsPdfPageOptions.Prepend">
            <summary>
            The new content is inserted before the old content and any subsequent drawing in done beneath the existing graphic.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicsPdfPageOptions.Replace">
            <summary>
            The new content entirely replaces the old content and any subsequent drawing in done on a blank page.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.ThickThinBarCode">
            <summary>
            Internal base class for several bar code types.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.BarCode">
            <summary>
            Represents the base class of all bar codes.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.CodeBase">
            <summary>
            Represents the base class of all codes.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeBase.#ctor(System.String,PdfSharp.Drawing.XSize,PdfSharp.Drawing.BarCodes.CodeDirection)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.BarCodes.CodeBase" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeBase.CheckCode(System.String)">
            <summary>
            When implemented in a derived class, determines whether the specified string can be used as Text
            for this bar code type.
            </summary>
            <param name="text">The code string to check.</param>
            <returns>True if the text can be used for the actual barcode.</returns>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeBase.CalcDistance(PdfSharp.Drawing.BarCodes.AnchorType,PdfSharp.Drawing.BarCodes.AnchorType,PdfSharp.Drawing.XSize)">
            <summary>
            Calculates the distance between an old anchor point and a new anchor point.
            </summary>
            <param name="oldType" />
            <param name="newType" />
            <param name="size" />
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.CodeBase.Size">
            <summary>
            Gets or sets the size.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.CodeBase.Text">
            <summary>
            Gets or sets the text the bar code shall represent.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.CodeBase.Anchor">
            <summary>
            Always MiddleCenter.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.CodeBase.Direction">
            <summary>
            Gets or sets the drawing direction.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.BarCode.#ctor(System.String,PdfSharp.Drawing.XSize,PdfSharp.Drawing.BarCodes.CodeDirection)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.BarCodes.BarCode" /> class.
            </summary>
            <param name="text" />
            <param name="size" />
            <param name="direction" />
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.BarCode.FromType(PdfSharp.Drawing.BarCodes.CodeType,System.String,PdfSharp.Drawing.XSize,PdfSharp.Drawing.BarCodes.CodeDirection)">
            <summary>
            Creates a bar code from the specified code type.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.BarCode.FromType(PdfSharp.Drawing.BarCodes.CodeType,System.String,PdfSharp.Drawing.XSize)">
            <summary>
            Creates a bar code from the specified code type.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.BarCode.FromType(PdfSharp.Drawing.BarCodes.CodeType,System.String)">
            <summary>
            Creates a bar code from the specified code type.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.BarCode.FromType(PdfSharp.Drawing.BarCodes.CodeType)">
            <summary>
            Creates a bar code from the specified code type.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.BarCode.Render(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XPoint)">
            <summary>
            When defined in a derived class renders the code.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.BarCode.WideNarrowRatio">
            <summary>
            When overridden in a derived class gets or sets the wide narrow ratio.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.BarCode.TextLocation">
            <summary>
            Gets or sets the location of the text next to the bar code.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.BarCode.DataLength">
            <summary>
            Gets or sets the length of the data that defines the bar code.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.BarCode.StartChar">
            <summary>
            Gets or sets the optional start character.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.BarCode.EndChar">
            <summary>
            Gets or sets the optional end character.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.BarCode.TurboBit">
            <summary>
            Gets or sets a value indicating whether the turbo bit is to be drawn.
            (A turbo bit is something special to Kern (computer output processing) company (as far as I know))
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.ThickThinBarCode.#ctor(System.String,PdfSharp.Drawing.XSize,PdfSharp.Drawing.BarCodes.CodeDirection)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.BarCodes.ThickThinBarCode" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.ThickThinBarCode.RenderBar(PdfSharp.Drawing.BarCodes.BarCodeRenderInfo,System.Boolean)">
            <summary>
            Renders a thick or thin line for the bar code.
            </summary>
            <param name="info" />
            <param name="isThick">Determines whether a thick or a thin line is about to be rendered.</param>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.ThickThinBarCode.RenderGap(PdfSharp.Drawing.BarCodes.BarCodeRenderInfo,System.Boolean)">
            <summary>
            Renders a thick or thin gap for the bar code.
            </summary>
            <param name="info" />
            <param name="isThick">Determines whether a thick or a thin gap is about to be rendered.</param>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.ThickThinBarCode.RenderTurboBit(PdfSharp.Drawing.BarCodes.BarCodeRenderInfo,System.Boolean)">
            <summary>
            Renders a thick bar before or behind the code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.ThickThinBarCode.GetBarWidth(PdfSharp.Drawing.BarCodes.BarCodeRenderInfo,System.Boolean)">
            <summary>
            Gets the width of a thick or a thin line (or gap). CalcLineWidth must have been called before.
            </summary>
            <param name="info" />
            <param name="isThick">Determines whether a thick line's with shall be returned.</param>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.ThickThinBarCode.WideNarrowRatio">
            <summary>
            Gets or sets the ration between thick an thin lines. Must be between 2 and 3.
            Optimal and also default value is 2.6.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.Code3of9Standard">
            <summary>
            Imlpementation of the Code 3 of 9 bar code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code3of9Standard.#ctor">
            <summary>
            Initializes a new instance of Standard3of9.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code3of9Standard.#ctor(System.String)">
            <summary>
            Initializes a new instance of Standard3of9.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code3of9Standard.#ctor(System.String,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of Standard3of9.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code3of9Standard.#ctor(System.String,PdfSharp.Drawing.XSize,PdfSharp.Drawing.BarCodes.CodeDirection)">
            <summary>
            Initializes a new instance of Standard3of9.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code3of9Standard.ThickThinLines(System.Char)">
            <summary>
            Returns an array of size 9 that represents the thick (true) and thin (false) lines and spaces
            representing the specified digit.
            </summary>
            <param name="ch">The character to represent.</param>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code3of9Standard.CalcThinBarWidth(PdfSharp.Drawing.BarCodes.BarCodeRenderInfo)">
            <summary>
            Calculates the thick and thin line widths,
            taking into account the required rendering size.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code3of9Standard.CheckCode(System.String)">
            <summary>
            Checks the code to be convertible into an standard 3 of 9 bar code.
            </summary>
            <param name="text">The code to be checked.</param>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code3of9Standard.Render(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XPoint)">
            <summary>
            Renders the bar code.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfSignatureField">
            <summary>
            Represents the signature field.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfAcroField">
            <summary>
            Represents the base class for all interactive field dictionaries.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfAcroField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of PdfAcroField.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfAcroField.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.AcroForms.PdfAcroField" /> class. Used for type transformation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfAcroField.GetValue(System.String)">
            <summary>
            Gets a child field by name.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.Name">
            <summary>
            Gets the name of this field.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.Flags">
            <summary>
            Gets the field flags of this instance.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.Value">
            <summary>
            Gets or sets the value of the field.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.ReadOnly">
            <summary>
            Gets or sets a value indicating whether the field is read only.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.Item(System.String)">
            <summary>
            Gets the field with the specified name.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.HasKids">
            <summary>
            Indicates whether the field has child fields.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.DescendantNames">
            <summary>
            Gets the names of all descendants of this field.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.Fields">
            <summary>
            Gets the collection of fields within this field.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfAcroField.PdfAcroFieldCollection">
            <summary>
            Holds a collection of interactive fields.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfArray">
            <summary>
            Represents a PDF array object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfArray" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfArray" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.#ctor(PdfSharp.Pdf.PdfDocument,PdfSharp.Pdf.PdfItem[])">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfArray" /> class.
            </summary>
            <param name="document">The document.</param>
            <param name="items">The items.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.#ctor(PdfSharp.Pdf.PdfArray)">
            <summary>
            Initializes a new instance from an existing dictionary. Used for object type transformation.
            </summary>
            <param name="array">The array.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.Clone">
            <summary>
            Creates a copy of this array. Direct elements are deep copied. Indirect references are not
            modified.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.Copy">
            <summary>
            Implements the copy mechanism.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ToString">
            <summary>
            Returns a string with the content of this object in a readable form. Useful for debugging purposes only.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfArray.Elements">
            <summary>
            Gets the collection containing the elements of this object.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfArray.ArrayElements">
            <summary>
            Represents the elements of an PdfArray.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.Clone">
            <summary>
            Creates a shallow copy of this object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.SetOwner(PdfSharp.Pdf.PdfArray)">
            <summary>
            Moves this instance to another dictionary during object type transformation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetBoolean(System.Int32)">
            <summary>
            Converts the specified value to boolean.
            If the value not exists, the function returns false.
            If the value is not convertible, the function throws an InvalidCastException.
            If the index is out of range, the function throws an ArgumentOutOfRangeException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetInteger(System.Int32)">
            <summary>
            Converts the specified value to integer.
            If the value not exists, the function returns 0.
            If the value is not convertible, the function throws an InvalidCastException.
            If the index is out of range, the function throws an ArgumentOutOfRangeException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetReal(System.Int32)">
            <summary>
            Converts the specified value to double.
            If the value not exists, the function returns 0.
            If the value is not convertible, the function throws an InvalidCastException.
            If the index is out of range, the function throws an ArgumentOutOfRangeException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetString(System.Int32)">
            <summary>
            Converts the specified value to string.
            If the value not exists, the function returns the empty string.
            If the value is not convertible, the function throws an InvalidCastException.
            If the index is out of range, the function throws an ArgumentOutOfRangeException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetName(System.Int32)">
            <summary>
            Converts the specified value to a name.
            If the value not exists, the function returns the empty string.
            If the value is not convertible, the function throws an InvalidCastException.
            If the index is out of range, the function throws an ArgumentOutOfRangeException.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetIndirectObject(System.Int32)">
            <summary>
            Returns the indirect object if the value at the specified index is a PdfReference.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetObject(System.Int32)">
            <summary>
            Gets the PdfObject with the specified index, or null, if no such object exists. If the index refers to
            a reference, the referenced PdfObject is returned.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetDictionary(System.Int32)">
            <summary>
            Gets the PdfArray with the specified index, or null, if no such object exists. If the index refers to
            a reference, the referenced PdfArray is returned.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetArray(System.Int32)">
            <summary>
            Gets the PdfArray with the specified index, or null, if no such object exists. If the index refers to
            a reference, the referenced PdfArray is returned.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetReference(System.Int32)">
            <summary>
            Gets the PdfReference with the specified index, or null, if no such object exists.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the specified index.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.Remove(PdfSharp.Pdf.PdfItem)">
            <summary>
            Removes the first occurrence of a specific object from the array/&gt;.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.Insert(System.Int32,PdfSharp.Pdf.PdfItem)">
            <summary>
            Inserts the item the specified index.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.Contains(PdfSharp.Pdf.PdfItem)">
            <summary>
            Determines whether the specified value is in the array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.Clear">
            <summary>
            Removes all items from the array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.IndexOf(PdfSharp.Pdf.PdfItem)">
            <summary>
            Gets the index of the specified item.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.Add(PdfSharp.Pdf.PdfItem)">
            <summary>
            Appends the specified object to the array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.CopyTo(PdfSharp.Pdf.PdfItem[],System.Int32)">
            <summary>
            Copies the elements of the array to the specified array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfArray.ArrayElements.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the array.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfArray.ArrayElements.Items">
            <summary>
            Gets all items of this array.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfArray.ArrayElements.IsReadOnly">
            <summary>
            Returns false.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfArray.ArrayElements.Item(System.Int32)">
            <summary>
            Gets or sets an item at the specified index.
            </summary>
            <value />
        </member>
        <member name="P:PdfSharp.Pdf.PdfArray.ArrayElements.IsFixedSize">
            <summary>
            Returns false.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfArray.ArrayElements.IsSynchronized">
            <summary>
            Returns false.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfArray.ArrayElements.Count">
            <summary>
            Gets the number of elements in the array.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfArray.ArrayElements.SyncRoot">
            <summary>
            The current implementation return null.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfAcroField.PdfAcroFieldCollection.CreateAcroField(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Create a derived type like PdfTextField or PdfCheckBox if possible.
            If the actual cannot be guessed by PDFsharp the function returns an instance
            of PdfGenericField.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.PdfAcroFieldCollection.Names">
            <summary>
            Gets the names of all fields in the collection.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.PdfAcroFieldCollection.DescendantNames">
            <summary>
            Gets an array of all descendant names.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.PdfAcroFieldCollection.Item(System.Int32)">
            <summary>
            Gets a field from the collection. For your convenience an instance of a derived class like
            PdfTextField or PdfCheckBox is returned if PDFsharp can guess the actual type of the dictionary.
            If the actual type cannot be guessed by PDFsharp the function returns an instance
            of PdfGenericField.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroField.PdfAcroFieldCollection.Item(System.String)">
            <summary>
            Gets the field with the specified name.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.FT">
            <summary>
            (Required for terminal fields; inheritable) The type of field that this dictionary
            describes:
              Btn           Button
              Tx            Text
              Ch            Choice
              Sig (PDF 1.3) Signature
            Note: This entry may be present in a nonterminal field (one whose descendants
            are themselves fields) in order to provide an inheritable FT value. However, a
            nonterminal field does not logically have a type of its own; it is merely a container
            for inheritable attributes that are intended for descendant terminal fields of
            any type.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.Parent">
            <summary>
            (Required if this field is the child of another in the field hierarchy; absent otherwise)
            The field that is the immediate parent of this one (the field, if any, whose Kids array
            includes this field). A field can have at most one parent; that is, it can be included
            in the Kids array of at most one other field.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.Kids">
            <summary>
            (Optional) An array of indirect references to the immediate children of this field.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.T">
            <summary>
            (Optional) The partial field name.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.TU">
            <summary>
            (Optional; PDF 1.3) An alternate field name, to be used in place of the actual
            field name wherever the field must be identified in the user interface (such as
            in error or status messages referring to the field). This text is also useful
            when extracting the document’s contents in support of accessibility to disabled
            users or for other purposes.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.TM">
            <summary>
            (Optional; PDF 1.3) The mapping name to be used when exporting interactive form field 
            data from the document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.Ff">
            <summary>
            (Optional; inheritable) A set of flags specifying various characteristics of the field.
            Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.V">
            <summary>
            (Optional; inheritable) The field’s value, whose format varies depending on
            the field type; see the descriptions of individual field types for further information.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.DV">
            <summary>
            (Optional; inheritable) The default value to which the field reverts when a
            reset-form action is executed. The format of this value is the same as that of V.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.AA">
            <summary>
            (Optional; PDF 1.2) An additional-actions dictionary defining the field’s behavior
            in response to various trigger events. This entry has exactly the same meaning as
            the AA entry in an annotation dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.DR">
            <summary>
            (Required; inheritable) A resource dictionary containing default resources
            (such as fonts, patterns, or color spaces) to be used by the appearance stream.
            At a minimum, this dictionary must contain a Font entry specifying the resource
            name and font dictionary of the default font for displaying the field’s text.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.DA">
            <summary>
            (Required; inheritable) The default appearance string, containing a sequence of
            valid page-content graphics or text state operators defining such properties as
            the field’s text size and color.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroField.Keys.Q">
            <summary>
            (Optional; inheritable) A code specifying the form of quadding (justification)
            to be used in displaying the text:
              0 Left-justified
              1 Centered
              2 Right-justified
            Default value: 0 (left-justified).
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfSignatureField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of PdfSignatureField.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfSignatureField.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys">
            <summary>
            Predefined keys of this dictionary.
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes; if present,
            must be Sig for a signature dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys.Filter">
            <summary>
            (Required; inheritable) The name of the signature handler to be used for
            authenticating the field’s contents, such as Adobe.PPKLite, Entrust.PPKEF,
            CICI.SignIt, or VeriSign.PPKVS.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys.SubFilter">
            <summary>
            (Optional) The name of a specific submethod of the specified handler.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys.ByteRange">
            <summary>
            (Required) An array of pairs of integers (starting byte offset, length in bytes)
            describing the exact byte range for the digest calculation. Multiple discontinuous
            byte ranges may be used to describe a digest that does not include the
            signature token itself.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys.Contents">
            <summary>
            (Required) The encrypted signature token.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys.Name">
            <summary>
            (Optional) The name of the person or authority signing the document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys.M">
            <summary>
            (Optional) The time of signing. Depending on the signature handler, this
            may be a normal unverified computer time or a time generated in a verifiable
            way from a secure time server.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys.Location">
            <summary>
            (Optional) The CPU host name or physical location of the signing.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys.Reason">
            <summary>
            (Optional) The reason for the signing, such as (I agree…).
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfSignatureField.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfAcroForm">
            <summary>
            Represents a interactive form (or AcroForm), a collection of fields for 
            gathering information interactively from the user.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfAcroForm.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of AcroForm.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroForm.Fields">
            <summary>
            Gets the fields collection of this form.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroForm.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfAcroForm.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroForm.Keys.Fields">
            <summary>
            (Required) An array of references to the document’s root fields (those with
            no ancestors in the field hierarchy).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroForm.Keys.NeedAppearances">
            <summary>
            (Optional) A flag specifying whether to construct appearance streams and
            appearance dictionaries for all widget annotations in the document.
            Default value: false.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroForm.Keys.SigFlags">
            <summary>
            (Optional; PDF 1.3) A set of flags specifying various document-level characteristics
            related to signature fields.
            Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroForm.Keys.CO">
            <summary>
            (Required if any fields in the document have additional-actions dictionaries
            containing a C entry; PDF 1.3) An array of indirect references to field dictionaries
            with calculation actions, defining the calculation order in which their values will 
            be recalculated when the value of any field changes.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroForm.Keys.DR">
            <summary>
            (Optional) A document-wide default value for the DR attribute of variable text fields.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroForm.Keys.DA">
            <summary>
            (Optional) A document-wide default value for the DA attribute of variable text fields.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroForm.Keys.Q">
            <summary>
            (Optional) A document-wide default value for the Q attribute of variable text fields.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfAcroForm.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.NamespaceDoc">
            <summary>
            Base namespace of PDFsharp. Most classes are implemented in nested namespaces like e. g. PdfSharp.Pdf.
            </summary>
            <seealso cref="N:PdfSharp.Pdf" />
        </member>
        <member name="T:PdfSharp.PageOrientation">
            <summary>
            Specifies the orientation of a page.
            </summary>
        </member>
        <member name="F:PdfSharp.PageOrientation.Portrait">
            <summary>
            The default page orientation.
            </summary>
        </member>
        <member name="F:PdfSharp.PageOrientation.Landscape">
            <summary>
            The width and height of the page are reversed.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.Streams.OutputWindow">
            <summary>
            Contains the output from the Inflation process.
            We need to have a window so that we can refer backwards into the output stream
            to repeat stuff.<br />
            Author of the original java version: John Leuner
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.OutputWindow.Write(System.Int32)">
            <summary>
            Write a byte to this output window
            </summary>
            <param name="abyte">value to write</param>
            <exception cref="T:System.InvalidOperationException">
            if window is full
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.OutputWindow.Repeat(System.Int32,System.Int32)">
            <summary>
            Append a byte pattern already in the window itself
            </summary>
            <param name="len">length of pattern to copy</param>
            <param name="dist">distance from end of window pattern occurs</param>
            <exception cref="T:System.InvalidOperationException">
            If the repeated data overflows the window
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyStored(PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator,System.Int32)">
            <summary>
            Copy from input manipulator to internal window
            </summary>
            <param name="input">source of data</param>
            <param name="len">length of data to copy</param>
            <returns>the number of bytes copied</returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyDict(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy dictionary to window
            </summary>
            <param name="dict">source dictionary</param>
            <param name="offset">offset of start in source dictionary</param>
            <param name="len">length of dictionary</param>
            <exception cref="T:System.InvalidOperationException">
            If window isnt empty
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetFreeSpace">
            <summary>
            Get remaining unfilled space in window
            </summary>
            <returns>Number of bytes left in window</returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">
            <summary>
            Get bytes available for output in window
            </summary>
            <returns>Number of bytes filled</returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy contents of window to output
            </summary>
            <param name="output">buffer to copy to</param>
            <param name="offset">offset to start at</param>
            <param name="len">number of bytes to count</param>
            <returns>The number of bytes copied</returns>
            <exception cref="T:System.InvalidOperationException">
            If a window underflow occurs
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.OutputWindow.Reset">
            <summary>
            Reset by clearing window so <see cref="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">GetAvailable</see> returns 0
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.KeyDescriptor">
            <summary>
            Hold information about the value of a key in a dictionary. This information is used to create
            and interpret this value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.KeyDescriptor.#ctor(PdfSharp.Pdf.KeyInfoAttribute)">
            <summary>
            Initializes a new instance of KeyDescriptor from the specified attribute during a KeysMeta
            initializes itself using reflection.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.KeyDescriptor.GetValueType">
            <summary>
            Returns the type of the object to be created as value for the described key.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.KeyDescriptor.Version">
            <summary>
            Gets or sets the PDF version starting with the availability of the described key.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.DictionaryMeta">
            <summary>
            Contains meta information about all keys of a PDF dictionary.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.PdfReaderException">
            <summary>
            Exception thrown by PdfReader.
            </summary>
        </member>
        <member name="T:PdfSharp.PdfSharpException">
            <summary>
            Base class of all exceptions in the PDFsharp frame work.
            </summary>
        </member>
        <member name="M:PdfSharp.PdfSharpException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.PdfSharpException" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.PdfSharpException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.PdfSharpException" /> class.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:PdfSharp.PdfSharpException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.PdfSharpException" /> class.
            </summary>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReaderException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.IO.PdfReaderException" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReaderException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.IO.PdfReaderException" /> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReaderException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.IO.PdfReaderException" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfShadingPattern">
            <summary>
            Represents a shading pattern dictionary.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream">
            <summary>
            Represents a base class for dictionaries with a content stream.
            Implement IContentStream for use with a content writer.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Initializes a new instance from an existing dictionary. Used for object type transformation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.GetImageName(PdfSharp.Drawing.XImage)">
            <summary>
            Gets the resource name of the specified image within this dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.PdfSharp#Pdf#Advanced#IContentStream#GetImageName(PdfSharp.Drawing.XImage)">
            <summary>
            Implements the interface because the primary function is internal.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.GetFormName(PdfSharp.Drawing.XForm)">
            <summary>
            Gets the resource name of the specified form within this dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.PdfSharp#Pdf#Advanced#IContentStream#GetFormName(PdfSharp.Drawing.XForm)">
            <summary>
            Implements the interface because the primary function is internal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.Resources">
            <summary>
            Gets the resources dictionary of this dictionary. If no such dictionary exists, it is created.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.PdfSharp#Pdf#Advanced#IContentStream#Resources">
            <summary>
            Implements the interface because the primary function is internal.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfDictionaryWithContentStream.Keys.Resources">
            <summary>
            (Optional but strongly recommended; PDF 1.2) A dictionary specifying any
            resources (such as fonts and images) required by the form XObject.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfShadingPattern.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfShadingPattern" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfShadingPattern.SetupFromBrush(PdfSharp.Drawing.XLinearGradientBrush,PdfSharp.Drawing.XMatrix)">
            <summary>
            Setups the shading pattern from the specified brush.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfShadingPattern.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfShadingPattern.Keys">
            <summary>
            Common keys for all streams.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShadingPattern.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes; if present,
            must be Pattern for a pattern dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShadingPattern.Keys.PatternType">
            <summary>
            (Required) A code identifying the type of pattern that this dictionary describes;
            must be 2 for a shading pattern.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShadingPattern.Keys.Shading">
            <summary>
            (Required) A shading object (see below) defining the shading pattern’s gradient fill.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShadingPattern.Keys.Matrix">
            <summary>
            (Optional) An array of six numbers specifying the pattern matrix.
            Default value: the identity matrix [1 0 0 1 0 0].
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShadingPattern.Keys.ExtGState">
            <summary>
            (Optional) A graphics state parameter dictionary containing graphics state parameters
            to be put into effect temporarily while the shading pattern is painted. Any parameters
            that are not so specified are inherited from the graphics state that was in effect
            at the beginning of the content stream in which the pattern is defined as a resource.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfShadingPattern.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFormXObject">
            <summary>
            Represents an external form object (e.g. an imported page).
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfXObject">
            <summary>
            Base class for all PDF external objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfXObject.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfXObject" /> class.
            </summary>
            <param name="document">The document that owns the object.</param>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfXObject.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFormXObject.GetFontName(System.String,System.Byte[],PdfSharp.Pdf.Advanced.PdfFont@)">
            <summary>
            Gets the resource name of the specified font data within this form XObject.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFormXObject.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFormXObject.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFormXObject.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes; if present,
            must be XObject for a form XObject.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFormXObject.Keys.Subtype">
            <summary>
            (Required) The type of XObject that this dictionary describes; must be Form
            for a form XObject.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFormXObject.Keys.FormType">
            <summary>
            (Optional) A code identifying the type of form XObject that this dictionary
            describes. The only valid value defined at the time of publication is 1.
            Default value: 1.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFormXObject.Keys.BBox">
            <summary>
            (Required) An array of four numbers in the form coordinate system, giving the 
            coordinates of the left, bottom, right, and top edges, respectively, of the 
            form XObject’s bounding box. These boundaries are used to clip the form XObject
            and to determine its size for caching.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFormXObject.Keys.Matrix">
            <summary>
            (Optional) An array of six numbers specifying the form matrix, which maps
            form space into user space.
            Default value: the identity matrix [1 0 0 1 0 0].
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFormXObject.Keys.Resources">
            <summary>
            (Optional but strongly recommended; PDF 1.2) A dictionary specifying any
            resources (such as fonts and images) required by the form XObject.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFormXObject.Keys.Group">
            <summary>
            (Optional; PDF 1.4) A group attributes dictionary indicating that the contents
            of the form XObject are to be treated as a group and specifying the attributes
            of that group (see Section 4.9.2, “Group XObjects”).
            Note: If a Ref entry (see below) is present, the group attributes also apply to the
            external page imported by that entry, which allows such an imported page to be
            treated as a group without further modification.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFormXObject.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.BarCodeRenderInfo">
            <summary>
            Holds all temporary information needed during rendering.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.CObject">
            <summary>
            Base class for all PDF content stream objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Content.Objects.CObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CObject.System#ICloneable#Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CObject.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CObject.Copy">
            <summary>
            Implements the copy mechanism. Must be overridden in derived classes.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CObject.WriteObject(PdfSharp.Pdf.Content.ContentWriter)">
            <summary />
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.CComment">
            <summary>
            Represents a comment in a PDF content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CComment.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CComment.Copy">
            <summary>
            Implements the copy mechanism of this class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CComment.ToString">
            <summary>
            Returns a string that represents the current comment.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.Objects.CComment.Text">
            <summary>
            Gets or sets the comment text.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.CSequence">
            <summary>
            Represents a sequence of objects in a PDF content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.Copy">
            <summary>
            Implements the copy mechanism of this class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.Add(PdfSharp.Pdf.Content.Objects.CSequence)">
            <summary>
            Adds the specified sequence.
            </summary>
            <param name="sequence">The sequence.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.Add(PdfSharp.Pdf.Content.Objects.CObject)">
            <summary>
            Adds the specified value add the end of the sequence.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.Clear">
            <summary>
            Removes all elements from the sequence.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.Contains(PdfSharp.Pdf.Content.Objects.CObject)">
            <summary>
            Determines whether the specified value is in the sequence.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.IndexOf(PdfSharp.Pdf.Content.Objects.CObject)">
            <summary>
            Returns the index of the specified value in the sequence or -1, if no such value is in the sequence.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.Insert(System.Int32,PdfSharp.Pdf.Content.Objects.CObject)">
            <summary>
            Inserts the specified value in the sequence.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.Remove(PdfSharp.Pdf.Content.Objects.CObject)">
            <summary>
            Removes the specified value from the sequence.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.RemoveAt(System.Int32)">
            <summary>
            Removes the value at the specified index from the sequence.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.CopyTo(PdfSharp.Pdf.Content.Objects.CObject[],System.Int32)">
            <summary>
            Copies the elements of the sequence to the specified array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the sequence.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.ToContent">
            <summary>
            Converts the sequence to a PDF content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CSequence.ToString">
            <summary>
            Returns a string containing all elements of the sequence.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.Objects.CSequence.Item(System.Int32)">
            <summary>
            Gets or sets a CObject at the specified index.
            </summary>
            <value />
        </member>
        <member name="P:PdfSharp.Pdf.Content.Objects.CSequence.Count">
            <summary>
            Gets the number of elements contained in the sequence.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.CNumber">
            <summary>
            Represents the base class for numerical objects in a PDF content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CNumber.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CNumber.Copy">
            <summary>
            Implements the copy mechanism of this class.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.CInteger">
            <summary>
            Represents an integer value in a PDF content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CInteger.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CInteger.Copy">
            <summary>
            Implements the copy mechanism of this class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CInteger.ToString">
            <summary>
            Returns a string that represents the current value.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.Objects.CInteger.Value">
            <summary>
            Gets or sets the value.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.CReal">
            <summary>
            Represents a real value in a PDF content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CReal.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CReal.Copy">
            <summary>
            Implements the copy mechanism of this class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CReal.ToString">
            <summary>
            Returns a string that represents the current value.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.Objects.CReal.Value">
            <summary>
            Gets or sets the value.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.CString">
            <summary>
            Represents a string value in a PDF content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CString.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CString.Copy">
            <summary>
            Implements the copy mechanism of this class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CString.ToString">
            <summary>
            Returns a string that represents the current value.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.Objects.CString.Value">
            <summary>
            Gets or sets the value.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.CName">
            <summary>
            Represents a name in a PDF content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CName.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Content.Objects.CName" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CName.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Content.Objects.CName" /> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CName.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CName.Copy">
            <summary>
            Implements the copy mechanism of this class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CName.ToString">
            <summary>
            Returns a string that represents the current value.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.Objects.CName.Name">
            <summary>
            Gets or sets the name. Names must start with a slash.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.CArray">
            <summary>
            Represents an array of objects in a PDF content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CArray.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CArray.Copy">
            <summary>
            Implements the copy mechanism of this class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.CArray.ToString">
            <summary>
            Returns a string that represents the current value.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.COperator">
            <summary>
            Represents an operator a PDF content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.COperator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Content.Objects.COperator" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.COperator.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.COperator.Copy">
            <summary>
            Implements the copy mechanism of this class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.Objects.COperator.ToString">
            <summary>
            Returns a string that represents the current operator.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.Objects.COperator.Name">
            <summary>
            Gets or sets the name of the operator
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:PdfSharp.Pdf.Content.Objects.COperator.Operands">
            <summary>
            Gets or sets the operands.
            </summary>
            <value>The operands.</value>
        </member>
        <member name="P:PdfSharp.Pdf.Content.Objects.COperator.OpCode">
            <summary>
            Gets the operator description for this instance.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfObjectInternals">
            <summary>
            Provides access to the internal PDF object data structures. This class prevents the public
            interfaces from pollution with to much internal functions.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfObjectInternals.ObjectID">
            <summary>
            Gets the object identifier. Returns PdfObjectID.Empty for direct objects.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfObjectInternals.ObjectNumber">
            <summary>
            Gets the object number.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfObjectInternals.GenerationNumber">
            <summary>
            Gets the generation number.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfObjectInternals.TypeID">
            <summary>
            Gets the name of the current type.
            Not a very useful property, but can be used for data binding.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags">
            <summary>
            Specifies the flags of AcroForm fields.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.ReadOnly">
            <summary>
            If set, the user may not change the value of the field. Any associated widget
            annotations will not interact with the user; that is, they will not respond to 
            mouse clicks or change their appearance in response to mouse motions. This
            flag is useful for fields whose values are computed or imported from a database.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.Required">
            <summary>
            If set, the field must have a value at the time it is exported by a submit-form action.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.NoExport">
            <summary>
            If set, the field must not be exported by a submit-form action.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.Pushbutton">
            <summary>
            If set, the field is a pushbutton that does not retain a permanent value.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.Radio">
            <summary>
            If set, the field is a set of radio buttons; if clear, the field is a checkbox.
            This flag is meaningful only if the Pushbutton flag is clear.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.NoToggleToOff">
            <summary>
            (Radio buttons only) If set, exactly one radio button must be selected at all times;
            clicking the currently selected button has no effect. If clear, clicking
            the selected button deselects it, leaving no button selected.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.Multiline">
            <summary>
            If set, the field may contain multiple lines of text; if clear, the field’s text
            is restricted to a single line.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.Password">
            <summary>
            If set, the field is intended for entering a secure password that should
            not be echoed visibly to the screen. Characters typed from the keyboard
            should instead be echoed in some unreadable form, such as
            asterisks or bullet characters.
            To protect password confidentiality, viewer applications should never
            store the value of the text field in the PDF file if this flag is set.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.FileSelect">
            <summary>
            (PDF 1.4) If set, the text entered in the field represents the pathname of
            a file whose contents are to be submitted as the value of the field.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.DoNotSpellCheckTextField">
            <summary>
            (PDF 1.4) If set, the text entered in the field will not be spell-checked.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.DoNotScroll">
            <summary>
            (PDF 1.4) If set, the field will not scroll (horizontally for single-line
            fields, vertically for multiple-line fields) to accommodate more text
            than will fit within its annotation rectangle. Once the field is full, no
            further text will be accepted.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.Combo">
            <summary>
            If set, the field is a combo box; if clear, the field is a list box.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.Edit">
            <summary>
            If set, the combo box includes an editable text box as well as a drop list;
            if clear, it includes only a drop list. This flag is meaningful only if the
            Combo flag is set.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.Sort">
            <summary>
            If set, the field’s option items should be sorted alphabetically. This flag is
            intended for use by form authoring tools, not by PDF viewer applications;
            viewers should simply display the options in the order in which they occur 
            in the Opt array.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.MultiSelect">
            <summary>
            (PDF 1.4) If set, more than one of the field’s option items may be selected
            simultaneously; if clear, no more than one item at a time may be selected.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfAcroFieldFlags.DoNotSpellCheckChoiseField">
            <summary>
            (PDF 1.4) If set, the text entered in the field will not be spell-checked.
            This flag is meaningful only if the Combo and Edit flags are both set.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfReadingDirection">
            <summary>
            Specifies how the document should be displayed by a viewer when opened.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfReadingDirection.LeftToRight">
            <summary>
            Left to right.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfReadingDirection.RightToLeft">
            <summary>
            Right to left (including vertical writing systems, such as Chinese, Japanese, and Korean)
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Internal.ColorSpaceHelper">
            <summary>
            Helper functions for RGB and CMYK colors.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.ColorSpaceHelper.EnsureColorMode(PdfSharp.Pdf.PdfColorMode,PdfSharp.Drawing.XColor)">
            <summary>
            Checks whether a color mode and a color match.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.ColorSpaceHelper.EnsureColorMode(PdfSharp.Pdf.PdfDocument,PdfSharp.Drawing.XColor)">
            <summary>
            Checks whether the color mode of a document and a color match.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.ColorSpaceHelper.IsEqualCmyk(PdfSharp.Drawing.XColor,PdfSharp.Drawing.XColor)">
            <summary>
            Determines whether two colors are equal referring to their CMYK color values.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfResources">
            <summary>
            Represents a PDF resource object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfResources.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfResources" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfResources.AddFont(PdfSharp.Pdf.Advanced.PdfFont)">
            <summary>
            Adds the specified font to this resource dictionary and returns its local resource name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfResources.AddImage(PdfSharp.Pdf.Advanced.PdfImage)">
            <summary>
            Adds the specified image to this resource dictionary
            and returns its local resource name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfResources.AddForm(PdfSharp.Pdf.Advanced.PdfFormXObject)">
            <summary>
            Adds the specified form object to this resource dictionary
            and returns its local resource name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfResources.AddExtGState(PdfSharp.Pdf.Advanced.PdfExtGState)">
            <summary>
            Adds the specified graphics state to this resource dictionary
            and returns its local resource name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfResources.AddPattern(PdfSharp.Pdf.Advanced.PdfShadingPattern)">
            <summary>
            Adds the specified pattern to this resource dictionary
            and returns its local resource name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfResources.AddPattern(PdfSharp.Pdf.Advanced.PdfTilingPattern)">
            <summary>
            Adds the specified pattern to this resource dictionary
            and returns its local resource name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfResources.AddShading(PdfSharp.Pdf.Advanced.PdfShading)">
            <summary>
            Adds the specified shading to this resource dictionary
            and returns its local resource name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfResources.ExistsResourceNames(System.String)">
            <summary>
            Check whether a resource name is already used in the context of this resource dictionary.
            PDF4NET uses GUIDs as resource names, but I think this weapon is to heavy.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfResources.importedResourceNames">
            <summary>
            All the names of imported resources.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfResources.resources">
            <summary>
            Maps all PDFsharp resources to their local resource names.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfResources.Fonts">
            <summary>
            Gets the fonts map.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfResources.XObjects">
            <summary>
            Gets the external objects map.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfResources.NextFontName">
            <summary>
            Gets a new local name for this resource.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfResources.NextImageName">
            <summary>
            Gets a new local name for this resource.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfResources.NextFormName">
            <summary>
            Gets a new local name for this resource.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfResources.NextExtGStateName">
            <summary>
            Gets a new local name for this resource.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfResources.NextPatternName">
            <summary>
            Gets a new local name for this resource.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfResources.NextShadingName">
            <summary>
            Gets a new local name for this resource.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfResources.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfResources.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfResources.Keys.ExtGState">
            <summary>
            (Optional) A dictionary that maps resource names to graphics state 
            parameter dictionaries.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfResources.Keys.ColorSpace">
            <summary>
            (Optional) A dictionary that maps each resource name to either the name of a
            device-dependent color space or an array describing a color space.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfResources.Keys.Pattern">
            <summary>
            (Optional) A dictionary that maps each resource name to either the name of a
            device-dependent color space or an array describing a color space.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfResources.Keys.Shading">
            <summary>
            (Optional; PDF 1.3) A dictionary that maps resource names to shading dictionaries.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfResources.Keys.XObject">
            <summary>
            (Optional) A dictionary that maps resource names to external objects.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfResources.Keys.Font">
            <summary>
            (Optional) A dictionary that maps resource names to font dictionaries.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfResources.Keys.ProcSet">
            <summary>
            (Optional) An array of predefined procedure set names.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfResources.Keys.Properties">
            <summary>
            (Optional; PDF 1.2) A dictionary that maps resource names to property list
            dictionaries for marked content.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfResources.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Forms.DeviceInfos">
            <summary>
            Contains information about a physical device like a display or a printer.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.DeviceInfos.HorizontalSize">
            <summary>
            Width, in millimeters, of the physical screen or device.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.DeviceInfos.VerticalSize">
            <summary>
            Height, in millimeters, of the physical screen or device.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.DeviceInfos.HorizontalResolution">
            <summary>
            Width, in pixels, of the screen or device.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.DeviceInfos.VerticalResolution">
            <summary>
            Height, in pixels, of the screen or device.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.DeviceInfos.LogicalDpiX">
            <summary>
            Number of pixels per logical inch along the screen or device width.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.DeviceInfos.LogicalDpiY">
            <summary>
            Number of pixels per logical inch along the screen or device height.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.DeviceInfos.PhysicalDpiX">
            <summary>
            Number of pixels per physical inch along the screen or device width.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.DeviceInfos.PhysicalDpiY">
            <summary>
            Number of pixels per physical inch along the screen or device height.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.DeviceInfos.ScaleX">
            <summary>
            The ratio of LogicalDpiX and PhysicalDpiX.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.DeviceInfos.ScaleY">
            <summary>
            The ratio of LogicalDpiY and PhysicalDpiY.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.DeviceInfos.GetInfos(System.IntPtr)">
            <summary>
            Gets a DeviceInfo for the specifed device context.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XMatrix">
            <summary>
            Represents a 3-by-3 matrix that represents an affine 2D transformation.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the XMatrix struct.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.SetIdentity">
            <summary>
            Sets this matrix into an identity matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.InitIdentity">
            <summary>
            Fixes a bug that XMatrixTypes.Identity is not handled correctly in some cases.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.GetElements">
            <summary>
            Gets an array of double values that represents the elements of this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.op_Multiply(PdfSharp.Drawing.XMatrix,PdfSharp.Drawing.XMatrix)">
            <summary>
            Multiplies two matrices.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Multiply(PdfSharp.Drawing.XMatrix,PdfSharp.Drawing.XMatrix)">
            <summary>
            Multiplies two matrices.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Append(PdfSharp.Drawing.XMatrix)">
            <summary>
            Appends the specified matrix to this matrix. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Prepend(PdfSharp.Drawing.XMatrix)">
            <summary>
            Prepends the specified matrix to this matrix. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Multiply(PdfSharp.Drawing.XMatrix)">
            <summary>
            Appends the specified matrix to this matrix. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.MultiplyPrepend(PdfSharp.Drawing.XMatrix)">
            <summary>
            Prepends the specified matrix to this matrix. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Multiply(PdfSharp.Drawing.XMatrix,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Multiplies this matrix with the specified matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Translate(System.Double,System.Double)">
            <summary>
            Appends a translation of the specified offsets to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.TranslateAppend(System.Double,System.Double)">
            <summary>
            Appends a translation of the specified offsets to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.TranslatePrepend(System.Double,System.Double)">
            <summary>
            Prepends a translation of the specified offsets to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Translate(System.Double,System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Translates the matrix with the specified offsets.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Scale(System.Double,System.Double)">
            <summary>
            Appends the specified scale vector to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ScaleAppend(System.Double,System.Double)">
            <summary>
            Appends the specified scale vector to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ScalePrepend(System.Double,System.Double)">
            <summary>
            Prepends the specified scale vector to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Scale(System.Double,System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Scales the matrix with the specified scalars.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Scale(System.Double)">
            <summary>
            Scales the matrix with the specified scalar.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ScaleAppend(System.Double)">
            <summary>
            Appends the specified scale vector to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ScalePrepend(System.Double)">
            <summary>
            Prepends the specified scale vector to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Scale(System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Scales the matrix with the specified scalar.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ScaleAt(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Function is obsolete.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ScaleAtAppend(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Apppends the specified scale about the specified point of this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ScaleAtPrepend(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Prepends the specified scale about the specified point of this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Rotate(System.Double)">
            <summary>
            Function is obsolete.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.RotateAppend(System.Double)">
            <summary>
            Appends a rotation of the specified angle to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.RotatePrepend(System.Double)">
            <summary>
            Prepends a rotation of the specified angle to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Rotate(System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Rotates the matrix with the specified angle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.RotateAt(System.Double,System.Double,System.Double)">
            <summary>
            Function is obsolete.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.RotateAtAppend(System.Double,System.Double,System.Double)">
            <summary>
            Appends a rotation of the specified angle at the specified point to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.RotateAtPrepend(System.Double,System.Double,System.Double)">
            <summary>
            Prepends a rotation of the specified angle at the specified point to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.RotateAt(System.Double,PdfSharp.Drawing.XPoint)">
            <summary>
            Rotates the matrix with the specified angle at the specified point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.RotateAtAppend(System.Double,PdfSharp.Drawing.XPoint)">
            <summary>
            Appends a rotation of the specified angle at the specified point to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.RotateAtPrepend(System.Double,PdfSharp.Drawing.XPoint)">
            <summary>
            Prepends a rotation of the specified angle at the specified point to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.RotateAt(System.Double,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Rotates the matrix with the specified angle at the specified point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Shear(System.Double,System.Double)">
            <summary>
            Function is obsolete.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ShearAppend(System.Double,System.Double)">
            <summary>
            Appends a skew of the specified degrees in the x and y dimensions to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ShearPrepend(System.Double,System.Double)">
            <summary>
            Prepends a skew of the specified degrees in the x and y dimensions to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Shear(System.Double,System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Shears the matrix with the specified scalars.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Skew(System.Double,System.Double)">
            <summary>
            Function is obsolete.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.SkewAppend(System.Double,System.Double)">
            <summary>
            Appends a skew of the specified degrees in the x and y dimensions to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.SkewPrepend(System.Double,System.Double)">
            <summary>
            Prepends a skew of the specified degrees in the x and y dimensions to this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Transform(PdfSharp.Drawing.XPoint)">
            <summary>
            Transforms the specified point by this matrix and returns the result.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Transform(PdfSharp.Drawing.XPoint[])">
            <summary>
            Transforms the specified points by this matrix. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.TransformPoints(PdfSharp.Drawing.XPoint[])">
            <summary>
            Multiplies all points of the specified array with the this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.TransformPoints(System.Drawing.Point[])">
            <summary>
            Multiplies all points of the specified array with the this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Transform(PdfSharp.Drawing.XVector)">
            <summary>
            Transforms the specified vector by this Matrix and returns the result.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Transform(PdfSharp.Drawing.XVector[])">
            <summary>
            Transforms the specified vectors by this matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.TransformVectors(System.Drawing.PointF[])">
            <summary>
            Multiplies all vectors of the specified array with the this matrix. The translation elements 
            of this matrix (third row) are ignored.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Invert">
            <summary>
            Inverts the matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ToGdiMatrix">
            <summary>
            Converts this matrix to a System.Drawing.Drawing2D.Matrix object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ToGdipMatrix">
            <summary>
            Obsolete, will be deleted.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.op_Explicit(PdfSharp.Drawing.XMatrix)~System.Drawing.Drawing2D.Matrix">
            <summary>
            Explicitly converts a XMatrix to a Matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.op_Implicit(System.Drawing.Drawing2D.Matrix)~PdfSharp.Drawing.XMatrix">
            <summary>
            Implicitly converts a Matrix to an XMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.op_Equality(PdfSharp.Drawing.XMatrix,PdfSharp.Drawing.XMatrix)">
            <summary>
            Determines whether the two matrices are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.op_Inequality(PdfSharp.Drawing.XMatrix,PdfSharp.Drawing.XMatrix)">
            <summary>
            Determines whether the two matrices are not equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Equals(PdfSharp.Drawing.XMatrix,PdfSharp.Drawing.XMatrix)">
            <summary>
            Determines whether the two matrices are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Equals(System.Object)">
            <summary>
            Determines whether this matrix is equal to the specified object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Equals(PdfSharp.Drawing.XMatrix)">
            <summary>
            Determines whether this matrix is equal to the specified matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.Parse(System.String)">
            <summary>
            Parses a matrix from a string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ToString">
            <summary>
            Converts this XMatrix to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.ToString(System.IFormatProvider)">
            <summary>
            Converts this XMatrix to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts this XMatrix to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XMatrix.SetMatrix(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,PdfSharp.Drawing.XMatrix.XMatrixTypes)">
            <summary>
            Sets the matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.Identity">
            <summary>
            Gets a value that indicates whether this matrix is an identity matrix. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.IsIdentity">
            <summary>
            Gets a value indicating whether this matrix instance is the identity matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.Elements">
            <summary>
            Gets an array of double values that represents the elements of this matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.Determinant">
            <summary>
            Gets the determinant of this matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.HasInverse">
            <summary>
            Gets a value that indicates whether this matrix is invertible.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.M11">
            <summary>
            Gets or sets the value of the first row and first column of this matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.M12">
            <summary>
            Gets or sets the value of the first row and second column of this matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.M21">
            <summary>
            Gets or sets the value of the second row and first column of this matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.M22">
            <summary>
            Gets or sets the value of the second row and second column of this matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.OffsetX">
            <summary>
            Gets or sets the value of the third row and first column of this matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XMatrix.OffsetY">
            <summary>
            Gets or sets the value of the third row and second  column of this matrix.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XMatrix.MatrixHelper">
            <summary>
            Internal matrix helper.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.InternalGraphicsState">
            <summary>
            Represents the internal state of an XGraphics object.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.InternalGraphicsState.Transform">
            <summary>
            Gets or sets the current transformation matrix.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.GraphicsStateStack">
            <summary>
            Represents a stack of XGraphicsState and XGraphicsContainer objects.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfImage">
            <summary>
            Represents an image.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.CountOneBits(PdfSharp.Pdf.Advanced.BitReader,System.UInt32)">
            <summary>
            Counts the consecutive one bits in an image line.
            </summary>
            <param name="reader">The reader.</param>
            <param name="bitsLeft">The bits left.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.CountZeroBits(PdfSharp.Pdf.Advanced.BitReader,System.UInt32)">
            <summary>
            Counts the consecutive zero bits in an image line.
            </summary>
            <param name="reader">The reader.</param>
            <param name="bitsLeft">The bits left.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.FindDifference(PdfSharp.Pdf.Advanced.BitReader,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Returns the offset of the next bit in the range
            [bitStart..bitEnd] that is different from the
            specified color.  The end, bitEnd, is returned
            if no such bit exists.
            </summary>
            <param name="reader">The reader.</param>
            <param name="bitStart">The offset of the start bit.</param>
            <param name="bitEnd">The offset of the end bit.</param>
            <param name="searchOne">If set to <c>true</c> searches "one" (i. e. white), otherwise searches black.</param>
            <returns>The offset of the first non-matching bit.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.FindDifferenceWithCheck(PdfSharp.Pdf.Advanced.BitReader,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Returns the offset of the next bit in the range
            [bitStart..bitEnd] that is different from the
            specified color.  The end, bitEnd, is returned
            if no such bit exists.
            Like FindDifference, but also check the
            starting bit against the end in case start &gt; end.
            </summary>
            <param name="reader">The reader.</param>
            <param name="bitStart">The offset of the start bit.</param>
            <param name="bitEnd">The offset of the end bit.</param>
            <param name="searchOne">If set to <c>true</c> searches "one" (i. e. white), otherwise searches black.</param>
            <returns>The offset of the first non-matching bit.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.FaxEncode2DRow(PdfSharp.Pdf.Advanced.BitWriter,System.UInt32,System.Byte[],System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            2d-encode a row of pixels. Consult the CCITT documentation for the algorithm.
            </summary>
            <param name="writer">The writer.</param>
            <param name="bytesFileOffset">Offset of image data in bitmap file.</param>
            <param name="imageBits">The bitmap file.</param>
            <param name="currentRow">Index of the current row.</param>
            <param name="referenceRow">Index of the reference row (0xffffffff if there is none).</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="bytesPerLineBmp">The bytes per line in the bitmap file.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.DoFaxEncoding(System.Byte[]@,System.Byte[],System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Encodes a bitonal bitmap using 1D CCITT fax encoding.
            </summary>
            <param name="imageData">Space reserved for the fax encoded bitmap. An exception will be thrown if this buffer is too small.</param>
            <param name="imageBits">The bitmap to be encoded.</param>
            <param name="bytesFileOffset">Offset of image data in bitmap file.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <returns>The size of the fax encoded image (0 on failure).</returns>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.DoFaxEncodingGroup4(System.Byte[]@,System.Byte[],System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Encodes a bitonal bitmap using 2D group 4 CCITT fax encoding.
            </summary>
            <param name="imageData">Space reserved for the fax encoded bitmap. An exception will be thrown if this buffer is too small.</param>
            <param name="imageBits">The bitmap to be encoded.</param>
            <param name="bytesFileOffset">Offset of image data in bitmap file.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <returns>The size of the fax encoded image (0 on failure).</returns>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.WriteSample(PdfSharp.Pdf.Advanced.BitWriter,System.UInt32,System.Boolean)">
            <summary>
            Writes the image data.
            </summary>
            <param name="writer">The writer.</param>
            <param name="count">The count of bits (pels) to encode.</param>
            <param name="white">The color of the pels.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.#ctor(PdfSharp.Pdf.PdfDocument,PdfSharp.Drawing.XImage)">
            <summary>
            Initializes a new instance of PdfImage from an XImage.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.ToString">
            <summary>
            Returns 'Image'.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.InitializeJpeg">
            <summary>
            Creates the keys for a JPEG image.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.InitializeNonJpeg">
            <summary>
            Creates the keys for a FLATE image.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImage.ReadTrueColorMemoryBitmap(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Reads images that are returned from GDI+ without color palette.
            </summary>
            <param name="components">4 (32bpp RGB), 3 (24bpp RGB, 32bpp ARGB)</param>
            <param name="bits">8</param>
            <param name="hasAlpha">true (ARGB), false (RGB)</param>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfImage.Image">
            <summary>
            Gets the underlying XImage object.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfImage.Keys">
            <summary>
            Common keys for all streams.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes;
            if present, must be XObject for an image XObject.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Subtype">
            <summary>
            (Required) The type of XObject that this dictionary describes;
            must be Image for an image XObject.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Width">
            <summary>
            (Required) The width of the image, in samples.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Height">
            <summary>
            (Required) The height of the image, in samples.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.ColorSpace">
            <summary>
            (Required for images, except those that use the JPXDecode filter; not allowed for image masks)
            The color space in which image samples are specified; it can be any type of color space except
            Pattern. If the image uses the JPXDecode filter, this entry is optional:
            • If ColorSpace is present, any color space specifications in the JPEG2000 data are ignored.
            • If ColorSpace is absent, the color space specifications in the JPEG2000 data are used.
              The Decode array is also ignored unless ImageMask is true.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.BitsPerComponent">
            <summary>
            (Required except for image masks and images that use the JPXDecode filter)
            The number of bits used to represent each color component. Only a single value may be specified;
            the number of bits is the same for all color components. Valid values are 1, 2, 4, 8, and 
            (in PDF 1.5) 16. If ImageMask is true, this entry is optional, and if specified, its value 
            must be 1.
            If the image stream uses a filter, the value of BitsPerComponent must be consistent with the 
            size of the data samples that the filter delivers. In particular, a CCITTFaxDecode or JBIG2Decode 
            filter always delivers 1-bit samples, a RunLengthDecode or DCTDecode filter delivers 8-bit samples,
            and an LZWDecode or FlateDecode filter delivers samples of a specified size if a predictor function
            is used.
            If the image stream uses the JPXDecode filter, this entry is optional and ignored if present.
            The bit depth is determined in the process of decoding the JPEG2000 image.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Intent">
            <summary>
            (Optional; PDF 1.1) The name of a color rendering intent to be used in rendering the image.
            Default value: the current rendering intent in the graphics state.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.ImageMask">
            <summary>
            (Optional) A flag indicating whether the image is to be treated as an image mask.
            If this flag is true, the value of BitsPerComponent must be 1 and Mask and ColorSpace should
            not be specified; unmasked areas are painted using the current nonstroking color.
            Default value: false.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Mask">
            <summary>
            (Optional except for image masks; not allowed for image masks; PDF 1.3)
            An image XObject defining an image mask to be applied to this image, or an array specifying 
            a range of colors to be applied to it as a color key mask. If ImageMask is true, this entry
            must not be present.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Decode">
            <summary>
            (Optional) An array of numbers describing how to map image samples into the range of values
            appropriate for the image’s color space. If ImageMask is true, the array must be either
            [0 1] or [1 0]; otherwise, its length must be twice the number of color components required 
            by ColorSpace. If the image uses the JPXDecode filter and ImageMask is false, Decode is ignored.
            Default value: see “Decode Arrays”.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Interpolate">
            <summary>
            (Optional) A flag indicating whether image interpolation is to be performed. 
            Default value: false.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Alternates">
            <summary>
            (Optional; PDF 1.3) An array of alternate image dictionaries for this image. The order of 
            elements within the array has no significance. This entry may not be present in an image 
            XObject that is itself an alternate image.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.SMask">
            <summary>
            (Optional; PDF 1.4) A subsidiary image XObject defining a soft-mask image to be used as a 
            source of mask shape or mask opacity values in the transparent imaging model. The alpha 
            source parameter in the graphics state determines whether the mask values are interpreted as
            shape or opacity. If present, this entry overrides the current soft mask in the graphics state,
            as well as the image’s Mask entry, if any. (However, the other transparency related graphics 
            state parameters — blend mode and alpha constant — remain in effect.) If SMask is absent, the 
            image has no associated soft mask (although the current soft mask in the graphics state may
            still apply).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.SMaskInData">
            <summary>
            (Optional for images that use the JPXDecode filter, meaningless otherwise; PDF 1.5)
            A code specifying how soft-mask information encoded with image samples should be used:
            0 If present, encoded soft-mask image information should be ignored.
            1 The image’s data stream includes encoded soft-mask values. An application can create
              a soft-mask image from the information to be used as a source of mask shape or mask 
              opacity in the transparency imaging model.
            2 The image’s data stream includes color channels that have been preblended with a 
              background; the image data also includes an opacity channel. An application can create
              a soft-mask image with a Matte entry from the opacity channel information to be used as
              a source of mask shape or mask opacity in the transparency model. If this entry has a 
              nonzero value, SMask should not be specified.
            Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Name">
            <summary>
            (Required in PDF 1.0; optional otherwise) The name by which this image XObject is 
            referenced in the XObject subdictionary of the current resource dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.StructParent">
            <summary>
            (Required if the image is a structural content item; PDF 1.3) The integer key of the 
            image’s entry in the structural parent tree.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.ID">
            <summary>
            (Optional; PDF 1.3; indirect reference preferred) The digital identifier of the image’s
            parent Web Capture content set.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.OPI">
            <summary>
            (Optional; PDF 1.2) An OPI version dictionary for the image. If ImageMask is true, 
            this entry is ignored.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.Metadata">
            <summary>
            (Optional; PDF 1.4) A metadata stream containing metadata for the image.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImage.Keys.OC">
            <summary>
            (Optional; PDF 1.5) An optional content group or optional content membership dictionary,
            specifying the optional content properties for this image XObject. Before the image is
            processed, its visibility is determined based on this entry. If it is determined to be 
            invisible, the entire image is skipped, as if there were no Do operator to invoke it.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.BitReader">
            <summary>
            The BitReader class is a helper to read bits from an in-memory bitmap file.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitReader.#ctor(System.Byte[],System.UInt32,System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.BitReader" /> class.
            </summary>
            <param name="imageBits">The in-memory bitmap file.</param>
            <param name="bytesFileOffset">The offset of the line to read.</param>
            <param name="bits">The count of bits that may be read (i. e. the width of the image for normal usage).</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitReader.SetPosition(System.UInt32)">
            <summary>
            Sets the position within the line (needed for 2D encoding).
            </summary>
            <param name="position">The new position.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitReader.GetBit(System.UInt32)">
            <summary>
            Gets a single bit at the specified position.
            </summary>
            <param name="position">The position.</param>
            <returns>True if bit is set.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitReader.PeekByte(System.UInt32@)">
            <summary>
            Returns the bits that are in the buffer (without changing the position).
            Data is MSB aligned.
            </summary>
            <param name="bits">The count of bits that were returned (1 through 8).</param>
            <returns>The MSB aligned bits from the buffer.</returns>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitReader.NextByte">
            <summary>
            Moves the buffer to the next byte.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitReader.SkipBits(System.UInt32)">
            <summary>
            "Removes" (eats) bits from the buffer.
            </summary>
            <param name="bits">The count of bits that were processed.</param>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.BitWriter">
            <summary>
            A helper class for writing groups of bits into an array of bytes.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitWriter.#ctor(System.Byte[]@)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.BitWriter" /> class.
            </summary>
            <param name="imageData">The byte array to be written to.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitWriter.FlushBuffer">
            <summary>
            Writes the buffered bits into the byte array.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.BitWriter.masks">
            <summary>
            Masks for n bits in a byte (with n = 0 through 8).
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitWriter.WriteBits(System.UInt32,System.UInt32)">
            <summary>
            Writes bits to the byte array.
            </summary>
            <param name="value">The bits to be written (LSB aligned).</param>
            <param name="bits">The count of bits.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitWriter.WriteTableLine(System.UInt32[],System.UInt32)">
            <summary>
            Writes a line from a look-up table.
            A "line" in the table are two integers, one containing the values, one containing the bit count.
            </summary>
            <param name="table">The table.</param>
            <param name="line">The line.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.BitWriter.BytesWritten">
            <summary>
            Flushes the buffer and returns the count of bytes written to the array.
            </summary>
            <returns />
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.TableDirectoryEntry">
            <summary>
            Represents an entry in the fonts table dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.TableDirectoryEntry.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Fonts.OpenType.TableDirectoryEntry" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.TableDirectoryEntry.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Fonts.OpenType.TableDirectoryEntry" /> class.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableDirectoryEntry.Tag">
            <summary>
            4 -byte identifier.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableDirectoryEntry.CheckSum">
            <summary>
            CheckSum for this table.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableDirectoryEntry.Offset">
            <summary>
            Offset from beginning of TrueType font file.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableDirectoryEntry.Length">
            <summary>
            Actual length of this table in bytes.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableDirectoryEntry.FontTable">
            <summary>
            Associated font table.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.TableDirectoryEntry.ReadFrom(PdfSharp.Fonts.OpenType.FontData)">
            <summary>
            Creates and reads a TableDirectoryEntry from the font image.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.OpenType.TableDirectoryEntry.PaddedLength">
            <summary>
            Gets the length rounded up to a multiple of four bytes.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XStringFormats">
            <summary>
            Represents predefined text layouts.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormats.Default">
            <summary>
            Gets a new XStringFormat object that aligns the text left on the base line.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormats.TopLeft">
            <summary>
            Gets a new XStringFormat object that aligns the text top left of the layout rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormats.Center">
            <summary>
            Gets a new XStringFormat object that centers the text in the middle of the layout rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormats.TopCenter">
            <summary>
            Gets a new XStringFormat object that centers the text at the top of the layout rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormats.BottomCenter">
            <summary>
            Gets a new XStringFormat object that centers the text at the bottom of the layout rectangle.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.GeometryHelper">
            <summary>
            Helper class for Geometry paths.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.GeometryHelper.BezierCurveFromArc(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,PdfSharp.Drawing.PathStart,PdfSharp.Drawing.XMatrix@)">
            <summary>
            Creates between 1 and 5 Béziers curves from parameters specified like in GDI+.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.GeometryHelper.Quatrant(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Calculates the quadrant (0 through 3) of the specified angle. If the angle lies on an edge
            (0, 90, 180, etc.) the result depends on the details how the angle is used.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.GeometryHelper.AppendPartialArcQuadrant(System.Collections.Generic.List{PdfSharp.Drawing.XPoint},System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,PdfSharp.Drawing.PathStart,PdfSharp.Drawing.XMatrix)">
            <summary>
            Appends a Bézier curve for an arc within a full quadrant.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.GeometryHelper.BezierCurveFromArc(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint,System.Double,PdfSharp.Drawing.XSize,System.Boolean,System.Boolean,PdfSharp.Drawing.PathStart)">
            <summary>
            Creates between 1 and 5 Béziers curves from parameters specified like in WPF.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphicTargetContext">
            <summary>
             Determines whether rendering based on GDI+ or WPF. For internal use only.
             </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicTargetContext.GDI">
            <summary>
            Renders using GDI+.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicTargetContext.WPF">
            <summary>
            Renders using WPF (including Silverlight).
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.DataMatrixImage">
            <summary>
            Creates the XImage object for a DataMatrix.
            Important note for OpenSource version of PDFsharp:
              The generated image object only contains random data.
              If you need the correct implementation as defined in the ISO/IEC 16022:2000 specification,
              please contact empira Software GmbH via www.pdfsharp.com.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.DataMatrixImage.ecc200Sizes">
            <summary>
            Possible ECC200 Matrixes
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.DataMatrixImage.DataMatrix">
            <summary>
            Creates the DataMatrix code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.DataMatrixImage.Iec16022Ecc200(System.Int32,System.Int32,System.String,System.Int32,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Encodes the DataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.DataMatrixImage.CreateImage(System.Char[],System.Int32)">
            <summary>
            Creates a DataMatrix image object.
            </summary>
            <param name="code">A hex string like "AB 08 C3...".</param>
            <param name="size">I.e. 26 for a 26x26 matrix</param>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.DataMatrixImage.CreateImage(System.Char[],System.Int32,System.Int32)">
            <summary>
            Creates a DataMatrix image object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.DataMatrixImage.CreateImage(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a DataMatrix image object.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator">
            <summary>
             This class allows us to retrieve a specified number of bits from
             the input buffer, as well as copy big byte blocks.
            
             It uses an int buffer to store up to 31 bits for direct
             manipulation.  This guarantees that we can get at least 16 bits,
             but we only need at most 15, so this is all safe.
            
             There are some optimizations in this class, for example, you must
             never peek more than 8 bits more than needed, and you must first
             peek bits before you may drop them.  This is not a general purpose
             class but optimized for the behaviour of the Inflater.
            
             Authors of the original java version: John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)">
            <summary>
            Get the next n bits but don't increase input pointer.  n must be
            less or equal 16 and if this call succeeds, you must drop
            at least n - 8 bits in the next call.
            </summary>
            <returns>
            the value of the bits, or -1 if not enough bits available.  */
            </returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)">
            <summary>
            Drops the next n bits from the input.  You should have called PeekBits
            with a bigger or equal n before, to make sure that enough bits are in
            the bit buffer.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.GetBits(System.Int32)">
            <summary>
            Gets the next n bits and increases input pointer.  This is equivalent
            to PeekBits followed by dropBits, except for correct error handling.
            </summary>
            <returns>
            the value of the bits, or -1 if not enough bits available.
            </returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary">
            <summary>
            Skips to the next byte boundary.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.CopyBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies length bytes from input buffer to output buffer starting
            at output[offset].  You have to make sure, that the buffer is
            byte aligned.  If not enough bytes are available, copies fewer
            bytes.
            </summary>
            <param name="output">
            The buffer to copy bytes to.
            </param>
            <param name="offset">
            The offset in the buffer at which copying starts
            </param>
            <param name="length">
            The length to copy, 0 is allowed.
            </param>
            <returns>
            The number of bytes copied, 0 if no bytes were available.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Length is less than zero
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Bit buffer isnt byte aligned
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.#ctor">
            <summary>
            Constructs a default StreamManipulator with all buffers empty
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.Reset">
            <summary>
            resets state and empties internal buffers
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add more input for consumption.
            Only call when IsNeedingInput returns true
            </summary>
            <param name="buf">data to be input</param>
            <param name="off">offset of first byte of input</param>
            <param name="len">length of input</param>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBits">
            <summary>
            Gets the number of bits available in the bit buffer.  This must be
            only called when a previous PeekBits() returned -1.
            </summary>
            <returns>
            the number of bits available.
            </returns>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBytes">
            <summary>
            Gets the number of bytes available.
            </summary>
            <returns>
            The number of bytes available.
            </returns>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator.IsNeedingInput">
            <summary>
            Returns true when SetInput can be called
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer">
            <summary>
            This class is general purpose class for writing data to a buffer.
            
            It allows you to write bits as well as bytes
            Based on DeflaterPending.java
            
            Author of the original java version: Jochen Hoenicke
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.buf">
            <summary>Internal work buffer
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.#ctor">
            <summary>
            construct instance using default buffer size of 4096
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.#ctor(System.Int32)">
            <summary>
            construct instance using specified buffer size
            </summary>
            <param name="bufsize">
            size to use for internal buffer
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.Reset">
            <summary>
            Clear internal state/buffers
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.WriteByte(System.Int32)">
            <summary>
            write a byte to buffer
            </summary>
            <param name="b">
            value to write
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.WriteShort(System.Int32)">
            <summary>
            Write a short value to buffer LSB first
            </summary>
            <param name="s">
            value to write
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.WriteInt(System.Int32)">
            <summary>
            write an integer LSB first
            </summary>
            <param name="s">value to write</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.WriteBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write a block of data to buffer
            </summary>
            <param name="block">data to write</param>
            <param name="offset">offset of first byte to write</param>
            <param name="len">number of bytes to write</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.AlignToByte">
            <summary>
            Align internal buffer on a byte boundary
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.WriteBits(System.Int32,System.Int32)">
            <summary>
            Write bits to internal buffer
            </summary>
            <param name="b">source of bits</param>
            <param name="count">number of bits to write</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.WriteShortMSB(System.Int32)">
            <summary>
            Write a short value to internal buffer most significant byte first
            </summary>
            <param name="s">value to write</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.Flush(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Flushes the pending buffer into the given output array.  If the
            output array is to small, only a partial flush is done.
            </summary>
            <param name="output">
            the output array;
            </param>
            <param name="offset">
            the offset into output array;
            </param>
            <param name="length">		
            length the maximum number of bytes to store;
            </param>
            <exception name="ArgumentOutOfRangeException">
            IndexOutOfBoundsException if offset or length are invalid.
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.ToByteArray">
            <summary>
            Convert internal buffer to byte array.
            Buffer is empty on completion
            </summary>
            <returns>
            converted buffer contents contents
            </returns>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.BitCount">
            <summary>
            The number of bits written to the buffer
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.PendingBuffer.IsFlushed">
            <summary>
            Indicates if buffer has been flushed
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.DeflateStrategy">
            <summary>
            Strategies for deflater
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflateStrategy.Default">
            <summary>
            The default strategy
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflateStrategy.Filtered">
            <summary>
            This strategy will only allow longer string repetitions.  It is
            useful for random data with a small character set.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflateStrategy.HuffmanOnly">
            <summary>
            This strategy will not look for string repetitions at all.  It
            only encodes with Huffman trees (which means, that more common
            characters get a smaller encoding.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine">
            <summary>
            Low level compression engine for deflate algorithm which uses a 32K sliding window
            with secondary compression from Huffman/Shannon-Fano codes.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants">
            <summary>
            This class contains constants used for deflation.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.STORED_BLOCK">
            <summary>
            Written to Zip file to identify a stored block
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.STATIC_TREES">
            <summary>
            Identifies static tree in Zip file
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.DYN_TREES">
            <summary>
            Identifies dynamic tree in Zip file
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.PRESET_DICT">
            <summary>
            Header flag indicating a preset dictionary for deflation
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.DEFAULT_MEM_LEVEL">
            <summary>
            Sets internal buffer sizes for Huffman encoding
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_MATCH">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_MATCH">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_WBITS">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.WSIZE">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.WMASK">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_BITS">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SIZE">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_MASK">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SHIFT">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_LOOKAHEAD">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_DIST">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.PENDING_BUF_SIZE">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_STORED">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_FAST">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_SLOW">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_BLOCK_SIZE">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.GOOD_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_LAZY">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.NICE_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_CHAIN">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.COMPR_FUNC">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.DeflaterConstants.DEBUGGING">
            <summary>
            Set to true to enable debugging
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.comprFunc">
            <summary>
            The current compression function.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.inputBuf">
            <summary>
            The input data for compression.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.totalIn">
            <summary>
            The total bytes of input read.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.inputOff">
            <summary>
            The offset into inputBuf, where input data starts.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.inputEnd">
            <summary>
            The end offset of the input data.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.adler">
            <summary>
            The adler checksum
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.#ctor(PdfSharp.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">
            Pending buffer to use
            </param>&gt;
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.Reset">
            <summary>
            Reset internal state
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.ResetAdler">
            <summary>
            Reset Adler checksum
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.SetLevel(System.Int32)">
            <summary>
            Set the deflate level (0-9)
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.FillWindow">
            <summary>
            Fill the window
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set compression dictionary
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.Deflate(System.Boolean,System.Boolean)">
            <summary>
            Deflate drives actual compression of data
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">
            Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code>
            returns true
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.NeedsInput">
            <summary>
            Return true if input is needed <see cref="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)"> via SetInput</see></summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.Adler">
            <summary>
            Get current value of Adler checksum
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.TotalIn">
            <summary>
            Total data processed
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.DeflaterEngine.Strategy">
            <summary>
            Get/set the <see cref="T:PdfSharp.SharpZipLib.Zip.Compression.DeflateStrategy">deflate strategy</see></summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfObjectID">
            <summary>
            Represents a PDF object identifier, a pair of object and generation number.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObjectID.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfObjectID" /> class.
            </summary>
            <param name="objectNumber">The object number.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObjectID.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfObjectID" /> class.
            </summary>
            <param name="objectNumber">The object number.</param>
            <param name="generationNumber">The generation number.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObjectID.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObjectID.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObjectID.op_Equality(PdfSharp.Pdf.PdfObjectID,PdfSharp.Pdf.PdfObjectID)">
            <summary>
            Determines whether the tow objects are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObjectID.op_Inequality(PdfSharp.Pdf.PdfObjectID,PdfSharp.Pdf.PdfObjectID)">
            <summary>
            Determines whether the tow objects not are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObjectID.ToString">
            <summary>
            Returns the object and generation numbers as a string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfObjectID.CompareTo(System.Object)">
            <summary>
            Compares the current object id with another object.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObjectID.ObjectNumber">
            <summary>
            Gets or sets the object number.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObjectID.GenerationNumber">
            <summary>
            Gets or sets the generation number.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObjectID.IsEmpty">
            <summary>
            Indicates whether this object is an empty object identifier.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfObjectID.Empty">
            <summary>
            Creates an empty object identifier.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.PdfWriterLayout">
            <summary>
            Determines how the PDF output stream is formatted. Even all formats create valid PDF files,
            only Compact or Standard should be used for production purposes.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfWriterLayout.Compact">
            <summary>
            The PDF stream contains no unnecessary characters. This is default in release build.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfWriterLayout.Standard">
            <summary>
            The PDF stream contains some superfluous line feeds, but is more readable.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfWriterLayout.Indented">
            <summary>
            The PDF stream is indented to reflect the nesting levels of the objects. This is useful
            for analyzing PDF files, but increases the size of the file significantly.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfWriterLayout.Verbose">
            <summary>
            The PDF stream is indented to reflect the nesting levels of the objects and contains additional
            information about the PDFsharp objects. Furthermore content streams are not deflated. This 
            is useful for debugging purposes only and increases the size of the file significantly.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Internal.AnsiEncoding">
            <summary>
            An encoder for PDF AnsiEncoding.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.AnsiEncoding.IsAnsi1252Char(System.Char)">
            <summary>
            Indicates whether the specified Unicode character is available in the ANSI code page 1252.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Internal.AnsiEncoding.AnsiToUnicode">
            <summary>
            Converts WinAnsi to Unicode characters.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfResourceMap">
            <summary>
            Base class for all dictionaries that map resource names to objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfResourceMap.CollectResourceNames(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Adds all imported resource names to the specified hashtable.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfImageTable">
            <summary>
            Contains all used images of a document.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfResourceTable">
            <summary>
            Base class for FontTable, ImageTable, FormXObjectTable etc.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImageTable.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of this class, which is a singleton for each document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImageTable.GetImage(PdfSharp.Drawing.XImage)">
            <summary>
            Gets a PdfImage from an XImage. If no PdfImage already exists, a new one is created.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImageTable.images">
            <summary>
            Map from ImageSelector to PdfImage.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfImageTable.ImageSelector">
            <summary>
            A collection of information that uniquely identifies a particular PdfImage.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImageTable.ImageSelector.#ctor(PdfSharp.Drawing.XImage)">
            <summary>
            Initializes a new instance of ImageSelector from an XImage.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Actions.PdfAction">
            <summary>
            Represents the base class for all PDF actions.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Actions.PdfAction.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Actions.PdfAction" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Actions.PdfAction.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Actions.PdfAction" /> class.
            </summary>
            <param name="document">The document that owns this object.</param>
        </member>
        <member name="T:PdfSharp.Pdf.Actions.PdfAction.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Actions.PdfAction.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes;
            if present, must be Action for an action dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Actions.PdfAction.Keys.S">
            <summary>
            (Required) The type of action that this dictionary describes.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Actions.PdfAction.Keys.Next">
            <summary>
            (Optional; PDF 1.2) The next action or sequence of actions to be performed
            after the action represented by this dictionary. The value is either a
            single action dictionary or an array of action dictionaries to be performed
            in order; see below for further discussion.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.AdobeGlyphListForNewFonts">
            <summary>
            Testing only
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.A">
            <summary>
            LATIN CAPITAL LETTER A
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.AE">
            <summary>
            LATIN CAPITAL LETTER AE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.AEacute">
            <summary>
            LATIN CAPITAL LETTER AE WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Aacute">
            <summary>
            LATIN CAPITAL LETTER A WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Abreve">
            <summary>
            LATIN CAPITAL LETTER A WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Acircumflex">
            <summary>
            LATIN CAPITAL LETTER A WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Adieresis">
            <summary>
            LATIN CAPITAL LETTER A WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Agrave">
            <summary>
            LATIN CAPITAL LETTER A WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Alpha">
            <summary>
            GREEK CAPITAL LETTER ALPHA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Alphatonos">
            <summary>
            GREEK CAPITAL LETTER ALPHA WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Amacron">
            <summary>
            LATIN CAPITAL LETTER A WITH MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Aogonek">
            <summary>
            LATIN CAPITAL LETTER A WITH OGONEK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Aring">
            <summary>
            LATIN CAPITAL LETTER A WITH RING ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Aringacute">
            <summary>
            LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Atilde">
            <summary>
            LATIN CAPITAL LETTER A WITH TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.B">
            <summary>
            LATIN CAPITAL LETTER B
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Beta">
            <summary>
            GREEK CAPITAL LETTER BETA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.C">
            <summary>
            LATIN CAPITAL LETTER C
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Cacute">
            <summary>
            LATIN CAPITAL LETTER C WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ccaron">
            <summary>
            LATIN CAPITAL LETTER C WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ccedilla">
            <summary>
            LATIN CAPITAL LETTER C WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ccircumflex">
            <summary>
            LATIN CAPITAL LETTER C WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Cdotaccent">
            <summary>
            LATIN CAPITAL LETTER C WITH DOT ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Chi">
            <summary>
            GREEK CAPITAL LETTER CHI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.D">
            <summary>
            LATIN CAPITAL LETTER D
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Dcaron">
            <summary>
            LATIN CAPITAL LETTER D WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Dcroat">
            <summary>
            LATIN CAPITAL LETTER D WITH STROKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Delta">
            <summary>
            INCREMENT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.E">
            <summary>
            LATIN CAPITAL LETTER E
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Eacute">
            <summary>
            LATIN CAPITAL LETTER E WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ebreve">
            <summary>
            LATIN CAPITAL LETTER E WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ecaron">
            <summary>
            LATIN CAPITAL LETTER E WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ecircumflex">
            <summary>
            LATIN CAPITAL LETTER E WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Edieresis">
            <summary>
            LATIN CAPITAL LETTER E WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Edotaccent">
            <summary>
            LATIN CAPITAL LETTER E WITH DOT ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Egrave">
            <summary>
            LATIN CAPITAL LETTER E WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Emacron">
            <summary>
            LATIN CAPITAL LETTER E WITH MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Eng">
            <summary>
            LATIN CAPITAL LETTER ENG
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Eogonek">
            <summary>
            LATIN CAPITAL LETTER E WITH OGONEK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Epsilon">
            <summary>
            GREEK CAPITAL LETTER EPSILON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Epsilontonos">
            <summary>
            GREEK CAPITAL LETTER EPSILON WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Eta">
            <summary>
            GREEK CAPITAL LETTER ETA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Etatonos">
            <summary>
            GREEK CAPITAL LETTER ETA WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Eth">
            <summary>
            LATIN CAPITAL LETTER ETH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Euro">
            <summary>
            EURO SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.F">
            <summary>
            LATIN CAPITAL LETTER F
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.G">
            <summary>
            LATIN CAPITAL LETTER G
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Gamma">
            <summary>
            GREEK CAPITAL LETTER GAMMA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Gbreve">
            <summary>
            LATIN CAPITAL LETTER G WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Gcaron">
            <summary>
            LATIN CAPITAL LETTER G WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Gcircumflex">
            <summary>
            LATIN CAPITAL LETTER G WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Gcommaaccent">
            <summary>
            LATIN CAPITAL LETTER G WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Gdotaccent">
            <summary>
            LATIN CAPITAL LETTER G WITH DOT ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.H">
            <summary>
            LATIN CAPITAL LETTER H
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.H18533">
            <summary>
            BLACK CIRCLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.H18543">
            <summary>
            BLACK SMALL SQUARE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.H18551">
            <summary>
            WHITE SMALL SQUARE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.H22073">
            <summary>
            WHITE SQUARE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Hbar">
            <summary>
            LATIN CAPITAL LETTER H WITH STROKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Hcircumflex">
            <summary>
            LATIN CAPITAL LETTER H WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.I">
            <summary>
            LATIN CAPITAL LETTER I
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.IJ">
            <summary>
            LATIN CAPITAL LIGATURE IJ
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Iacute">
            <summary>
            LATIN CAPITAL LETTER I WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ibreve">
            <summary>
            LATIN CAPITAL LETTER I WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Icircumflex">
            <summary>
            LATIN CAPITAL LETTER I WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Idieresis">
            <summary>
            LATIN CAPITAL LETTER I WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Idotaccent">
            <summary>
            LATIN CAPITAL LETTER I WITH DOT ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ifraktur">
            <summary>
            BLACK-LETTER CAPITAL I
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Igrave">
            <summary>
            LATIN CAPITAL LETTER I WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Imacron">
            <summary>
            LATIN CAPITAL LETTER I WITH MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Iogonek">
            <summary>
            LATIN CAPITAL LETTER I WITH OGONEK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Iota">
            <summary>
            GREEK CAPITAL LETTER IOTA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Iotadieresis">
            <summary>
            GREEK CAPITAL LETTER IOTA WITH DIALYTIKA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Iotatonos">
            <summary>
            GREEK CAPITAL LETTER IOTA WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Itilde">
            <summary>
            LATIN CAPITAL LETTER I WITH TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.J">
            <summary>
            LATIN CAPITAL LETTER J
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Jcircumflex">
            <summary>
            LATIN CAPITAL LETTER J WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.K">
            <summary>
            LATIN CAPITAL LETTER K
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Kappa">
            <summary>
            GREEK CAPITAL LETTER KAPPA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Kcommaaccent">
            <summary>
            LATIN CAPITAL LETTER K WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.L">
            <summary>
            LATIN CAPITAL LETTER L
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Lacute">
            <summary>
            LATIN CAPITAL LETTER L WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Lambda">
            <summary>
            GREEK CAPITAL LETTER LAMDA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Lcaron">
            <summary>
            LATIN CAPITAL LETTER L WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Lcommaaccent">
            <summary>
            LATIN CAPITAL LETTER L WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ldot">
            <summary>
            LATIN CAPITAL LETTER L WITH MIDDLE DOT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Lslash">
            <summary>
            LATIN CAPITAL LETTER L WITH STROKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.M">
            <summary>
            LATIN CAPITAL LETTER M
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Mu">
            <summary>
            GREEK CAPITAL LETTER MU
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.N">
            <summary>
            LATIN CAPITAL LETTER N
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Nacute">
            <summary>
            LATIN CAPITAL LETTER N WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ncaron">
            <summary>
            LATIN CAPITAL LETTER N WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ncommaaccent">
            <summary>
            LATIN CAPITAL LETTER N WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ntilde">
            <summary>
            LATIN CAPITAL LETTER N WITH TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Nu">
            <summary>
            GREEK CAPITAL LETTER NU
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.O">
            <summary>
            LATIN CAPITAL LETTER O
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.OE">
            <summary>
            LATIN CAPITAL LIGATURE OE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Oacute">
            <summary>
            LATIN CAPITAL LETTER O WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Obreve">
            <summary>
            LATIN CAPITAL LETTER O WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ocircumflex">
            <summary>
            LATIN CAPITAL LETTER O WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Odieresis">
            <summary>
            LATIN CAPITAL LETTER O WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ograve">
            <summary>
            LATIN CAPITAL LETTER O WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ohorn">
            <summary>
            LATIN CAPITAL LETTER O WITH HORN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ohungarumlaut">
            <summary>
            LATIN CAPITAL LETTER O WITH DOUBLE ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Omacron">
            <summary>
            LATIN CAPITAL LETTER O WITH MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Omega">
            <summary>
            OHM SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Omegatonos">
            <summary>
            GREEK CAPITAL LETTER OMEGA WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Omicron">
            <summary>
            GREEK CAPITAL LETTER OMICRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Omicrontonos">
            <summary>
            GREEK CAPITAL LETTER OMICRON WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Oslash">
            <summary>
            LATIN CAPITAL LETTER O WITH STROKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Oslashacute">
            <summary>
            LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Otilde">
            <summary>
            LATIN CAPITAL LETTER O WITH TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.P">
            <summary>
            LATIN CAPITAL LETTER P
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Phi">
            <summary>
            GREEK CAPITAL LETTER PHI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Pi">
            <summary>
            GREEK CAPITAL LETTER PI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Psi">
            <summary>
            GREEK CAPITAL LETTER PSI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Q">
            <summary>
            LATIN CAPITAL LETTER Q
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.R">
            <summary>
            LATIN CAPITAL LETTER R
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Racute">
            <summary>
            LATIN CAPITAL LETTER R WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Rcaron">
            <summary>
            LATIN CAPITAL LETTER R WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Rcommaaccent">
            <summary>
            LATIN CAPITAL LETTER R WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Rfraktur">
            <summary>
            BLACK-LETTER CAPITAL R
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Rho">
            <summary>
            GREEK CAPITAL LETTER RHO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.S">
            <summary>
            LATIN CAPITAL LETTER S
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF010000">
            <summary>
            BOX DRAWINGS LIGHT DOWN AND RIGHT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF020000">
            <summary>
            BOX DRAWINGS LIGHT UP AND RIGHT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF030000">
            <summary>
            BOX DRAWINGS LIGHT DOWN AND LEFT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF040000">
            <summary>
            BOX DRAWINGS LIGHT UP AND LEFT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF050000">
            <summary>
            BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF060000">
            <summary>
            BOX DRAWINGS LIGHT DOWN AND HORIZONTAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF070000">
            <summary>
            BOX DRAWINGS LIGHT UP AND HORIZONTAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF080000">
            <summary>
            BOX DRAWINGS LIGHT VERTICAL AND RIGHT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF090000">
            <summary>
            BOX DRAWINGS LIGHT VERTICAL AND LEFT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF100000">
            <summary>
            BOX DRAWINGS LIGHT HORIZONTAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF110000">
            <summary>
            BOX DRAWINGS LIGHT VERTICAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF190000">
            <summary>
            BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF200000">
            <summary>
            BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF210000">
            <summary>
            BOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF220000">
            <summary>
            BOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF230000">
            <summary>
            BOX DRAWINGS DOUBLE VERTICAL AND LEFT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF240000">
            <summary>
            BOX DRAWINGS DOUBLE VERTICAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF250000">
            <summary>
            BOX DRAWINGS DOUBLE DOWN AND LEFT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF260000">
            <summary>
            BOX DRAWINGS DOUBLE UP AND LEFT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF270000">
            <summary>
            BOX DRAWINGS UP DOUBLE AND LEFT SINGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF280000">
            <summary>
            BOX DRAWINGS UP SINGLE AND LEFT DOUBLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF360000">
            <summary>
            BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF370000">
            <summary>
            BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF380000">
            <summary>
            BOX DRAWINGS DOUBLE UP AND RIGHT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF390000">
            <summary>
            BOX DRAWINGS DOUBLE DOWN AND RIGHT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF400000">
            <summary>
            BOX DRAWINGS DOUBLE UP AND HORIZONTAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF410000">
            <summary>
            BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF420000">
            <summary>
            BOX DRAWINGS DOUBLE VERTICAL AND RIGHT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF430000">
            <summary>
            BOX DRAWINGS DOUBLE HORIZONTAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF440000">
            <summary>
            BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF450000">
            <summary>
            BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF460000">
            <summary>
            BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF470000">
            <summary>
            BOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF480000">
            <summary>
            BOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF490000">
            <summary>
            BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF500000">
            <summary>
            BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF510000">
            <summary>
            BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF520000">
            <summary>
            BOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF530000">
            <summary>
            BOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.SF540000">
            <summary>
            BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Sacute">
            <summary>
            LATIN CAPITAL LETTER S WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Scaron">
            <summary>
            LATIN CAPITAL LETTER S WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Scedilla">
            <summary>
            LATIN CAPITAL LETTER S WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Scircumflex">
            <summary>
            LATIN CAPITAL LETTER S WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Scommaaccent">
            <summary>
            LATIN CAPITAL LETTER S WITH COMMA BELOW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Sigma">
            <summary>
            GREEK CAPITAL LETTER SIGMA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.T">
            <summary>
            LATIN CAPITAL LETTER T
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Tau">
            <summary>
            GREEK CAPITAL LETTER TAU
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Tbar">
            <summary>
            LATIN CAPITAL LETTER T WITH STROKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Tcaron">
            <summary>
            LATIN CAPITAL LETTER T WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Tcommaaccent">
            <summary>
            LATIN CAPITAL LETTER T WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Theta">
            <summary>
            GREEK CAPITAL LETTER THETA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Thorn">
            <summary>
            LATIN CAPITAL LETTER THORN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.U">
            <summary>
            LATIN CAPITAL LETTER U
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Uacute">
            <summary>
            LATIN CAPITAL LETTER U WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ubreve">
            <summary>
            LATIN CAPITAL LETTER U WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ucircumflex">
            <summary>
            LATIN CAPITAL LETTER U WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Udieresis">
            <summary>
            LATIN CAPITAL LETTER U WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ugrave">
            <summary>
            LATIN CAPITAL LETTER U WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Uhorn">
            <summary>
            LATIN CAPITAL LETTER U WITH HORN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Uhungarumlaut">
            <summary>
            LATIN CAPITAL LETTER U WITH DOUBLE ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Umacron">
            <summary>
            LATIN CAPITAL LETTER U WITH MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Uogonek">
            <summary>
            LATIN CAPITAL LETTER U WITH OGONEK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Upsilon">
            <summary>
            GREEK CAPITAL LETTER UPSILON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Upsilon1">
            <summary>
            GREEK UPSILON WITH HOOK SYMBOL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Upsilondieresis">
            <summary>
            GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Upsilontonos">
            <summary>
            GREEK CAPITAL LETTER UPSILON WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Uring">
            <summary>
            LATIN CAPITAL LETTER U WITH RING ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Utilde">
            <summary>
            LATIN CAPITAL LETTER U WITH TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.V">
            <summary>
            LATIN CAPITAL LETTER V
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.W">
            <summary>
            LATIN CAPITAL LETTER W
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Wacute">
            <summary>
            LATIN CAPITAL LETTER W WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Wcircumflex">
            <summary>
            LATIN CAPITAL LETTER W WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Wdieresis">
            <summary>
            LATIN CAPITAL LETTER W WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Wgrave">
            <summary>
            LATIN CAPITAL LETTER W WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.X">
            <summary>
            LATIN CAPITAL LETTER X
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Xi">
            <summary>
            GREEK CAPITAL LETTER XI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Y">
            <summary>
            LATIN CAPITAL LETTER Y
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Yacute">
            <summary>
            LATIN CAPITAL LETTER Y WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ycircumflex">
            <summary>
            LATIN CAPITAL LETTER Y WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ydieresis">
            <summary>
            LATIN CAPITAL LETTER Y WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Ygrave">
            <summary>
            LATIN CAPITAL LETTER Y WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Z">
            <summary>
            LATIN CAPITAL LETTER Z
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Zacute">
            <summary>
            LATIN CAPITAL LETTER Z WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Zcaron">
            <summary>
            LATIN CAPITAL LETTER Z WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Zdotaccent">
            <summary>
            LATIN CAPITAL LETTER Z WITH DOT ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.Zeta">
            <summary>
            GREEK CAPITAL LETTER ZETA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.a">
            <summary>
            LATIN SMALL LETTER A
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.aacute">
            <summary>
            LATIN SMALL LETTER A WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.abreve">
            <summary>
            LATIN SMALL LETTER A WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.acircumflex">
            <summary>
            LATIN SMALL LETTER A WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.acute">
            <summary>
            ACUTE ACCENT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.acutecomb">
            <summary>
            COMBINING ACUTE ACCENT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.adieresis">
            <summary>
            LATIN SMALL LETTER A WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ae">
            <summary>
            LATIN SMALL LETTER AE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.aeacute">
            <summary>
            LATIN SMALL LETTER AE WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii00208">
            <summary>
            HORIZONTAL BAR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10017">
            <summary>
            CYRILLIC CAPITAL LETTER A
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10018">
            <summary>
            CYRILLIC CAPITAL LETTER BE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10019">
            <summary>
            CYRILLIC CAPITAL LETTER VE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10020">
            <summary>
            CYRILLIC CAPITAL LETTER GHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10021">
            <summary>
            CYRILLIC CAPITAL LETTER DE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10022">
            <summary>
            CYRILLIC CAPITAL LETTER IE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10023">
            <summary>
            CYRILLIC CAPITAL LETTER IO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10024">
            <summary>
            CYRILLIC CAPITAL LETTER ZHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10025">
            <summary>
            CYRILLIC CAPITAL LETTER ZE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10026">
            <summary>
            CYRILLIC CAPITAL LETTER I
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10027">
            <summary>
            CYRILLIC CAPITAL LETTER SHORT I
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10028">
            <summary>
            CYRILLIC CAPITAL LETTER KA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10029">
            <summary>
            CYRILLIC CAPITAL LETTER EL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10030">
            <summary>
            CYRILLIC CAPITAL LETTER EM
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10031">
            <summary>
            CYRILLIC CAPITAL LETTER EN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10032">
            <summary>
            CYRILLIC CAPITAL LETTER O
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10033">
            <summary>
            CYRILLIC CAPITAL LETTER PE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10034">
            <summary>
            CYRILLIC CAPITAL LETTER ER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10035">
            <summary>
            CYRILLIC CAPITAL LETTER ES
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10036">
            <summary>
            CYRILLIC CAPITAL LETTER TE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10037">
            <summary>
            CYRILLIC CAPITAL LETTER U
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10038">
            <summary>
            CYRILLIC CAPITAL LETTER EF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10039">
            <summary>
            CYRILLIC CAPITAL LETTER HA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10040">
            <summary>
            CYRILLIC CAPITAL LETTER TSE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10041">
            <summary>
            CYRILLIC CAPITAL LETTER CHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10042">
            <summary>
            CYRILLIC CAPITAL LETTER SHA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10043">
            <summary>
            CYRILLIC CAPITAL LETTER SHCHA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10044">
            <summary>
            CYRILLIC CAPITAL LETTER HARD SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10045">
            <summary>
            CYRILLIC CAPITAL LETTER YERU
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10046">
            <summary>
            CYRILLIC CAPITAL LETTER SOFT SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10047">
            <summary>
            CYRILLIC CAPITAL LETTER E
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10048">
            <summary>
            CYRILLIC CAPITAL LETTER YU
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10049">
            <summary>
            CYRILLIC CAPITAL LETTER YA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10050">
            <summary>
            CYRILLIC CAPITAL LETTER GHE WITH UPTURN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10051">
            <summary>
            CYRILLIC CAPITAL LETTER DJE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10052">
            <summary>
            CYRILLIC CAPITAL LETTER GJE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10053">
            <summary>
            CYRILLIC CAPITAL LETTER UKRAINIAN IE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10054">
            <summary>
            CYRILLIC CAPITAL LETTER DZE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10055">
            <summary>
            CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10056">
            <summary>
            CYRILLIC CAPITAL LETTER YI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10057">
            <summary>
            CYRILLIC CAPITAL LETTER JE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10058">
            <summary>
            CYRILLIC CAPITAL LETTER LJE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10059">
            <summary>
            CYRILLIC CAPITAL LETTER NJE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10060">
            <summary>
            CYRILLIC CAPITAL LETTER TSHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10061">
            <summary>
            CYRILLIC CAPITAL LETTER KJE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10062">
            <summary>
            CYRILLIC CAPITAL LETTER SHORT U
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10065">
            <summary>
            CYRILLIC SMALL LETTER A
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10066">
            <summary>
            CYRILLIC SMALL LETTER BE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10067">
            <summary>
            CYRILLIC SMALL LETTER VE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10068">
            <summary>
            CYRILLIC SMALL LETTER GHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10069">
            <summary>
            CYRILLIC SMALL LETTER DE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10070">
            <summary>
            CYRILLIC SMALL LETTER IE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10071">
            <summary>
            CYRILLIC SMALL LETTER IO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10072">
            <summary>
            CYRILLIC SMALL LETTER ZHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10073">
            <summary>
            CYRILLIC SMALL LETTER ZE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10074">
            <summary>
            CYRILLIC SMALL LETTER I
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10075">
            <summary>
            CYRILLIC SMALL LETTER SHORT I
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10076">
            <summary>
            CYRILLIC SMALL LETTER KA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10077">
            <summary>
            CYRILLIC SMALL LETTER EL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10078">
            <summary>
            CYRILLIC SMALL LETTER EM
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10079">
            <summary>
            CYRILLIC SMALL LETTER EN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10080">
            <summary>
            CYRILLIC SMALL LETTER O
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10081">
            <summary>
            CYRILLIC SMALL LETTER PE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10082">
            <summary>
            CYRILLIC SMALL LETTER ER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10083">
            <summary>
            CYRILLIC SMALL LETTER ES
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10084">
            <summary>
            CYRILLIC SMALL LETTER TE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10085">
            <summary>
            CYRILLIC SMALL LETTER U
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10086">
            <summary>
            CYRILLIC SMALL LETTER EF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10087">
            <summary>
            CYRILLIC SMALL LETTER HA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10088">
            <summary>
            CYRILLIC SMALL LETTER TSE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10089">
            <summary>
            CYRILLIC SMALL LETTER CHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10090">
            <summary>
            CYRILLIC SMALL LETTER SHA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10091">
            <summary>
            CYRILLIC SMALL LETTER SHCHA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10092">
            <summary>
            CYRILLIC SMALL LETTER HARD SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10093">
            <summary>
            CYRILLIC SMALL LETTER YERU
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10094">
            <summary>
            CYRILLIC SMALL LETTER SOFT SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10095">
            <summary>
            CYRILLIC SMALL LETTER E
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10096">
            <summary>
            CYRILLIC SMALL LETTER YU
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10097">
            <summary>
            CYRILLIC SMALL LETTER YA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10098">
            <summary>
            CYRILLIC SMALL LETTER GHE WITH UPTURN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10099">
            <summary>
            CYRILLIC SMALL LETTER DJE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10100">
            <summary>
            CYRILLIC SMALL LETTER GJE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10101">
            <summary>
            CYRILLIC SMALL LETTER UKRAINIAN IE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10102">
            <summary>
            CYRILLIC SMALL LETTER DZE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10103">
            <summary>
            CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10104">
            <summary>
            CYRILLIC SMALL LETTER YI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10105">
            <summary>
            CYRILLIC SMALL LETTER JE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10106">
            <summary>
            CYRILLIC SMALL LETTER LJE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10107">
            <summary>
            CYRILLIC SMALL LETTER NJE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10108">
            <summary>
            CYRILLIC SMALL LETTER TSHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10109">
            <summary>
            CYRILLIC SMALL LETTER KJE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10110">
            <summary>
            CYRILLIC SMALL LETTER SHORT U
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10145">
            <summary>
            CYRILLIC CAPITAL LETTER DZHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10146">
            <summary>
            CYRILLIC CAPITAL LETTER YAT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10147">
            <summary>
            CYRILLIC CAPITAL LETTER FITA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10148">
            <summary>
            CYRILLIC CAPITAL LETTER IZHITSA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10193">
            <summary>
            CYRILLIC SMALL LETTER DZHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10194">
            <summary>
            CYRILLIC SMALL LETTER YAT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10195">
            <summary>
            CYRILLIC SMALL LETTER FITA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10196">
            <summary>
            CYRILLIC SMALL LETTER IZHITSA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii10846">
            <summary>
            CYRILLIC SMALL LETTER SCHWA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii299">
            <summary>
            LEFT-TO-RIGHT MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii300">
            <summary>
            RIGHT-TO-LEFT MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii301">
            <summary>
            ZERO WIDTH JOINER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57381">
            <summary>
            ARABIC PERCENT SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57388">
            <summary>
            ARABIC COMMA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57392">
            <summary>
            ARABIC-INDIC DIGIT ZERO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57393">
            <summary>
            ARABIC-INDIC DIGIT ONE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57394">
            <summary>
            ARABIC-INDIC DIGIT TWO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57395">
            <summary>
            ARABIC-INDIC DIGIT THREE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57396">
            <summary>
            ARABIC-INDIC DIGIT FOUR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57397">
            <summary>
            ARABIC-INDIC DIGIT FIVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57398">
            <summary>
            ARABIC-INDIC DIGIT SIX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57399">
            <summary>
            ARABIC-INDIC DIGIT SEVEN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57400">
            <summary>
            ARABIC-INDIC DIGIT EIGHT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57401">
            <summary>
            ARABIC-INDIC DIGIT NINE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57403">
            <summary>
            ARABIC SEMICOLON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57407">
            <summary>
            ARABIC QUESTION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57409">
            <summary>
            ARABIC LETTER HAMZA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57410">
            <summary>
            ARABIC LETTER ALEF WITH MADDA ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57411">
            <summary>
            ARABIC LETTER ALEF WITH HAMZA ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57412">
            <summary>
            ARABIC LETTER WAW WITH HAMZA ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57413">
            <summary>
            ARABIC LETTER ALEF WITH HAMZA BELOW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57414">
            <summary>
            ARABIC LETTER YEH WITH HAMZA ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57415">
            <summary>
            ARABIC LETTER ALEF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57416">
            <summary>
            ARABIC LETTER BEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57417">
            <summary>
            ARABIC LETTER TEH MARBUTA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57418">
            <summary>
            ARABIC LETTER TEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57419">
            <summary>
            ARABIC LETTER THEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57420">
            <summary>
            ARABIC LETTER JEEM
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57421">
            <summary>
            ARABIC LETTER HAH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57422">
            <summary>
            ARABIC LETTER KHAH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57423">
            <summary>
            ARABIC LETTER DAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57424">
            <summary>
            ARABIC LETTER THAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57425">
            <summary>
            ARABIC LETTER REH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57426">
            <summary>
            ARABIC LETTER ZAIN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57427">
            <summary>
            ARABIC LETTER SEEN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57428">
            <summary>
            ARABIC LETTER SHEEN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57429">
            <summary>
            ARABIC LETTER SAD
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57430">
            <summary>
            ARABIC LETTER DAD
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57431">
            <summary>
            ARABIC LETTER TAH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57432">
            <summary>
            ARABIC LETTER ZAH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57433">
            <summary>
            ARABIC LETTER AIN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57434">
            <summary>
            ARABIC LETTER GHAIN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57440">
            <summary>
            ARABIC TATWEEL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57441">
            <summary>
            ARABIC LETTER FEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57442">
            <summary>
            ARABIC LETTER QAF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57443">
            <summary>
            ARABIC LETTER KAF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57444">
            <summary>
            ARABIC LETTER LAM
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57445">
            <summary>
            ARABIC LETTER MEEM
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57446">
            <summary>
            ARABIC LETTER NOON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57448">
            <summary>
            ARABIC LETTER WAW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57449">
            <summary>
            ARABIC LETTER ALEF MAKSURA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57450">
            <summary>
            ARABIC LETTER YEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57451">
            <summary>
            ARABIC FATHATAN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57452">
            <summary>
            ARABIC DAMMATAN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57453">
            <summary>
            ARABIC KASRATAN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57454">
            <summary>
            ARABIC FATHA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57455">
            <summary>
            ARABIC DAMMA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57456">
            <summary>
            ARABIC KASRA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57457">
            <summary>
            ARABIC SHADDA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57458">
            <summary>
            ARABIC SUKUN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57470">
            <summary>
            ARABIC LETTER HEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57505">
            <summary>
            ARABIC LETTER VEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57506">
            <summary>
            ARABIC LETTER PEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57507">
            <summary>
            ARABIC LETTER TCHEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57508">
            <summary>
            ARABIC LETTER JEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57509">
            <summary>
            ARABIC LETTER GAF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57511">
            <summary>
            ARABIC LETTER TTEH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57512">
            <summary>
            ARABIC LETTER DDAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57513">
            <summary>
            ARABIC LETTER RREH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57514">
            <summary>
            ARABIC LETTER NOON GHUNNA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57519">
            <summary>
            ARABIC LETTER YEH BARREE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57534">
            <summary>
            ARABIC LETTER AE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57636">
            <summary>
            NEW SHEQEL SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57645">
            <summary>
            HEBREW PUNCTUATION MAQAF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57658">
            <summary>
            HEBREW PUNCTUATION SOF PASUQ
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57664">
            <summary>
            HEBREW LETTER ALEF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57665">
            <summary>
            HEBREW LETTER BET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57666">
            <summary>
            HEBREW LETTER GIMEL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57667">
            <summary>
            HEBREW LETTER DALET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57668">
            <summary>
            HEBREW LETTER HE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57669">
            <summary>
            HEBREW LETTER VAV
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57670">
            <summary>
            HEBREW LETTER ZAYIN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57671">
            <summary>
            HEBREW LETTER HET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57672">
            <summary>
            HEBREW LETTER TET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57673">
            <summary>
            HEBREW LETTER YOD
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57674">
            <summary>
            HEBREW LETTER FINAL KAF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57675">
            <summary>
            HEBREW LETTER KAF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57676">
            <summary>
            HEBREW LETTER LAMED
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57677">
            <summary>
            HEBREW LETTER FINAL MEM
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57678">
            <summary>
            HEBREW LETTER MEM
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57679">
            <summary>
            HEBREW LETTER FINAL NUN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57680">
            <summary>
            HEBREW LETTER NUN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57681">
            <summary>
            HEBREW LETTER SAMEKH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57682">
            <summary>
            HEBREW LETTER AYIN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57683">
            <summary>
            HEBREW LETTER FINAL PE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57684">
            <summary>
            HEBREW LETTER PE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57685">
            <summary>
            HEBREW LETTER FINAL TSADI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57686">
            <summary>
            HEBREW LETTER TSADI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57687">
            <summary>
            HEBREW LETTER QOF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57688">
            <summary>
            HEBREW LETTER RESH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57689">
            <summary>
            HEBREW LETTER SHIN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57690">
            <summary>
            HEBREW LETTER TAV
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57716">
            <summary>
            HEBREW LIGATURE YIDDISH DOUBLE VAV
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57717">
            <summary>
            HEBREW LIGATURE YIDDISH VAV YOD
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57718">
            <summary>
            HEBREW LIGATURE YIDDISH DOUBLE YOD
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57793">
            <summary>
            HEBREW POINT HIRIQ
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57794">
            <summary>
            HEBREW POINT TSERE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57795">
            <summary>
            HEBREW POINT SEGOL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57796">
            <summary>
            HEBREW POINT QUBUTS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57797">
            <summary>
            HEBREW POINT QAMATS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57798">
            <summary>
            HEBREW POINT PATAH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57799">
            <summary>
            HEBREW POINT SHEVA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57800">
            <summary>
            HEBREW POINT HATAF PATAH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57801">
            <summary>
            HEBREW POINT HATAF SEGOL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57802">
            <summary>
            HEBREW POINT HATAF QAMATS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57803">
            <summary>
            HEBREW POINT SIN DOT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57804">
            <summary>
            HEBREW POINT SHIN DOT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57806">
            <summary>
            HEBREW POINT HOLAM
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57807">
            <summary>
            HEBREW POINT DAGESH OR MAPIQ
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57839">
            <summary>
            HEBREW POINT METEG
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57841">
            <summary>
            HEBREW POINT RAFE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57842">
            <summary>
            HEBREW PUNCTUATION PASEQ
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii57929">
            <summary>
            MODIFIER LETTER APOSTROPHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii61248">
            <summary>
            CARE OF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii61289">
            <summary>
            SCRIPT SMALL L
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii61352">
            <summary>
            NUMERO SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii61573">
            <summary>
            POP DIRECTIONAL FORMATTING
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii61574">
            <summary>
            LEFT-TO-RIGHT OVERRIDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii61575">
            <summary>
            RIGHT-TO-LEFT OVERRIDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii61664">
            <summary>
            ZERO WIDTH NON-JOINER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii63167">
            <summary>
            ARABIC FIVE POINTED STAR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.afii64937">
            <summary>
            MODIFIER LETTER REVERSED COMMA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.agrave">
            <summary>
            LATIN SMALL LETTER A WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.aleph">
            <summary>
            ALEF SYMBOL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.alpha">
            <summary>
            GREEK SMALL LETTER ALPHA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.alphatonos">
            <summary>
            GREEK SMALL LETTER ALPHA WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.amacron">
            <summary>
            LATIN SMALL LETTER A WITH MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ampersand">
            <summary>
            AMPERSAND
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.angle">
            <summary>
            ANGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.angleleft">
            <summary>
            LEFT-POINTING ANGLE BRACKET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.angleright">
            <summary>
            RIGHT-POINTING ANGLE BRACKET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.anoteleia">
            <summary>
            GREEK ANO TELEIA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.aogonek">
            <summary>
            LATIN SMALL LETTER A WITH OGONEK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.approxequal">
            <summary>
            ALMOST EQUAL TO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.aring">
            <summary>
            LATIN SMALL LETTER A WITH RING ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.aringacute">
            <summary>
            LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowboth">
            <summary>
            LEFT RIGHT ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowdblboth">
            <summary>
            LEFT RIGHT DOUBLE ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowdbldown">
            <summary>
            DOWNWARDS DOUBLE ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowdblleft">
            <summary>
            LEFTWARDS DOUBLE ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowdblright">
            <summary>
            RIGHTWARDS DOUBLE ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowdblup">
            <summary>
            UPWARDS DOUBLE ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowdown">
            <summary>
            DOWNWARDS ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowleft">
            <summary>
            LEFTWARDS ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowright">
            <summary>
            RIGHTWARDS ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowup">
            <summary>
            UPWARDS ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowupdn">
            <summary>
            UP DOWN ARROW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.arrowupdnbse">
            <summary>
            UP DOWN ARROW WITH BASE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.asciicircum">
            <summary>
            CIRCUMFLEX ACCENT                                      
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.asciitilde">
            <summary>
            TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.asterisk">
            <summary>
            ASTERISK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.asteriskmath">
            <summary>
            ASTERISK OPERATOR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.at">
            <summary>
            COMMERCIAL AT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.atilde">
            <summary>
            LATIN SMALL LETTER A WITH TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.b">
            <summary>
            LATIN SMALL LETTER B
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.backslash">
            <summary>
            REVERSE SOLIDUS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.bar">
            <summary>
            VERTICAL LINE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.beta">
            <summary>
            GREEK SMALL LETTER BETA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.block">
            <summary>
            FULL BLOCK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.braceleft">
            <summary>
            LEFT CURLY BRACKET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.braceright">
            <summary>
            RIGHT CURLY BRACKET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.bracketleft">
            <summary>
            LEFT SQUARE BRACKET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.bracketright">
            <summary>
            RIGHT SQUARE BRACKET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.breve">
            <summary>
            BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.brokenbar">
            <summary>
            BROKEN BAR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.bullet">
            <summary>
            BULLET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.c">
            <summary>
            LATIN SMALL LETTER C
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.cacute">
            <summary>
            LATIN SMALL LETTER C WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.caron">
            <summary>
            CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.carriagereturn">
            <summary>
            DOWNWARDS ARROW WITH CORNER LEFTWARDS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ccaron">
            <summary>
            LATIN SMALL LETTER C WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ccedilla">
            <summary>
            LATIN SMALL LETTER C WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ccircumflex">
            <summary>
            LATIN SMALL LETTER C WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.cdotaccent">
            <summary>
            LATIN SMALL LETTER C WITH DOT ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.cedilla">
            <summary>
            CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.cent">
            <summary>
            CENT SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.chi">
            <summary>
            GREEK SMALL LETTER CHI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.circle">
            <summary>
            WHITE CIRCLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.circlemultiply">
            <summary>
            CIRCLED TIMES
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.circleplus">
            <summary>
            CIRCLED PLUS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.circumflex">
            <summary>
            MODIFIER LETTER CIRCUMFLEX ACCENT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.club">
            <summary>
            BLACK CLUB SUIT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.colon">
            <summary>
            COLON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.colonmonetary">
            <summary>
            COLON SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.comma">
            <summary>
            COMMA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.congruent">
            <summary>
            APPROXIMATELY EQUAL TO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.copyright">
            <summary>
            COPYRIGHT SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.currency">
            <summary>
            CURRENCY SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.d">
            <summary>
            LATIN SMALL LETTER D
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dagger">
            <summary>
            DAGGER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.daggerdbl">
            <summary>
            DOUBLE DAGGER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dcaron">
            <summary>
            LATIN SMALL LETTER D WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dcroat">
            <summary>
            LATIN SMALL LETTER D WITH STROKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.degree">
            <summary>
            DEGREE SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.delta">
            <summary>
            GREEK SMALL LETTER DELTA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.diamond">
            <summary>
            BLACK DIAMOND SUIT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dieresis">
            <summary>
            DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dieresistonos">
            <summary>
            GREEK DIALYTIKA TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.divide">
            <summary>
            DIVISION SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dkshade">
            <summary>
            DARK SHADE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dnblock">
            <summary>
            LOWER HALF BLOCK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dollar">
            <summary>
            DOLLAR SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dong">
            <summary>
            DONG SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dotaccent">
            <summary>
            DOT ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dotbelowcomb">
            <summary>
            COMBINING DOT BELOW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dotlessi">
            <summary>
            LATIN SMALL LETTER DOTLESS I
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.dotmath">
            <summary>
            DOT OPERATOR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.e">
            <summary>
            LATIN SMALL LETTER E
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.eacute">
            <summary>
            LATIN SMALL LETTER E WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ebreve">
            <summary>
            LATIN SMALL LETTER E WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ecaron">
            <summary>
            LATIN SMALL LETTER E WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ecircumflex">
            <summary>
            LATIN SMALL LETTER E WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.edieresis">
            <summary>
            LATIN SMALL LETTER E WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.edotaccent">
            <summary>
            LATIN SMALL LETTER E WITH DOT ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.egrave">
            <summary>
            LATIN SMALL LETTER E WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.eight">
            <summary>
            DIGIT EIGHT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.element">
            <summary>
            ELEMENT OF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ellipsis">
            <summary>
            HORIZONTAL ELLIPSIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.emacron">
            <summary>
            LATIN SMALL LETTER E WITH MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.emdash">
            <summary>
            EM DASH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.emptyset">
            <summary>
            EMPTY SET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.endash">
            <summary>
            EN DASH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.eng">
            <summary>
            LATIN SMALL LETTER ENG
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.eogonek">
            <summary>
            LATIN SMALL LETTER E WITH OGONEK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.epsilon">
            <summary>
            GREEK SMALL LETTER EPSILON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.epsilontonos">
            <summary>
            GREEK SMALL LETTER EPSILON WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.equal">
            <summary>
            EQUALS SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.equivalence">
            <summary>
            IDENTICAL TO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.estimated">
            <summary>
            ESTIMATED SYMBOL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.eta">
            <summary>
            GREEK SMALL LETTER ETA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.etatonos">
            <summary>
            GREEK SMALL LETTER ETA WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.eth">
            <summary>
            LATIN SMALL LETTER ETH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.exclam">
            <summary>
            EXCLAMATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.exclamdbl">
            <summary>
            DOUBLE EXCLAMATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.exclamdown">
            <summary>
            INVERTED EXCLAMATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.existential">
            <summary>
            THERE EXISTS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.f">
            <summary>
            LATIN SMALL LETTER F
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.female">
            <summary>
            FEMALE SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.figuredash">
            <summary>
            FIGURE DASH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.filledbox">
            <summary>
            BLACK SQUARE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.filledrect">
            <summary>
            BLACK RECTANGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.five">
            <summary>
            DIGIT FIVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.fiveeighths">
            <summary>
            VULGAR FRACTION FIVE EIGHTHS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.florin">
            <summary>
            LATIN SMALL LETTER F WITH HOOK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.four">
            <summary>
            DIGIT FOUR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.fraction">
            <summary>
            FRACTION SLASH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.franc">
            <summary>
            FRENCH FRANC SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.g">
            <summary>
            LATIN SMALL LETTER G
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.gamma">
            <summary>
            GREEK SMALL LETTER GAMMA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.gbreve">
            <summary>
            LATIN SMALL LETTER G WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.gcaron">
            <summary>
            LATIN SMALL LETTER G WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.gcircumflex">
            <summary>
            LATIN SMALL LETTER G WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.gcommaaccent">
            <summary>
            LATIN SMALL LETTER G WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.gdotaccent">
            <summary>
            LATIN SMALL LETTER G WITH DOT ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.germandbls">
            <summary>
            LATIN SMALL LETTER SHARP S
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.gradient">
            <summary>
            NABLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.grave">
            <summary>
            GRAVE ACCENT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.gravecomb">
            <summary>
            COMBINING GRAVE ACCENT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.greater">
            <summary>
            GREATER-THAN SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.greaterequal">
            <summary>
            GREATER-THAN OR EQUAL TO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.guillemotleft">
            <summary>
            LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.guillemotright">
            <summary>
            RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.guilsinglleft">
            <summary>
            SINGLE LEFT-POINTING ANGLE QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.guilsinglright">
            <summary>
            SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.h">
            <summary>
            LATIN SMALL LETTER H
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.hbar">
            <summary>
            LATIN SMALL LETTER H WITH STROKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.hcircumflex">
            <summary>
            LATIN SMALL LETTER H WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.heart">
            <summary>
            BLACK HEART SUIT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.hookabovecomb">
            <summary>
            COMBINING HOOK ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.house">
            <summary>
            HOUSE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.hungarumlaut">
            <summary>
            DOUBLE ACUTE ACCENT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.hyphen">
            <summary>
            HYPHEN-MINUS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.i">
            <summary>
            LATIN SMALL LETTER I
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.iacute">
            <summary>
            LATIN SMALL LETTER I WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ibreve">
            <summary>
            LATIN SMALL LETTER I WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.icircumflex">
            <summary>
            LATIN SMALL LETTER I WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.idieresis">
            <summary>
            LATIN SMALL LETTER I WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.igrave">
            <summary>
            LATIN SMALL LETTER I WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ij">
            <summary>
            LATIN SMALL LIGATURE IJ
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.imacron">
            <summary>
            LATIN SMALL LETTER I WITH MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.infinity">
            <summary>
            INFINITY
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.integral">
            <summary>
            INTEGRAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.integralbt">
            <summary>
            BOTTOM HALF INTEGRAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.integraltp">
            <summary>
            TOP HALF INTEGRAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.intersection">
            <summary>
            INTERSECTION
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.invbullet">
            <summary>
            INVERSE BULLET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.invcircle">
            <summary>
            INVERSE WHITE CIRCLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.invsmileface">
            <summary>
            BLACK SMILING FACE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.iogonek">
            <summary>
            LATIN SMALL LETTER I WITH OGONEK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.iota">
            <summary>
            GREEK SMALL LETTER IOTA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.iotadieresis">
            <summary>
            GREEK SMALL LETTER IOTA WITH DIALYTIKA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.iotadieresistonos">
            <summary>
            GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.iotatonos">
            <summary>
            GREEK SMALL LETTER IOTA WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.itilde">
            <summary>
            LATIN SMALL LETTER I WITH TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.j">
            <summary>
            LATIN SMALL LETTER J
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.jcircumflex">
            <summary>
            LATIN SMALL LETTER J WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.k">
            <summary>
            LATIN SMALL LETTER K
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.kappa">
            <summary>
            GREEK SMALL LETTER KAPPA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.kcommaaccent">
            <summary>
            LATIN SMALL LETTER K WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.kgreenlandic">
            <summary>
            LATIN SMALL LETTER KRA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.l">
            <summary>
            LATIN SMALL LETTER L
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.lacute">
            <summary>
            LATIN SMALL LETTER L WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.lambda">
            <summary>
            GREEK SMALL LETTER LAMDA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.lcaron">
            <summary>
            LATIN SMALL LETTER L WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.lcommaaccent">
            <summary>
            LATIN SMALL LETTER L WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ldot">
            <summary>
            LATIN SMALL LETTER L WITH MIDDLE DOT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.less">
            <summary>
            LESS-THAN SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.lessequal">
            <summary>
            LESS-THAN OR EQUAL TO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.lfblock">
            <summary>
            LEFT HALF BLOCK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.lira">
            <summary>
            LIRA SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.logicaland">
            <summary>
            LOGICAL AND
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.logicalnot">
            <summary>
            NOT SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.logicalor">
            <summary>
            LOGICAL OR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.longs">
            <summary>
            LATIN SMALL LETTER LONG S
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.lozenge">
            <summary>
            LOZENGE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.lslash">
            <summary>
            LATIN SMALL LETTER L WITH STROKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ltshade">
            <summary>
            LIGHT SHADE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.m">
            <summary>
            LATIN SMALL LETTER M
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.macron">
            <summary>
            MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.male">
            <summary>
            MALE SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.minus">
            <summary>
            MINUS SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.minute">
            <summary>
            PRIME
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.mu">
            <summary>
            MICRO SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.multiply">
            <summary>
            MULTIPLICATION SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.musicalnote">
            <summary>
            EIGHTH NOTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.musicalnotedbl">
            <summary>
            BEAMED EIGHTH NOTES
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.n">
            <summary>
            LATIN SMALL LETTER N
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.nacute">
            <summary>
            LATIN SMALL LETTER N WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.napostrophe">
            <summary>
            LATIN SMALL LETTER N PRECEDED BY APOSTROPHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ncaron">
            <summary>
            LATIN SMALL LETTER N WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ncommaaccent">
            <summary>
            LATIN SMALL LETTER N WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.nine">
            <summary>
            DIGIT NINE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.notelement">
            <summary>
            NOT AN ELEMENT OF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.notequal">
            <summary>
            NOT EQUAL TO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.notsubset">
            <summary>
            NOT A SUBSET OF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ntilde">
            <summary>
            LATIN SMALL LETTER N WITH TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.nu">
            <summary>
            GREEK SMALL LETTER NU
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.numbersign">
            <summary>
            NUMBER SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.o">
            <summary>
            LATIN SMALL LETTER O
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.oacute">
            <summary>
            LATIN SMALL LETTER O WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.obreve">
            <summary>
            LATIN SMALL LETTER O WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ocircumflex">
            <summary>
            LATIN SMALL LETTER O WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.odieresis">
            <summary>
            LATIN SMALL LETTER O WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.oe">
            <summary>
            LATIN SMALL LIGATURE OE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ogonek">
            <summary>
            OGONEK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ograve">
            <summary>
            LATIN SMALL LETTER O WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ohorn">
            <summary>
            LATIN SMALL LETTER O WITH HORN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ohungarumlaut">
            <summary>
            LATIN SMALL LETTER O WITH DOUBLE ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.omacron">
            <summary>
            LATIN SMALL LETTER O WITH MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.omega">
            <summary>
            GREEK SMALL LETTER OMEGA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.omega1">
            <summary>
            GREEK PI SYMBOL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.omegatonos">
            <summary>
            GREEK SMALL LETTER OMEGA WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.omicron">
            <summary>
            GREEK SMALL LETTER OMICRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.omicrontonos">
            <summary>
            GREEK SMALL LETTER OMICRON WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.one">
            <summary>
            DIGIT ONE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.onedotenleader">
            <summary>
            ONE DOT LEADER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.oneeighth">
            <summary>
            VULGAR FRACTION ONE EIGHTH
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.onehalf">
            <summary>
            VULGAR FRACTION ONE HALF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.onequarter">
            <summary>
            VULGAR FRACTION ONE QUARTER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.onethird">
            <summary>
            VULGAR FRACTION ONE THIRD
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.openbullet">
            <summary>
            WHITE BULLET
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ordfeminine">
            <summary>
            FEMININE ORDINAL INDICATOR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ordmasculine">
            <summary>
            MASCULINE ORDINAL INDICATOR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.orthogonal">
            <summary>
            RIGHT ANGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.oslash">
            <summary>
            LATIN SMALL LETTER O WITH STROKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.oslashacute">
            <summary>
            LATIN SMALL LETTER O WITH STROKE AND ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.otilde">
            <summary>
            LATIN SMALL LETTER O WITH TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.p">
            <summary>
            LATIN SMALL LETTER P
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.paragraph">
            <summary>
            PILCROW SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.parenleft">
            <summary>
            LEFT PARENTHESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.parenright">
            <summary>
            RIGHT PARENTHESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.partialdiff">
            <summary>
            PARTIAL DIFFERENTIAL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.percent">
            <summary>
            PERCENT SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.period">
            <summary>
            FULL STOP
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.periodcentered">
            <summary>
            MIDDLE DOT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.perpendicular">
            <summary>
            UP TACK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.perthousand">
            <summary>
            PER MILLE SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.peseta">
            <summary>
            PESETA SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.phi">
            <summary>
            GREEK SMALL LETTER PHI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.phi1">
            <summary>
            GREEK PHI SYMBOL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.pi">
            <summary>
            GREEK SMALL LETTER PI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.plus">
            <summary>
            PLUS SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.plusminus">
            <summary>
            PLUS-MINUS SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.prescription">
            <summary>
            PRESCRIPTION TAKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.product">
            <summary>
            N-ARY PRODUCT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.propersubset">
            <summary>
            SUBSET OF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.propersuperset">
            <summary>
            SUPERSET OF
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.proportional">
            <summary>
            PROPORTIONAL TO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.psi">
            <summary>
            GREEK SMALL LETTER PSI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.q">
            <summary>
            LATIN SMALL LETTER Q
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.question">
            <summary>
            QUESTION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.questiondown">
            <summary>
            INVERTED QUESTION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.quotedbl">
            <summary>
            QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.quotedblbase">
            <summary>
            DOUBLE LOW-9 QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.quotedblleft">
            <summary>
            LEFT DOUBLE QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.quotedblright">
            <summary>
            RIGHT DOUBLE QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.quoteleft">
            <summary>
            LEFT SINGLE QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.quotereversed">
            <summary>
            SINGLE HIGH-REVERSED-9 QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.quoteright">
            <summary>
            RIGHT SINGLE QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.quotesinglbase">
            <summary>
            SINGLE LOW-9 QUOTATION MARK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.quotesingle">
            <summary>
            APOSTROPHE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.r">
            <summary>
            LATIN SMALL LETTER R
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.racute">
            <summary>
            LATIN SMALL LETTER R WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.radical">
            <summary>
            SQUARE ROOT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.rcaron">
            <summary>
            LATIN SMALL LETTER R WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.rcommaaccent">
            <summary>
            LATIN SMALL LETTER R WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.reflexsubset">
            <summary>
            SUBSET OF OR EQUAL TO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.reflexsuperset">
            <summary>
            SUPERSET OF OR EQUAL TO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.registered">
            <summary>
            REGISTERED SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.revlogicalnot">
            <summary>
            REVERSED NOT SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.rho">
            <summary>
            GREEK SMALL LETTER RHO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ring">
            <summary>
            RING ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.rtblock">
            <summary>
            RIGHT HALF BLOCK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.s">
            <summary>
            LATIN SMALL LETTER S
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.sacute">
            <summary>
            LATIN SMALL LETTER S WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.scaron">
            <summary>
            LATIN SMALL LETTER S WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.scedilla">
            <summary>
            LATIN SMALL LETTER S WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.scircumflex">
            <summary>
            LATIN SMALL LETTER S WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.scommaaccent">
            <summary>
            LATIN SMALL LETTER S WITH COMMA BELOW
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.second">
            <summary>
            DOUBLE PRIME
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.section">
            <summary>
            SECTION SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.semicolon">
            <summary>
            SEMICOLON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.seven">
            <summary>
            DIGIT SEVEN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.seveneighths">
            <summary>
            VULGAR FRACTION SEVEN EIGHTHS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.shade">
            <summary>
            MEDIUM SHADE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.sigma">
            <summary>
            GREEK SMALL LETTER SIGMA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.sigma1">
            <summary>
            GREEK SMALL LETTER FINAL SIGMA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.similar">
            <summary>
            TILDE OPERATOR
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.six">
            <summary>
            DIGIT SIX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.slash">
            <summary>
            SOLIDUS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.smileface">
            <summary>
            WHITE SMILING FACE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.space">
            <summary>
            SPACE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.spade">
            <summary>
            BLACK SPADE SUIT
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.sterling">
            <summary>
            POUND SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.suchthat">
            <summary>
            CONTAINS AS MEMBER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.summation">
            <summary>
            N-ARY SUMMATION
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.sun">
            <summary>
            WHITE SUN WITH RAYS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.t">
            <summary>
            LATIN SMALL LETTER T
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.tau">
            <summary>
            GREEK SMALL LETTER TAU
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.tbar">
            <summary>
            LATIN SMALL LETTER T WITH STROKE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.tcaron">
            <summary>
            LATIN SMALL LETTER T WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.tcommaaccent">
            <summary>
            LATIN SMALL LETTER T WITH CEDILLA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.therefore">
            <summary>
            THEREFORE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.theta">
            <summary>
            GREEK SMALL LETTER THETA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.theta1">
            <summary>
            GREEK THETA SYMBOL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.thorn">
            <summary>
            LATIN SMALL LETTER THORN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.three">
            <summary>
            DIGIT THREE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.threeeighths">
            <summary>
            VULGAR FRACTION THREE EIGHTHS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.threequarters">
            <summary>
            VULGAR FRACTION THREE QUARTERS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.tilde">
            <summary>
            SMALL TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.tildecomb">
            <summary>
            COMBINING TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.tonos">
            <summary>
            GREEK TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.trademark">
            <summary>
            TRADE MARK SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.triagdn">
            <summary>
            BLACK DOWN-POINTING TRIANGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.triaglf">
            <summary>
            BLACK LEFT-POINTING POINTER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.triagrt">
            <summary>
            BLACK RIGHT-POINTING POINTER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.triagup">
            <summary>
            BLACK UP-POINTING TRIANGLE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.two">
            <summary>
            DIGIT TWO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.twodotenleader">
            <summary>
            TWO DOT LEADER
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.twothirds">
            <summary>
            VULGAR FRACTION TWO THIRDS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.u">
            <summary>
            LATIN SMALL LETTER U
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.uacute">
            <summary>
            LATIN SMALL LETTER U WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ubreve">
            <summary>
            LATIN SMALL LETTER U WITH BREVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ucircumflex">
            <summary>
            LATIN SMALL LETTER U WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.udieresis">
            <summary>
            LATIN SMALL LETTER U WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ugrave">
            <summary>
            LATIN SMALL LETTER U WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.uhorn">
            <summary>
            LATIN SMALL LETTER U WITH HORN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.uhungarumlaut">
            <summary>
            LATIN SMALL LETTER U WITH DOUBLE ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.umacron">
            <summary>
            LATIN SMALL LETTER U WITH MACRON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.underscore">
            <summary>
            LOW LINE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.underscoredbl">
            <summary>
            DOUBLE LOW LINE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.union">
            <summary>
            UNION
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.universal">
            <summary>
            FOR ALL
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.uogonek">
            <summary>
            LATIN SMALL LETTER U WITH OGONEK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.upblock">
            <summary>
            UPPER HALF BLOCK
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.upsilon">
            <summary>
            GREEK SMALL LETTER UPSILON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.upsilondieresis">
            <summary>
            GREEK SMALL LETTER UPSILON WITH DIALYTIKA
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.upsilondieresistonos">
            <summary>
            GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.upsilontonos">
            <summary>
            GREEK SMALL LETTER UPSILON WITH TONOS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.uring">
            <summary>
            LATIN SMALL LETTER U WITH RING ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.utilde">
            <summary>
            LATIN SMALL LETTER U WITH TILDE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.v">
            <summary>
            LATIN SMALL LETTER V
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.w">
            <summary>
            LATIN SMALL LETTER W
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.wacute">
            <summary>
            LATIN SMALL LETTER W WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.wcircumflex">
            <summary>
            LATIN SMALL LETTER W WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.wdieresis">
            <summary>
            LATIN SMALL LETTER W WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.weierstrass">
            <summary>
            SCRIPT CAPITAL P
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.wgrave">
            <summary>
            LATIN SMALL LETTER W WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.x">
            <summary>
            LATIN SMALL LETTER X
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.xi">
            <summary>
            GREEK SMALL LETTER XI
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.y">
            <summary>
            LATIN SMALL LETTER Y
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.yacute">
            <summary>
            LATIN SMALL LETTER Y WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ycircumflex">
            <summary>
            LATIN SMALL LETTER Y WITH CIRCUMFLEX
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ydieresis">
            <summary>
            LATIN SMALL LETTER Y WITH DIAERESIS
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.yen">
            <summary>
            YEN SIGN
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.ygrave">
            <summary>
            LATIN SMALL LETTER Y WITH GRAVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.z">
            <summary>
            LATIN SMALL LETTER Z
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.zacute">
            <summary>
            LATIN SMALL LETTER Z WITH ACUTE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.zcaron">
            <summary>
            LATIN SMALL LETTER Z WITH CARON
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.zdotaccent">
            <summary>
            LATIN SMALL LETTER Z WITH DOT ABOVE
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.zero">
            <summary>
            DIGIT ZERO
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.AdobeGlyphListForNewFonts.zeta">
            <summary>
            GREEK SMALL LETTER ZETA
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.FontDescriptorStock">
            <summary>
            Global table of TrueType fontdescriptor objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontDescriptorStock.FindDescriptor(PdfSharp.Fonts.FontDescriptorStock.FontSelector)">
            <summary>
            Gets the FontDescriptor identified by the specified FontSelector. Returns null if no
            such objects exists.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontDescriptorStock.CreateDescriptor(PdfSharp.Drawing.XFont)">
            <summary>
            Gets the FontDescriptor identified by the specified FontSelector. If no such objects 
            exists, a new FontDescriptor is created and added to the stock.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontDescriptorStock.CreateDescriptor(PdfSharp.Drawing.XFontFamily,PdfSharp.Drawing.XFontStyle)">
            <summary>
            Gets the FontDescriptor identified by the specified FontSelector. If no such objects 
            exists, a new FontDescriptor is created and added to the stock.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.FontDescriptorStock.FontSelector">
            <summary>
            A collection of information that uniquely identifies a particular font.
            Used to map XFont to PdfFont.
            There is a one to one relationship between a FontSelector and a TrueType/OpenType file.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontDescriptorStock.FontSelector.ToString">
            <summary>
            Returns a string for diagnostic purposes only.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XUnit">
            <summary>
            Represents a value and its unit of measure. The structure converts implicitly from and to
            double with a value measured in point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the XUnit class with type set to point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.#ctor(System.Double,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Initializes a new instance of the XUnit class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.ToString(System.IFormatProvider)">
            <summary>
            Returns the object as string using the format information.
            The unit of measure is appended to the end of the string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns the object as string using the specified format and format information.
            The unit of measure is appended to the end of the string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.ToString">
            <summary>
            Returns the object as string. The unit of measure is appended to the end of the string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.GetSuffix">
            <summary>
            Returns the unit of measure of the object as a string like 'pt', 'cm', or 'in'.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.FromPoint(System.Double)">
            <summary>
            Returns an XUnit object. Sets type to point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.FromInch(System.Double)">
            <summary>
            Returns an XUnit object. Sets type to inch.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.FromMillimeter(System.Double)">
            <summary>
            Returns an XUnit object. Sets type to millimeters.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.FromCentimeter(System.Double)">
            <summary>
            Returns an XUnit object. Sets type to centimeters.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.FromPresentation(System.Double)">
            <summary>
            Returns an XUnit object. Sets type to Presentation.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.op_Implicit(System.String)~PdfSharp.Drawing.XUnit">
            <summary>
            Converts a string to an XUnit object.
            If the string contains a suffix like 'cm' or 'in' the object will be converted
            to the appropriate type, otherwise point is assumed.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.op_Implicit(System.Int32)~PdfSharp.Drawing.XUnit">
            <summary>
            Converts an int to an XUnit object with type set to point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.op_Implicit(System.Double)~PdfSharp.Drawing.XUnit">
            <summary>
            Converts a double to an XUnit object with type set to point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.op_Implicit(PdfSharp.Drawing.XUnit)~System.Double">
            <summary>
            Returns a double value as point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.op_Equality(PdfSharp.Drawing.XUnit,PdfSharp.Drawing.XUnit)">
            <summary>
            Memberwise comparison. To compare by value, 
            use code like Math.Abs(a.Pt - b.Pt) &lt; 1e5.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.op_Inequality(PdfSharp.Drawing.XUnit,PdfSharp.Drawing.XUnit)">
            <summary>
            Memberwise comparison. To compare by value, 
            use code like Math.Abs(a.Pt - b.Pt) &lt; 1e5.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.Equals(System.Object)">
            <summary>
            Calls base class Equals.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.Parse(System.String)">
            <summary>
            This member is intended to be used by XmlDomainObjectReader only.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XUnit.ConvertType(PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Converts an existing object from one unit into another unit type.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XUnit.Zero">
            <summary>
            Represents a unit with all values zero.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XUnit.Value">
            <summary>
            Gets the raw value of the object without any conversion.
            To determine the XGraphicsUnit use property <code>Type</code>.
            To get the value in point use the implicit conversion to double.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XUnit.Type">
            <summary>
            Gets the unit of measure.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XUnit.Point">
            <summary>
            Gets or sets the value in point.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XUnit.Inch">
            <summary>
            Gets or sets the value in inch.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XUnit.Millimeter">
            <summary>
            Gets or sets the value in millimeter.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XUnit.Centimeter">
            <summary>
            Gets or sets the value in centimeter.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XUnit.Presentation">
            <summary>
            Gets or sets the value in presentation units (1/96 inch).
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XPdfForm">
            <summary>
            Represents a so called 'PDF form external object', which is typically an imported page of an external
            PDF document. XPdfForm objects are used like images to draw an existing PDF page of an external
            document in the current document. XPdfForm objects can only be placed in PDF documents. If you try
            to draw them using a XGraphics based on an GDI+ context no action is taken if no placeholder image
            is specified. Otherwise the place holder is drawn.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XForm">
            <summary>
            Represents a graphical object that can be used to render retained graphics on it.
            In GDI+ it is represented by a Metafile, in WPF by a DrawingVisual, and in PDF by a Form XObjects.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XImage">
            <summary>
            Defines an object used to draw image files (bmp, png, jpeg, gif) and PDF forms.
            An abstract base class that provides functionality for the Bitmap and Metafile descended classes.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XImage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XImage" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XImage.#ctor(System.Drawing.Image)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XImage" /> class from a GDI+ image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XImage.op_Implicit(System.Drawing.Image)~PdfSharp.Drawing.XImage">
            <summary>
            Implicit conversion from Image to XImage.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XImage.FromGdiPlusImage(System.Drawing.Image)">
            <summary>
            Conversion from Image to XImage.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XImage.FromFile(System.String)">
            <summary>
            Creates an image from the specified file.
            </summary>
            <param name="path">The path to a BMP, PNG, GIF, JPEG, TIFF, or PDF file.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XImage.ExistsFile(System.String)">
            <summary>
            Tests if a file exist. Supports PDF files with page number suffix.
            </summary>
            <param name="path">The path to a BMP, PNG, GIF, JPEG, TIFF, or PDF file.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XImage.Dispose">
            <summary>
            Under construction
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XImage.Dispose(System.Boolean)">
            <summary>
            Disposes underlying GDI+ object.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XImage.path">
            <summary>
            If path starts with '*' the image is created from a stream and the path is a GUID.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XImage.selector">
            <summary>
            Cache PdfImageTable.ImageSelector to speed up finding the right PdfImage
            if this image is used more than once.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.Width">
            <summary>
            Gets the width of the image.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.Height">
            <summary>
            Gets the height of the image.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.PointWidth">
            <summary>
            Gets the width of the image in point.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.PointHeight">
            <summary>
            Gets the height of the image in point.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.PixelWidth">
            <summary>
            Gets the width of the image in pixels.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.PixelHeight">
            <summary>
            Gets the height of the image in pixels.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.Size">
            <summary>
            Gets the size in point of the image.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.HorizontalResolution">
            <summary>
            Gets the horizontal resolution of the image.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.VerticalResolution">
            <summary>
            Gets the vertical resolution of the image.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.Interpolate">
            <summary>
            Gets or sets a flag indicating whether image interpolation is to be performed. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImage.Format">
            <summary>
            Gets the format of the image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XForm" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.#ctor(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of the XForm class such that it can be drawn on the specified graphics
            object.
            </summary>
            <param name="gfx">The graphics object that later is used to draw this form.</param>
            <param name="size">The size in points of the form.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.#ctor(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XUnit,PdfSharp.Drawing.XUnit)">
            <summary>
            Initializes a new instance of the XForm class such that it can be drawn on the specified graphics
            object.
            </summary>
            <param name="gfx">The graphics object that later is used to draw this form.</param>
            <param name="width">The width of the form.</param>
            <param name="height">The height of the form.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.#ctor(PdfSharp.Pdf.PdfDocument,PdfSharp.Drawing.XRect)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XForm" /> class that represents a page of a PDF document.
            </summary>
            <param name="document">The PDF document.</param>
            <param name="viewBox">The view box of the page.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.#ctor(PdfSharp.Pdf.PdfDocument,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XForm" /> class that represents a page of a PDF document.
            </summary>
            <param name="document">The PDF document.</param>
            <param name="size">The size of the page.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.#ctor(PdfSharp.Pdf.PdfDocument,PdfSharp.Drawing.XUnit,PdfSharp.Drawing.XUnit)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XForm" /> class that represents a page of a PDF document.
            </summary>
            <param name="document">The PDF document.</param>
            <param name="width">The width of the page.</param>
            <param name="height">The height of the page</param>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.DrawingFinished">
            <summary>
            This function should be called when drawing the content of this form is finished.
            The XGraphics object used for drawing the content is disposed by this function and 
            cannot be used for any further drawing operations.
            PDFsharp automatically calls this function when this form was used the first time
            in a DrawImage function. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.AssociateGraphics(PdfSharp.Drawing.XGraphics)">
            <summary>
            Called from XGraphics constructor that creates an instance that work on this form.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.Dispose(System.Boolean)">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.Finish">
            <summary>
            Sets the form in the state FormState.Finished.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.GetFontName(PdfSharp.Drawing.XFont,PdfSharp.Pdf.Advanced.PdfFont@)">
            <summary>
            Gets the resource name of the specified font within this form.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.TryGetFontName(System.String,PdfSharp.Pdf.Advanced.PdfFont@)">
            <summary>
            Tries to get the resource name of the specified font data within this form.
            Returns null if no such font exists.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.GetFontName(System.String,System.Byte[],PdfSharp.Pdf.Advanced.PdfFont@)">
            <summary>
            Gets the resource name of the specified font data within this form.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.GetImageName(PdfSharp.Drawing.XImage)">
            <summary>
            Gets the resource name of the specified image within this form.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.PdfSharp#Pdf#Advanced#IContentStream#GetImageName(PdfSharp.Drawing.XImage)">
            <summary>
            Implements the interface because the primary function is internal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.GetFormName(PdfSharp.Drawing.XForm)">
            <summary>
            Gets the resource name of the specified form within this form.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XForm.PdfSharp#Pdf#Advanced#IContentStream#GetFormName(PdfSharp.Drawing.XForm)">
            <summary>
            Implements the interface because the primary function is internal.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XForm.pdfForm">
            <summary>
            The PdfFormXObject gets invalid when PageNumber or transform changed. This is because a modification
            of an XPdfForm must not change objects that are already been drawn.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.Owner">
            <summary>
            Gets the owning document.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.ColorMode">
            <summary>
            Gets the color model used in the underlying PDF document.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.IsTemplate">
            <summary>
            Gets a value indicating whether this instance is a template.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.Width">
            <summary>
            Get the width of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.Height">
            <summary>
            Get the width of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.PointWidth">
            <summary>
            Get the width in point of this image.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.PointHeight">
            <summary>
            Get the height in point of this image.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.PixelWidth">
            <summary>
            Get the width of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.PixelHeight">
            <summary>
            Get the height of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.Size">
            <summary>
            Get the size of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.ViewBox">
            <summary>
            Gets the view box of the form.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.HorizontalResolution">
            <summary>
            Gets 72, the horizontal resolution by design of a form object.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.VerticalResolution">
            <summary>
            Gets 72 always, the vertical resolution by design of a form object.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.BoundingBox">
            <summary>
            Gets or sets the bounding box.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.Transform">
            <summary>
            Gets or sets the transformation matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XForm.PdfSharp#Pdf#Advanced#IContentStream#Resources">
            <summary>
            Implements the interface because the primary function is internal.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XForm.FormState.NotATemplate">
            <summary>
            The form is an imported PDF page.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XForm.FormState.Created">
            <summary>
            The template is just created.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XForm.FormState.UnderConstruction">
            <summary>
            XGraphics.FromForm() was called.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XForm.FormState.Finished">
            <summary>
            The form was drawn at least once and is 'frozen' now.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfForm.#ctor(System.String)">
            <summary>
            Initializes a new instance of the XPdfForm class from the specified path to an external PDF document.
            Although PDFsharp internally caches XPdfForm objects it is recommended to reuse XPdfForm objects
            in your code and change the PageNumber property if more than one page is needed form the external
            document. Furthermore, because XPdfForm can occupy very much memory, it is recommended to
            dispose XPdfForm objects if not needed anymore.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfForm.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPdfForm" /> class from a stream.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfForm.FromFile(System.String)">
            <summary>
            Creates an XPdfForm from a file.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfForm.FromStream(System.IO.Stream)">
            <summary>
            Creates an XPdfForm from a stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfForm.Finish">
            <summary>
            Sets the form in the state FormState.Finished.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfForm.Dispose(System.Boolean)">
            <summary>
            Frees the memory occupied by the underlying imported PDF document, even if other XPdfForm objects
            refer to this document. A reuse of this object doesn't fail, because the underlying PDF document
            is re-imported if necessary.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfForm.ExtractPageNumber(System.String,System.Int32@)">
            <summary>
            Extracts the page number if the path has the form 'MyFile.pdf#123' and returns
            the actual path without the number sign and the following digits.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.PlaceHolder">
            <summary>
            Gets or sets an image that is used for drawing if the current XGraphics object cannot handle
            PDF forms. A place holder is useful for showing a preview of a page on the display, because
            PDFsharp cannot render native PDF objects.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.Page">
            <summary>
            Gets the underlying PdfPage (if one exists).
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.PageCount">
            <summary>
            Gets the number of pages in the PDF form.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.Width">
            <summary>
            Gets the width in point of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.Height">
            <summary>
            Gets the height in point of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.PointWidth">
            <summary>
            Gets the width in point of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.PointHeight">
            <summary>
            Gets the height in point of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.PixelWidth">
            <summary>
            Gets the width in point of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.PixelHeight">
            <summary>
            Gets the height in point of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.Size">
            <summary>
            Get the size of the page identified by the property PageNumber.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.Transform">
            <summary>
            Gets or sets the transformation matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.PageNumber">
            <summary>
            Gets or sets the page number in the external PDF document this object refers to. The page number
            is one-based, i.e. it is in the range from 1 to PageCount. The default value is 1.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.PageIndex">
            <summary>
            Gets or sets the page index in the external PDF document this object refers to. The page index
            is zero-based, i.e. it is in the range from 0 to PageCount - 1. The default value is 0.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfForm.ExternalDocument">
            <summary>
            Gets the underlying document from which pages are imported.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.BcgSR">
            <summary>
            String resources for the empira barcode renderer.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.InflaterHuffmanTree">
            <summary>
            Huffman tree used for inflation
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defLitLenTree">
            <summary>
            Literal length tree
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defDistTree">
            <summary>
            Distance tree
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.InflaterHuffmanTree.#ctor(System.Byte[])">
            <summary>
            Constructs a Huffman tree from the array of code lengths.
            </summary>
            <param name="codeLengths">
            the array of code lengths
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.InflaterHuffmanTree.GetSymbol(PdfSharp.SharpZipLib.Zip.Compression.Streams.StreamManipulator)">
            <summary>
            Reads the next symbol from input.  The symbol is encoded using the
            huffman tree.
            </summary>
            <param name="input">
            input the input source.
            </param>
            <returns>
            the next symbol, or -1 if not enough input is available.
            </returns>
        </member>
        <member name="T:PdfSharp.Pdf.PdfStringObject">
            <summary>
            Represents an indirect text string value. This type is not used by PDFsharp. If it is imported from
            an external PDF file, the value is converted into a direct object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfStringObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfStringObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfStringObject.#ctor(PdfSharp.Pdf.PdfDocument,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfStringObject" /> class.
            </summary>
            <param name="document">The document.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfStringObject.#ctor(System.String,PdfSharp.Pdf.PdfStringEncoding)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfStringObject" /> class.
            </summary>
            <param name="value">The value.</param>
            <param name="encoding">The encoding.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfStringObject.ToString">
            <summary>
            Returns the string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfStringObject.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the string literal with encoding DOCEncoded.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfStringObject.Length">
            <summary>
            Gets the number of characters in this string.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfStringObject.Encoding">
            <summary>
            Gets or sets the encoding.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfStringObject.HexLiteral">
            <summary>
            Gets a value indicating whether the string is a hexadecimal literal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfStringObject.Value">
            <summary>
            Gets or sets the value as string
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfStringObject.EncryptionValue">
            <summary>
            Gets or sets the string value for encryption purposes.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Filters.Filtering">
            <summary>
            Applies standard filters to streams.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filtering.GetFilter(System.String)">
            <summary>
            Gets the filter specified by the case sensitive name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filtering.Encode(System.Byte[],System.String)">
            <summary>
            Encodes the data with the specified filter.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filtering.Encode(System.String,System.String)">
            <summary>
            Encodes a raw string with the specified filter.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filtering.Decode(System.Byte[],System.String,PdfSharp.Pdf.Filters.FilterParms)">
            <summary>
            Decodes the data with the specified filter.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filtering.Decode(System.Byte[],System.String)">
            <summary>
            Decodes the data with the specified filter.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filtering.Decode(System.Byte[],PdfSharp.Pdf.PdfItem)">
            <summary>
            Decodes the data with the specified filter.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filtering.DecodeToString(System.Byte[],System.String,PdfSharp.Pdf.Filters.FilterParms)">
            <summary>
            Decodes to a raw string with the specified filter.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filtering.DecodeToString(System.Byte[],System.String)">
            <summary>
            Decodes to a raw string with the specified filter.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Filters.Filtering.ASCIIHexDecode">
            <summary>
            Gets the filter singleton.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Filters.Filtering.ASCII85Decode">
            <summary>
            Gets the filter singleton.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Filters.Filtering.LzwDecode">
            <summary>
            Gets the filter singleton.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Filters.Filtering.FlateDecode">
            <summary>
            Gets the filter singleton.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.FontType.TrueType">
            <summary>
            TrueType with WinAnsi encoding.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.FontType.Type0">
            <summary>
            TrueType with Identity-H or Identity-V encoding (unicode).
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFontTable">
            <summary>
            Contains all used fonts of a document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFontTable.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of this class, which is a singleton for each document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFontTable.GetFont(PdfSharp.Drawing.XFont)">
            <summary>
            Gets a PdfFont from an XFont. If no PdfFont already exists, a new one is created.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFontTable.GetFont(System.String,System.Byte[])">
            <summary>
            Gets a PdfFont from a font program. If no PdfFont already exists, a new one is created.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFontTable.TryGetFont(System.String)">
            <summary>
            Tries to gets a PdfFont from the font dictionary.
            Returns null if no such PdfFont exists.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontTable.fonts">
            <summary>
            Map from PdfFontSelector to PdfFont.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFontTable.FontSelector">
            <summary>
            A collection of information that uniquely identifies a particular PDF font.
            ... more docu... TODO
            Two PDF fonts are equal if and only if their font selector objects are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFontTable.FontSelector.#ctor(PdfSharp.Drawing.XFont)">
            <summary>
            Initializes a new instance of PdfFontSelector from an XFont.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFontTable.FontSelector.#ctor(System.String)">
            <summary>
            Initializes a new instance of PdfFontSelector from a unique name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFontTable.FontSelector.ToString">
            <summary>
            Returns a string for diagnostic purposes only.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFontTable.FontSelector.Name">
            <summary>
            Gets the (generated) resource name of the font. In our own PDF files equal fonts share the
            same resource name in all contents streams.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFontTable.FontSelector.Style">
            <summary>
            Gets the style. Contains only flags that effects the font face and are available for the specified font.
            </summary>
            <value>The style.</value>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFontTable.FontSelector.FontType">
            <summary>
            Gets the type of the font (TrueType with Ansi Encoding or CID font).
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XRect">
            <summary>
            Stores a set of four floating-point numbers that represent the location and size of a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the XRect class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.#ctor(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Initializes a new instance of the XRect class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.#ctor(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XVector)">
            <summary>
            Initializes a new instance of the XRect class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.#ctor(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of the XRect class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.#ctor(PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of the XRect class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.#ctor(System.Drawing.PointF,System.Drawing.SizeF)">
            <summary>
            Initializes a new instance of the XRect class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.#ctor(System.Drawing.RectangleF)">
            <summary>
            Initializes a new instance of the XRect class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.FromLTRB(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a rectangle from for straight lines.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.op_Equality(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XRect)">
            <summary>
            Determines whether the two rectangles are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.op_Inequality(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XRect)">
            <summary>
            Determines whether the two rectangles are not equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Equals(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XRect)">
            <summary>
            Determines whether the two rectangles are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Equals(PdfSharp.Drawing.XRect)">
            <summary>
            Determines whether this instance and the specified rect are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Parse(System.String)">
            <summary>
            Parses the rectangle from a string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.ToString">
            <summary>
            Converts this XRect to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.ToString(System.IFormatProvider)">
            <summary>
            Converts this XRect to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts this XRect to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Contains(PdfSharp.Drawing.XPoint)">
            <summary>
            Indicates whether the rectangle contains the specified point. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Contains(System.Double,System.Double)">
            <summary>
            Indicates whether the rectangle contains the specified point. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Contains(PdfSharp.Drawing.XRect)">
            <summary>
            Indicates whether the rectangle contains the specified rectangle. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.IntersectsWith(PdfSharp.Drawing.XRect)">
            <summary>
            Indicates whether the specified rectangle intersects with the current rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Intersect(PdfSharp.Drawing.XRect)">
            <summary>
            Sets current rectangle to the intersection of the current rectangle and the specified rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Intersect(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XRect)">
            <summary>
            Returns the intersection of two rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Union(PdfSharp.Drawing.XRect)">
            <summary>
            Sets current rectangle to the union of the current rectangle and the specified rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Union(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XRect)">
            <summary>
            Returns the union of two rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Union(PdfSharp.Drawing.XPoint)">
            <summary>
            Sets current rectangle to the union of the current rectangle and the specified point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Union(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XPoint)">
            <summary>
            Returns the intersection of a rectangle and a point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Offset(PdfSharp.Drawing.XVector)">
            <summary>
            Moves a rectangle by the specified amount.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Offset(System.Double,System.Double)">
            <summary>
            Moves a rectangle by the specified amount.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Offset(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XVector)">
            <summary>
            Returns a rectangle that is offset from the specified rectangle by using the specified vector. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Offset(PdfSharp.Drawing.XRect,System.Double,System.Double)">
            <summary>
            Returns a rectangle that is offset from the specified rectangle by using specified horizontal and vertical amounts. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.op_Addition(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XPoint)">
            <summary>
            Translates the rectangle by adding the specified point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.op_Subtraction(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XPoint)">
            <summary>
            Translates the rectangle by subtracting the specified point.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Inflate(PdfSharp.Drawing.XSize)">
            <summary>
            Expands the rectangle by using the specified Size, in all directions.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Inflate(System.Double,System.Double)">
            <summary>
            Expands or shrinks the rectangle by using the specified width and height amounts, in all directions.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Inflate(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XSize)">
            <summary>
            Returns the rectangle that results from expanding the specified rectangle by the specified Size, in all directions.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Inflate(PdfSharp.Drawing.XRect,System.Double,System.Double)">
            <summary>
            Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified width and height amounts, in all directions.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Transform(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XMatrix)">
            <summary>
            Returns the rectangle that results from applying the specified matrix to the specified rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Transform(PdfSharp.Drawing.XMatrix)">
            <summary>
            Transforms the rectangle by applying the specified matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.Scale(System.Double,System.Double)">
            <summary>
            Multiplies the size of the current rectangle by the specified x and y values.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.ToRectangleF">
            <summary>
            Converts this instance to a System.Drawing.RectangleF.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.op_Implicit(System.Drawing.Rectangle)~PdfSharp.Drawing.XRect">
            <summary>
            Performs an implicit  conversion from a System.Drawing.Rectangle to an XRect.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XRect.op_Implicit(System.Drawing.RectangleF)~PdfSharp.Drawing.XRect">
            <summary>
            Performs an implicit  conversion from a System.Drawing.RectangleF to an XRect.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Empty">
            <summary>
            Gets the empty rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Location">
            <summary>
            Gets or sets the location of the rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Size">
            <summary>
            Gets or sets the size of the rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.X">
            <summary>
            Gets or sets the X value of the rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Y">
            <summary>
            Gets or sets the Y value of the rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Width">
            <summary>
            Gets or sets the width of the rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Height">
            <summary>
            Gets or sets the height of the rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Left">
            <summary>
            Gets the x-axis value of the left side of the rectangle. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Top">
            <summary>
            Gets the y-axis value of the top side of the rectangle. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Right">
            <summary>
            Gets the x-axis value of the right side of the rectangle. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Bottom">
            <summary>
            Gets the y-axis value of the bottom side of the rectangle. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.TopLeft">
            <summary>
            Gets the position of the top-left corner of the rectangle. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.TopRight">
            <summary>
            Gets the position of the top-right corner of the rectangle. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.BottomLeft">
            <summary>
            Gets the position of the bottom-left corner of the rectangle. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.BottomRight">
            <summary>
            Gets the position of the bottom-right corner of the rectangle. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XRect.Center">
            <summary>
            Gets the center of the rectangle.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XStringAlignment">
            <summary>
            Specifies the alignment of a text string relative to its layout rectangle.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XStringAlignment.Near">
            <summary>
            Specifies the text be aligned near the layout.
            In a left-to-right layout, the near position is left. In a right-to-left layout, the near
            position is right.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XStringAlignment.Center">
            <summary>
            Specifies that text is aligned in the center of the layout rectangle.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XStringAlignment.Far">
            <summary>
            Specifies that text is aligned far from the origin position of the layout rectangle.
            In a left-to-right layout, the far position is right. In a right-to-left layout, the far
            position is left. 
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XSmoothingMode">
            <summary>
            Specifies whether smoothing (or antialiasing) is applied to lines and curves
            and the edges of filled areas.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XSmoothingMode.Invalid">
            <summary>
            Specifies an invalid mode.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XSmoothingMode.Default">
            <summary>
            Specifies the default mode.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XSmoothingMode.HighSpeed">
            <summary>
            Specifies high speed, low quality rendering.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XSmoothingMode.HighQuality">
            <summary>
            Specifies high quality, low speed rendering.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XSmoothingMode.None">
            <summary>
            Specifies no antialiasing.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XSmoothingMode.AntiAlias">
            <summary>
            Specifies antialiased rendering.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XCombineMode">
            <summary>
            Specifies how different clipping regions can be combined.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XCombineMode.Replace">
            <summary>
            One clipping region is replaced by another.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XCombineMode.Intersect">
            <summary>
            Two clipping regions are combined by taking their intersection.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XCombineMode.Union">
            <summary>
            Not yet implemented in PDFsharp.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XCombineMode.Xor">
            <summary>
            Not yet implemented in PDFsharp.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XCombineMode.Exclude">
            <summary>
            Not yet implemented in PDFsharp.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XCombineMode.Complement">
            <summary>
            Not yet implemented in PDFsharp.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.Layout.XTextFormatter">
            <summary>
            Represents a very simple text formatter.
            If this class does not satisfy your needs on formatting paragraphs I recommend to take a look
            at MigraDoc Foundation. Alternatively you should copy this class in your own source code and modify it.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Layout.XTextFormatter.#ctor(PdfSharp.Drawing.XGraphics)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.Layout.XTextFormatter" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Layout.XTextFormatter.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect)">
            <summary>
            Draws the text.
            </summary>
            <param name="text">The text to be drawn.</param>
            <param name="font">The font.</param>
            <param name="brush">The text brush.</param>
            <param name="layoutRectangle">The layout rectangle.</param>
        </member>
        <member name="M:PdfSharp.Drawing.Layout.XTextFormatter.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Draws the text.
            </summary>
            <param name="text">The text to be drawn.</param>
            <param name="font">The font.</param>
            <param name="brush">The text brush.</param>
            <param name="layoutRectangle">The layout rectangle.</param>
            <param name="format">The format. Must be <c>XStringFormat.TopLeft</c></param>
        </member>
        <member name="M:PdfSharp.Drawing.Layout.XTextFormatter.AlignLine(System.Int32,System.Int32,System.Double)">
            <summary>
            Align center, right or justify.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.Layout.XTextFormatter.Text">
            <summary>
            Gets or sets the text.
            </summary>
            <value>The text.</value>
        </member>
        <member name="P:PdfSharp.Drawing.Layout.XTextFormatter.Font">
            <summary>
            Gets or sets the font.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.Layout.XTextFormatter.LayoutRectangle">
            <summary>
            Gets or sets the bounding box of the layout.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.Layout.XTextFormatter.Alignment">
            <summary>
            Gets or sets the alignment of the text.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.Layout.XTextFormatter.Block">
            <summary>
            Represents a single word.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Layout.XTextFormatter.Block.#ctor(System.String,PdfSharp.Drawing.Layout.XTextFormatter.BlockType,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.Layout.XTextFormatter.Block" /> class.
            </summary>
            <param name="text">The text of the block.</param>
            <param name="type">The type of the block.</param>
            <param name="width">The width of the text.</param>
        </member>
        <member name="M:PdfSharp.Drawing.Layout.XTextFormatter.Block.#ctor(PdfSharp.Drawing.Layout.XTextFormatter.BlockType)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.Layout.XTextFormatter.Block" /> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XTextFormatter.Block.Text">
            <summary>
            The text represented by this block.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XTextFormatter.Block.Type">
            <summary>
            The type of the block.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XTextFormatter.Block.Width">
            <summary>
            The width of the text.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XTextFormatter.Block.Location">
            <summary>
            The location relative to the upper left corner of the layout rectangle.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XTextFormatter.Block.Alignment">
            <summary>
            The alignment of this line.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XTextFormatter.Block.Stop">
            <summary>
            A flag indicating that this is the last bock that fits in the layout rectangle.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Chars">
            <summary>
            Character table by name. Same as PdfSharp.Pdf.IO.Chars. Not yet clear if necessary.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.OpenTypeFontWriter">
            <summary>
            Represents a writer for True Type font files. 
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.FontWriter">
            <summary>
            Represents a writer for generation of font file streams. 
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Fonts.FontWriter" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.Close(System.Boolean)">
            <summary>
            Closes the writer and, if specified, the underlying stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.Close">
            <summary>
            Closes the writer and the underlying stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.WriteByte(System.Byte)">
            <summary>
            Writes the specified value to the font stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.WriteByte(System.Int32)">
            <summary>
            Writes the specified value to the font stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.WriteShort(System.Int16)">
            <summary>
            Writes the specified value to the font stream using big-endian.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.WriteShort(System.Int32)">
            <summary>
            Writes the specified value to the font stream using big-endian.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.WriteUShort(System.UInt16)">
            <summary>
            Writes the specified value to the font stream using big-endian.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.WriteUShort(System.Int32)">
            <summary>
            Writes the specified value to the font stream using big-endian.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.WriteInt(System.Int32)">
            <summary>
            Writes the specified value to the font stream using big-endian.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.FontWriter.WriteUInt(System.UInt32)">
            <summary>
            Writes the specified value to the font stream using big-endian.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.FontWriter.Position">
            <summary>
            Gets or sets the position within the stream.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.FontWriter.Stream">
            <summary>
            Gets the underlying stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.OpenTypeFontWriter.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Fonts.OpenType.OpenTypeFontWriter" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.OpenTypeFontWriter.WriteTag(System.String)">
            <summary>
            Writes a table name.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.FontDescriptor">
            <summary>
            Base class for all font descriptors.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.FontFile">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.FontType">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.FontName">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.FullName">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.FamilyName">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.Weight">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.IsBoldFace">
            <summary>
            Gets a value indicating whether this instance belongs to a bold font.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.ItalicAngle">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.IsItalicFace">
            <summary>
            Gets a value indicating whether this instance belongs to an italic font.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.XMin">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.YMin">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.XMax">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.YMax">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.IsFixedPitch">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.UnderlinePosition">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.UnderlineThickness">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.StrikeoutPosition">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.StrikeoutSize">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.Version">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.EncodingScheme">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.UnitsPerEm">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.CapHeight">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.XHeight">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.Ascender">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.Descender">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.Leading">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.Flags">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.StemV">
            <summary />
        </member>
        <member name="P:PdfSharp.Fonts.FontDescriptor.FontMetrics">
            <summary>
            Under Construction
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.FontDataStock">
            <summary>
            Global table of TrueType font faces.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontDataStock.CalcChecksum(System.Byte[])">
            <summary>
            Calculates an Adler32 checksum.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.OpenType.FontDataStock.Global">
            <summary>
            Gets the singleton.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XColorResourceManager">
            <summary>
            Manages the localization of the color class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColorResourceManager.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XColorResourceManager" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColorResourceManager.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XColorResourceManager" /> class.
            </summary>
            <param name="cultureInfo">The culture info.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XColorResourceManager.GetKnownColor(System.UInt32)">
            <summary>
            Gets a known color from an ARGB value. Throws an ArgumentException if the value is not a known color.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColorResourceManager.GetKnownColors(System.Boolean)">
            <summary>
            Gets all known colors.
            </summary>
            <param name="includeTransparent">Indicates whether to include the color Transparent.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XColorResourceManager.ToColorName(PdfSharp.Drawing.XKnownColor)">
            <summary>
            Converts a known color to a localized color name.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColorResourceManager.ToColorName(PdfSharp.Drawing.XColor)">
            <summary>
            Converts a color to a localized color name or an ARGB value.
            </summary>
        </member>
        <member name="T:PdfSharp.VersionInfo">
            <summary>
            Version info of this assembly.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfRealObject">
            <summary>
            Represents an indirect real value. This type is not used by PDFsharp. If it is imported from
            an external PDF file, the value is converted into a direct object.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfNumberObject">
            <summary>
            Base class for indirect number values (not yet used, maybe superfluous).
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNumberObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfNumberObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNumberObject.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfNumberObject" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRealObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfRealObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRealObject.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfRealObject" /> class.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRealObject.#ctor(PdfSharp.Pdf.PdfDocument,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfRealObject" /> class.
            </summary>
            <param name="document">The document.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRealObject.ToString">
            <summary>
            Returns the real as a culture invariant string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRealObject.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the real literal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfRealObject.Value">
            <summary>
            Gets or sets the value.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfPage">
            <summary>
            Represents a page in a PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.#ctor">
            <summary>
            Initializes a new page. The page must be added to a document before it can be used.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfPage" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.Close">
            <summary>
            Closes the page. A closes page cannot be modified anymore and it is not possible to
            get an XGraphics object for a closed page. Closing a page is not required, but may saves
            resources if the document has many pages. 
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.RenderContent">
            <summary>
            The content stream currently used by an XGraphics object for rendering.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.AddDocumentLink(PdfSharp.Pdf.PdfRectangle,System.Int32)">
            <summary>
            Adds an intra document link.
            </summary>
            <param name="rect">The rect.</param>
            <param name="destinationPage">The destination page.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.AddWebLink(PdfSharp.Pdf.PdfRectangle,System.String)">
            <summary>
            Adds a link to the Web.
            </summary>
            <param name="rect">The rect.</param>
            <param name="url">The URL.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.AddFileLink(PdfSharp.Pdf.PdfRectangle,System.String)">
            <summary>
            Adds a link to a file.
            </summary>
            <param name="rect">The rect.</param>
            <param name="fileName">Name of the file.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.GetFontName(PdfSharp.Drawing.XFont,PdfSharp.Pdf.Advanced.PdfFont@)">
            <summary>
            Gets the resource name of the specified font within this page.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.TryGetFontName(System.String,PdfSharp.Pdf.Advanced.PdfFont@)">
            <summary>
            Tries to get the resource name of the specified font data within this page.
            Returns null if no such font exists.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.GetFontName(System.String,System.Byte[],PdfSharp.Pdf.Advanced.PdfFont@)">
            <summary>
            Gets the resource name of the specified font data within this page.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.GetImageName(PdfSharp.Drawing.XImage)">
            <summary>
            Gets the resource name of the specified image within this page.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.PdfSharp#Pdf#Advanced#IContentStream#GetImageName(PdfSharp.Drawing.XImage)">
            <summary>
            Implements the interface because the primary function is internal.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.GetFormName(PdfSharp.Drawing.XForm)">
            <summary>
            Gets the resource name of the specified form within this page.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.PdfSharp#Pdf#Advanced#IContentStream#GetFormName(PdfSharp.Drawing.XForm)">
            <summary>
            Implements the interface because the primary function is internal.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.transparencyUsed">
            <summary>
            Hack to indicate that a page-level transparency group must be created.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.InheritValues(PdfSharp.Pdf.PdfDictionary,PdfSharp.Pdf.PdfPage.InheritedValues)">
            <summary>
            Inherit values from parent node.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPage.InheritValues(PdfSharp.Pdf.PdfDictionary,PdfSharp.Pdf.PdfPage.InheritedValues@)">
            <summary>
            Add all inheritable values from the specified page to the specified values structure.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Tag">
            <summary>
            Gets or sets a user defined object that contains arbitrary information associated with this PDF page.
            The tag is not used by PDFsharp.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.IsClosed">
            <summary>
            Gets a value indicating whether the page is closed.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Document">
            <summary>
            Gets or sets the PdfDocument this page belongs to.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Orientation">
            <summary>
            Gets or sets the orientation of the page. The default value PageOrientation.Portrait.
            If an imported page has a /Rotate value that matches the formula 90 + n * 180 the 
            orientation is set to PageOrientation.Landscape.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Size">
            <summary>
            Gets or sets one of the predefined standard sizes like.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.TrimMargins">
            <summary>
            Gets or sets the trim margins.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.MediaBox">
            <summary>
            Gets or sets the media box directly. XGrahics is not prepared to work with a media box
            with an origin other than (0,0).
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.CropBox">
            <summary>
            Gets or sets the crop box.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.BleedBox">
            <summary>
            Gets or sets the bleed box.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.ArtBox">
            <summary>
            Gets or sets the art box.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.TrimBox">
            <summary>
            Gets or sets the trim box.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Height">
            <summary>
            Gets or sets the height of the page. If orientation is Landscape, this function applies to
            the width.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Width">
            <summary>
            Gets or sets the width of the page. If orientation is Landscape, this function applies to
            the height.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Rotate">
            <summary>
            Gets or sets the /Rotate entry of the PDF page. The value is the number of degrees by which the page 
            should be rotated clockwise when displayed or printed. The value must be a multiple of 90.
            PDFsharp does not set this value, but for imported pages this value can be set and must be taken
            into account when adding graphic to such a page.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Contents">
            <summary>
            Gets the array of content streams of the page.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Annotations">
            <summary>
            Gets the annotations array of this page.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.CustomValues">
            <summary>
            Gets or sets the custom values.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.PdfSharp#Pdf#Advanced#IContentStream#Resources">
            <summary>
            Implements the interface because the primary function is internal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfPage.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfPage.InheritablePageKeys">
            <summary>
            Predefined keys common to PdfPage and PdfPages.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.InheritablePageKeys.Resources">
            <summary>
            (Required; inheritable) A dictionary containing any resources required by the page. 
            If the page requires no resources, the value of this entry should be an empty dictionary.
            Omitting the entry entirely indicates that the resources are to be inherited from an 
            ancestor node in the page tree.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.InheritablePageKeys.MediaBox">
            <summary>
            (Required; inheritable) A rectangle, expressed in default user space units, defining the 
            boundaries of the physical medium on which the page is intended to be displayed or printed.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.InheritablePageKeys.CropBox">
            <summary>
            (Optional; inheritable) A rectangle, expressed in default user space units, defining the 
            visible region of default user space. When the page is displayed or printed, its contents 
            are to be clipped (cropped) to this rectangle and then imposed on the output medium in some
            implementation defined manner. Default value: the value of MediaBox.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.InheritablePageKeys.Rotate">
            <summary>
            (Optional; inheritable) The number of degrees by which the page should be rotated clockwise 
            when displayed or printed. The value must be a multiple of 90. Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.Type">
            <summary>
            (Required) The type of PDF object that this dictionary describes;
            must be Page for a page object.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.Parent">
            <summary>
            (Required; must be an indirect reference)
            The page tree node that is the immediate parent of this page object.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.LastModified">
            <summary>
            (Required if PieceInfo is present; optional otherwise; PDF 1.3) The date and time
            when the page’s contents were most recently modified. If a page-piece dictionary
            (PieceInfo) is present, the modification date is used to ascertain which of the 
            application data dictionaries that it contains correspond to the current content
            of the page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.BleedBox">
            <summary>
            (Optional; PDF 1.3) A rectangle, expressed in default user space units, defining the 
            region to which the contents of the page should be clipped when output in a production
            environment. Default value: the value of CropBox.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.TrimBox">
            <summary>
            (Optional; PDF 1.3) A rectangle, expressed in default user space units, defining the
            intended dimensions of the finished page after trimming. Default value: the value of 
            CropBox.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.ArtBox">
            <summary>
            (Optional; PDF 1.3) A rectangle, expressed in default user space units, defining the
            extent of the page’s meaningful content (including potential white space) as intended
            by the page’s creator. Default value: the value of CropBox.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.BoxColorInfo">
            <summary>
            (Optional; PDF 1.4) A box color information dictionary specifying the colors and other 
            visual characteristics to be used in displaying guidelines on the screen for the various
            page boundaries. If this entry is absent, the application should use its own current 
            default settings.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.Contents">
            <summary>
            (Optional) A content stream describing the contents of this page. If this entry is absent, 
            the page is empty. The value may be either a single stream or an array of streams. If the 
            value is an array, the effect is as if all of the streams in the array were concatenated,
            in order, to form a single stream. This allows PDF producers to create image objects and
            other resources as they occur, even though they interrupt the content stream. The division
            between streams may occur only at the boundaries between lexical tokens but is unrelated
            to the page’s logical content or organization. Applications that consume or produce PDF 
            files are not required to preserve the existing structure of the Contents array.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.Group">
            <summary>
            (Optional; PDF 1.4) A group attributes dictionary specifying the attributes of the page’s 
            page group for use in the transparent imaging model.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.Thumb">
            <summary>
            (Optional) A stream object defining the page’s thumbnail image.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.B">
            <summary>
            (Optional; PDF 1.1; recommended if the page contains article beads) An array of indirect
            references to article beads appearing on the page. The beads are listed in the array in 
            natural reading order.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.Dur">
            <summary>
            (Optional; PDF 1.1) The page’s display duration (also called its advance timing): the 
            maximum length of time, in seconds, that the page is displayed during presentations before
            the viewer application automatically advances to the next page. By default, the viewer does 
            not advance automatically.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.Trans">
            <summary>
            (Optional; PDF 1.1) A transition dictionary describing the transition effect to be used 
            when displaying the page during presentations.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.Annots">
            <summary>
            (Optional) An array of annotation dictionaries representing annotations associated with 
            the page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.AA">
            <summary>
            (Optional; PDF 1.2) An additional-actions dictionary defining actions to be performed 
            when the page is opened or closed.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.Metadata">
            <summary>
            (Optional; PDF 1.4) A metadata stream containing metadata for the page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.PieceInfo">
            <summary>
            (Optional; PDF 1.3) A page-piece dictionary associated with the page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.StructParents">
            <summary>
            (Required if the page contains structural content items; PDF 1.3)
            The integer key of the page’s entry in the structural parent tree.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.ID">
            <summary>
            (Optional; PDF 1.3; indirect reference preferred) The digital identifier of
            the page’s parent Web Capture content set.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.PZ">
            <summary>
            (Optional; PDF 1.3) The page’s preferred zoom (magnification) factor: the factor 
            by which it should be scaled to achieve the natural display magnification.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.SeparationInfo">
            <summary>
            (Optional; PDF 1.3) A separation dictionary containing information needed
            to generate color separations for the page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.Tabs">
            <summary>
            (Optional; PDF 1.5) A name specifying the tab order to be used for annotations
            on the page. The possible values are R (row order), C (column order),
            and S (structure order).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.TemplateInstantiated">
            <summary>
            (Required if this page was created from a named page object; PDF 1.5)
            The name of the originating page object.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.PresSteps">
            <summary>
            (Optional; PDF 1.5) A navigation node dictionary representing the first node
            on the page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.UserUnit">
            <summary>
            (Optional; PDF 1.6) A positive number giving the size of default user space units,
            in multiples of 1/72 inch. The range of supported values is implementation-dependent.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPage.Keys.VP">
            <summary>
            (Optional; PDF 1.6) An array of viewport dictionaries specifying rectangular regions 
            of the page.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPage.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfPage.InheritedValues">
            <summary>
            Values inherited from a parent in the parent chain of a page tree.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfOutline">
            <summary>
            Represents an outline item in the outlines tree. An outline is also knows as a bookmark.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfOutline" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfOutline" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Initializes a new instance from an existing dictionary. Used for object type transformation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.#ctor(System.String,PdfSharp.Pdf.PdfPage,System.Boolean,PdfSharp.Pdf.PdfOutlineStyle,PdfSharp.Drawing.XColor)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfOutline" /> class.
            </summary>
            <param name="title">The outline text.</param>
            <param name="destinationPage">The destination page.</param>
            <param name="opened">Specifies whether the node is displayed expanded (opened) or collapsed.</param>
            <param name="style">The font style used to draw the outline text.</param>
            <param name="textColor">The color used to draw the outline text.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.#ctor(System.String,PdfSharp.Pdf.PdfPage,System.Boolean,PdfSharp.Pdf.PdfOutlineStyle)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfOutline" /> class.
            </summary>
            <param name="title">The outline text.</param>
            <param name="destinationPage">The destination page.</param>
            <param name="opened">Specifies whether the node is displayed expanded (opened) or collapsed.</param>
            <param name="style">The font style used to draw the outline text.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.#ctor(System.String,PdfSharp.Pdf.PdfPage,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfOutline" /> class.
            </summary>
            <param name="title">The outline text.</param>
            <param name="destinationPage">The destination page.</param>
            <param name="opened">Specifies whether the node is displayed expanded (opened) or collapsed.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.#ctor(System.String,PdfSharp.Pdf.PdfPage)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfOutline" /> class.
            </summary>
            <param name="title">The outline text.</param>
            <param name="destinationPage">The destination page.</param>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.openCount">
            <summary>
            The total number of open descendants at all lower levels.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.PrepareForSave">
            <summary>
            Creates key/values pairs according to the object structure.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.Title">
            <summary>
            Gets or sets the title.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.DestinationPage">
            <summary>
            Gets or sets the destination page.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.Opened">
            <summary>
            Gets or sets whether the outline item is opened (or expanded).
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.Style">
            <summary>
            Gets or sets the style.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.TextColor">
            <summary>
            Gets or sets the color of the text.
            </summary>
            <value>The color of the text.</value>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.Outlines">
            <summary>
            Gets the outline collection of this node.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection">
            <summary>
            Represents a collection of outlines.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection.Add(PdfSharp.Pdf.PdfOutline)">
            <summary>
            Adds the specified outline.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection.Add(System.String,PdfSharp.Pdf.PdfPage,System.Boolean,PdfSharp.Pdf.PdfOutlineStyle,PdfSharp.Drawing.XColor)">
            <summary>
            Adds the specified outline entry.
            </summary>
            <param name="title">The outline text.</param>
            <param name="destinationPage">The destination page.</param>
            <param name="opened">Specifies whether the node is displayed expanded (opened) or collapsed.</param>
            <param name="style">The font style used to draw the outline text.</param>
            <param name="textColor">The color used to draw the outline text.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection.Add(System.String,PdfSharp.Pdf.PdfPage,System.Boolean,PdfSharp.Pdf.PdfOutlineStyle)">
            <summary>
            Adds the specified outline entry.
            </summary>
            <param name="title">The outline text.</param>
            <param name="destinationPage">The destination page.</param>
            <param name="opened">Specifies whether the node is displayed expanded (opened) or collapsed.</param>
            <param name="style">The font style used to draw the outline text.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection.Add(System.String,PdfSharp.Pdf.PdfPage,System.Boolean)">
            <summary>
            Adds the specified outline entry.
            </summary>
            <param name="title">The outline text.</param>
            <param name="destinationPage">The destination page.</param>
            <param name="opened">Specifies whether the node is displayed expanded (opened) or collapsed.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection.Add(System.String,PdfSharp.Pdf.PdfPage)">
            <summary>
            Adds the specified outline entry.
            </summary>
            <param name="title">The outline text.</param>
            <param name="destinationPage">The destination page.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection.IndexOf(PdfSharp.Pdf.PdfOutline)">
            <summary>
            Gets the index of the specified outline.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection.HasOutline">
            <summary>
            Indicates whether the outline has at least one entry.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection.Count">
            <summary>
            Gets the number of entries in this collection.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.PdfOutlineCollection.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:PdfSharp.Pdf.PdfOutline" /> at the specified index.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfOutline.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes; if present,
            must be Outlines for an outline dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.Title">
            <summary>
            (Required) The text to be displayed on the screen for this item.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.Parent">
            <summary>
            (Required; must be an indirect reference) The parent of this item in the outline hierarchy.
            The parent of a top-level item is the outline dictionary itself.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.Prev">
            <summary>
            (Required for all but the first item at each level; must be an indirect reference)
            The previous item at this outline level.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.Next">
            <summary>
            (Required for all but the last item at each level; must be an indirect reference)
            The next item at this outline level.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.First">
            <summary>
            (Required if the item has any descendants; must be an indirect reference)
             The first of this item’s immediate children in the outline hierarchy.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.Last">
            <summary>
            (Required if the item has any descendants; must be an indirect reference)
            The last of this item’s immediate children in the outline hierarchy.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.Count">
            <summary>
            (Required if the item has any descendants) If the item is open, the total number of its 
            open descendants at all lower levels of the outline hierarchy. If the item is closed, a 
            negative integer whose absolute value specifies how many descendants would appear if the 
            item were reopened.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.Dest">
            <summary>
            (Optional; not permitted if an A entry is present) The destination to be displayed when this 
            item is activated.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.A">
            <summary>
            (Optional; not permitted if an A entry is present) The destination to be displayed when 
            this item is activated.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.SE">
            <summary>
            (Optional; PDF 1.3; must be an indirect reference) The structure element to which the item 
            refers.
            Note: The ability to associate an outline item with a structure element (such as the beginning 
            of a chapter) is a PDF 1.3 feature. For backward compatibility with earlier PDF versions, such
            an item should also specify a destination (Dest) corresponding to an area of a page where the
            contents of the designated structure element are displayed.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.C">
            <summary>
            (Optional; PDF 1.4) An array of three numbers in the range 0.0 to 1.0, representing the 
            components in the DeviceRGB color space of the color to be used for the outline entry’s text.
            Default value: [0.0 0.0 0.0].
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutline.Keys.F">
            <summary>
            (Optional; PDF 1.4) A set of flags specifying style characteristics for displaying the outline
            item’s text. Default value: 0.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfOutline.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.VCF">
            <summary>
            Value creation flags. Specifies whether and how a value that not exists is created.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.VCF.None">
            <summary>
            Don't create the value.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.VCF.Create">
            <summary>
            Create the value as direct object.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.VCF.CreateIndirect">
            <summary>
            Create the value as indirect object.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Printing.PdfFilePrinter">
            <summary>
            A wrapper around Adobe Reader or Adobe Acrobat that helps to print PDF files.
            The property AdobeReaderPath must be set before the class can be used for printing.
            The class was tested with Adobe Reader 7.0.7.
            If this stuff does not work, <c>please</c> don't write me mails!
            If you enhance this class, please let me know.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Printing.PdfFilePrinter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Printing.PdfFilePrinter" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Printing.PdfFilePrinter.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Printing.PdfFilePrinter" /> class.
            </summary>
            <param name="pdfFileName">Name of the PDF file.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Printing.PdfFilePrinter.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Printing.PdfFilePrinter" /> class.
            </summary>
            <param name="pdfFileName">Name of the PDF file.</param>
            <param name="printerName">Name of the printer.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Printing.PdfFilePrinter.Print">
            <summary>
            Prints the PDF file.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Printing.PdfFilePrinter.Print(System.Int32)">
            <summary>
            Prints the PDF file.
            </summary>
            <param name="milliseconds">The number of milliseconds to wait for completing the print job.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Printing.PdfFilePrinter.DoSomeVeryDirtyHacksToMakeItWork">
            <summary>
            For reasons only Adobe knows the Reader seams to open and shows the document instead of printing it
            when it was not already running.
            If you use PDFsharp and have any suggestions to circumvent this function, please let us know.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Printing.PdfFilePrinter.PdfFileName">
            <summary>
            Gets or sets the name of the PDF file to print.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Printing.PdfFilePrinter.PrinterName">
            <summary>
            Gets or sets the name of the printer. A typical name looks like '\\myserver\HP LaserJet PCL5'.
            </summary>
            <value>The name of the printer.</value>
        </member>
        <member name="P:PdfSharp.Pdf.Printing.PdfFilePrinter.WorkingDirectory">
            <summary>
            Gets or sets the working directory.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Printing.PdfFilePrinter.AdobeReaderPath">
            <summary>
            Gets or sets the Adobe Reader or Adobe Acrobat path.
            A typical name looks like 'C:\Program Files\Adobe\Adobe Reader 7.0\AcroRd32.exe'.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Printing.PdfFilePrinter.DefaultPrinterName">
            <summary>
            Gets or sets the name of the default printer. A typical name looks like '\\myserver\HP LaserJet PCL5'.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfWidgetAnnotation">
            <summary>
            Represents a text annotation.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfWidgetAnnotation.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfWidgetAnnotation.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfWidgetAnnotation.Keys.H">
            <summary>
            (Optional) The annotation’s highlighting mode, the visual effect to be used when
            the mouse button is pressed or held down inside its active area:
              N (None) No highlighting.
              I (Invert) Invert the contents of the annotation rectangle.
              O (Outline) Invert the annotation’s border.
              P (Push) Display the annotation’s down appearance, if any. If no down appearance is defined,
                offset the contents of the annotation rectangle to appear as if it were being pushed below
                the surface of the page.
              T (Toggle) Same as P (which is preferred).
            A highlighting mode other than P overrides any down appearance defined for the annotation. 
            Default value: I.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfWidgetAnnotation.Keys.MK">
            <summary>
            (Optional) An appearance characteristics dictionary to be used in constructing a dynamic 
            appearance stream specifying the annotation’s visual presentation on the page.
            The name MK for this entry is of historical significance only and has no direct meaning.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon">
            <summary>
            Specifies the predefined icon names of rubber stamp annotations.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.NoIcon">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.Approved">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.AsIs">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.Confidential">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.Departmental">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.Draft">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.Experimental">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.Expired">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.Final">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.ForComment">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.ForPublicRelease">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.NotApproved">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.NotForPublicRelease">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.Sold">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotationIcon.TopSecret">
            <summary>
            A pre-defined rubber stamp annotation icon.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfInternals">
            <summary>
            Provides access to the internal document data structures. This class prevents the public
            interfaces from pollution with to much internal functions.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.GetObject(PdfSharp.Pdf.PdfObjectID)">
            <summary>
            Returns the object with the specified Identifier, or null, if no such object exists.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.GetReference(PdfSharp.Pdf.PdfObject)">
            <summary>
            Returns the PdfReference of the specified object, or null, if the object is not in the
            document's object table.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.GetObjectID(PdfSharp.Pdf.PdfObject)">
            <summary>
            Gets the object identifier of the specified object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.GetObjectNumber(PdfSharp.Pdf.PdfObject)">
            <summary>
            Gets the object number of the specified object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.GenerationNumber(PdfSharp.Pdf.PdfObject)">
            <summary>
            Gets the generation number of the specified object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.GetAllObjects">
            <summary>
            Gets all indirect objects ordered by their object identifier.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.CreateIndirectObject``1">
            <summary>
            Creates the indirect object of the specified type, adds it to the document, and
            returns the object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.AddObject(PdfSharp.Pdf.PdfObject)">
            <summary>
            Adds an object to the PDF document. This operation and only this operation makes the object 
            an indirect object owned by this document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.RemoveObject(PdfSharp.Pdf.PdfObject)">
            <summary>
            Removes an object from the PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.GetClosure(PdfSharp.Pdf.PdfObject)">
            <summary>
            Returns an array containing the specified object as first element follows by its transitive
            closure. The closure of an object are all objects that can be reached by indirect references. 
            The transitive closure is the result of applying the calculation of the closure to a closure
            as long as no new objects came along. This is e.g. useful for getting all objects belonging 
            to the resources of a page.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfInternals.WriteObject(System.IO.Stream,PdfSharp.Pdf.PdfItem)">
            <summary>
            Writes a PdfItem into the specified stream.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfInternals.CustomValueKey">
            <summary>
            The name of the custom value key.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfInternals.FirstDocumentID">
            <summary>
            Gets or sets the first document identifier.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfInternals.FirstDocumentGuid">
            <summary>
            Gets the first document identifier as GUID.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfInternals.SecondDocumentID">
            <summary>
            Gets or sets the second document identifier.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfInternals.SecondDocumentGuid">
            <summary>
            Gets the first document identifier as GUID.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfInternals.Catalog">
            <summary>
            Gets the catalog dictionary.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfInternals.AllObjects">
            <summary>
            Gets all indirect objects ordered by their object identifier.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags">
            <summary>
            The PDF font descriptor flags.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags.FixedPitch">
            <summary>
            All glyphs have the same width (as opposed to proportional or variable-pitch
            fonts, which have different widths).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags.Serif">
            <summary>
            Glyphs have serifs, which are short strokes drawn at an angle on the top and
            bottom of glyph stems. (Sans serif fonts do not have serifs.)
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags.Symbolic">
            <summary>
            Font contains glyphs outside the Adobe standard Latin character set. This
            flag and the Nonsymbolic flag cannot both be set or both be clear.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags.Script">
            <summary>
            Glyphs resemble cursive handwriting.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags.Nonsymbolic">
            <summary>
            Font uses the Adobe standard Latin character set or a subset of it.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags.Italic">
            <summary>
            Glyphs have dominant vertical strokes that are slanted.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags.AllCap">
            <summary>
            Font contains no lowercase letters; typically used for display purposes,
            such as for titles or headlines.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags.SmallCap">
            <summary>
            Font contains both uppercase and lowercase letters. The uppercase letters are
            similar to those in the regular version of the same typeface family. The glyphs
            for the lowercase letters have the same shapes as the corresponding uppercase
            letters, but they are sized and their proportions adjusted so that they have the
            same size and stroke weight as lowercase glyphs in the same typeface family.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptorFlags.ForceBold">
            <summary>
            Determines whether bold glyphs are painted with extra pixels even at very small
            text sizes.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFontDescriptor">
            <summary>
            A PDF font descriptor specifies metrics and other attributes of a simple font, 
            as distinct from the metrics of individual glyphs.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFontDescriptor.FontName">
            <summary>
            Gets or sets the name of the font.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFontDescriptor.IsSymbolFont">
            <summary>
            Gets a value indicating whether this instance is symbol font.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.Type">
            <summary>
            (Required) The type of PDF object that this dictionary describes; must be
            FontDescriptor for a font descriptor.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.FontName">
            <summary>
            (Required) The PostScript name of the font. This name should be the same as the 
            value of BaseFont in the font or CIDFont dictionary that refers to this font descriptor.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.FontFamily">
            <summary>
            (Optional; PDF 1.5; strongly recommended for Type 3 fonts in Tagged PDF documents)
            A string specifying the preferred font family name. For example, for the font 
            Times Bold Italic, the FontFamily is Times.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.FontStretch">
            <summary>
            (Optional; PDF 1.5; strongly recommended for Type 3 fonts in Tagged PDF documents)
            The font stretch value. It must be one of the following names (ordered from 
            narrowest to widest): UltraCondensed, ExtraCondensed, Condensed, SemiCondensed, 
            Normal, SemiExpanded, Expanded, ExtraExpanded or UltraExpanded.
            Note: The specific interpretation of these values varies from font to font. 
            For example, Condensed in one font may appear most similar to Normal in another.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.FontWeight">
            <summary>
            (Optional; PDF 1.5; strongly recommended for Type 3 fonts in Tagged PDF documents)
            The weight (thickness) component of the fully-qualified font name or font specifier.
            The possible values are 100, 200, 300, 400, 500, 600, 700, 800, or 900, where each
            number indicates a weight that is at least as dark as its predecessor. A value of 
            400 indicates a normal weight; 700 indicates bold.
            Note: The specific interpretation of these values varies from font to font. 
            For example, 300 in one font may appear most similar to 500 in another.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.Flags">
            <summary>
            (Required) A collection of flags defining various characteristics of the font.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.FontBBox">
            <summary>
            (Required, except for Type 3 fonts) A rectangle (see Section 3.8.4, “Rectangles”),
            expressed in the glyph coordinate system, specifying the font bounding box. This 
            is the smallest rectangle enclosing the shape that would result if all of the 
            glyphs of the font were placed with their origins coincident and then filled.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.ItalicAngle">
            <summary>
            (Required) The angle, expressed in degrees counterclockwise from the vertical, of
            the dominant vertical strokes of the font. (For example, the 9-o’clock position is 90 
            degrees, and the 3-o’clock position is –90 degrees.) The value is negative for fonts 
            that slope to the right, as almost all italic fonts do.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.Ascent">
            <summary>
            (Required, except for Type 3 fonts) The maximum height above the baseline reached 
            by glyphs in this font, excluding the height of glyphs for accented characters.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.Descent">
            <summary>
            (Required, except for Type 3 fonts) The maximum depth below the baseline reached 
            by glyphs in this font. The value is a negative number.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.Leading">
            <summary>
            (Optional) The spacing between baselines of consecutive lines of text.
            Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.CapHeight">
            <summary>
            (Required for fonts that have Latin characters, except for Type 3 fonts) The vertical
            coordinate of the top of flat capital letters, measured from the baseline.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.XHeight">
            <summary>
            (Optional) The font’s x height: the vertical coordinate of the top of flat nonascending
            lowercase letters (like the letter x), measured from the baseline, in fonts that have 
            Latin characters. Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.StemV">
            <summary>
            (Required, except for Type 3 fonts) The thickness, measured horizontally, of the dominant 
            vertical stems of glyphs in the font.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.StemH">
            <summary>
            (Optional) The thickness, measured vertically, of the dominant horizontal stems 
            of glyphs in the font. Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.AvgWidth">
            <summary>
            (Optional) The average width of glyphs in the font. Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.MaxWidth">
            <summary>
            (Optional) The maximum width of glyphs in the font. Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.MissingWidth">
            <summary>
            (Optional) The width to use for character codes whose widths are not specified in a 
            font dictionary’s Widths array. This has a predictable effect only if all such codes 
            map to glyphs whose actual widths are the same as the value of the MissingWidth entry.
            Default value: 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.FontFile">
            <summary>
            (Optional) A stream containing a Type 1 font program.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.FontFile2">
            <summary>
            (Optional; PDF 1.1) A stream containing a TrueType font program.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.FontFile3">
            <summary>
            (Optional; PDF 1.2) A stream containing a font program whose format is specified 
            by the Subtype entry in the stream dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.CharSet">
            <summary>
            (Optional; meaningful only in Type 1 fonts; PDF 1.1) A string listing the character
            names defined in a font subset. The names in this string must be in PDF syntax—that is,
            each name preceded by a slash (/). The names can appear in any order. The name .notdef
            should be omitted; it is assumed to exist in the font subset. If this entry is absent,
            the only indication of a font subset is the subset tag in the FontName entry.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfFontDescriptor.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfContent">
            <summary>
            Represents the content of a page. PDFsharp supports only one content stream per page.
            If an imported page has an array of content streams, the streams are concatenated to
            one single stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfContent.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfContent" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfContent.#ctor(PdfSharp.Pdf.PdfPage)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfContent" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfContent.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfContent" /> class.
            </summary>
            <param name="dict">The dict.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfContent.Decode">
            <summary>
            Unfilters the stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfContent.PreserveGraphicsState">
            <summary>
            Surround content with q/Q operations if necessary.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfContent.Compressed">
            <summary>
            Sets a value indicating whether the content is compressed with the ZIP algorithm.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfContent.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfContent.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfContent.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Forms.PagePreviewCanvas">
            <summary>
            Implements the control that previews the page.
            </summary>
        </member>
        <member name="T:PdfSharp.Forms.Zoom">
            <summary>
            Defines a zoom factor used in the preview control.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Mininum">
            <summary>
            The smallest possible zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Maximum">
            <summary>
            The largest possible zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Percent800">
            <summary>
            A pre-defined zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Percent600">
            <summary>
            A pre-defined zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Percent400">
            <summary>
            A pre-defined zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Percent200">
            <summary>
            A pre-defined zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Percent150">
            <summary>
            A pre-defined zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Percent100">
            <summary>
            A pre-defined zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Percent75">
            <summary>
            A pre-defined zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Percent50">
            <summary>
            A pre-defined zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Percent25">
            <summary>
            A pre-defined zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.Percent10">
            <summary>
            A pre-defined zoom factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.BestFit">
            <summary>
            Sets the zoom factor so that the document fits horizontally into the window.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.TextFit">
            <summary>
            Sets the zoom factor so that the printable area of the document fits horizontally into the window.
            Currently not yet implemented and the same as ZoomBestFit.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.FullPage">
            <summary>
            Sets the zoom factor so that the whole document fits completely into the window.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.Zoom.OriginalSize">
            <summary>
            Sets the zoom factor so that the document is displayed in its real physical size (based on the DPI information returned from the OS for the current monitor).
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XSize">
            <summary>
            Represents a pair of floating-point numbers, typically the width and height of a
            graphical object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the XPoint class with the specified values.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.#ctor(PdfSharp.Drawing.XPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XSize" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.op_Equality(PdfSharp.Drawing.XSize,PdfSharp.Drawing.XSize)">
            <summary>
            Determines whether two size objects are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.op_Inequality(PdfSharp.Drawing.XSize,PdfSharp.Drawing.XSize)">
            <summary>
            Determines whether two size objects are not equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.Equals(PdfSharp.Drawing.XSize,PdfSharp.Drawing.XSize)">
            <summary>
            Indicates whether this tow instance are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.Equals(PdfSharp.Drawing.XSize)">
            <summary>
            Indicates whether this instance and a specified size are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.Parse(System.String)">
            <summary>
            Parses the size from a string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.ToPointF">
            <summary>
            Converts this XSize to a PointF.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.ToXPoint">
            <summary>
            Converts this XSize to an XPoint.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.ToXVector">
            <summary>
            Converts this XSize to an XVector.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.ToSizeF">
            <summary>
            Converts this XSize to a SizeF.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.FromSize(System.Drawing.Size)">
            <summary>
            Creates an XSize from a System.Drawing.Size.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.op_Implicit(System.Drawing.Size)~PdfSharp.Drawing.XSize">
            <summary>
            Implicit conversion from XSize to System.Drawing.Size. The conversion must be implicit because the
            WinForms designer uses it.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.FromSizeF(System.Drawing.SizeF)">
            <summary>
            Creates an XSize from a System.Drawing.Size.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.ToString">
            <summary>
            Converts this XSize to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.ToString(System.IFormatProvider)">
            <summary>
            Converts this XSize to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts this XSize to a human readable string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.op_Explicit(PdfSharp.Drawing.XSize)~PdfSharp.Drawing.XVector">
            <summary>
            Performs an explicit conversion from XSize to XVector.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XSize.op_Explicit(PdfSharp.Drawing.XSize)~PdfSharp.Drawing.XPoint">
            <summary>
            Performs an explicit conversion from XSize to XPoint.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XSize.Empty">
            <summary>
            Returns an empty size, i.e. a size with a width or height less than 0.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XSize.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XSize.Width">
            <summary>
            Gets or sets the width.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XSize.Height">
            <summary>
            Gets or sets the height.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XImageFormat">
            <summary>
            Specifies the format of the image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XImageFormat.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XImageFormat.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImageFormat.Png">
            <summary>
            Gets the Portable Network Graphics (PNG) image format. 
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImageFormat.Gif">
            <summary>
            Gets the Graphics Interchange Format (GIF) image format.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImageFormat.Jpeg">
            <summary>
            Gets the Joint Photographic Experts Group (JPEG) image format.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImageFormat.Tiff">
            <summary>
            Gets the Tag Image File Format (TIFF) image format.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImageFormat.Pdf">
            <summary>
            Gets the Portable Document Format (PDF) image format
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XImageFormat.Icon">
            <summary>
            Gets the Windows icon image format.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.TextLocation">
            <summary>
            Specifies whether and how the text is displayed at the code.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.TextLocation.None">
            <summary>
            No text is drawn.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.TextLocation.Above">
            <summary>
            The text is located above the code.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.TextLocation.Below">
            <summary>
            The text is located below the code.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.TextLocation.AboveEmbedded">
            <summary>
            The text is located above within the code.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.TextLocation.BelowEmbedded">
            <summary>
            The text is located below within the code.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.AnchorType">
            <summary>
            Specifies whether and how the text is displayed at the code area.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.AnchorType.TopLeft">
            <summary>
            The anchor is located top left.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.AnchorType.TopCenter">
            <summary>
            The anchor is located top center.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.AnchorType.TopRight">
            <summary>
            The anchor is located top right.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.AnchorType.MiddleLeft">
            <summary>
            The anchor is located middle left.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.AnchorType.MiddleCenter">
            <summary>
            The anchor is located middle center.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.AnchorType.MiddleRight">
            <summary>
            The anchor is located middle right.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.AnchorType.BottomLeft">
            <summary>
            The anchor is located bottom left.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.AnchorType.BottomCenter">
            <summary>
            The anchor is located bottom center.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.AnchorType.BottomRight">
            <summary>
            The anchor is located bottom right.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfGenericField">
            <summary>
            Represents a generic field. Used for AcroForm dictionaries unknown to PDFsharp.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfGenericField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of PdfGenericField.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfGenericField.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfGenericField.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfCheckBoxField">
            <summary>
            Represents the check box field.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfButtonField">
            <summary>
            Represents the base class for all button fields.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfButtonField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.AcroForms.PdfButtonField" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfButtonField.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.AcroForms.PdfButtonField" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfButtonField.GetNonOffValue">
            <summary>
            Gets the name which represents the opposite of /Off.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfButtonField.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfCheckBoxField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of PdfCheckBoxField.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfCheckBoxField.Checked">
            <summary>
            Indicates whether the field is checked.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfCheckBoxField.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfCheckBoxField.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfCheckBoxField.Keys.Opt">
            <summary>
            (Optional; inheritable; PDF 1.4) A text string to be used in place of the V entry for the
            value of the field.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfCheckBoxField.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.Pdf.StreamMode">
            <summary>
            Indicates whether we are within a BT/ET block.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.StreamMode.Graphic">
            <summary>
            Graphic mode. This is default.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.StreamMode.Text">
            <summary>
            Text mode.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfReferenceTable">
            <summary>
            Represents the cross reference table of a PDF document. It contains all indirect objects of
            a document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfReferenceTable.objectTable">
            <summary>
            Represents the relation between PdfObjectID and PdfReference for a PdfDocument.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReferenceTable.Add(PdfSharp.Pdf.Advanced.PdfReference)">
            <summary>
            Adds a cross reference entry to the table. Used when parsing the trailer.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReferenceTable.Add(PdfSharp.Pdf.PdfObject)">
            <summary>
            Adds a PdfObject to the table.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReferenceTable.Contains(PdfSharp.Pdf.PdfObjectID)">
            <summary>
            Indicates whether the specified object identifier is in the table.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReferenceTable.GetNewObjectNumber">
            <summary>
            Returns the next free object number.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReferenceTable.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the iref section in pdf stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReferenceTable.Compact">
            <summary>
            Removes all objects that cannot be reached from the trailer. Returns the number of removed objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReferenceTable.Renumber">
            <summary>
            Renumbers the objects starting at 1.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReferenceTable.CheckConsistence">
            <summary>
            Checks the logical consistence for debugging purposes (useful after reconstruction work).
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReferenceTable.TransitiveClosure(PdfSharp.Pdf.PdfObject)">
            <summary>
            Calculates the transitive closure of the specified PdfObject with the specified depth, i.e. all indirect objects
            recursively reachable from the specified object in up to maximally depth steps.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfReferenceTable.Item(PdfSharp.Pdf.PdfObjectID)">
            <summary>
            Gets a cross reference entry from an object identifier.
            Returns null if no object with the specified ID exists in the object table.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfReferenceTable.AllObjectIDs">
            <summary>
            Gets an array of all object identifier. For debugging purposes only.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfReferenceTable.AllReferences">
            <summary>
            Gets an array of all cross references ordered increasing by their object identifier.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfReferenceTable.DeadObject">
            <summary>
            Gets the cross reference to an objects used for undefined indirect references.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfStringEncoding">
            <summary>
            Determines the encoding of a PdfString or PdfStringObject.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfStringEncoding.RawEncoding">
            <summary>
            The characters of the string are actually bytes with an unknown or context specific meaning or encoding.
            With this encoding the 8 high bits of each character is zero.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfStringEncoding.StandardEncoding">
            <summary>
            Not yet used by PDFsharp.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfStringEncoding.PDFDocEncoding">
            <summary>
            The characters of the string are actually bytes with PDF document encoding.
            With this encoding the 8 high bits of each character is zero.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfStringEncoding.WinAnsiEncoding">
            <summary>
            The characters of the string are actually bytes with Windows ANSI encoding.
            With this encoding the 8 high bits of each character is zero.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfStringEncoding.MacRomanEncoding">
            <summary>
            Not yet used by PDFsharp.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfStringEncoding.MacExpertEncoding">
            <summary>
            Not yet used by PDFsharp.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfStringEncoding.Unicode">
            <summary>
            The characters of the string are Unicode characters.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfStringFlags">
            <summary>
            Internal wrapper for PdfStringEncoding.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfString">
            <summary>
            Represents a direct text string value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfString.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfString" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfString.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfString" /> class.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfString.#ctor(System.String,PdfSharp.Pdf.PdfStringEncoding)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfString" /> class.
            </summary>
            <param name="value">The value.</param>
            <param name="encoding">The encoding.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfString.ToString">
            <summary>
            Returns the string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfString.ToStringFromPdfDocEncoded">
            <summary>
            Hack for document encoded bookmarks.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfString.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the string DocEncoded.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfString.Length">
            <summary>
            Gets the number of characters in this string.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfString.Encoding">
            <summary>
            Gets the encoding.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfString.HexLiteral">
            <summary>
            Gets a value indicating whether the string is a hexadecimal literal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfString.Value">
            <summary>
            Gets the string value.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfString.EncryptionValue">
            <summary>
            Gets or sets the string value for encryption purposes.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfRectangle">
            <summary>
            Represents a PDF rectangle value, that is internally an array with 4 real values.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.#ctor">
            <summary>
            Initializes a new instance of the PdfRectangle class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the PdfRectangle class with two points specifying
            two diagonally opposite corners. Notice that in contrast to GDI+ convention the 
            3rd and the 4th parameter specify a point and not a width. This is so much confusing
            that this function is for internal use only.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.#ctor(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Initializes a new instance of the PdfRectangle class with two points specifying
            two diagonally opposite corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.#ctor(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Initializes a new instance of the PdfRectangle class with two points specifying
            two diagonally opposite corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.#ctor(System.Drawing.PointF,System.Drawing.SizeF)">
            <summary>
            Initializes a new instance of the PdfRectangle class with the specified location and size.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.#ctor(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of the PdfRectangle class with the specified location and size.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.#ctor(PdfSharp.Drawing.XRect)">
            <summary>
            Initializes a new instance of the PdfRectangle class with the specified XRect.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.#ctor(PdfSharp.Pdf.PdfItem)">
            <summary>
            Initializes a new instance of the PdfRectangle class with the specified PdfArray.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.Clone">
            <summary>
            Clones this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.Copy">
            <summary>
            Implements cloning this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.Equals(System.Object)">
            <summary>
            Tests whether the specified object is a PdfRectangle and has equal coordinates.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.op_Equality(PdfSharp.Pdf.PdfRectangle,PdfSharp.Pdf.PdfRectangle)">
            <summary>
            Tests whether two structures have equal coordinates.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.op_Inequality(PdfSharp.Pdf.PdfRectangle,PdfSharp.Pdf.PdfRectangle)">
            <summary>
            Tests whether two structures differ in one or more coordinates.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.Contains(System.Drawing.PointF)">
            <summary>
            Determines if the specified point is contained within this PdfRectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.Contains(PdfSharp.Drawing.XPoint)">
            <summary>
            Determines if the specified point is contained within this PdfRectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.Contains(System.Double,System.Double)">
            <summary>
            Determines if the specified point is contained within this PdfRectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.Contains(System.Drawing.RectangleF)">
            <summary>
            Determines if the rectangular region represented by rect is entirely contained within this PdfRectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.Contains(PdfSharp.Drawing.XRect)">
            <summary>
            Determines if the rectangular region represented by rect is entirely contained within this PdfRectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.Contains(PdfSharp.Pdf.PdfRectangle)">
            <summary>
            Determines if the rectangular region represented by rect is entirely contained within this PdfRectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.ToXRect">
            <summary>
            Returns the rectangle as an XRect object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.ToString">
            <summary>
            Returns the rectangle as a string in the form «[x1 y1 x2 y2]».
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfRectangle.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the rectangle.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfRectangle.Empty">
            <summary>
            Represents an empty PdfRectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfRectangle.IsEmpty">
            <summary>
            Tests whether all coordinate are zero.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfRectangle.X1">
            <summary>
            Gets or sets the x-coordinate of the first corner of this PdfRectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfRectangle.Y1">
            <summary>
            Gets or sets the y-coordinate of the first corner of this PdfRectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfRectangle.X2">
            <summary>
            Gets or sets the x-coordinate of the second corner of this PdfRectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfRectangle.Y2">
            <summary>
            Gets or sets the y-coordinate of the second corner of this PdfRectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfRectangle.Width">
            <summary>
            Gets X2 - X1.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfRectangle.Height">
            <summary>
            Gets Y2 - Y1.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfRectangle.Location">
            <summary>
            Gets or sets the coordinates of the first point of this PdfRectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfRectangle.Size">
            <summary>
            Gets or sets the size of this PdfRectangle.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfReal">
            <summary>
            Represents a direct real value.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfNumber">
            <summary>
            Base class for direct number values (not yet used, maybe superfluous).
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReal.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfReal" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReal.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfReal" /> class.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReal.ToString">
            <summary>
            Returns the real number as string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfReal.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the real value with up to three digits.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfReal.Value">
            <summary>
            Gets the value as double.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfPages">
            <summary>
            Represents the pages of the document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.Add">
            <summary>
            Creates a new PdfPage, adds it to this document, and returns it.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.Add(PdfSharp.Pdf.PdfPage)">
            <summary>
            Adds the specified PdfPage to this document and maybe returns a new PdfPage object.
            The value returned is a new object if the added page comes from a foreign document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.Insert(System.Int32)">
            <summary>
            Creates a new PdfPage, inserts it at the specified position into this document, and returns it.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.Insert(System.Int32,PdfSharp.Pdf.PdfPage)">
            <summary>
            Inserts the specified PdfPage at the specified position to this document and maybe returns a new PdfPage object.
            The value returned is a new object if the inserted page comes from a foreign document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.Remove(PdfSharp.Pdf.PdfPage)">
            <summary>
            Removes the specified page from the document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.RemoveAt(System.Int32)">
            <summary>
            Removes the specified page from the document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.MovePage(System.Int32,System.Int32)">
            <summary>
            Moves a page within the page sequence.
            </summary>
            <param name="oldIndex">The page index before this operation.</param>
            <param name="newIndex">The page index after this operation.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.ImportExternalPage(PdfSharp.Pdf.PdfPage)">
            <summary>
            Imports an external page. The elements of the imported page are cloned and added to this document.
            Important: In contrast to PdfFormXObject adding an external page always make a deep copy
            of their transitive closure. Any reuse of already imported objects is not intended because
            any modification of an imported page must not change another page.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.CloneElement(PdfSharp.Pdf.PdfPage,PdfSharp.Pdf.PdfPage,System.String,System.Boolean)">
            <summary>
            Helper function for ImportExternalPage.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.FlattenPageTree">
            <summary>
            Replaces the page tree by a flat array of indirect references to the pages objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.GetKids(PdfSharp.Pdf.Advanced.PdfReference,PdfSharp.Pdf.PdfPage.InheritedValues,PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Recursively converts the page tree into a flat array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.PrepareForSave">
            <summary>
            Prepares the document for saving.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfPages.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPages.Count">
            <summary>
            Gets the number of pages.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPages.Item(System.Int32)">
            <summary>
            Gets the page with the specified index.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPages.PagesArray">
            <summary>
            Gets a PdfArray containing all pages of this document. The array must not be modified.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPages.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfPages.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPages.Keys.Type">
            <summary>
            (Required) The type of PDF object that this dictionary describes; 
            must be Pages for a page tree node.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPages.Keys.Parent">
            <summary>
            (Required except in root node; must be an indirect reference)
            The page tree node that is the immediate parent of this one.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPages.Keys.Kids">
            <summary>
            (Required) An array of indirect references to the immediate children of this node.
            The children may be page objects or other page tree nodes.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPages.Keys.Count">
            <summary>
            (Required) The number of leaf nodes (page objects) that are descendants of this node 
            within the page tree.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfPages.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Security.PdfUserAccessPermission">
            <summary>
            Specifies which operations are permitted when the document is opened with user access.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfUserAccessPermission.PermitAll">
            <summary>
            Permits everything. This is the default value.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.PdfWriter">
            <summary>
            Represents a writer for generation of PDF streams. 
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.Write(System.Boolean)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.Write(PdfSharp.Pdf.PdfBoolean)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.Write(System.Int32)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.Write(System.UInt32)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.Write(PdfSharp.Pdf.PdfInteger)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.Write(PdfSharp.Pdf.PdfUInteger)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.Write(System.Double)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.Write(PdfSharp.Pdf.PdfReal)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.Write(PdfSharp.Pdf.PdfString)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.Write(PdfSharp.Pdf.PdfName)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.WriteBeginObject(PdfSharp.Pdf.PdfObject)">
            <summary>
            Begins a direct or indirect dictionary or array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.WriteEndObject">
            <summary>
            Ends a direct or indirect dictionary or array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.WriteStream(PdfSharp.Pdf.PdfDictionary,System.Boolean)">
            <summary>
            Writes the stream of the specified dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.IncreaseIndent">
            <summary>
            Increases indent level.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfWriter.DecreaseIndent">
            <summary>
            Decreases indent level.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.PdfWriter.Indent">
            <summary>
            Gets or sets the indentation for a new indentation level.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.PdfWriter.IndentBlanks">
            <summary>
            Gets an indent string of current indent.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.PdfWriter.Stream">
            <summary>
            Gets the underlying stream.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.PdfPasswordProviderArgs">
            <summary>
            Encapsulates the arguments of the PdfPasswordProvider delegate.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfPasswordProviderArgs.Password">
            <summary>
            Sets the password to open the document with.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfPasswordProviderArgs.Abort">
            <summary>
            When set to true the PdfReader.Open function returns null indicating that no PdfDocument was created.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.PdfPasswordProvider">
            <summary>
            A delegated used by the PdfReader.Open function to retrieve a password if the document is protected.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.PdfReader">
            <summary>
            Represents the functionality for reading PDF documents.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.TestPdfFile(System.String)">
            <summary>
            Determines whether the file specified by its path is a PDF file by inspecting the first eight
            bytes of the data. If the file header has the form «%PDF-x.y» the function returns the version
            number as integer (e.g. 14 for PDF 1.4). If the file header is invalid or inaccessible
            for any reason, 0 is returned. The function never throws an exception. 
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.TestPdfFile(System.IO.Stream)">
            <summary>
            Determines whether the specified stream is a PDF file by inspecting the first eight
            bytes of the data. If the data begins with «%PDF-x.y» the function returns the version
            number as integer (e.g. 14 for PDF 1.4). If the data is invalid or inaccessible
            for any reason, 0 is returned. The function never throws an exception. 
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.TestPdfFile(System.Byte[])">
            <summary>
            Determines whether the specified data is a PDF file by inspecting the first eight
            bytes of the data. If the data begins with «%PDF-x.y» the function returns the version
            number as integer (e.g. 14 for PDF 1.4). If the data is invalid or inaccessible
            for any reason, 0 is returned. The function never throws an exception. 
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.GetPdfFileVersion(System.Byte[])">
            <summary>
            Implements scanning the PDF file version.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.String,PdfSharp.Pdf.IO.PdfDocumentOpenMode)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.String,PdfSharp.Pdf.IO.PdfDocumentOpenMode,PdfSharp.Pdf.IO.PdfPasswordProvider)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.String,System.String,PdfSharp.Pdf.IO.PdfDocumentOpenMode)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.String,System.String,PdfSharp.Pdf.IO.PdfDocumentOpenMode,PdfSharp.Pdf.IO.PdfPasswordProvider)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.String)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.String,System.String)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.IO.Stream,PdfSharp.Pdf.IO.PdfDocumentOpenMode)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.IO.Stream,PdfSharp.Pdf.IO.PdfDocumentOpenMode,PdfSharp.Pdf.IO.PdfPasswordProvider)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.IO.Stream,System.String,PdfSharp.Pdf.IO.PdfDocumentOpenMode)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.IO.Stream,System.String,PdfSharp.Pdf.IO.PdfDocumentOpenMode,PdfSharp.Pdf.IO.PdfPasswordProvider)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.PdfReader.Open(System.IO.Stream)">
            <summary>
            Opens an existing PDF document.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Internal.DocEncoding">
            <summary>
            An encoder for PDF DocEncoding.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Internal.DocEncoding.AnsiToDoc">
            <summary>
            Converts WinAnsi to DocEncode characters. Incomplete, just maps € and some other characters.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Filters.ASCII85Decode">
            <summary>
            Implements the ASCII85Decode filter.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Filters.Filter">
            <summary>
            Base class for all stream filters
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filter.Encode(System.Byte[])">
            <summary>
            When implemented in a derived class encodes the specified data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filter.Encode(System.String)">
            <summary>
            Encodes a raw string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filter.Decode(System.Byte[],PdfSharp.Pdf.Filters.FilterParms)">
            <summary>
            When implemented in a derived class decodes the specified data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filter.Decode(System.Byte[])">
            <summary>
            Decodes the specified data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filter.DecodeToString(System.Byte[],PdfSharp.Pdf.Filters.FilterParms)">
            <summary>
            Decodes to a raw string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filter.DecodeToString(System.Byte[])">
            <summary>
            Decodes to a raw string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.Filter.RemoveWhiteSpace(System.Byte[])">
            <summary>
            Removes all white spaces from the data. The function assumes that the bytes are characters.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.ASCII85Decode.Encode(System.Byte[])">
            <summary>
            Encodes the specified data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.ASCII85Decode.Decode(System.Byte[],PdfSharp.Pdf.Filters.FilterParms)">
            <summary>
            Decodes the specified data.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.WinEncodingId">
            <summary>
            Only Symbol and Unicode is used by PDFsharp.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.CMap4">
            <summary>
            CMap format 4: Segment mapping to delta values.
            The Windows standard format.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.CMapTable">
            <summary>
            This table defines the mapping of character codes to the glyph index values used in the font.
            It may contain more than one subtable, in order to support more than one character encoding scheme.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.CMapTable.symbol">
            <summary>
            Is true for symbol font encoding.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.CMapTable.#ctor(PdfSharp.Fonts.OpenType.FontData)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Fonts.OpenType.CMapTable" /> class.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.FontHeaderTable">
            <summary>
            This table gives global information about the font. The bounding box values should be computed using 
            only glyphs that have contours. Glyphs with no contours should be ignored for the purposes of these calculations.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.HorizontalHeaderTable">
            <summary>
            This table contains information for horizontal layout. The values in the minRightSidebearing, 
            minLeftSideBearing and xMaxExtent should be computed using only glyphs that have contours.
            Glyphs with no contours should be ignored for the purposes of these calculations.
            All reserved areas must be set to 0. 
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.HorizontalMetricsTable">
            <summary>
            The type longHorMetric is defined as an array where each element has two parts:
            the advance width, which is of type USHORT, and the left side bearing, which is of type SHORT.
            These fields are in font design units.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.VerticalMetricsTable">
            <summary>
            The vertical metrics table allows you to specify the vertical spacing for each glyph in a
            vertical font. This table consists of either one or two arrays that contain metric
            information (the advance heights and top sidebearings) for the vertical layout of each
            of the glyphs in the font.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.MaximumProfileTable">
            <summary>
            This table establishes the memory requirements for this font.
            Fonts with CFF data must use Version 0.5 of this table, specifying only the numGlyphs field.
            Fonts with TrueType outlines must use Version 1.0 of this table, where all data is required.
            Both formats of OpenType require a 'maxp' table because a number of applications call the 
            Windows GetFontData() API on the 'maxp' table to determine the number of glyphs in the font.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.NameTable">
            <summary>
             The naming table allows multilingual strings to be associated with the OpenTypeTM font file.
             These strings can represent copyright notices, font names, family names, style names, and so on.
             To keep this table short, the font manufacturer may wish to make a limited set of entries in some
             small set of languages; later, the font can be "localized" and the strings translated or added.
             Other parts of the OpenType font file that require these strings can then refer to them simply by
             their index number. Clients that need a particular string can look it up by its platform ID, character
             encoding ID, language ID and name ID. Note that some platforms may require single byte character
             strings, while others may require double byte strings. 
            
             For historical reasons, some applications which install fonts perform version control using Macintosh
             platform (platform ID 1) strings from the 'name' table. Because of this, we strongly recommend that
             the 'name' table of all fonts include Macintosh platform strings and that the syntax of the version
             number (name id 5) follows the guidelines given in this document.
             </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.OS2Table">
            <summary>
            The OS/2 table consists of a set of metrics that are required in OpenType fonts. 
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.PostScriptTable">
            <summary>
            This table contains additional information needed to use TrueType or OpenTypeTM fonts
            on PostScript printers. 
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.ControlValueTable">
            <summary>
            This table contains a list of values that can be referenced by instructions.
            They can be used, among other things, to control characteristics for different glyphs.
            The length of the table must be an integral number of FWORD units. 
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.FontProgram">
            <summary>
            This table is similar to the CVT Program, except that it is only run once, when the font is first used.
            It is used only for FDEFs and IDEFs. Thus the CVT Program need not contain function definitions.
            However, the CVT Program may redefine existing FDEFs or IDEFs. 
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.ControlValueProgram">
            <summary>
            The Control Value Program consists of a set of TrueType instructions that will be executed whenever the font or 
            point size or transformation matrix change and before each glyph is interpreted. Any instruction is legal in the
            CVT Program but since no glyph is associated with it, instructions intended to move points within a particular
            glyph outline cannot be used in the CVT Program. The name 'prep' is anachronistic. 
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.GlyphSubstitutionTable">
            <summary>
            This table contains information that describes the glyphs in the font in the TrueType outline format.
            Information regarding the rasterizer (scaler) refers to the TrueType rasterizer. 
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphicsState">
            <summary>
            Represents the internal state of an XGraphics object.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XColor">
            <summary>
             Represents a RGB, CMYK, or gray scale color.
             </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromArgb(System.Int32)">
            <summary>
            Creates an XColor structure from a 32-bit ARGB value.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromArgb(System.UInt32)">
            <summary>
            Creates an XColor structure from a 32-bit ARGB value.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromArgb(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an XColor structure from the specified 8-bit color values (red, green, and blue).
            The alpha value is implicitly 255 (fully opaque).
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromArgb(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an XColor structure from the four ARGB component (alpha, red, green, and blue) values.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromArgb(System.Drawing.Color)">
            <summary>
            Creates an XColor structure from the specified System.Drawing.Color.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromArgb(System.Int32,PdfSharp.Drawing.XColor)">
            <summary>
            Creates an XColor structure from the specified alpha value and color.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromArgb(System.Int32,System.Drawing.Color)">
            <summary>
            Creates an XColor structure from the specified alpha value and color.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromCmyk(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an XColor structure from the specified CMYK values.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromCmyk(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an XColor structure from the specified CMYK values.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromGrayScale(System.Double)">
            <summary>
            Creates an XColor structure from the specified gray value.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromKnownColor(PdfSharp.Drawing.XKnownColor)">
            <summary>
            Creates an XColor from the specified pre-defined color.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromKnownColor(System.Drawing.KnownColor)">
            <summary>
            Creates an XColor from the specified pre-defined color.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.FromName(System.String)">
            <summary>
            Creates an XColor from the specified name of a pre-defined color.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.op_Implicit(System.Drawing.Color)~PdfSharp.Drawing.XColor">
            <summary>
            Implicit conversion from Color to XColor
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.ToGdiColor">
            <summary>
             Creates a System.Drawing.Color object from this color.
             </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.Equals(System.Object)">
            <summary>
            Determines whether the specified object is a Color structure and is equivalent to this 
            Color structure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.op_Equality(PdfSharp.Drawing.XColor,PdfSharp.Drawing.XColor)">
            <summary>
            Determines whether two colors are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.op_Inequality(PdfSharp.Drawing.XColor,PdfSharp.Drawing.XColor)">
            <summary>
            Determines whether two colors are not equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.GetHue">
            <summary>
            Gets the hue-saturation-brightness (HSB) hue value, in degrees, for this color.
            </summary>
            <returns>The hue, in degrees, of this color. The hue is measured in degrees, ranging from 0 through 360, in HSB color space.</returns>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.GetSaturation">
            <summary>
            Gets the hue-saturation-brightness (HSB) saturation value for this color.
            </summary>
            <returns>The saturation of this color. The saturation ranges from 0 through 1, where 0 is grayscale and 1 is the most saturated.</returns>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.GetBrightness">
            <summary>
            Gets the hue-saturation-brightness (HSB) brightness value for this color.
            </summary>
            <returns>The brightness of this color. The brightness ranges from 0 through 1, where 0 represents black and 1 represents white.</returns>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.RgbChanged">
            <summary>
             One of the RGB values changed; recalculate other color representations.
             </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.CmykChanged">
            <summary>
             One of the CMYK values changed; recalculate other color representations.
             </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XColor.GrayChanged">
            <summary>
             The gray scale value changed; recalculate other color representations.
             </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XColor.Empty">
            <summary>
            Represents the null color.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.ColorSpace">
            <summary>
            Gets or sets the color space to be used for PDF generation.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.IsEmpty">
            <summary>
            Indicates whether this XColor structure is uninitialized.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.IsKnownColor">
            <summary>
            Gets a value indicating whether this color is a known color.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.A">
            <summary>
            Gets or sets the alpha value the specifies the transparency. 
            The value is in the range from 1 (opaque) to 0 (completely transparent).
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.R">
            <summary>
            Gets or sets the red value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.G">
            <summary>
            Gets or sets the green value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.B">
            <summary>
            Gets or sets the blue value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.Rgb">
            <summary>
            Gets the RGB part value of the color. Internal helper function.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.Argb">
            <summary>
            Gets the ARGB part value of the color. Internal helper function.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.C">
            <summary>
            Gets or sets the cyan value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.M">
            <summary>
            Gets or sets the magenta value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.Y">
            <summary>
            Gets or sets the yellow value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.K">
            <summary>
            Gets or sets the black (or key) value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.GS">
            <summary>
            Gets or sets the gray scale value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColor.RgbCmykG">
            <summary>
             Special property for XmlSerializer only.
             </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XLineCap">
            <summary>
            Specifies the available cap styles with which an XPen object can start and end a line.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLineCap.Flat">
            <summary>
            Specifies a flat line cap.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLineCap.Round">
            <summary>
            Specifies a round line cap.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLineCap.Square">
            <summary>
            Specifies a square line cap.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfRadioButtonField">
            <summary>
            Represents the radio button field.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfRadioButtonField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of PdfRadioButtonField.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfRadioButtonField.SelectedIndex">
            <summary>
            Gets or sets the index of the selected radio button in a radio button group.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfRadioButtonField.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfRadioButtonField.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfRadioButtonField.Keys.Opt">
            <summary>
            (Optional; inheritable; PDF 1.4) An array of text strings to be used in
            place of the V entries for the values of the widget annotations representing
            the individual radio buttons. Each element in the array represents
            the export value of the corresponding widget annotation in the
            Kids array of the radio button field.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfRadioButtonField.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Forms.ColorComboBox">
            <summary>
            A combo box control for selection XColor values.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.ColorComboBox.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Forms.ColorComboBox" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.ColorComboBox.OnDropDownStyleChanged(System.EventArgs)">
            <summary>
            Keep control a drop down combo box.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.ColorComboBox.OnSelectedIndexChanged(System.EventArgs)">
            <summary>
            Sets the color with the selected item.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.ColorComboBox.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)">
            <summary>
            Draw a color entry.
            </summary>
        </member>
        <member name="P:PdfSharp.Forms.ColorComboBox.Color">
            <summary>
            Gets or sets the custom color.
            </summary>
        </member>
        <member name="T:PdfSharp.Forms.ColorComboBox.ColorItem">
            <summary>
            Represents a combo box item.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.FontData">
            <summary>
            Represents an Open Type Font font in memory.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.#ctor(PdfSharp.Fonts.OpenType.FontData)">
            <summary>
            Shallow copy for font subset.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.#ctor(PdfSharp.Drawing.XFont,PdfSharp.Drawing.XPdfFontOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Fonts.OpenType.FontData" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Fonts.OpenType.FontData" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.CreateGdiFontImage(PdfSharp.Drawing.XFont,PdfSharp.Drawing.XPdfFontOptions)">
            <summary>
            Create the font image using GDI+ functionality.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.FontData.tableDictionary">
            <summary>
            The dictionary of all font tables.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.AddTable(PdfSharp.Fonts.OpenType.OpenTypeFontTable)">
            <summary>
            Adds the specified table to this font image.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.Read">
            <summary>
            Reads all required tables from the font data.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.CreateFontSubSet(System.Collections.Generic.Dictionary{System.Int32,System.Object},System.Boolean)">
            <summary>
            Creates a new font image that is a subset of this font image containing only the specified glyphs.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.Compile">
            <summary>
            Compiles the font to its binary representation.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadByte">
            <summary>
            Reads a System.Byte.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadShort">
            <summary>
            Reads a System.Int16.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadUShort">
            <summary>
            Reads a System.UInt16.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadLong">
            <summary>
            Reads a System.Int32.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadULong">
            <summary>
            Reads a System.UInt32.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadFixed">
            <summary>
            Reads a System.Int32.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadFWord">
            <summary>
            Reads a System.Int16.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadUFWord">
            <summary>
            Reads a System.UInt16.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadLongDate">
            <summary>
            Reads a System.Int64.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadString(System.Int32)">
            <summary>
            Reads a System.String with the specified size.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadBytes(System.Int32)">
            <summary>
            Reads a System.Byte[] with the specified size.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.Read(System.Byte[])">
            <summary>
            Reads the specified buffer.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified buffer.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.ReadTag">
            <summary>
            Reads a System.Char[4] as System.String.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.OpenType.FontData.Data">
            <summary>
            Gets the bytes that represents the font data.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.FontData.OffsetTable">
            <summary>
            Represents the font offset table.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.FontData.OffsetTable.Version">
            <summary>
            0x00010000 for version 1.0.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.FontData.OffsetTable.TableCount">
            <summary>
            Number of tables.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.FontData.OffsetTable.SearchRange">
            <summary>
            (Maximum power of 2 ≤ numTables) x 16.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.FontData.OffsetTable.EntrySelector">
            <summary>
            Log2(maximum power of 2 ≤ numTables).
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.FontData.OffsetTable.RangeShift">
            <summary>
            NumTables x 16-searchRange.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.FontData.OffsetTable.Write(PdfSharp.Fonts.OpenType.OpenTypeFontWriter)">
            <summary>
            Writes the offset table.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGlyphTypeface">
            <summary>
            Specifies a physical font face that corresponds to a font file on the disk.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGlyphTypeface.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XGlyphTypeface" /> class from the specified font file.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGlyphTypeface.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XGlyphTypeface" /> class from the specified font bytes.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGlyphTypeface.FamilyName">
            <summary>
            Gets the English family name of the font.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGlyphTypeface.IsBold">
            <summary>
            Gets a value indicating whether the font weight is bold.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGlyphTypeface.IsItalic">
            <summary>
            Gets a value indicating whether the font style is italic.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream">
            <summary>
             This filter stream is used to decompress data compressed using the "deflate"
             format. The "deflate" format is described in RFC 1951.
            
             Author of the original java version: John Leuner.
             </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inf">
            <summary>
            Decompressor for this stream
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.buf">
            <summary>
            Byte array used for buffering input.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.len">
            <summary>
            Size of buffer <see cref="F:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.buf" /></summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.baseInputStream">
            <summary>
            Base stream the inflater reads from.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Flush">
            <summary>
            Flushes the baseInputStream
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream
            Always throws a NotSupportedException
            </summary>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.SetLength(System.Int64)">
            <summary>
            Set the length of the current stream
            Always throws a NotSupportedException
            </summary>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to stream and advances the current position
            This method always throws a NotSupportedException
            </summary>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.WriteByte(System.Byte)">
            <summary>
            Writes one byte to the current stream and advances the current position
            Always throws a NotSupportedException
            </summary>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Entry point to begin an asynchronous write.  Always throws a NotSupportedException.
            </summary>
            <param name="buffer">The buffer to write data from</param>
            <param name="offset">Offset of first byte to write</param>
            <param name="count">The maximum number of bytes to write</param>
            <param name="callback">The method to be called when the asynchronous write operation is completed</param>
            <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests</param>
            <returns>An <see cref="T:System.IAsyncResult">IAsyncResult</see> that references the asynchronous write</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream)">
            <summary>
            Create an InflaterInputStream with the default decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name="baseInputStream">
            The InputStream to read bytes from
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,PdfSharp.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name="baseInputStream">
            The source of input data
            </param>
            <param name="inf">
            The decompressor used to decompress data read from baseInputStream
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,PdfSharp.SharpZipLib.Zip.Compression.Inflater,System.Int32)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and the specified buffer size.
            </summary>
            <param name="baseInputStream">
            The InputStream to read bytes from
            </param>
            <param name="inflater">
            The decompressor to use
            </param>
            <param name="bufferSize">
            Size of the buffer to use
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close">
            <summary>
            Closes the input stream.  When <see cref="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner" />
            is true the underlying stream is also closed.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.FillInputBuffer">
            <summary>
            Fill input buffer with a chunk of data.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Fill">
            <summary>
            Fills the buffer with more data to decompress.
            </summary>
            <exception cref="T:PdfSharp.SharpZipLib.SharpZipBaseException">
            Stream ends early
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.ReadByte">
            <summary>
             Reads one byte of decompressed data.
            
             The byte is baseInputStream the lower 8 bits of the int.
             </summary>
            <returns>
             The byte read cast to an int, or -1 on end of stream.
             </returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompresses data into the byte array
            </summary>
            <param name="b">
            The array to read and decompress data into
            </param>
            <param name="off">
            The offset indicating where the data should be placed
            </param>
            <param name="len">
            The number of bytes to decompress
            </param>
            <returns>The number of bytes read.  Zero signals the end of stream</returns>
            <exception cref="T:PdfSharp.SharpZipLib.SharpZipBaseException">
            Inflater needs a dictionary
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Skip(System.Int64)">
            <summary>
            Skip specified number of bytes of uncompressed data
            </summary>
            <param name="n">
            Number of bytes to skip
            </param>
            <returns>
            The number of bytes skipped, zero if the end of 
            stream has been reached
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Number of bytes to skip is zero or less
            </exception>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.cryptbuffer">
            <summary>
            A buffer used for decrypting data.  Used to hold Zip crypto header.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.DecryptByte">
            <summary>
            Decrypt a single byte
            </summary>
            <returns>plain text byte value</returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.DecryptBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decrypt cipher text block, updating keys
            </summary>
            <param name="buf">Data to decrypt</param>
            <param name="off">Offset of first byte to process</param>
            <param name="len">Number of bytes to process</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.InitializePassword(System.String)">
            <summary>
            Initialise the decryption keys
            </summary>
            <param name="password">The password used to initialise the keys</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.UpdateKeys(System.Byte)">
            <summary>
            Update the decryption keys
            </summary>
            <param name="ch">Character to update the keys with</param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.StopDecrypting">
            <summary>
            Clear any cryptographic state.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close" /> will close the underlying stream also.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanSeek">
            <summary>
            Gets a value of false indicating seeking is not supported for this stream.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanWrite">
            <summary>
            Gets a value of false indicating that this stream is not writeable.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Length">
            <summary>
            A value representing the length of the stream in bytes.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Position">
            <summary>
            The current position within the stream.
            Throws a NotSupportedException when attempting to set the position
            </summary>
            <exception cref="T:System.NotSupportedException">Attempting to set the position</exception>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Available">
            <summary>
            Returns 0 once the end of the stream (EOF) has been reached.
            Otherwise returns 1.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.BufferReadSize">
            <summary>
            Sets the size of chunks to read from the input stream
            0 means as larger as possible.
            </summary>
            <remarks>
            Used to handle decryption where the length of stream is unknown.
            </remarks>
        </member>
        <member name="T:PdfSharp.Pdf.PdfIntegerObject">
            <summary>
            Represents an indirect integer value. This type is not used by PDFsharp. If it is imported from
            an external PDF file, the value is converted into a direct object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfIntegerObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfIntegerObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfIntegerObject.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfIntegerObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfIntegerObject.#ctor(PdfSharp.Pdf.PdfDocument,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfIntegerObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfIntegerObject.ToString">
            <summary>
            Returns the integer as string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfIntegerObject.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the integer literal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfIntegerObject.Value">
            <summary>
            Gets the value as integer.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDocumentInformation">
            <summary>
            Represents the PDF document information dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocumentInformation.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfDocumentInformation" /> class.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentInformation.Title">
            <summary>
            Gets or sets the document's title.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentInformation.Author">
            <summary>
            Gets or sets the name of the person who created the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentInformation.Subject">
            <summary>
            Gets or sets the name of the subject of the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentInformation.Keywords">
            <summary>
            Gets or sets keywords associated with the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentInformation.Creator">
            <summary>
            Gets or sets the name of the application (for example, MigraDoc) that created the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentInformation.Producer">
            <summary>
            Gets the producer application (for example, PDFsharp).
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentInformation.CreationDate">
            <summary>
            Gets or sets the creation date of the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentInformation.ModificationDate">
            <summary>
            Gets or sets the modification date of the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentInformation.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDocumentInformation.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDocumentInformation.Keys.Title">
            <summary>
            (Optional; PDF 1.1) The document’s title.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDocumentInformation.Keys.Author">
            <summary>
            (Optional) The name of the person who created the document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDocumentInformation.Keys.Subject">
            <summary>
            (Optional; PDF 1.1) The subject of the document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDocumentInformation.Keys.Keywords">
            <summary>
            (Optional; PDF 1.1) Keywords associated with the document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDocumentInformation.Keys.Creator">
            <summary>
            (Optional) If the document was converted to PDF from another format,
            the name of the application (for example, empira MigraDoc) that created the
            original document from which it was converted.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDocumentInformation.Keys.Producer">
            <summary>
            (Optional) If the document was converted to PDF from another format,
            the name of the application (for example, this library) that converted it to PDF.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDocumentInformation.Keys.CreationDate">
            <summary>
            (Optional) The date and time the document was created, in human-readable form.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDocumentInformation.Keys.ModDate">
            <summary>
            (Required if PieceInfo is present in the document catalog; otherwise optional; PDF 1.1)
            The date and time the document was most recently modified, in human-readable form.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfDocumentInformation.Keys.Trapped">
            <summary>
            (Optional; PDF 1.3) A name object indicating whether the document has been modified 
            to include trapping information.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentInformation.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDocument">
            <summary>
            Represents a PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.#ctor">
            <summary>
            Creates a new PDF document in memory.
            To open an existing PDF file, use the PdfReader class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.#ctor(System.String)">
            <summary>
            Creates a new PDF document with the specified file name. The file is immediately created and keeps
            looked until the document is saved.
            To open an existing PDF file and import it, use the PdfReader class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.#ctor(System.IO.Stream)">
            <summary>
            Creates a new PDF document using the specified stream.
            To open an existing PDF file, use the PdfReader class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.Dispose">
            <summary>
            Disposes all references to this document stored in other documents. This function should be called
            for documents you finished importing pages from. Calling Dispose is technically not necessary but
            useful for earlier reclaiming memory of documents you do not need anymore.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.NewName">
            <summary>
            Get a new default name for a new document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.Close">
            <summary>
            Closes this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.Save(System.String)">
            <summary>
            Saves the document to the specified path. If a file already exists, it will be overwritten.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.Save(System.IO.Stream,System.Boolean)">
            <summary>
            Saves the document to the specified stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.Save(System.IO.Stream)">
            <summary>
            Saves the document to the specified stream and closes the stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.DoSave(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Implements saving a PDF file.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.PrepareForSave">
            <summary>
            Dispatches PrepareForSave to the objects that need it.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.CanSave(System.String@)">
            <summary>
            Determines whether the document can be saved.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.AddPage">
            <summary>
            Creates a new page and adds it to this document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.AddPage(PdfSharp.Pdf.PdfPage)">
            <summary>
            Adds the specified page to this document. If the page is from an external document,
            it is imported to this document. In this case the returned page is not the same
            object as the specified one.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.InsertPage(System.Int32)">
            <summary>
            Creates a new page and inserts it in this document at the specified position.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.InsertPage(System.Int32,PdfSharp.Pdf.PdfPage)">
            <summary>
            Inserts the specified page in this document. If the page is from an external document,
            it is imported to this document. In this case the returned page is not the same
            object as the specified one.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDocument.OnExternalDocumentFinalized(PdfSharp.Pdf.PdfDocument.DocumentHandle)">
            <summary>
            Occurs when the specified document is not used anymore for importing content.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Tag">
            <summary>
            Gets or sets a user defined object that contains arbitrary information associated with this document.
            The tag is not used by PDFsharp.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Name">
            <summary>
            Gets or sets a value used to distinguish PdfDocument objects.
            The name is not used by PDFsharp.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Options">
            <summary>
            Gets the document options used for saving the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Settings">
            <summary>
            Gets PDF specific document settings.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.EarlyWrite">
            <summary>
            NYI Indicates whether large objects are written immediately to the output stream to relieve
            memory consumption.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Version">
            <summary>
            Gets or sets the PDF version number. Return value 14 e.g. means PDF 1.4 / Acrobat 5 etc.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.PageCount">
            <summary>
            Gets the number of pages in the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.FileSize">
            <summary>
            Gets the file size of the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.FullPath">
            <summary>
            Gets the full qualified file name if the document was read form a file, or an empty string otherwise.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Guid">
            <summary>
            Gets a Guid that uniquely identifies this instance of PdfDocument.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.IsImported">
            <summary>
            Returns a value indicating whether the document was newly created or opened from an existing document.
            Returns true if the document was opened with the PdfReader.Open function, false otherwise.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.IsReadOnly">
            <summary>
            Returns a value indicating whether the document is read only or can be modified.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Info">
            <summary>
            Gets information about the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.CustomValues">
            <summary>
            This function is intended to be undocumented.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Pages">
            <summary>
            Get the pages dictionary.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.PageLayout">
            <summary>
            Gets or sets a value specifying the page layout to be used when the document is opened.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.PageMode">
            <summary>
            Gets or sets a value specifying how the document should be displayed when opened.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.ViewerPreferences">
            <summary>
            Gets the viewer preferences of this document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Outlines">
            <summary>
            Gets the root of the outline (or bookmark) tree.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.AcroForm">
            <summary>
            Get the AcroForm dictionary.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Language">
            <summary>
            Gets or sets the default language of the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.SecuritySettings">
            <summary>
            Gets the security settings of this document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.FontTable">
            <summary>
            Gets the document font table that holds all fonts used in the current document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.ImageTable">
            <summary>
            Gets the document image table that holds all images used in the current document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.FormTable">
            <summary>
            Gets the document form table that holds all form external objects used in the current document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.ExtGStateTable">
            <summary>
            Gets the document ExtGState table that holds all form state objects used in the current document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Catalog">
            <summary>
            Gets the PdfCatalog of the current document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Internals">
            <summary>
            Gets the PdfInternals object of this document, that grants access to some internal structures
            which are not part of the public interface of PdfDocument.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.SecurityHandler">
            <summary>
            Gets the security handler.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocument.Tls">
            <summary>
            Gets the ThreadLocalStorage object. It is used for caching objects that should created
            only once.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Internal.GlobalObjectTable">
            <summary>
            Provides a thread-local cache for large objects.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Internal.GlobalObjectTable.documentHandles">
            <summary>
            Array of handles to all documents.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfExtGState">
            <summary>
            Represents an extended graphics state object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfExtGState.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfExtGState" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfExtGState.SetDefault2">
            <summary>
            ...for shading patterns
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfExtGState.StrokeAlpha">
            <summary>
            Sets the alpha value for stroking operations.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfExtGState.NonStrokeAlpha">
            <summary>
            Sets the alpha value for nonstroking operations.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfExtGState.SoftMask">
            <summary>
            Sets a soft mask object.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfExtGState.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfExtGState.Keys">
            <summary>
            Common keys for all streams.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes;
            must be ExtGState for a graphics state parameter dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.LW">
            <summary>
            (Optional; PDF 1.3) The line width (see “Line Width” on page 185).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.LC">
            <summary>
            (Optional; PDF 1.3) The line cap style.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.LJ">
            <summary>
            (Optional; PDF 1.3) The line join style.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.ML">
            <summary>
            (Optional; PDF 1.3) The miter limit.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.D">
            <summary>
            (Optional; PDF 1.3) The line dash pattern, expressed as an array of the form
            [dashArray dashPhase], where dashArray is itself an array and dashPhase is an integer.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.RI">
            <summary>
            (Optional; PDF 1.3) The name of the rendering intent.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.OP">
            <summary>
            (Optional) A flag specifying whether to apply overprint. In PDF 1.2 and earlier,
            there is a single overprint parameter that applies to all painting operations.
            Beginning with PDF 1.3, there are two separate overprint parameters: one for stroking 
            and one for all other painting operations. Specifying an OP entry sets both parameters
            unless there is also an op entry in the same graphics state parameter dictionary, in
            which case the OP entry sets only the overprint parameter for stroking.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.op">
            <summary>
            (Optional; PDF 1.3) A flag specifying whether to apply overprint for painting operations
            other than stroking. If this entry is absent, the OP entry, if any, sets this parameter.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.OPM">
            <summary>
            (Optional; PDF 1.3) The overprint mode.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.Font">
            <summary>
            (Optional; PDF 1.3) An array of the form [font size], where font is an indirect
             reference to a font dictionary and size is a number expressed in text space units.
             These two objects correspond to the operands of the Tf operator; however,
             the first operand is an indirect object reference instead of a resource name.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.BG">
            <summary>
            (Optional) The black-generation function, which maps the interval [0.0 1.0]
            to the interval [0.0 1.0].
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.BG2">
            <summary>
            (Optional; PDF 1.3) Same as BG except that the value may also be the name Default,
            denoting the black-generation function that was in effect at the start of the page.
            If both BG and BG2 are present in the same graphics state parameter dictionary, 
            BG2 takes precedence.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.UCR">
            <summary>
            (Optional) The undercolor-removal function, which maps the interval
            [0.0 1.0] to the interval [-1.0 1.0].
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.UCR2">
            <summary>
            (Optional; PDF 1.3) Same as UCR except that the value may also be the name Default,
            denoting the undercolor-removal function that was in effect at the start of the page.
            If both UCR and UCR2 are present in the same graphics state parameter dictionary, 
            UCR2 takes precedence.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.SA">
            <summary>
            (Optional) A flag specifying whether to apply automatic stroke adjustment.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.BM">
            <summary>
            (Optional; PDF 1.4) The current blend mode to be used in the transparent imaging model.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.SMask">
            <summary>
            (Optional; PDF 1.4) The current soft mask, specifying the mask shape or
            mask opacity values to be used in the transparent imaging model.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.CA">
            <summary>
            (Optional; PDF 1.4) The current stroking alpha constant, specifying the constant 
            shape or constant opacity value to be used for stroking operations in the transparent
            imaging model.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.ca">
            <summary>
            (Optional; PDF 1.4) Same as CA, but for nonstroking operations.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.AIS">
            <summary>
            (Optional; PDF 1.4) The alpha source flag (“alpha is shape”), specifying whether 
            the current soft mask and alpha constant are to be interpreted as shape values (true)
            or opacity values (false).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.TK">
            <summary>
            (Optional; PDF 1.4) The text knockout flag, which determines the behavior of 
            overlapping glyphs within a text object in the transparent imaging model.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfExtGState.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.CMapInfo">
            <summary>
            Helper class that determines the characters used in a particular font.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.CMapInfo.AddChars(System.String)">
            <summary>
            Adds the characters of the specified string to the hashtable.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.CMapInfo.AddGlyphIndices(System.String)">
            <summary>
            Adds the glyphIndices to the hashtable.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.CMapInfo.AddAnsiChars">
            <summary>
            Adds a ANSI characters.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XStringFormatFlags">
            <summary>
            Not used in this implementation.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XStringFormatFlags.MeasureTrailingSpaces">
            <summary>
            The default value.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XStringFormat">
            <summary>
            Represents the text layout information.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XStringFormat.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XStringFormat" /> class.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormat.Alignment">
            <summary>
            Gets or sets horizontal text alignment information.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormat.LineAlignment">
            <summary>
            Gets or sets the line alignment.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormat.Default">
            <summary>
            Gets a new XStringFormat object that aligns the text left on the base line.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormat.TopLeft">
            <summary>
            Gets a new XStringFormat object that aligns the text top left of the layout rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormat.Center">
            <summary>
            Gets a new XStringFormat object that centers the text in the middle of the layout rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormat.TopCenter">
            <summary>
            Gets a new XStringFormat object that centers the text at the top of the layout rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormat.BottomCenter">
            <summary>
            Gets a new XStringFormat object that centers the text at the bottom of the layout rectangle.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XStringFormat.FormatFlags">
            <summary>
            Gets or sets flags with format information.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphicsContainer">
            <summary>
            Represents the internal state of an XGraphics object.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XBrushes">
            <summary>
            Brushes for all the pre-defined colors.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.AliceBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.AntiqueWhite">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Aqua">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Aquamarine">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Azure">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Beige">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Bisque">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Black">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.BlanchedAlmond">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Blue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.BlueViolet">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Brown">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.BurlyWood">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.CadetBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Chartreuse">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Chocolate">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Coral">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.CornflowerBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Cornsilk">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Crimson">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Cyan">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkCyan">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkGoldenrod">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkGray">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkKhaki">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkMagenta">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkOliveGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkOrange">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkOrchid">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkRed">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkSalmon">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkSeaGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkSlateBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkSlateGray">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkTurquoise">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DarkViolet">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DeepPink">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DeepSkyBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DimGray">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.DodgerBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Firebrick">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.FloralWhite">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.ForestGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Fuchsia">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Gainsboro">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.GhostWhite">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Gold">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Goldenrod">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Gray">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Green">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.GreenYellow">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Honeydew">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.HotPink">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.IndianRed">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Indigo">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Ivory">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Khaki">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Lavender">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LavenderBlush">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LawnGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LemonChiffon">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightCoral">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightCyan">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightGoldenrodYellow">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightGray">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightPink">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightSalmon">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightSeaGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightSkyBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightSlateGray">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightSteelBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LightYellow">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Lime">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.LimeGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Linen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Magenta">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Maroon">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MediumAquamarine">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MediumBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MediumOrchid">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MediumPurple">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MediumSeaGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MediumSlateBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MediumSpringGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MediumTurquoise">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MediumVioletRed">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MidnightBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MintCream">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.MistyRose">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Moccasin">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.NavajoWhite">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Navy">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.OldLace">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Olive">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.OliveDrab">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Orange">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.OrangeRed">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Orchid">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.PaleGoldenrod">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.PaleGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.PaleTurquoise">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.PaleVioletRed">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.PapayaWhip">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.PeachPuff">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Peru">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Pink">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Plum">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.PowderBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Purple">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Red">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.RosyBrown">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.RoyalBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.SaddleBrown">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Salmon">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.SandyBrown">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.SeaGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.SeaShell">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Sienna">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Silver">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.SkyBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.SlateBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.SlateGray">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Snow">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.SpringGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.SteelBlue">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Tan">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Teal">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Thistle">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Tomato">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Transparent">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Turquoise">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Violet">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Wheat">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.White">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.WhiteSmoke">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.Yellow">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XBrushes.YellowGreen">
            <summary>Gets a pre-defined XBrush object.</summary>
        </member>
        <member name="T:PdfSharp.Drawing.XPdfFontOptions">
            <summary>
            Specifies details about how the font is used in PDF creation.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfFontOptions.#ctor(PdfSharp.Pdf.PdfFontEncoding,PdfSharp.Pdf.PdfFontEmbedding)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPdfFontOptions" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfFontOptions.#ctor(PdfSharp.Pdf.PdfFontEncoding)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPdfFontOptions" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfFontOptions.#ctor(PdfSharp.Pdf.PdfFontEmbedding)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPdfFontOptions" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfFontOptions.#ctor(System.Boolean,System.Boolean,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPdfFontOptions" /> class.
            </summary>
            <param name="embed">If set to <c>true</c> the font is embedded.</param>
            <param name="unicode">If set to <c>true</c> Unicode encoding is used.</param>
            <param name="baseFont">Not yet implemented. Should be "".</param>
            <param name="fontFile">Not yet implemented. Should be "".</param>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfFontOptions.#ctor(System.Boolean,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPdfFontOptions" /> class.
            </summary>
            <param name="unicode">If set to <c>true</c> Unicode encoding is used.</param>
            <param name="fontData">User supplied font data.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfFontOptions.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPdfFontOptions" /> class.
            </summary>
            <param name="embed">If set to <c>true</c> the font is embedded.</param>
            <param name="baseFont">Not yet implemented. Should be "".</param>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfFontOptions.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPdfFontOptions" /> class.
            </summary>
            <param name="embed">If set to <c>true</c> the font is embedded.</param>
            <param name="unicode">If set to <c>true</c> Unicode encoding is used.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfFontOptions.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPdfFontOptions" /> class.
            </summary>
            <param name="embed">If set to <c>true</c> the font is embedded.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XPdfFontOptions.#ctor(PdfSharp.Pdf.PdfFontEmbedding,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPdfFontOptions" /> class.
            </summary>
            <param name="fontEmbedding">Indicates how font is embedded.</param>
            <param name="unicode">If set to <c>true</c> Unicode encoding is used.</param>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfFontOptions.Embed">
            <summary>
            Gets a value indicating whether the gets embedded in the PDF file.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfFontOptions.FontEmbedding">
            <summary>
            Gets a value indicating the font embedding.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfFontOptions.Unicode">
            <summary>
            Gets a value indicating whether the font is encoded as Unicode.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfFontOptions.FontEncoding">
            <summary>
            Gets a value indicating how the font is encoded.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfFontOptions.BaseFont">
            <summary>
            Not yet implemented.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfFontOptions.FontFile">
            <summary>
            Not yet implemented.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPdfFontOptions.FontData">
            <summary>
            Gets the font image.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XColorSpace">
            <summary>
             Currently not used. Only DeviceRGB is rendered in PDF.
             </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XColorSpace.Rgb">
            <summary>
            Identifies the RGB color space.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XColorSpace.Cmyk">
            <summary>
            Identifies the CMYK color space.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XColorSpace.GrayScale">
            <summary>
            Identifies the gray scale color space.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.ContentReaderException">
            <summary>
            Exception thrown by ContentReader.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.ContentReaderException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Content.ContentReaderException" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.ContentReaderException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Content.ContentReaderException" /> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Content.ContentReaderException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Content.ContentReaderException" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfPushButtonField">
            <summary>
            Represents the push button field.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfPushButtonField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of PdfPushButtonField.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfPushButtonField.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfPushButtonField.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="T:PdfSharp.PageSizeConverter">
            <summary>
            Converter from <see cref="T:PdfSharp.PageSize" /> to <see cref="T:PdfSharp.Drawing.XSize" />.
            </summary>
        </member>
        <member name="M:PdfSharp.PageSizeConverter.ToSize(PdfSharp.PageSize)">
            <summary>
            Converts the specified page size enumeration to a pair of values in point.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfTextStringEncoding">
            <summary>
            Specifies how text strings are encoded. A text string is any text used outside of a page content 
            stream, e.g. document information, outline text, annotation text etc.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfTextStringEncoding.PDFDocEncoding">
            <summary>
            Specifies that hypertext uses PDF DocEncoding.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfTextStringEncoding.Unicode">
            <summary>
            Specifies that hypertext uses unicode encoding.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfInteger">
            <summary>
            Represents a direct integer value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfInteger.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfInteger" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfInteger.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfInteger" /> class.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfInteger.ToString">
            <summary>
            Returns the integer as string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfInteger.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the integer as string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfInteger.GetTypeCode">
            <summary>
            Returns TypeCode for 32-bit integers.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfInteger.Value">
            <summary>
            Gets the value as integer
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDocumentOptions">
            <summary>
            Holds information how to handle the document when it is saved as PDF stream.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentOptions.ColorMode">
            <summary>
            Gets or sets the color mode.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentOptions.CompressContentStreams">
            <summary>
            Gets or sets a value indicating whether to compress content streams of PDF pages.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentOptions.NoCompression">
            <summary>
            Gets or sets a value indicating that all objects are not compressed.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.KeyType">
            <summary>
            Specifies the type of a key's value in a dictionary.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.KeyInfoAttribute">
            <summary>
            Summary description for KeyInfo.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.TrimMargins">
            <summary>
            Represents trim margins added to the page.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.TrimMargins.All">
            <summary>
            Sets all four crop margins simultaneously.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.TrimMargins.Left">
            <summary>
            Gets or sets the left crop margin.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.TrimMargins.Right">
            <summary>
            Gets or sets the right crop margin.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.TrimMargins.Top">
            <summary>
            Gets or sets the top crop margin.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.TrimMargins.Bottom">
            <summary>
            Gets or sets the bottom crop margin.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.TrimMargins.AreSet">
            <summary>
            Gets a value indicating whether this instance has at least one margin with a value other than zero.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Security.PdfSecurityHandler">
            <summary>
            Represents the base of all security handlers.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Security.PdfSecurityHandler.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfSecurityHandler.Keys.Filter">
            <summary>
            (Required) The name of the preferred security handler for this document. Typically,
            it is the name of the security handler that was used to encrypt the document. If 
            SubFilter is not present, only this security handler should be used when opening 
            the document. If it is present, consumer applications can use any security handler
            that implements the format specified by SubFilter.
            Standard is the name of the built-in password-based security handler. Names for other
            security handlers can be registered by using the procedure described in Appendix E.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfSecurityHandler.Keys.SubFilter">
            <summary>
            (Optional; PDF 1.3) A name that completely specifies the format and interpretation of
            the contents of the encryption dictionary. It is needed to allow security handlers other
            than the one specified by Filter to decrypt the document. If this entry is absent, other
            security handlers should not be allowed to decrypt the document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfSecurityHandler.Keys.V">
            <summary>
            (Optional but strongly recommended) A code specifying the algorithm to be used in encrypting
            and decrypting the document:
            0 An algorithm that is undocumented and no longer supported, and whose use is strongly discouraged.
            1 Algorithm 3.1, with an encryption key length of 40 bits.
            2 (PDF 1.4) Algorithm 3.1, but permitting encryption key lengths greater than 40 bits.
            3 (PDF 1.4) An unpublished algorithm that permits encryption key lengths ranging from 40 to 128 bits.
            4 (PDF 1.5) The security handler defines the use of encryption and decryption in the document, using
                        the rules specified by the CF, StmF, and StrF entries.
            The default value if this entry is omitted is 0, but a value of 1 or greater is strongly recommended.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfSecurityHandler.Keys.Length">
            <summary>
            (Optional; PDF 1.4; only if V is 2 or 3) The length of the encryption key, in bits.
            The value must be a multiple of 8, in the range 40 to 128. Default value: 40.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfSecurityHandler.Keys.CF">
            <summary>
            (Optional; meaningful only when the value of V is 4; PDF 1.5)
            A dictionary whose keys are crypt filter names and whose values are the corresponding
            crypt filter dictionaries. Every crypt filter used in the document must have an entry
            in this dictionary, except for the standard crypt filter names.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfSecurityHandler.Keys.StmF">
            <summary>
            (Optional; meaningful only when the value of V is 4; PDF 1.5)
            The name of the crypt filter that is used by default when decrypting streams.
            The name must be a key in the CF dictionary or a standard crypt filter name. All streams
            in the document, except for cross-reference streams or streams that have a Crypt entry in
            their Filter array, are decrypted by the security handler, using this crypt filter.
            Default value: Identity.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfSecurityHandler.Keys.StrF">
            <summary>
            (Optional; meaningful only when the value of V is 4; PDF 1.)
            The name of the crypt filter that is used when decrypting all strings in the document.
            The name must be a key in the CF dictionary or a standard crypt filter name.
            Default value: Identity.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfSecurityHandler.Keys.EFF">
            <summary>
            (Optional; meaningful only when the value of V is 4; PDF 1.6)
            The name of the crypt filter that should be used by default when encrypting embedded
            file streams; it must correspond to a key in the CF dictionary or a standard crypt
            filter name. This entry is provided by the security handler. Applications should respect
            this value when encrypting embedded files, except for embedded file streams that have
            their own crypt filter specifier. If this entry is not present, and the embedded file
            stream does not contain a crypt filter specifier, the stream should be encrypted using
            the default stream crypt filter specified by StmF.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Security.PdfDocumentSecurityLevel">
            <summary>
            Specifies the security level of the PDF document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfDocumentSecurityLevel.None">
            <summary>
            Document is not protected.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfDocumentSecurityLevel.Encrypted40Bit">
            <summary>
            Document is protected with 40-bit security. This option is for compatibility with 
            Acrobat 3 and 4 only. Use Encrypted128Bit whenever possible.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfDocumentSecurityLevel.Encrypted128Bit">
            <summary>
            Document is protected with 128-bit security.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.Parser">
            <summary>
            Provides the functions to parse PDF documents.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.MoveToObject(PdfSharp.Pdf.PdfObjectID)">
            <summary>
            Sets PDF input stream position to the specified object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ReadObject(PdfSharp.Pdf.PdfObject,PdfSharp.Pdf.PdfObjectID,System.Boolean)">
            <summary>
            Reads PDF object from input stream.
            </summary>
            <param name="pdfObject">Either the instance of a derived type or null. If it is null
            an appropriate object is created.</param>
            <param name="objectID">The address of the object.</param>
            <param name="includeReferences">If true, specifies that all indirect objects
            are included recursively.</param>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ParseObject(PdfSharp.Pdf.IO.Symbol)">
            <summary>
            Parses whatever comes until the specified stop symbol is reached.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ReadObjectID(PdfSharp.Pdf.PdfObject)">
            <summary>
            Reads the object ID and the generation and sets it into the specified object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ReadSymbol(PdfSharp.Pdf.IO.Symbol)">
            <summary>
            Reads the next symbol that must be the specified one.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ReadToken(System.String)">
            <summary>
            Reads the next token that must be the specified one.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ReadName">
            <summary>
            Reads a name from the PDF data stream. The preceding slash is part of the result string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ReadInteger(System.Boolean)">
            <summary>
            Reads an integer value directly from the PDF data stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ReadObject(PdfSharp.Pdf.PdfDocument,PdfSharp.Pdf.PdfObjectID)">
            <summary>
            Reads an object from the PDF input stream using the default parser.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ReadTrailer">
            <summary>
            Reads the iref table and the trailer dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ReadXRefTableAndTrailer(PdfSharp.Pdf.PdfReferenceTable)">
            <summary />
        </member>
        <member name="M:PdfSharp.Pdf.IO.Parser.ParseDateTime(System.String,System.DateTime)">
            <summary>
            Parses a PDF date string.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Internal.ThreadLocalStorage">
            <summary>
            Provides a thread-local cache for large objects.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Internal.ThreadLocalStorage.importedDocuments">
            <summary>
            Maps path to document handle.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Internal.RawUnicodeEncoding">
            <summary>
            An encoder for Unicode strings.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Filters.LzwDecode">
            <summary>
            Implements the LzwDecode filter.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.LzwDecode.Encode(System.Byte[])">
            <summary>
            Throws a NotImplementedException because the obsolete LZW encoding is not supported by PDFsharp.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.LzwDecode.Decode(System.Byte[],PdfSharp.Pdf.Filters.FilterParms)">
            <summary>
            Decodes the specified data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.LzwDecode.InitializeDictionary">
            <summary>
            Initialize the dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.LzwDecode.AddEntry(System.Byte[],System.Byte)">
            <summary>
            Add a new entry to the Dictionary.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Filters.LzwDecode.NextCode">
            <summary>
            Returns the next set of bits.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.ContentWriter">
            <summary>
            Represents a writer for generation of PDF streams. 
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.ContentWriter.Write(System.Boolean)">
            <summary>
            Writes the specified value to the PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.ContentWriter.IncreaseIndent">
            <summary>
            Increases indent level.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.ContentWriter.DecreaseIndent">
            <summary>
            Decreases indent level.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.ContentWriter.Indent">
            <summary>
            Gets or sets the indentation for a new indentation level.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.ContentWriter.IndentBlanks">
            <summary>
            Gets an indent string of current indent.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.ContentWriter.Stream">
            <summary>
            Gets the underlying stream.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfGenericAnnotation">
            <summary>
            Represents a generic annotation. Used for annotation dictionaries unknown to PDFsharp.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfGenericAnnotation.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfGenericAnnotation.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="T:PdfSharp.Forms.PagePreview">
            <summary>
            Represents a preview control for an XGraphics page. Can be used as an alternative to
            System.Windows.Forms.PrintPreviewControl.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Forms.PagePreview" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.SetRenderEvent(PdfSharp.Forms.PagePreview.RenderEvent)">
            <summary>
            Sets a delagate that is invoked when the preview wants to be painted.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.OnZoomChanged(System.EventArgs)">
            <summary>
            Raises the ZoomChanged event when the zoom factor changed.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.OnPaintBackground(System.Windows.Forms.PaintEventArgs)">
            <summary>
            Paints the background with the sheet of paper.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.OnSizeChanged(System.EventArgs)">
            <summary>
            Recalculates the preview dimension.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)">
            <summary>
            Invalidates the canvas.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.OnLayout(System.Windows.Forms.LayoutEventArgs)">
            <summary>
            Layouts the child controls.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.CalculatePreviewDimension(System.Boolean@)">
            <summary>
            Calculates all values for drawing the page preview.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.PaintBackground(System.Drawing.Graphics)">
            <summary>
            Paints the background and the empty page.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.DrawDash(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Check clipping rectangle calculations.
            </summary>
        </member>
        <member name="M:PdfSharp.Forms.PagePreview.SetScrollBarRange">
            <summary>
            Adjusts scroll bars.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.PagePreview.posOffset">
            <summary>
            Upper left corner of scroll area.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.PagePreview.pageSize">
            <summary>
            Real page size in point.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.PagePreview.virtualPage">
            <summary>
            Page in pixel relative to virtual canvas.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.PagePreview.virtualCanvas">
            <summary>
            The size in pixel of an area that completely contains the virtual page and at leat a small 
            border around it. If this area is larger than the canvas window, it is scrolled.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.PagePreview.printableArea">
            <summary>
            Printable area in point.
            </summary>
        </member>
        <member name="P:PdfSharp.Forms.PagePreview.BorderStyle">
            <summary>
            Gets or sets the border style of the control.
            </summary>
            <value />
        </member>
        <member name="P:PdfSharp.Forms.PagePreview.Zoom">
            <summary>
            Gets or sets a predefined zoom factor.
            </summary>
        </member>
        <member name="P:PdfSharp.Forms.PagePreview.ZoomPercent">
            <summary>
            Gets or sets an arbitrary zoom factor. The range is from 10 to 800.
            </summary>
        </member>
        <member name="P:PdfSharp.Forms.PagePreview.PageColor">
            <summary>
            Gets or sets the color of the page.
            </summary>
        </member>
        <member name="P:PdfSharp.Forms.PagePreview.DesktopColor">
            <summary>
            Gets or sets the color of the desktop.
            </summary>
        </member>
        <member name="P:PdfSharp.Forms.PagePreview.ShowScrollbars">
            <summary>
            Gets or sets a value indicating whether the scrollbars are visilbe.
            </summary>
        </member>
        <member name="P:PdfSharp.Forms.PagePreview.ShowPage">
            <summary>
            Gets or sets a value indicating whether the page is visilbe.
            </summary>
        </member>
        <member name="P:PdfSharp.Forms.PagePreview.PageSize">
            <summary>
            Gets or sets the page size in point.
            </summary>
        </member>
        <member name="P:PdfSharp.Forms.PagePreview.PageSizeF">
            <summary>
            This is a hack for Visual Studio 2008. The designer uses reflection for setting the PageSize property.
            This fails, even an implicit operator that converts Size to XSize exits.
            </summary>
        </member>
        <member name="E:PdfSharp.Forms.PagePreview.ZoomChanged">
            <summary>
            Occurs when the zoom factor changed.
            </summary>
        </member>
        <member name="T:PdfSharp.Forms.PagePreview.RenderEvent">
            <summary>
            A delegate for invoking the render function.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XMatrixOrder">
            <summary>
            Specifies the order for matrix transform operations.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XMatrixOrder.Prepend">
            <summary>
            The new operation is applied before the old operation.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XMatrixOrder.Append">
            <summary>
            The new operation is applied after the old operation.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XLinearGradientMode">
            <summary>
            Specifies the direction of a linear gradient.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLinearGradientMode.Horizontal">
            <summary>
            Specifies a gradient from left to right.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLinearGradientMode.Vertical">
            <summary>
            Specifies a gradient from top to bottom.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLinearGradientMode.ForwardDiagonal">
            <summary>
            Specifies a gradient from upper left to lower right.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLinearGradientMode.BackwardDiagonal">
            <summary>
            Specifies a gradient from upper right to lower left.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.Code2of5Interleaved">
            <summary>
            Implementation of the Code 2 of 5 bar code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code2of5Interleaved.#ctor">
            <summary>
            Initializes a new instance of Interleaved2of5.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code2of5Interleaved.#ctor(System.String)">
            <summary>
            Initializes a new instance of Interleaved2of5.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code2of5Interleaved.#ctor(System.String,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of Interleaved2of5.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code2of5Interleaved.#ctor(System.String,PdfSharp.Drawing.XSize,PdfSharp.Drawing.BarCodes.CodeDirection)">
            <summary>
            Initializes a new instance of Interleaved2of5.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code2of5Interleaved.ThickAndThinLines(System.Int32)">
            <summary>
            Returns an array of size 5 that represents the thick (true) and thin (false) lines or spaces
            representing the specified digit.
            </summary>
            <param name="digit">The digit to represent.</param>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code2of5Interleaved.Render(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XPoint)">
            <summary>
            Renders the bar code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code2of5Interleaved.CalcThinBarWidth(PdfSharp.Drawing.BarCodes.BarCodeRenderInfo)">
            <summary>
            Calculates the thick and thin line widths,
            taking into account the required rendering size.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code2of5Interleaved.RenderNextPair(PdfSharp.Drawing.BarCodes.BarCodeRenderInfo)">
            <summary>
            Renders the next digit pair as bar code element.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.Code2of5Interleaved.CheckCode(System.String)">
            <summary>
            Checks the code to be convertible into an interleaved 2 of 5 bar code.
            </summary>
            <param name="text">The code to be checked.</param>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.CodeOmr">
            <summary>
            Represents an OMR code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeOmr.#ctor(System.String,PdfSharp.Drawing.XSize,PdfSharp.Drawing.BarCodes.CodeDirection)">
            <summary>
            initializes a new OmrCode with the given data.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeOmr.Render(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XPoint)">
            <summary>
            Renders the OMR code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeOmr.CheckCode(System.String)">
            <summary>
            Determines whether the specified string can be used as Text for the OMR code.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.CodeOmr.SynchronizeCode">
            <summary>
            Gets or sets a value indicating whether a synchronize mark is rendered.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.CodeOmr.MakerDistance">
            <summary>
            Gets or sets the distance of the markers.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.CodeOmr.MakerThickness">
            <summary>
            Gets or sets the thickness of the makers.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.CodeDataMatrix">
            <summary>
            Defines the DataMatrix 2D barcode. THIS IS AN EMPIRA INTERNAL IMPLEMENTATION. THE CODE IN
            THE OPEN SOURCE VERSION IS A FAKE.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.MatrixCode">
            <summary>
            Represents the base class of all 2D codes.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.MatrixCode.#ctor(System.String,System.String,System.Int32,System.Int32,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.BarCodes.MatrixCode" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.MatrixCode.Render(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint)">
            <summary>
            When implemented in a derived class renders the 2D code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.MatrixCode.CheckCode(System.String)">
            <summary>
            Determines whether the specified string can be used as Text for this matrix code type.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.MatrixCode.Encoding">
            <summary>
            Gets or sets the encoding. docDaSt
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.MatrixCode.Columns">
            <summary>
            docDaSt
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.MatrixCode.Rows">
            <summary>
            docDaSt
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.MatrixCode.Text">
            <summary>
            docDaSt
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.#ctor">
            <summary>
            Initializes a new instance of CodeDataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of CodeDataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.#ctor(System.String,System.Int32,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of CodeDataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.#ctor(System.String,PdfSharp.Drawing.BarCodes.DataMatrixEncoding,System.Int32,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of CodeDataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of CodeDataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.#ctor(System.String,System.Int32,System.Int32,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of CodeDataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.#ctor(System.String,PdfSharp.Drawing.BarCodes.DataMatrixEncoding,System.Int32,System.Int32,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of CodeDataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of CodeDataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.#ctor(System.String,System.String,System.Int32,System.Int32,System.Int32,PdfSharp.Drawing.XSize)">
            <summary>
            Initializes a new instance of CodeDataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.SetEncoding(PdfSharp.Drawing.BarCodes.DataMatrixEncoding)">
            <summary>
            Sets the encoding of the DataMatrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.Render(PdfSharp.Drawing.XGraphics,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint)">
            <summary>
            Renders the matrix code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.BarCodes.CodeDataMatrix.CheckCode(System.String)">
            <summary>
            Determines whether the specified string can be used as data in the DataMatrix.
            </summary>
            <param name="text">The code to be checked.</param>
        </member>
        <member name="P:PdfSharp.Drawing.BarCodes.CodeDataMatrix.QuietZone">
            <summary>
            Gets or sets the size of the Matrix' Quiet Zone.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.CParser">
            <summary>
            Provides the functionality to parse PDF content streams.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CParser.ParseObject(PdfSharp.Pdf.Content.Objects.CSequence,PdfSharp.Pdf.Content.CSymbol)">
            <summary>
            Parses whatever comes until the specified stop symbol is reached.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CParser.ReadSymbol(PdfSharp.Pdf.Content.CSymbol)">
            <summary>
            Reads the next symbol that must be the specified one.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.ContentReader">
            <summary>
            Represents the functionality for reading PDF content streams.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.ContentReader.ReadContent(PdfSharp.Pdf.PdfPage)">
            <summary>
            Reads the content stream(s) of the specified page.
            </summary>
            <param name="page">The page.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Content.ContentReader.ReadContent(System.Byte[])">
            <summary>
            Reads the specified content.
            </summary>
            <param name="content">The content.</param>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfGroupAttributes">
            <summary>
            Represents a PDF group XObject.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfGroupAttributes.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfGroupAttributes.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfGroupAttributes.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes;
            if present, must be Group for a group attributes dictionary.
             </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfGroupAttributes.Keys.S">
            <summary>
            (Required) The group subtype, which identifies the type of group whose
            attributes this dictionary describes and determines the format and meaning
            of the dictionary’s remaining entries. The only group subtype defined in
            PDF 1.4 is Transparency. Other group subtypes may be added in the future.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfGroupAttributes.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfTextField">
            <summary>
            Represents the text field.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfTextField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of PdfTextField.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfTextField.RenderAppearance">
            <summary>
            Creates the normal appearance form X object for the annotation that represents
            this acro form text field.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfTextField.Text">
            <summary>
            Gets or sets the text value of the text field.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfTextField.Font">
            <summary>
            Gets or sets the font used to draw the text of the field.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfTextField.ForeColor">
            <summary>
            Gets or sets the foreground color of the field.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfTextField.BackColor">
            <summary>
            Gets or sets the background color of the field.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfTextField.MaxLength">
            <summary>
            Gets or sets the maximum length of the field.
            </summary>
            <value>The length of the max.</value>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfTextField.MultiLine">
            <summary>
            Gets or sets a value indicating whether the field has multiple lines.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfTextField.Password">
            <summary>
            Gets or sets a value indicating whether this field is used for passwords.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfTextField.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfTextField.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfTextField.Keys.MaxLen">
            <summary>
            (Optional; inheritable) The maximum length of the field’s text, in characters.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfTextField.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.IndexToLocationTable">
            <summary>
            The indexToLoc table stores the offsets to the locations of the glyphs in the font,
            relative to the beginning of the glyphData table. In order to compute the length of
            the last glyph element, there is an extra entry after the last valid index. 
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.IndexToLocationTable.Read">
            <summary>
            Converts the bytes in a handy representation
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.IndexToLocationTable.PrepareForCompilation">
            <summary>
            Prepares the font table to be compiled into its binary representation.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.IndexToLocationTable.Write(PdfSharp.Fonts.OpenType.OpenTypeFontWriter)">
            <summary>
            Converts the font into its binary representation.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XFontWeight">
            <summary>
            Defines the density of a typeface, in terms of the lightness or heaviness of the strokes.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.Compare(PdfSharp.Drawing.XFontWeight,PdfSharp.Drawing.XFontWeight)">
            <summary>
            Compares the specified font weights.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.op_LessThan(PdfSharp.Drawing.XFontWeight,PdfSharp.Drawing.XFontWeight)">
            <summary>
            Implements the operator &lt;.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.op_LessThanOrEqual(PdfSharp.Drawing.XFontWeight,PdfSharp.Drawing.XFontWeight)">
            <summary>
            Implements the operator &lt;=.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.op_GreaterThan(PdfSharp.Drawing.XFontWeight,PdfSharp.Drawing.XFontWeight)">
            <summary>
            Implements the operator &gt;.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.op_GreaterThanOrEqual(PdfSharp.Drawing.XFontWeight,PdfSharp.Drawing.XFontWeight)">
            <summary>
            Implements the operator &gt;=.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.op_Equality(PdfSharp.Drawing.XFontWeight,PdfSharp.Drawing.XFontWeight)">
            <summary>
            Implements the operator ==.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.op_Inequality(PdfSharp.Drawing.XFontWeight,PdfSharp.Drawing.XFontWeight)">
            <summary>
            Implements the operator !=.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.Equals(PdfSharp.Drawing.XFontWeight)">
            <summary>
            Determines whether the specified <see cref="T:PdfSharp.Drawing.XFontWeight" /> is equal to the current <see cref="T:PdfSharp.Drawing.XFontWeight" />.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.GetHashCode">
            <summary>
            Serves as a hash function for this type.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontWeight.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeight.Weight">
            <summary>
            Gets the weight of the font, a value between 1 and 999.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XFontStretch">
            <summary>
            NYI. Reserved for future extensions of PDFsharp.
            </summary>
        </member>
        <member name="T:PdfSharp.PageSize">
            <summary>
            Identifies the most popular predefined page sizes.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Undefined">
            <summary>
            The width or height of the page are set manually and override the PageSize property.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.A0">
            <summary>
            Identifies a paper sheet size of 841 mm times 1189 mm or 33.11 inch times 46.81 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.A1">
            <summary>
            Identifies a paper sheet size of 594 mm times 841 mm or 23.39 inch times 33.1 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.A2">
            <summary>
            Identifies a paper sheet size of 420 mm times 594 mm or 16.54 inch times 23.29 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.A3">
            <summary>
            Identifies a paper sheet size of 297 mm times 420 mm or 11.69 inch times 16.54 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.A4">
            <summary>
            Identifies a paper sheet size of 210 mm times 297 mm or 8.27 inch times 11.69 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.A5">
            <summary>
            Identifies a paper sheet size of 148 mm times 210 mm or 5.83 inch times 8.27 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.RA0">
            <summary>
            Identifies a paper sheet size of 860 mm times 1220 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.RA1">
            <summary>
            Identifies a paper sheet size of 610 mm times 860 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.RA2">
            <summary>
            Identifies a paper sheet size of 430 mm times 610 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.RA3">
            <summary>
            Identifies a paper sheet size of 305 mm times 430 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.RA4">
            <summary>
            Identifies a paper sheet size of 215 mm times 305 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.RA5">
            <summary>
            Identifies a paper sheet size of 153 mm times 215 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.B0">
            <summary>
            Identifies a paper sheet size of 1000 mm times 1414 mm or 39.37 inch times 55.67 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.B1">
            <summary>
            Identifies a paper sheet size of 707 mm times 1000 mm or 27.83 inch times 39.37 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.B2">
            <summary>
            Identifies a paper sheet size of 500 mm times 707 mm or 19.68 inch times 27.83 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.B3">
            <summary>
            Identifies a paper sheet size of 353 mm times 500 mm or 13.90 inch times 19.68 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.B4">
            <summary>
            Identifies a paper sheet size of 250 mm times 353 mm or 9.84 inch times 13.90 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.B5">
            <summary>
            Identifies a paper sheet size of 176 mm times 250 mm or 6.93 inch times 9.84 inch.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Quarto">
            <summary>
            Identifies a paper sheet size of 10 inch times 8 inch or 254 mm times 203 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Foolscap">
            <summary>
            Identifies a paper sheet size of 13 inch times 8 inch or 330 mm times 203 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Executive">
            <summary>
             Identifies a paper sheet size of 10.5 inch times 7.25 inch or 267 mm times 184 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.GovernmentLetter">
            <summary>
            Identifies a paper sheet size of 10.5 inch times 8 inch 267 mm times 203 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Letter">
            <summary>
            Identifies a paper sheet size of 11 inch times 8.5 inch 279 mm times 216 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Legal">
            <summary>
            Identifies a paper sheet size of 14 inch times 8.5 inch 356 mm times 216 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Ledger">
            <summary>
            Identifies a paper sheet size of 17 inch times 11 inch or 432 mm times 279 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Tabloid">
            <summary>
            Identifies a paper sheet size of 17 inch times 11 inch or 432 mm times 279 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Post">
            <summary>
            Identifies a paper sheet size of 19.25 inch times 15.5 inch 489 mm times 394 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Crown">
            <summary>
            20 ×Identifies a paper sheet size of 20 inch times 15 inch or 508 mm times 381 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.LargePost">
            <summary>
            Identifies a paper sheet size of 21 inch times 16.5 inch 533 mm times 419 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Demy">
            <summary>
            Identifies a paper sheet size of 22.5 inch times 17.5 inch 572 mm times 445 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Medium">
            <summary>
            Identifies a paper sheet size of 23 inch times 18 inch or 584 mm times 457 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Royal">
            <summary>
            Identifies a paper sheet size of 25 inch times 20 inch or 635 mm times 508 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Elephant">
            <summary>
            Identifies a paper sheet size of 28 inch times 23 inch or 711 mm times 584 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.DoubleDemy">
            <summary>
            Identifies a paper sheet size of 35 inch times 23.5 inch or 889 mm times 597 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.QuadDemy">
            <summary>
            Identifies a paper sheet size of 45 inch times 35 inch 1143 times 889 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.STMT">
            <summary>
            Identifies a paper sheet size of 8.5 inch times 5.5 inch or 216 mm times 396 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Folio">
            <summary>
            Identifies a paper sheet size of 8.5 inch times 13 inch or 216 mm times 330 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Statement">
            <summary>
            Identifies a paper sheet size of 5.5 inch times 8.5 inch or 396 mm times 216 mm.
            </summary>
        </member>
        <member name="F:PdfSharp.PageSize.Size10x14">
            <summary>
            Identifies a paper sheet size of 10 inch times 14 inch.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfName">
            <summary>
            Represents a PDF name value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfName.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfName" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfName.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfName" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfName.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to this name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfName.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfName.ToString">
            <summary>
            Returns the name. The string always begins with a slash.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfName.op_Equality(PdfSharp.Pdf.PdfName,System.String)">
            <summary>
            Determines whether the specified name and string are equal.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfName.op_Inequality(PdfSharp.Pdf.PdfName,System.String)">
            <summary>
            Determines whether the specified name and string are not equal.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfName.Empty">
            <summary>
            Represents the empty name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfName.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the name including the leading slash.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfName.Value">
            <summary>
            Gets the name as a string.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfName.Comparer">
            <summary>
            Gets the comparer for this type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfName.PdfXNameComparer">
            <summary>
            Implements a comparer that compares PdfName objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfName.PdfXNameComparer.Compare(PdfSharp.Pdf.PdfName,PdfSharp.Pdf.PdfName)">
            <summary>
            Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDate">
            <summary>
            Represents a direct date value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDate.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfDate" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDate.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfDate" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDate.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfDate" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDate.ToString">
            <summary>
            Returns the value in the PDF date format.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfDate.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the value in the PDF date format.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDate.Value">
            <summary>
            Gets the value as DateTime.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfAnnotationFlags">
            <summary>
            Specifies the annotation flags.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotationFlags.Invisible">
            <summary>
            If set, do not display the annotation if it does not belong to one of the standard
            annotation types and no annotation handler is available. If clear, display such an
            unknown annotation using an appearance stream specified by its appearancedictionary,
            if any.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotationFlags.Hidden">
            <summary>
            (PDF 1.2) If set, do not display or print the annotation or allow it to interact
            with the user, regardless of its annotation type or whether an annotation
            handler is available. In cases where screen space is limited, the ability to hide
            and show annotations selectively can be used in combination with appearance
            streams to display auxiliary pop-up information similar in function to online
            help systems.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotationFlags.Print">
            <summary>
            (PDF 1.2) If set, print the annotation when the page is printed. If clear, never
            print the annotation, regardless of whether it is displayed on the screen. This
            can be useful, for example, for annotations representing interactive pushbuttons,
            which would serve no meaningful purpose on the printed page.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotationFlags.NoZoom">
            <summary>
            (PDF 1.3) If set, do not scale the annotation’s appearance to match the magnification
            of the page. The location of the annotation on the page (defined by the
            upper-left corner of its annotation rectangle) remains fixed, regardless of the
            page magnification. See below for further discussion.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotationFlags.NoRotate">
            <summary>
            (PDF 1.3) If set, do not rotate the annotation’s appearance to match the rotation
            of the page. The upper-left corner of the annotation rectangle remains in a fixed
            location on the page, regardless of the page rotation. See below for further discussion.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotationFlags.NoView">
            <summary>
            (PDF 1.3) If set, do not display the annotation on the screen or allow it to
            interact with the user. The annotation may be printed (depending on the setting
            of the Print flag) but should be considered hidden for purposes of on-screen
            display and user interaction.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotationFlags.ReadOnly">
            <summary>
            (PDF 1.3) If set, do not allow the annotation to interact with the user. The
            annotation may be displayed or printed (depending on the settings of the
            NoView and Print flags) but should not respond to mouse clicks or change its
            appearance in response to mouse motions.
            Note: This flag is ignored for widget annotations; its function is subsumed by
            the ReadOnly flag of the associated form field.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotationFlags.Locked">
            <summary>
            (PDF 1.4) If set, do not allow the annotation to be deleted or its properties
            (including position and size) to be modified by the user. However, this flag does
            not restrict changes to the annotation’s contents, such as the value of a form
            field.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfAnnotationFlags.ToggleNoView">
            <summary>
            (PDF 1.5) If set, invert the interpretation of the NoView flag for certain events.
            A typical use is to have an annotation that appears only when a mouse cursor is
            held over it.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XLinearGradientBrush">
            <summary>
            Defines a Brush with a linear gradient.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.#ctor(System.Drawing.Point,System.Drawing.Point,PdfSharp.Drawing.XColor,PdfSharp.Drawing.XColor)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XLinearGradientBrush" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.#ctor(System.Drawing.PointF,System.Drawing.PointF,PdfSharp.Drawing.XColor,PdfSharp.Drawing.XColor)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XLinearGradientBrush" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.#ctor(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XColor,PdfSharp.Drawing.XColor)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XLinearGradientBrush" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.#ctor(System.Drawing.Rectangle,PdfSharp.Drawing.XColor,PdfSharp.Drawing.XColor,PdfSharp.Drawing.XLinearGradientMode)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XLinearGradientBrush" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.#ctor(System.Drawing.RectangleF,PdfSharp.Drawing.XColor,PdfSharp.Drawing.XColor,PdfSharp.Drawing.XLinearGradientMode)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XLinearGradientBrush" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.#ctor(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XColor,PdfSharp.Drawing.XColor,PdfSharp.Drawing.XLinearGradientMode)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XLinearGradientBrush" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.TranslateTransform(System.Double,System.Double)">
            <summary>
            Translates the brush with the specified offset.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.TranslateTransform(System.Double,System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Translates the brush with the specified offset.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.ScaleTransform(System.Double,System.Double)">
            <summary>
            Scales the brush with the specified scalars.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.ScaleTransform(System.Double,System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Scales the brush with the specified scalars.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.RotateTransform(System.Double)">
            <summary>
            Rotates the brush with the specified angle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.RotateTransform(System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Rotates the brush with the specified angle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.MultiplyTransform(PdfSharp.Drawing.XMatrix)">
            <summary>
            Multiply the brush transformation matrix with the specified matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.MultiplyTransform(PdfSharp.Drawing.XMatrix,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Multiply the brush transformation matrix with the specified matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XLinearGradientBrush.ResetTransform">
            <summary>
            Resets the brush transformation matrix with identity matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XLinearGradientBrush.Transform">
            <summary>
            Gets or sets an XMatrix that defines a local geometric transform for this LinearGradientBrush.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XFontFamily">
            <summary>
            Defines a group of type faces having a similar basic design and certain variations in styles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontFamily.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XFontFamily" /> class.
            </summary>
            <param name="name">The family name of a font.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XFontFamily.GetCellAscent(PdfSharp.Drawing.XFontStyle)">
            <summary>
            Returns the cell ascent, in design units, of the XFontFamily object of the specified style.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontFamily.GetCellDescent(PdfSharp.Drawing.XFontStyle)">
            <summary>
            Returns the cell descent, in design units, of the XFontFamily object of the specified style.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontFamily.GetEmHeight(PdfSharp.Drawing.XFontStyle)">
            <summary>
            Gets the height, in font design units, of the em square for the specified style.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontFamily.GetLineSpacing(PdfSharp.Drawing.XFontStyle)">
            <summary>
            Returns the line spacing, in design units, of the FontFamily object of the specified style.
            The line spacing is the vertical distance between the base lines of two consecutive lines of text.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontFamily.IsStyleAvailable(PdfSharp.Drawing.XFontStyle)">
            <summary>
            Indicates whether the specified FontStyle enumeration is available.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFontFamily.GetFamilies(PdfSharp.Drawing.XGraphics)">
            <summary>
            Returns an array that contains all the FontFamily objects available for the specified 
            graphics context.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XFontFamily.gdiFamily">
            <summary>
            GDI+ object.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontFamily.Name">
            <summary>
            Gets the name of the font family.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontFamily.Families">
            <summary>
            Returns an array that contains all the FontFamily objects associated with the current graphics context.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XKnownColor">
            <summary>
             Specifies all pre-defined colors. Used to identify the pre-defined colors and to 
             localize their names.
             </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.AliceBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.AntiqueWhite">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Aqua">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Aquamarine">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Azure">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Beige">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Bisque">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Black">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.BlanchedAlmond">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Blue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.BlueViolet">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Brown">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.BurlyWood">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.CadetBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Chartreuse">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Chocolate">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Coral">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.CornflowerBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Cornsilk">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Crimson">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Cyan">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkCyan">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkGoldenrod">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkGray">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkKhaki">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkMagenta">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkOliveGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkOrange">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkOrchid">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkRed">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkSalmon">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkSeaGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkSlateBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkSlateGray">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkTurquoise">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DarkViolet">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DeepPink">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DeepSkyBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DimGray">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.DodgerBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Firebrick">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.FloralWhite">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.ForestGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Fuchsia">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Gainsboro">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.GhostWhite">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Gold">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Goldenrod">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Gray">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Green">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.GreenYellow">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Honeydew">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.HotPink">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.IndianRed">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Indigo">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Ivory">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Khaki">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Lavender">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LavenderBlush">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LawnGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LemonChiffon">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightCoral">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightCyan">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightGoldenrodYellow">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightGray">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightPink">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightSalmon">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightSeaGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightSkyBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightSlateGray">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightSteelBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LightYellow">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Lime">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.LimeGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Linen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Magenta">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Maroon">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MediumAquamarine">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MediumBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MediumOrchid">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MediumPurple">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MediumSeaGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MediumSlateBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MediumSpringGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MediumTurquoise">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MediumVioletRed">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MidnightBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MintCream">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.MistyRose">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Moccasin">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.NavajoWhite">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Navy">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.OldLace">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Olive">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.OliveDrab">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Orange">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.OrangeRed">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Orchid">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.PaleGoldenrod">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.PaleGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.PaleTurquoise">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.PaleVioletRed">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.PapayaWhip">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.PeachPuff">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Peru">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Pink">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Plum">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.PowderBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Purple">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Red">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.RosyBrown">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.RoyalBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.SaddleBrown">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Salmon">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.SandyBrown">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.SeaGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.SeaShell">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Sienna">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Silver">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.SkyBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.SlateBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.SlateGray">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Snow">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.SpringGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.SteelBlue">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Tan">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Teal">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Thistle">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Tomato">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Transparent">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Turquoise">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Violet">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Wheat">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.White">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.WhiteSmoke">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.Yellow">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="F:PdfSharp.Drawing.XKnownColor.YellowGreen">
            <summary>A pre-defined color.</summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.DataMatrixEncoding">
            <summary>
            docDaSt
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.DataMatrixEncoding.Ascii">
            <summary>
            docDaSt
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.DataMatrixEncoding.C40">
            <summary>
            docDaSt
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.DataMatrixEncoding.Text">
            <summary>
            docDaSt
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.DataMatrixEncoding.X12">
            <summary>
            docDaSt
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.DataMatrixEncoding.EDIFACT">
            <summary>
            docDaSt
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.DataMatrixEncoding.Base256">
            <summary>
            docDaSt
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfTilingPattern">
            <summary>
            Represents a tiling pattern dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfTilingPattern.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfShadingPattern" /> class.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfTilingPattern.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys">
            <summary>
            Common keys for all streams.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes; if present,
            must be Pattern for a pattern dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys.PatternType">
            <summary>
            (Required) A code identifying the type of pattern that this dictionary describes;
            must be 1 for a tiling pattern.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys.PaintType">
            <summary>
            (Required) A code that determines how the color of the pattern cell is to be specified:
            1: Colored tiling pattern. The pattern’s content stream specifies the colors used to 
            paint the pattern cell. When the content stream begins execution, the current color
            is the one that was initially in effect in the pattern’s parent content stream.
            2: Uncolored tiling pattern. The pattern’s content stream does not specify any color
            information. Instead, the entire pattern cell is painted with a separately specified color
            each time the pattern is used. Essentially, the content stream describes a stencil
            through which the current color is to be poured. The content stream must not invoke
            operators that specify colors or other color-related parameters in the graphics state;
            otherwise, an error occurs. The content stream may paint an image mask, however,
            since it does not specify any color information.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys.TilingType">
            <summary>
            (Required) A code that controls adjustments to the spacing of tiles relative to the device
            pixel grid:
            1: Constant spacing. Pattern cells are spaced consistently—that is, by a multiple of a
            device pixel. To achieve this, the application may need to distort the pattern cell slightly
            by making small adjustments to XStep, YStep, and the transformation matrix. The amount
            of distortion does not exceed 1 device pixel.
            2: No distortion. The pattern cell is not distorted, but the spacing between pattern cells
            may vary by as much as 1 device pixel, both horizontally and vertically, when the pattern
            is painted. This achieves the spacing requested by XStep and YStep on average but not
            necessarily for each individual pattern cell.
            3: Constant spacing and faster tiling. Pattern cells are spaced consistently as in tiling
            type 1 but with additional distortion permitted to enable a more efficient implementation. 
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys.BBox">
            <summary>
            (Required) An array of four numbers in the pattern coordinate system giving the
            coordinates of the left, bottom, right, and top edges, respectively, of the pattern
            cell’s bounding box. These boundaries are used to clip the pattern cell.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys.XStep">
            <summary>
            (Required) The desired horizontal spacing between pattern cells, measured in the
            pattern coordinate system.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys.YStep">
            <summary>
            (Required) The desired vertical spacing between pattern cells, measured in the pattern
            coordinate system. Note that XStep and YStep may differ from the dimensions of the
            pattern cell implied by the BBox entry. This allows tiling with irregularly shaped figures.
            XStep and YStep may be either positive or negative but not zero.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys.Resources">
            <summary>
            (Required) A resource dictionary containing all of the named resources required by
            the pattern’s content stream (see Section 3.7.2, “Resource Dictionaries”).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys.Matrix">
            <summary>
            (Optional) An array of six numbers specifying the pattern matrix.
            Default value: the identity matrix [1 0 0 1 0 0].
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfTilingPattern.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfListBoxField">
            <summary>
            Represents the list box field.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfChoiceField">
            <summary>
            Represents the base class for all choice field dictionaries.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfChoiceField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.AcroForms.PdfChoiceField" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfChoiceField.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.AcroForms.PdfChoiceField" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfChoiceField.IndexInOptArray(System.String)">
            <summary>
            Gets the index of the specified string in the /Opt array or -1, if no such string exists.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfChoiceField.ValueInOptArray(System.Int32)">
            <summary>
            Gets the value from the index in the /Opt array.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfChoiceField.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfChoiceField.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfChoiceField.Keys.Opt">
            <summary>
            (Required; inheritable) An array of options to be presented to the user. Each element of
            the array is either a text string representing one of the available options or a two-element
            array consisting of a text string together with a default appearance string for constructing
            the item’s appearance dynamically at viewing time.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfChoiceField.Keys.TI">
            <summary>
            (Optional; inheritable) For scrollable list boxes, the top index (the index in the Opt array
            of the first option visible in the list).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.AcroForms.PdfChoiceField.Keys.I">
            <summary>
            (Sometimes required, otherwise optional; inheritable; PDF 1.4) For choice fields that allow
            multiple selection (MultiSelect flag set), an array of integers, sorted in ascending order,
            representing the zero-based indices in the Opt array of the currently selected option
            items. This entry is required when two or more elements in the Opt array have different
            names but the same export value, or when the value of the choice field is an array; in
            other cases, it is permitted but not required. If the items identified by this entry differ
            from those in the V entry of the field dictionary (see below), the V entry takes precedence.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfChoiceField.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfListBoxField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of PdfListBoxField.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfListBoxField.SelectedIndex">
            <summary>
            Gets or sets the index of the selected item
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfListBoxField.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfListBoxField.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.SharpZipBaseException">
            <summary>
            SharpZipBaseException is the base exception class for the SharpZipLibrary.
            All library exceptions are derived from this.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.SharpZipBaseException.#ctor">
            <summary>
            Initializes a new instance of the SharpZipLibraryException class.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.SharpZipBaseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SharpZipLibraryException class with a specified error message.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.SharpZipBaseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the SharpZipLibraryException class with a specified
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">Error message string</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="T:PdfSharp.Pdf.IO.PasswordValidity">
            <summary>
            Determines the type of the password.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PasswordValidity.Invalid">
            <summary>
            Password is neither user nor owner password.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PasswordValidity.UserPassword">
            <summary>
            Password is user password.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PasswordValidity.OwnerPassword">
            <summary>
            Password is owner password.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfShading">
            <summary>
            Represents a shading dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfShading.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfShading" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfShading.SetupFromBrush(PdfSharp.Drawing.XLinearGradientBrush)">
            <summary>
            Setups the shading from the specified brush.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfShading.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfShading.Keys">
            <summary>
            Common keys for all streams.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShading.Keys.ShadingType">
            <summary>
            (Required) The shading type:
            1 Function-based shading
            2 Axial shading
            3 Radial shading
            4 Free-form Gouraud-shaded triangle mesh
            5 Lattice-form Gouraud-shaded triangle mesh
            6 Coons patch mesh
            7 Tensor-product patch mesh
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShading.Keys.ColorSpace">
            <summary>
            (Required) The color space in which color values are expressed. This may be any device, 
            CIE-based, or special color space except a Pattern space.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShading.Keys.Background">
            <summary>
            (Optional) An array of color components appropriate to the color space, specifying
            a single background color value. If present, this color is used, before any painting 
            operation involving the shading, to fill those portions of the area to be painted 
            that lie outside the bounds of the shading object. In the opaque imaging model, 
            the effect is as if the painting operation were performed twice: first with the 
            background color and then with the shading.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShading.Keys.BBox">
            <summary>
            (Optional) An array of four numbers giving the left, bottom, right, and top coordinates, 
            respectively, of the shading’s bounding box. The coordinates are interpreted in the 
            shading’s target coordinate space. If present, this bounding box is applied as a temporary 
            clipping boundary when the shading is painted, in addition to the current clipping path
            and any other clipping boundaries in effect at that time.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShading.Keys.AntiAlias">
            <summary>
            (Optional) A flag indicating whether to filter the shading function to prevent aliasing 
            artifacts. The shading operators sample shading functions at a rate determined by the 
            resolution of the output device. Aliasing can occur if the function is not smooth—that
            is, if it has a high spatial frequency relative to the sampling rate. Anti-aliasing can
            be computationally expensive and is usually unnecessary, since most shading functions
            are smooth enough or are sampled at a high enough frequency to avoid aliasing effects.
            Anti-aliasing may not be implemented on some output devices, in which case this flag
            is ignored.
            Default value: false.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShading.Keys.Coords">
            <summary>
            (Required) An array of four numbers [x0 y0 x1 y1] specifying the starting and
            ending coordinates of the axis, expressed in the shading’s target coordinate space.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShading.Keys.Domain">
            <summary>
            (Optional) An array of two numbers [t0 t1] specifying the limiting values of a
            parametric variable t. The variable is considered to vary linearly between these
            two values as the color gradient varies between the starting and ending points of
            the axis. The variable t becomes the input argument to the color function(s).
            Default value: [0.0 1.0].
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShading.Keys.Function">
            <summary>
            (Required) A 1-in, n-out function or an array of n 1-in, 1-out functions (where n
            is the number of color components in the shading dictionary’s color space). The
            function(s) are called with values of the parametric variable t in the domain defined
            by the Domain entry. Each function’s domain must be a superset of that of the shading
            dictionary. If the value returned by the function for a given color component is out
            of range, it is adjusted to the nearest valid value.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfShading.Keys.Extend">
            <summary>
            (Optional) An array of two boolean values specifying whether to extend the shading
            beyond the starting and ending points of the axis, respectively.
            Default value: [false false].
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfShading.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XVector">
            <summary>
            Represents a two-dimensional vector specified by x- and y-coordinates.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XPrivateFontCollection">
            <summary>
             Makes fonts that are not installed on the system available within the current application domain.
             </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPrivateFontCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPrivateFontCollection" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPrivateFontCollection.Dispose">
            <summary>
            Disposes all fonts from the collection.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPrivateFontCollection.SetGlobalFontCollection(PdfSharp.Drawing.XPrivateFontCollection)">
            <summary>
            Sets a new global font collection and returns the previous one, or null if no previous one exists.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPrivateFontCollection.AddFont(System.Byte[],System.String)">
            <summary>
            Adds the font data to the font collections.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPrivateFontCollection.AddFont(System.Byte[],System.String,System.Boolean,System.Boolean)">
            <summary>
            HACK: to be removed.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPrivateFontCollection.AddFont(System.String)">
            <summary>
            Adds a font from the specified file to this collection.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPrivateFontCollection.AddFont(System.Byte[])">
            <summary>
            Adds a font from memory to this collection.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPrivateFontCollection.Global">
            <summary>
            Gets the global font collection.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Checksums.Crc32">
            <summary>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Checksums.Crc32.crc">
            <summary>
            The crc data checksum so far.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.Crc32.Reset">
            <summary>
            Resets the CRC32 data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.Crc32.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name="bval">
            the byte is taken as the lower 8 bits of bval
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.Crc32.Update(System.Byte[])">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Checksums.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name="buf">
            the buffer which contains the data
            </param>
            <param name="off">
            the offset in the buffer where the data starts
            </param>
            <param name="len">
            the length of the data
            </param>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Checksums.Crc32.Value">
            <summary>
            Returns the CRC32 data checksum computed so far.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfFontEmbedding">
            <summary>
            Specifies the embedding options of an XFont when converted into PDF.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfFontEmbedding.Default">
            <summary>
            Unicode fonts are embedded, WinAnsi fonts are not embedded.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfFontEmbedding.None">
            <summary>
            Fonts are not embedded.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfFontEmbedding.Always">
            <summary>
            All fonts are embedded.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfFontEmbedding.Automatic">
            <summary>
            Not yet implemented.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfUInteger">
            <summary>
            Represents a direct unsigned integer value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfUInteger" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfUInteger" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToString">
            <summary>
            Returns the unsigned integer as string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the integer as string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToUInt64(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 64-bit unsigned integer.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToSByte(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 8-bit signed integer.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToDouble(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent double-precision floating-point number.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToDateTime(System.IFormatProvider)">
            <summary>
            Returns an undefined DateTime structure.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToSingle(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent single-precision floating-point number.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToBoolean(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent Boolean value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToInt32(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 32-bit signed integer.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToUInt16(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 16-bit unsigned integer.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToInt16(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 16-bit signed integer.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.System#IConvertible#ToString(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent <see cref="T:System.String" />.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToByte(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 8-bit unsigned integer.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToChar(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent Unicode character.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToInt64(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 64-bit signed integer.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.GetTypeCode">
            <summary>
            Returns type code for 32-bit integers.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToDecimal(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent <see cref="T:System.Decimal" /> number.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToType(System.Type,System.IFormatProvider)">
            <summary>
            Returns null.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUInteger.ToUInt32(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 32-bit unsigned integer.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfUInteger.Value">
            <summary>
            Gets the value as integer.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfOutlineStyle">
            <summary>
            Specifies the font style for the outline (bookmark) text.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutlineStyle.Regular">
            <summary>
            Regular font.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutlineStyle.Italic">
            <summary>
            Italic font.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutlineStyle.Bold">
            <summary>
            Bold font.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfOutlineStyle.BoldItalic">
            <summary>
            Bold and italic font.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.Lexer">
            <summary>
            Lexical analyzer for PDF files. Technically a PDF file is a stream of bytes. Some chunks
            of bytes represent strings in several encodings. The actual encoding depends on the
            context where the string is used. Therefore the bytes are 'raw encoded' into characters,
            i.e. a character or token read by the lexer has always character values in the range from
            0 to 255.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the Lexer class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.Initialize">
            <summary>
            Initializes fields after position has changed.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.ScanNextToken">
            <summary>
            Reads the next token and returns its type. If the token starts with a digit, the parameter
            testReference specifies how to treat it. If it is false, the lexer scans for a single integer.
            If it is true, the lexer checks if the digit is the prefix of a reference. If it is a reference,
            the token is set to the object ID followed by the generation number separated by a blank
            (the 'R' is omitted from the token).
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.ReadStream(System.Int32)">
            <summary>
            Reads the raw content of a stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.ReadRawString(System.Int32,System.Int32)">
            <summary />
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.ScanComment">
            <summary>
            Scans a comment line.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.ScanName">
            <summary>
            Scans a name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.ScanNextChar">
            <summary>
            Move current position one character further in PDF stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.ClearToken">
            <summary>
            Resets the current token to the empty string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.AppendAndScanNextChar">
            <summary>
            Appends current character to the token and reads next one.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.MoveToNonWhiteSpace">
            <summary>
            If the current character is not a white space, the function immediately returns it.
            Otherwise the PDF cursor is moved forward to the first non-white space or EOF.
            White spaces are NUL, HT, LF, FF, CR, and SP.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.IsWhiteSpace(System.Char)">
            <summary>
            Indicates whether the specified character is a PDF white-space character.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.Lexer.IsDelimiter(System.Char)">
            <summary>
            Indicates whether the specified character is a PDF delimiter character.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.Lexer.Position">
            <summary>
            Gets or sets the position within the PDF stream.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.Lexer.Symbol">
            <summary>
            Gets the current symbol.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.Lexer.Token">
            <summary>
            Gets the current token.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.Lexer.TokenToBoolean">
            <summary>
            Interprets current token as boolean literal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.Lexer.TokenToInteger">
            <summary>
            Interprets current token as integer literal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.Lexer.TokenToUInteger">
            <summary>
            Interprets current token as unsigned integer literal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.Lexer.TokenToReal">
            <summary>
            Interpret current token as real or integer literal.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.Chars">
            <summary>
            Character table by name.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfTextAnnotationIcon">
            <summary>
            Specifies the pre-defined icon names of text annotations.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfTextAnnotationIcon.NoIcon">
            <summary>
            A pre-defined annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfTextAnnotationIcon.Comment">
            <summary>
            A pre-defined annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfTextAnnotationIcon.Help">
            <summary>
            A pre-defined annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfTextAnnotationIcon.Insert">
            <summary>
            A pre-defined annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfTextAnnotationIcon.Key">
            <summary>
            A pre-defined annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfTextAnnotationIcon.NewParagraph">
            <summary>
            A pre-defined annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfTextAnnotationIcon.Note">
            <summary>
            A pre-defined annotation icon.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfTextAnnotationIcon.Paragraph">
            <summary>
            A pre-defined annotation icon.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XPen">
            <summary>
            Defines an object used to draw lines and curves.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPen.#ctor(PdfSharp.Drawing.XColor)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPen" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPen.#ctor(PdfSharp.Drawing.XColor,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPen" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPen.#ctor(PdfSharp.Drawing.XPen)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XPen" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPen.Clone">
            <summary>
            Clones this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XPen.op_Implicit(System.Drawing.Pen)~PdfSharp.Drawing.XPen">
            <summary>
            Implicit conversion from Pen to XPen
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPen.Color">
            <summary>
            Gets or sets the color.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPen.Width">
            <summary>
            Gets or sets the width.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPen.LineJoin">
            <summary>
            Gets or sets the line join.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPen.LineCap">
            <summary>
            Gets or sets the line cap.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPen.MiterLimit">
            <summary>
            Gets or sets the miter limit.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPen.DashStyle">
            <summary>
            Gets or sets the dash style.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPen.DashOffset">
            <summary>
            Gets or sets the dash offset.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPen.DashPattern">
            <summary>
            Gets or sets the dash pattern.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XLineJoin">
            <summary>
            Specifies how to join consecutive line or curve segments in a figure or subpath.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLineJoin.Miter">
            <summary>
            Specifies a mitered join. This produces a sharp corner or a clipped corner,
            depending on whether the length of the miter exceeds the miter limit
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLineJoin.Round">
            <summary>
            Specifies a circular join. This produces a smooth, circular arc between the lines.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLineJoin.Bevel">
            <summary>
            Specifies a beveled join. This produces a diagonal corner.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XDashStyle">
            <summary>
            Specifies the style of dashed lines drawn with an XPen object.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XDashStyle.Solid">
            <summary>
            Specifies a solid line.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XDashStyle.Dash">
            <summary>
            Specifies a line consisting of dashes.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XDashStyle.Dot">
            <summary>
            Specifies a line consisting of dots.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XDashStyle.DashDot">
            <summary>
            Specifies a line consisting of a repeating pattern of dash-dot.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XDashStyle.DashDotDot">
            <summary>
            Specifies a line consisting of a repeating pattern of dash-dot-dot.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XDashStyle.Custom">
            <summary>
            Specifies a user-defined custom dash style.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfToUnicodeMap">
            <summary>
            Represents a ToUnicode map for composite font.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfToUnicodeMap.PrepareForSave">
            <summary>
            Creates the ToUnicode map from the CMapInfo.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfToUnicodeMap.CMapInfo">
            <summary>
            Gets or sets the CMap info.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfSoftMask">
            <summary>
            Represents a PDF soft mask.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfSoftMask.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfXObject" /> class.
            </summary>
            <param name="document">The document that owns the object.</param>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfSoftMask.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfSoftMask.Keys.Type">
            <summary>
            (Optional) The type of PDF object that this dictionary describes;
            if present, must be Mask for a soft-mask dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfSoftMask.Keys.S">
            <summary>
            (Required) A subtype specifying the method to be used in deriving the mask values
            from the transparency group specified by the G entry:
            Alpha: Use the group’s computed alpha, disregarding its color.
            Luminosity: Convert the group’s computed color to a single-component luminosity value.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfSoftMask.Keys.G">
            <summary>
            (Required) A transparency group XObject to be used as the source of alpha
            or color values for deriving the mask. If the subtype S is Luminosity, the
            group attributes dictionary must contain a CS entry defining the color space
            in which the compositing computation is to be performed.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfSoftMask.Keys.BC">
            <summary>
            (Optional) An array of component values specifying the color to be used
            as the backdrop against which to composite the transparency group XObject G.
            This entry is consulted only if the subtype S is Luminosity. The array consists of
            n numbers, where n is the number of components in the color space specified
            by the CS entry in the group attributes dictionary.
            Default value: the color space’s initial value, representing black.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfSoftMask.Keys.TR">
            <summary>
            (Optional) A function object specifying the transfer function to be used in
            deriving the mask values. The function accepts one input, the computed
            group alpha or luminosity (depending on the value of the subtype S), and
            returns one output, the resulting mask value. Both the input and output
            must be in the range 0.0 to 1.0; if the computed output falls outside this
            range, it is forced to the nearest valid value. The name Identity may be
            specified in place of a function object to designate the identity function.
            Default value: Identity.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphicsPathInternals">
            <summary>
            Provides access to the internal data structures of XGraphicsPath.
            This class prevents the public interface from pollution with internal functions.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphicsPathInternals.GdiPath">
            <summary>
            Gets the underlying GDI+ path object.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XFontWeights">
            <summary>
            Defines a set of static predefined XFontWeight values.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.Thin">
            <summary>
            Specifies a "Thin" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.ExtraLight">
            <summary>
            Specifies a "ExtraLight" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.UltraLight">
            <summary>
            Specifies a "UltraLight" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.Light">
            <summary>
            Specifies a "Light" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.Normal">
            <summary>
            Specifies a "Normal" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.Regular">
            <summary>
            Specifies a "Regular" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.Medium">
            <summary>
            Specifies a "Medium" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.SemiBold">
            <summary>
            Specifies a "SemiBold" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.DemiBold">
            <summary>
            Specifies a "DemiBold" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.Bold">
            <summary>
            Specifies a "Bold" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.ExtraBold">
            <summary>
            Specifies a "ExtraBold" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.UltraBold">
            <summary>
            Specifies a "UltraBold" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.Heavy">
            <summary>
            Specifies a "Heavy" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.Black">
            <summary>
            Specifies a "Black" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.ExtraBlack">
            <summary>
            Specifies a "ExtraBlack" font weight.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFontWeights.UltraBlack">
            <summary>
            Specifies a "UltraBlack" font weight.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.ImageHelper">
            <summary>
            Helper class for processing image files.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.Inflater">
            <summary>
             Inflater is used to decompress data that has been compressed according
             to the "deflate" standard described in rfc1951.
             
             By default Zlib (rfc1950) headers and footers are expected in the input.
             You can use constructor <code> public Inflater(bool noHeader)</code> passing true
             if there is no Zlib header information
            
             The usage is as following.  First you have to set some input with
             <code>setInput()</code>, then inflate() it.  If inflate doesn't
             inflate any bytes there may be three reasons:
             <ul><li>needsInput() returns true because the input buffer is empty.
             You have to provide more input with <code>setInput()</code>.
             NOTE: needsInput() also returns true when, the stream is finished.
             </li><li>needsDictionary() returns true, you have to provide a preset
                dictionary with <code>setDictionary()</code>.</li><li>finished() returns true, the inflater has finished.</li></ul>
             Once the first output byte is produced, a dictionary will not be
             needed at a later stage.
            
             Authors of the original java version: John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.DECODE_HEADER">
            <summary>
            These are the possible states for an inflater
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.CPLENS">
            <summary>
            Copy lengths for literal codes 257..285
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.CPLEXT">
            <summary>
            Extra bits for literal codes 257..285
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.CPDIST">
            <summary>
            Copy offsets for distance codes 0..29
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.CPDEXT">
            <summary>
            Extra bits for distance codes
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.mode">
            <summary>
            This variable contains the current state.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.readAdler">
            <summary>
            The adler checksum of the dictionary or of the decompressed
            stream, as it is written in the header resp. footer of the
            compressed stream. 
            Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.neededBits">
            <summary>
            The number of bits needed to complete the current state.  This
            is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
            DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.isLastBlock">
            <summary>
            True, if the last block flag was set in the last block of the
            inflated stream.  This means that the stream ends after the
            current block.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.totalOut">
            <summary>
            The total number of inflated bytes.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.totalIn">
            <summary>
            The total number of bytes set with setInput().  This is not the
            value returned by the TotalIn property, since this also includes the
            unprocessed input.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Inflater.noHeader">
            <summary>
            This variable stores the noHeader flag that was given to the constructor.
            True means, that the inflated stream doesn't contain a Zlib header or 
            footer.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.#ctor">
            <summary>
            Creates a new inflater or RFC1951 decompressor
            RFC1950/Zlib headers and footers will be expected in the input data
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.#ctor(System.Boolean)">
            <summary>
            Creates a new inflater.
            </summary>
            <param name="noHeader">
            True if no RFC1950/Zlib header and footer fields are expected in the input data
            
            This is used for GZIPed/Zipped input.
            
            For compatibility with
            Sun JDK you should provide one byte of input more than needed in
            this case.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.Reset">
            <summary>
            Resets the inflater so that a new stream can be decompressed.  All
            pending input and output will be discarded.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.DecodeHeader">
            <summary>
            Decodes a zlib/RFC1950 header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
            <exception cref="T:PdfSharp.SharpZipLib.SharpZipBaseException">
            The header is invalid.
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.DecodeDict">
            <summary>
            Decodes the dictionary checksum after the deflate header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.DecodeHuffman">
            <summary>
            Decodes the huffman encoded symbols in the input stream.
            </summary>
            <returns>
            false if more input is needed, true if output window is
            full or the current block ends.
            </returns>
            <exception cref="T:PdfSharp.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.DecodeChksum">
            <summary>
            Decodes the adler checksum after the deflate stream.
            </summary>
            <returns>
            false if more input is needed.
            </returns>
            <exception cref="T:PdfSharp.SharpZipLib.SharpZipBaseException">
            If checksum doesn't match.
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.Decode">
            <summary>
            Decodes the deflated stream.
            </summary>
            <returns>
            false if more input is needed, or if finished.
            </returns>
            <exception cref="T:PdfSharp.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
            <param name="offset">
            The offset into buffer where the dictionary starts.
            </param>
            <param name="len">
            The length of the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No dictionary is needed.
            </exception>
            <exception cref="T:PdfSharp.SharpZipLib.SharpZipBaseException">
            The adler checksum for the buffer is invalid
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[])">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buf">
            the input.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            The source of input data
            </param>
            <param name="offset">
            The offset into buffer where the input starts.
            </param>
            <param name="length">
            The number of bytes of input to use.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No input is needed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The off and/or len are wrong.
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[])">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether needsDictionary(),
            needsInput() or finished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buf">
            the output buffer.
            </param>
            <returns>
            the number of bytes written to the buffer, 0 if no further
            output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if buf has length 0.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether needsDictionary(),
            needsInput() or finished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buf">
            the output buffer.
            </param>
            <param name="offset">
            the offset into buffer where the output should start.
            </param>
            <param name="len">
            the maximum length of the output.
            </param>
            <returns>
            the number of bytes written to the buffer, 0 if no further output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if len is &lt;= 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if the offset and/or len are wrong.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Inflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method also returns true when the stream is finished.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Inflater.IsNeedingDictionary">
            <summary>
            Returns true, if a preset dictionary is needed to inflate the input.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Inflater.IsFinished">
            <summary>
            Returns true, if the inflater has finished.  This means, that no
            input is needed and no output can be produced.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Inflater.Adler">
            <summary>
            Gets the adler checksum.  This is either the checksum of all
            uncompressed bytes returned by inflate(), or if needsDictionary()
            returns true (and thus no output was yet produced) this is the
            adler checksum of the expected dictionary.
            </summary>
            <returns>
            the adler checksum.
            </returns>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Inflater.TotalOut">
            <summary>
            Gets the total number of output bytes returned by inflate().
            </summary>
            <returns>
            the total number of output bytes.
            </returns>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Inflater.TotalIn">
            <summary>
            Gets the total number of processed compressed input bytes.
            </summary>
            <returns>
            The total number of bytes of processed input bytes.
            </returns>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Inflater.RemainingInput">
            <summary>
            Gets the number of unprocessed input bytes.  Useful, if the end of the
            stream is reached and you want to further process the bytes after
            the deflate stream.
            </summary>
            <returns>
            The number of bytes of the input which have not been processed.
            </returns>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.Deflater">
            <summary>
             This is the Deflater class.  The deflater class compresses input
             with the deflate algorithm described in RFC 1951.  It has several
             compression levels and three different strategies described below.
            
             This class is <i>not</i> thread safe.  This is inherent in the API, due
             to the split of deflate and setInput.
             
             Author of the original java version: Jochen Hoenicke
             </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.BEST_COMPRESSION">
            <summary>
            The best and slowest compression level.  This tries to find very
            long and distant string repetitions.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.BEST_SPEED">
            <summary>
            The worst but fastest compression level.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.DEFAULT_COMPRESSION">
            <summary>
            The default compression level.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.NO_COMPRESSION">
            <summary>
            This level won't compress at all but output uncompressed blocks.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.DEFLATED">
            <summary>
            The compression method.  This is the only method supported so far.
            There is no need to use this constant at all.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.level">
            <summary>
            Compression level.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.noZlibHeaderOrFooter">
            <summary>
            If true no Zlib/RFC1950 headers or footers are generated
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.state">
            <summary>
            The current state.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.totalOut">
            <summary>
            The total bytes of output written.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.pending">
            <summary>
            The pending output.
            </summary>
        </member>
        <member name="F:PdfSharp.SharpZipLib.Zip.Compression.Deflater.engine">
            <summary>
            The deflater engine.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.#ctor">
            <summary>
            Creates a new deflater with default compression level.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="lvl">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION, or DEFAULT_COMPRESSION.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION.
            </param>
            <param name="noZlibHeaderOrFooter">
            true, if we should suppress the Zlib/RFC1950 header at the
            beginning and the adler checksum at the end of the output.  This is
            useful for the GZIP/PKZIP formats.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.Reset">
            <summary>
            Resets the deflater.  The deflater acts afterwards as if it was
            just created with the same compression level and strategy as it
            had before.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.Flush">
            <summary>
            Flushes the current input block.  Further calls to deflate() will
            produce enough output to inflate everything in the current input
            block.  This is not part of Sun's JDK so I have made it package
            private.  It is used by DeflaterOutputStream to implement
            flush().
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.Finish">
            <summary>
            Finishes the deflater with the current input block.  It is an error
            to give more input after this method was called.  This method must
            be called to force all bytes to be flushed.
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[])">
            <summary>
            Sets the data which should be compressed next.  This should be only
            called when needsInput indicates that more input is needed.
            If you call setInput when needsInput() returns false, the
            previous input that is still pending will be thrown away.
            The given byte array should not be changed, before needsInput() returns
            true again.
            This call is equivalent to <code>setInput(input, 0, input.length)</code>.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was finished() or ended().
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the data which should be compressed next.  This should be
            only called when needsInput indicates that more input is needed.
            The given byte array should not be changed, before needsInput() returns
            true again.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <param name="off">
            the start of the data.
            </param>
            <param name="len">
            the length of the data.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was finished() or ended() or if previous input is still pending.
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.SetLevel(System.Int32)">
            <summary>
            Sets the compression level.  There is no guarantee of the exact
            position of the change, but if you call this when needsInput is
            true the change of compression level will occur somewhere near
            before the end of the so far given input.
            </summary>
            <param name="lvl">
            the new compression level.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.GetLevel">
            <summary>
            Get current compression level
            </summary>
            <returns>Returns the current compression level</returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.SetStrategy(PdfSharp.SharpZipLib.Zip.Compression.DeflateStrategy)">
            <summary>
            Sets the compression strategy. Strategy is one of
            DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact
            position where the strategy is changed, the same as for
            setLevel() applies.
            </summary>
            <param name="strategy">
            The new compression strategy.
            </param>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[])">
            <summary>
            Deflates the current input block with to the given array.
            </summary>
            <param name="output">
            The buffer where compressed data is stored
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            needsInput() or finished() returns true or length is zero.
            </returns>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Deflates the current input block to the given array.
            </summary>
            <param name="output">
            Buffer to store the compressed data.
            </param>
            <param name="offset">
            Offset into the output array.
            </param>
            <param name="length">
            The maximum number of bytes that may be stored.
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            needsInput() or finished() returns true or length is zero.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If end() was previously called.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If offset and/or length don't match the array length.
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.
            </summary>
            <param name="dict">
            the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if setInput () or deflate () were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            The dictionary is a byte array containing strings that are
            likely to occur in the data which should be compressed.  The
            dictionary is not stored in the compressed output, only a
            checksum.  To decompress the output you need to supply the same
            dictionary again.
            </summary>
            <param name="dict">
            The dictionary data
            </param>
            <param name="offset">
            An offset into the dictionary.
            </param>
            <param name="length">
            The length of the dictionary data to use
            </param>
            <exception cref="T:System.InvalidOperationException">
            If setInput () or deflate () were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Deflater.Adler">
            <summary>
            Gets the current adler checksum of the data that was processed so far.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Deflater.TotalIn">
            <summary>
            Gets the number of input bytes processed so far.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Deflater.TotalOut">
            <summary>
            Gets the number of output bytes so far.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Deflater.IsFinished">
            <summary>
            Returns true if the stream was finished and no more output bytes
            are available.
            </summary>
        </member>
        <member name="P:PdfSharp.SharpZipLib.Zip.Compression.Deflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method can also return true when the stream
            was finished.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfPageMode">
            <summary>
            Specifies how the document should be displayed by a viewer when opened.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageMode.UseNone">
            <summary>
            Neither document outline nor thumbnail images visible.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageMode.UseOutlines">
            <summary>
            Document outline visible.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageMode.UseThumbs">
            <summary>
            Thumbnail images visible.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageMode.FullScreen">
            <summary>
            Full-screen mode, with no menu bar, windowcontrols, or any other window visible.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageMode.UseOC">
            <summary>
            (PDF 1.5) Optional content group panel visible.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfPageMode.UseAttachments">
            <summary>
            (PDF 1.6) Attachments panel visible.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfCustomValue">
            <summary>
            This class is intended for empira internal use only and may change or drop in future releases.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfCustomValue.#ctor">
            <summary>
            This function is intended for empira internal use only.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfCustomValue.#ctor(System.Byte[])">
            <summary>
            This function is intended for empira internal use only.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfCustomValue.CompressionMode">
            <summary>
            This property is intended for empira internal use only.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfCustomValue.Value">
            <summary>
            This property is intended for empira internal use only.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfCustomValueCompressionMode">
            <summary>
            This class is undocumented and may change or drop in future releases.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfCustomValueCompressionMode.Default">
            <summary>
            Use document default to determine compression.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfCustomValueCompressionMode.Uncompressed">
            <summary>
            Leave custom values uncompressed.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfCustomValueCompressionMode.Compressed">
            <summary>
            Compress custom values using FlateDecode.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.PdfDocumentOpenMode">
            <summary>
            Determines how a PDF document is opened. 
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfDocumentOpenMode.Modify">
            <summary>
            The PDF stream is completely read into memory and can be modified. Pages can be deleted or
            inserted, but it is not possible to extract pages. This mode is useful for modifying an
            existing PDF document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfDocumentOpenMode.Import">
            <summary>
            The PDF stream is opened for importing pages from it. A document opened in this mode cannot
            be modified.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfDocumentOpenMode.ReadOnly">
            <summary>
            The PDF stream is completely read into memory, but cannot be modified. This mode preserves the
            original internal structure of the document and is useful for analyzing existing PDF files.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfDocumentOpenMode.InformationOnly">
            <summary>
            The PDF stream is partially read for information purposes only. The only valid operation is to
            call the Info property at the imported document. This option is very fast and needs less memory
            and is e.g. useful for browsing information about a collection of PDF documents in a user interface.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Filters.FilterParms">
            <summary>
            Reserved for future extension.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfTrailer">
            <summary>
            Represents a PDF trailer dictionary. Even trailers are dictionaries their never have a cross
            reference entry in PdfReferenceTable.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfTrailer.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of PdfTrailer.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfTrailer.GetDocumentID(System.Int32)">
            <summary>
            Gets the first or second document identifier.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfTrailer.SetDocumentID(System.Int32,System.String)">
            <summary>
            Sets the first or second document identifier.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfTrailer.CreateNewDocumentIDs">
            <summary>
            Creates and sets two identical new document IDs.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfTrailer.Finish">
            <summary>
            Replace temporary irefs by their correct counterparts from the iref table.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfTrailer.Root">
            <summary>
            (Required; must be an indirect reference)
            The catalog dictionary for the PDF document contained in the file.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfTrailer.SecurityHandler">
            <summary>
            Gets the standard security handler.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfTrailer.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfTrailer.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrailer.Keys.Size">
            <summary>
            (Required; must not be an indirect reference) The total number of entries in the file’s 
            cross-reference table, as defined by the combination of the original section and all
            update sections. Equivalently, this value is 1 greater than the highest object number
            used in the file.
            Note: Any object in a cross-reference section whose number is greater than this value is
            ignored and considered missing.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrailer.Keys.Prev">
            <summary>
            (Present only if the file has more than one cross-reference section; must not be an indirect
            reference) The byte offset from the beginning of the file to the beginning of the previous 
            cross-reference section.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrailer.Keys.Root">
            <summary>
            (Required; must be an indirect reference) The catalog dictionary for the PDF document
            contained in the file.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrailer.Keys.Encrypt">
            <summary>
            (Required if document is encrypted; PDF 1.1) The document’s encryption dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrailer.Keys.Info">
            <summary>
            (Optional; must be an indirect reference) The document’s information dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrailer.Keys.ID">
            <summary>
            (Optional, but strongly recommended; PDF 1.1) An array of two strings constituting
            a file identifier for the file. Although this entry is optional, 
            its absence might prevent the file from functioning in some workflows
            that depend on files being uniquely identified.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrailer.Keys.XRefStm">
            <summary>
            (Optional) The byte offset from the beginning of the file of a cross-reference stream.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfTrailer.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfContents">
            <summary>
            Represents an array of PDF content streams of a page.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfContents.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfContents" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfContents.AppendContent">
            <summary>
            Appends a new content stream and returns it.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfContents.PrependContent">
            <summary>
            Prepends a new content stream and returns it.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfContents.CreateSingleContent">
            <summary>
            Creates a single content stream with the bytes from the array of the content streams.
            This operation does not modify any of the content streams in this array.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfTransparencyGroupAttributes">
            <summary>
            Represents a PDF transparency group XObject.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfTransparencyGroupAttributes.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfTransparencyGroupAttributes.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTransparencyGroupAttributes.Keys.CS">
            <summary>
            (Sometimes required, as discussed below)
            The group color space, which is used for the following purposes:
            • As the color space into which colors are converted when painted into the group
            • As the blending color space in which objects are composited within the group
            • As the color space of the group as a whole when it in turn is painted as an object onto its backdrop
            The group color space may be any device or CIE-based color space that
            treats its components as independent additive or subtractive values in the
            range 0.0 to 1.0, subject to the restrictions described in Section 7.2.3, “Blending Color Space.”
            These restrictions exclude Lab and lightness-chromaticity ICCBased color spaces,
            as well as the special color spaces Pattern, Indexed, Separation, and DeviceN.
            Device color spaces are subject to remapping according to the DefaultGray,
            DefaultRGB, and DefaultCMYK entries in the ColorSpace subdictionary of the
            current resource dictionary.
            Ordinarily, the CS entry is allowed only for isolated transparency groups
            (those for which I, below, is true), and even then it is optional. However,
            this entry is required in the group attributes dictionary for any transparency
            group XObject that has no parent group or page from which to inherit — in
            particular, one that is the value of the G entry in a soft-mask dictionary of
            subtype Luminosity.
            In addition, it is always permissible to specify CS in the group attributes
            dictionary associated with a page object, even if I is false or absent. In the
            normal case in which the page is imposed directly on the output medium,
            the page group is effectively isolated regardless of the I value, and the 
            specified CS value is therefore honored. But if the page is in turn used as an
            element of some other page and if the group is non-isolated, CS is ignored
            and the color space is inherited from the actual backdrop with which the
            page is composited.
            Default value: the color space of the parent group or page into which this
            transparency group is painted. (The parent’s color space in turn can be
            either explicitly specified or inherited.)
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTransparencyGroupAttributes.Keys.I">
            <summary>
            (Optional) A flag specifying whether the transparency group is isolated.
            If this flag is true, objects within the group are composited against a fully
            transparent initial backdrop; if false, they are composited against the
            group’s backdrop.
            Default value: false.
            In the group attributes dictionary for a page, the interpretation of this
            entry is slightly altered. In the normal case in which the page is imposed
            directly on the output medium, the page group is effectively isolated and
            the specified I value is ignored. But if the page is in turn used as an
            element of some other page, it is treated as if it were a transparency
            group XObject; the I value is interpreted in the normal way to determine
            whether the page group is isolated.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTransparencyGroupAttributes.Keys.K">
            <summary>
            (Optional) A flag specifying whether the transparency group is a knockout
            group. If this flag is false, later objects within the group are composited
            with earlier ones with which they overlap; if true, they are composited with
            the group’s initial backdrop and overwrite (“knock out”) any earlier
            overlapping objects.
            Default value: false.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfTransparencyGroupAttributes.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.TableTagNames">
            <summary>
            TrueType font table names.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.CMap">
            <summary>
            Character to glyph mapping.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Head">
            <summary>
            Font header .
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.HHea">
            <summary>
            Horizontal header.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.HMtx">
            <summary>
            Horizontal metrics.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.MaxP">
            <summary>
            Maximum profile.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Name">
            <summary>
            Naming table.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.OS2">
            <summary>
            OS/2 and Windows specific metrics.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Post">
            <summary>
            PostScript information.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Cvt">
            <summary>
            Control Value Table.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Fpgm">
            <summary>
            Font program.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Glyf">
            <summary>
            Glyph data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Loca">
            <summary>
            Index to location.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Prep">
            <summary>
            CVT Program.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Cff">
            <summary>
            PostScript font program (compact font format).
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.VOrg">
            <summary>
            Vertical Origin.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.EBDT">
            <summary>
            Embedded bitmap data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.EBLC">
            <summary>
            Embedded bitmap location data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.EBSC">
            <summary>
            Embedded bitmap scaling data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.BASE">
            <summary>
            Baseline data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.GDEF">
            <summary>
            Glyph definition data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.GPOS">
            <summary>
            Glyph positioning data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.GSUB">
            <summary>
            Glyph substitution data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.JSTF">
            <summary>
            Justification data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.DSIG">
            <summary>
            Digital signature.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Gasp">
            <summary>
            Grid-fitting/Scan-conversion.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Hdmx">
            <summary>
            Horizontal device metrics.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.Kern">
            <summary>
            Kerning.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.LTSH">
            <summary>
            Linear threshold data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.PCLT">
            <summary>
            PCL 5 data.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.VDMX">
            <summary>
            Vertical device metrics.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.VHea">
            <summary>
            Vertical Header.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.TableTagNames.VMtx">
            <summary>
            Vertical Metrics.
            </summary>
        </member>
        <member name="T:PdfSharp.SharpZipLib.Zip.Compression.DeflaterPending">
            <summary>
            This class stores the pending output of the Deflater.
            
            Author of the original java version: Jochen Hoenicke
            </summary>
        </member>
        <member name="M:PdfSharp.SharpZipLib.Zip.Compression.DeflaterPending.#ctor">
            <summary>
            Construct instance with default buffer size
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfFontEncoding">
            <summary>
            Specifies the encoding schema used for an XFont when converted into PDF.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfFontEncoding.WinAnsi">
            <summary>
            Windows ANSI encoding.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfFontEncoding.CP1252">
            <summary>
            Alternate name for Windows ANSI encoding.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfFontEncoding.Unicode">
            <summary>
            Unicode encoding.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfUIntegerObject">
            <summary>
            Represents an indirect integer value. This type is not used by PDFsharp. If it is imported from
            an external PDF file, the value is converted into a direct object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUIntegerObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfUIntegerObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUIntegerObject.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfUIntegerObject" /> class.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUIntegerObject.#ctor(PdfSharp.Pdf.PdfDocument,System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfUIntegerObject" /> class.
            </summary>
            <param name="document">The document.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUIntegerObject.ToString">
            <summary>
            Returns the integer as string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfUIntegerObject.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the integer literal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfUIntegerObject.Value">
            <summary>
            Gets the value as unsigned integer.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.ShiftStack">
            <summary>
            Represents the stack for the shift-reduce parser. It seems that it is only needed for
            reduction of indirect references.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.ShiftStack.GetItem(System.Int32)">
            <summary>
            Gets an item relative to the current stack pointer. The index must be a negative value (-1, -2, etc.).
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.ShiftStack.GetInteger(System.Int32)">
            <summary>
            Gets an item relative to the current stack pointer. The index must be a negative value (-1, -2, etc.).
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.ShiftStack.Shift(PdfSharp.Pdf.PdfItem)">
            <summary>
            Pushes the specified item onto the stack.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.ShiftStack.Reduce(System.Int32)">
            <summary>
            Replaces the last 'count' items with the specified item.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.IO.ShiftStack.Reduce(PdfSharp.Pdf.PdfItem,System.Int32)">
            <summary>
            Replaces the last 'count' items with the specified item.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.ShiftStack.sp">
            <summary>
            The stack pointer index. Points to the next free item.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.ShiftStack.items">
            <summary>
            An array representing the stack.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.ShiftStack.SP">
            <summary>
            Gets the stack pointer index.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.IO.ShiftStack.Item(System.Int32)">
            <summary>
            Gets the value at the specified index. Valid index is in range 0 up to sp-1.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfTextAnnotation">
            <summary>
            Represents a text annotation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfTextAnnotation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Annotations.PdfTextAnnotation" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfTextAnnotation.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Annotations.PdfTextAnnotation" /> class.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfTextAnnotation.Open">
            <summary>
            Gets or sets a flag indicating whether the annotation should initially be displayed open.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfTextAnnotation.Icon">
            <summary>
            Gets or sets an icon to be used in displaying the annotation.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfTextAnnotation.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfTextAnnotation.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfTextAnnotation.Keys.Open">
            <summary>
            (Optional) A flag specifying whether the annotation should initially be displayed open.
            Default value: false (closed).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfTextAnnotation.Keys.Name">
            <summary>
            (Optional) The name of an icon to be used in displaying the annotation. Viewer
            applications should provide predefined icon appearances for at least the following
            standard names:
              Comment 
              Help 
              Insert
              Key 
              NewParagraph 
              Note
              Paragraph
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.MonochromeMask">
            <summary>
            Helper class for creating bitmap masks (8 pels per byte).
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.MonochromeMask.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a bitmap mask.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.MonochromeMask.StartLine(System.Int32)">
            <summary>
            Starts a new line.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.MonochromeMask.AddPel(System.Boolean)">
            <summary>
            Adds a pel to the current line.
            </summary>
            <param name="isTransparent" />
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.MonochromeMask.AddPel(System.Int32)">
            <summary>
            Adds a pel from an alpha mask value.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.MonochromeMask.MaskData">
            <summary>
            Returns the bitmap mask that will be written to PDF.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfImportedObjectTable">
            <summary>
            Represents the imported objects of an external document. Used to cache objects that are
            already imported when a PdfFormXObject is added to a page.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImportedObjectTable.#ctor(PdfSharp.Pdf.PdfDocument,PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of this class with the document the objects are imported from.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImportedObjectTable.Contains(PdfSharp.Pdf.PdfObjectID)">
            <summary>
            Indicates whether the specified object is already imported.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfImportedObjectTable.Add(PdfSharp.Pdf.PdfObjectID,PdfSharp.Pdf.Advanced.PdfReference)">
            <summary>
            Adds a cloned object to this table.
            </summary>
            <param name="externalID">The object identifier in the foreign object.</param>
            <param name="iref">The cross reference to the clone of the foreign object, which belongs to
            this document. In general the clone has a different object identifier.</param>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfImportedObjectTable.externalIDs">
            <summary>
            Maps external object identifiers to cross reference entries of the importing document
            {PdfObjectID -&gt; PdfReference}.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfImportedObjectTable.Owner">
            <summary>
            Gets the document this table belongs to.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfImportedObjectTable.ExternalDocument">
            <summary>
            Gets the external document, or null, if the external document is garbage collected.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfImportedObjectTable.Item(PdfSharp.Pdf.PdfObjectID)">
            <summary>
            Gets the cloned object that corresponds to the specified external identifier.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfTrueTypeFont">
            <summary>
            Represents a TrueType font.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.#ctor(PdfSharp.Pdf.PdfDocument,PdfSharp.Drawing.XFont)">
            <summary>
            Initializes a new instance of PdfTrueTypeFont from an XFont.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.PrepareForSave">
            <summary>
            Prepares the object to get saved.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.Type">
            <summary>
            (Required) The type of PDF object that this dictionary describes;
            must be Font for a font dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.Subtype">
            <summary>
            (Required) The type of font; must be TrueType for a TrueType font.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.Name">
            <summary>
            (Required in PDF 1.0; optional otherwise) The name by which this font is 
            referenced in the Font subdictionary of the current resource dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.BaseFont">
            <summary>
            (Required) The PostScript name of the font. For Type 1 fonts, this is usually
            the value of the FontName entry in the font program; for more information.
            The Post-Script name of the font can be used to find the font’s definition in 
            the consumer application or its environment. It is also the name that is used when
            printing to a PostScript output device.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.FirstChar">
            <summary>
            (Required except for the standard 14 fonts) The first character code defined 
            in the font’s Widths array.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.LastChar">
            <summary>
            (Required except for the standard 14 fonts) The last character code defined
            in the font’s Widths array.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.Widths">
            <summary>
            (Required except for the standard 14 fonts; indirect reference preferred)
            An array of (LastChar - FirstChar + 1) widths, each element being the glyph width
            for the character code that equals FirstChar plus the array index. For character
            codes outside the range FirstChar to LastChar, the value of MissingWidth from the 
            FontDescriptor entry for this font is used. The glyph widths are measured in units 
            in which 1000 units corresponds to 1 unit in text space. These widths must be 
            consistent with the actual widths given in the font program. 
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.FontDescriptor">
            <summary>
            (Required except for the standard 14 fonts; must be an indirect reference)
            A font descriptor describing the font’s metrics other than its glyph widths.
            Note: For the standard 14 fonts, the entries FirstChar, LastChar, Widths, and 
            FontDescriptor must either all be present or all be absent. Ordinarily, they are
            absent; specifying them enables a standard font to be overridden.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.Encoding">
            <summary>
            (Optional) A specification of the font’s character encoding if different from its
            built-in encoding. The value of Encoding is either the name of a predefined
            encoding (MacRomanEncoding, MacExpertEncoding, or WinAnsiEncoding, as described in 
            Appendix D) or an encoding dictionary that specifies differences from the font’s
            built-in encoding or from a specified predefined encoding.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.ToUnicode">
            <summary>
            (Optional; PDF 1.2) A stream containing a CMap file that maps character
            codes to Unicode values.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfTrueTypeFont.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfCIDFont">
            <summary>
            Represents a CIDFont dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfCIDFont.PrepareForSave">
            <summary>
            Prepares the object to get saved.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCIDFont.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.Type">
            <summary>
            (Required) The type of PDF object that this dictionary describes;
            must be Font for a CIDFont dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.Subtype">
            <summary>
            (Required) The type of CIDFont; CIDFontType0 or CIDFontType2.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.BaseFont">
            <summary>
            (Required) The PostScript name of the CIDFont. For Type 0 CIDFonts, this
            is usually the value of the CIDFontName entry in the CIDFont program. For
            Type 2 CIDFonts, it is derived the same way as for a simple TrueType font;
            In either case, the name can have a subset prefix if appropriate.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.CIDSystemInfo">
            <summary>
            (Required) A dictionary containing entries that define the character collection
            of the CIDFont.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.FontDescriptor">
            <summary>
            (Required; must be an indirect reference) A font descriptor describing the
            CIDFont’s default metrics other than its glyph widths.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.DW">
            <summary>
            (Optional) The default width for glyphs in the CIDFont.
            Default value: 1000.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.W">
            <summary>
            (Optional) A description of the widths for the glyphs in the CIDFont. The
            array’s elements have a variable format that can specify individual widths
            for consecutive CIDs or one width for a range of CIDs.
            Default value: none (the DW value is used for all glyphs).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.DW2">
            <summary>
            (Optional; applies only to CIDFonts used for vertical writing) An array of two
            numbers specifying the default metrics for vertical writing.
            Default value: [880 −1000].
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.W2">
            <summary>
            (Optional; applies only to CIDFonts used for vertical writing) A description
            of the metrics for vertical writing for the glyphs in the CIDFont.
            Default value: none (the DW2 value is used for all glyphs).
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.CIDToGIDMap">
            <summary>
            (Optional; Type 2 CIDFonts only) A specification of the mapping from CIDs
            to glyph indices. If the value is a stream, the bytes in the stream contain the
            mapping from CIDs to glyph indices: the glyph index for a particular CID
            value c is a 2-byte value stored in bytes 2 × c and 2 × c + 1, where the first
            byte is the high-order byte. If the value of CIDToGIDMap is a name, it must
            be Identity, indicating that the mapping between CIDs and glyph indices is
            the identity mapping.
            Default value: Identity.
            This entry may appear only in a Type 2 CIDFont whose associated True-Type font 
            program is embedded in the PDF file.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCIDFont.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphicsPathItem">
            <summary>
            Represents a segment of a path defined by a type and a set of points.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphicsPath">
            <summary>
            Represents a series of connected lines and curves.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XGraphicsPath" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XGraphicsPath" /> class.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphicsPath.gdipPath">
            <summary>
            Gets access to underlying GDI+ path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.Clone">
            <summary>
            Clones this instance.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddLine(System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Adds a line segment to current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddLine(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Adds  a line segment to current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddLine(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Adds  a line segment to current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddLine(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds  a line segment to current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddLine(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Adds  a line segment to current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddLines(System.Drawing.Point[])">
            <summary>
            Adds a series of connected line segments to current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddLines(System.Drawing.PointF[])">
            <summary>
            Adds a series of connected line segments to current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddLines(PdfSharp.Drawing.XPoint[])">
            <summary>
            Adds a series of connected line segments to current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddBezier(System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Adds a cubic Bézier curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddBezier(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Adds a cubic Bézier curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddBezier(PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Adds a cubic Bézier curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddBezier(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds a cubic Bézier curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddBezier(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Adds a cubic Bézier curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddBeziers(System.Drawing.Point[])">
            <summary>
            Adds a sequence of connected cubic Bézier curves to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddBeziers(System.Drawing.PointF[])">
            <summary>
            Adds a sequence of connected cubic Bézier curves to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddBeziers(PdfSharp.Drawing.XPoint[])">
            <summary>
            Adds a sequence of connected cubic Bézier curves to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddCurve(System.Drawing.Point[])">
            <summary>
            Adds a spline curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddCurve(System.Drawing.PointF[])">
            <summary>
            Adds a spline curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddCurve(PdfSharp.Drawing.XPoint[])">
            <summary>
            Adds a spline curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddCurve(System.Drawing.Point[],System.Double)">
            <summary>
            Adds a spline curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddCurve(System.Drawing.PointF[],System.Double)">
            <summary>
            Adds a spline curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddCurve(PdfSharp.Drawing.XPoint[],System.Double)">
            <summary>
            Adds a spline curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddCurve(System.Drawing.Point[],System.Int32,System.Int32,System.Single)">
            <summary>
            Adds a spline curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddCurve(System.Drawing.PointF[],System.Int32,System.Int32,System.Single)">
            <summary>
            Adds a spline curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddCurve(PdfSharp.Drawing.XPoint[],System.Int32,System.Int32,System.Double)">
            <summary>
            Adds a spline curve to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddArc(System.Drawing.Rectangle,System.Double,System.Double)">
            <summary>
            Adds an elliptical arc to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddArc(System.Drawing.RectangleF,System.Double,System.Double)">
            <summary>
            Adds an elliptical arc to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddArc(PdfSharp.Drawing.XRect,System.Double,System.Double)">
            <summary>
            Adds an elliptical arc to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddArc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds an elliptical arc to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddArc(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Adds an elliptical arc to the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRectangle(System.Drawing.Rectangle)">
            <summary>
            Adds a rectangle to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRectangle(System.Drawing.RectangleF)">
            <summary>
            Adds a rectangle to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRectangle(PdfSharp.Drawing.XRect)">
            <summary>
            Adds a rectangle to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRectangle(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds a rectangle to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Adds a rectangle to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRectangles(System.Drawing.Rectangle[])">
            <summary>
            Adds a series of rectangles to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRectangles(System.Drawing.RectangleF[])">
            <summary>
            Adds a series of rectangles to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRectangles(PdfSharp.Drawing.XRect[])">
            <summary>
            Adds a series of rectangles to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRoundedRectangle(System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Adds a rectangle with rounded corners to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRoundedRectangle(System.Drawing.RectangleF,System.Drawing.SizeF)">
            <summary>
            Adds a rectangle with rounded corners to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRoundedRectangle(PdfSharp.Drawing.XRect,System.Drawing.SizeF)">
            <summary>
            Adds a rectangle with rounded corners to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRoundedRectangle(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds a rectangle with rounded corners to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddRoundedRectangle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Adds a rectangle with rounded corners to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddEllipse(System.Drawing.Rectangle)">
            <summary>
            Adds an ellipse to the current path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddEllipse(System.Drawing.RectangleF)">
            <summary>
            Adds an ellipse to the current path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddEllipse(PdfSharp.Drawing.XRect)">
            <summary>
            Adds an ellipse to the current path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddEllipse(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds an ellipse to the current path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddEllipse(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Adds an ellipse to the current path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddPolygon(System.Drawing.Point[])">
            <summary>
            Adds a polygon to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddPolygon(System.Drawing.PointF[])">
            <summary>
            Adds a polygon to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddPolygon(PdfSharp.Drawing.XPoint[])">
            <summary>
            Adds a polygon to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddPie(System.Drawing.Rectangle,System.Double,System.Double)">
            <summary>
            Adds the outline of a pie shape to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddPie(System.Drawing.RectangleF,System.Double,System.Double)">
            <summary>
            Adds the outline of a pie shape to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddPie(PdfSharp.Drawing.XRect,System.Double,System.Double)">
            <summary>
            Adds the outline of a pie shape to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddPie(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Adds the outline of a pie shape to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddPie(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Adds the outline of a pie shape to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddClosedCurve(System.Drawing.Point[])">
            <summary>
            Adds a closed curve to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddClosedCurve(System.Drawing.PointF[])">
            <summary>
            Adds a closed curve to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddClosedCurve(PdfSharp.Drawing.XPoint[])">
            <summary>
            Adds a closed curve to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddClosedCurve(System.Drawing.Point[],System.Double)">
            <summary>
            Adds a closed curve to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddClosedCurve(System.Drawing.PointF[],System.Double)">
            <summary>
            Adds a closed curve to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddClosedCurve(PdfSharp.Drawing.XPoint[],System.Double)">
            <summary>
            Adds a closed curve to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddPath(PdfSharp.Drawing.XGraphicsPath,System.Boolean)">
            <summary>
            Adds the specified path to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddString(System.String,PdfSharp.Drawing.XFontFamily,PdfSharp.Drawing.XFontStyle,System.Double,System.Drawing.Point,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Adds a text string to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddString(System.String,PdfSharp.Drawing.XFontFamily,PdfSharp.Drawing.XFontStyle,System.Double,System.Drawing.PointF,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Adds a text string to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddString(System.String,PdfSharp.Drawing.XFontFamily,PdfSharp.Drawing.XFontStyle,System.Double,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Adds a text string to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddString(System.String,PdfSharp.Drawing.XFontFamily,PdfSharp.Drawing.XFontStyle,System.Double,System.Drawing.Rectangle,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Adds a text string to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddString(System.String,PdfSharp.Drawing.XFontFamily,PdfSharp.Drawing.XFontStyle,System.Double,System.Drawing.RectangleF,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Adds a text string to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.AddString(System.String,PdfSharp.Drawing.XFontFamily,PdfSharp.Drawing.XFontStyle,System.Double,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Adds a text string to this path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.CloseFigure">
            <summary>
            Closes the current figure and starts a new figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.StartFigure">
            <summary>
            Starts a new figure without closing the current figure.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.Flatten">
            <summary>
            Converts each curve in this XGraphicsPath into a sequence of connected line segments. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.Flatten(PdfSharp.Drawing.XMatrix)">
            <summary>
            Converts each curve in this XGraphicsPath into a sequence of connected line segments. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.Flatten(PdfSharp.Drawing.XMatrix,System.Double)">
            <summary>
            Converts each curve in this XGraphicsPath into a sequence of connected line segments. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.Widen(PdfSharp.Drawing.XPen)">
            <summary>
            Replaces this path with curves that enclose the area that is filled when this path is drawn 
            by the specified pen.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.Widen(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XMatrix)">
            <summary>
            Replaces this path with curves that enclose the area that is filled when this path is drawn 
            by the specified pen.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphicsPath.Widen(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XMatrix,System.Double)">
            <summary>
            Replaces this path with curves that enclose the area that is filled when this path is drawn 
            by the specified pen.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphicsPath.FillMode">
            <summary>
            Gets or sets an XFillMode that determines how the interiors of shapes are filled.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphicsPath.Internals">
            <summary>
            Grants access to internal objects of this class.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphics">
            <summary>
            Represents a drawing surface (or canvas) for a fixed size page.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.#ctor(System.Drawing.Graphics,PdfSharp.Drawing.XSize,PdfSharp.Drawing.XGraphicsUnit,PdfSharp.Drawing.XPageDirection)">
            <summary>
            Initializes a new instance of the XGraphics class.
            </summary>
            <param name="gfx">The gfx.</param>
            <param name="size">The size.</param>
            <param name="pageUnit">The page unit.</param>
            <param name="pageDirection">The page direction.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.#ctor(PdfSharp.Pdf.PdfPage,PdfSharp.Drawing.XGraphicsPdfPageOptions,PdfSharp.Drawing.XGraphicsUnit,PdfSharp.Drawing.XPageDirection)">
            <summary>
            Initializes a new instance of the XGraphics class for drawing on a PDF page.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.#ctor(PdfSharp.Drawing.XForm)">
            <summary>
            Initializes a new instance of the XGraphics class used for drawing on a form.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.CreateMeasureContext(PdfSharp.Drawing.XSize,PdfSharp.Drawing.XGraphicsUnit,PdfSharp.Drawing.XPageDirection)">
            <summary>
            Creates the measure context. This is a graphics context created only for querying measures of text.
            Drawing on a measure context has no effect.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromGraphics(System.Drawing.Graphics,PdfSharp.Drawing.XSize)">
            <summary>
            Creates a new instance of the XGraphics class from a System.Drawing.Graphics object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromGraphics(System.Drawing.Graphics,PdfSharp.Drawing.XSize,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Creates a new instance of the XGraphics class from a System.Drawing.Graphics object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromPdfPage(PdfSharp.Pdf.PdfPage)">
            <summary>
            Creates a new instance of the XGraphics class from a PdfSharp.Pdf.PdfPage object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromPdfPage(PdfSharp.Pdf.PdfPage,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Creates a new instance of the XGraphics class from a PdfSharp.Pdf.PdfPage object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromPdfPage(PdfSharp.Pdf.PdfPage,PdfSharp.Drawing.XPageDirection)">
            <summary>
            Creates a new instance of the XGraphics class from a PdfSharp.Pdf.PdfPage object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromPdfPage(PdfSharp.Pdf.PdfPage,PdfSharp.Drawing.XGraphicsPdfPageOptions)">
            <summary>
            Creates a new instance of the XGraphics class from a PdfSharp.Pdf.PdfPage object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromPdfPage(PdfSharp.Pdf.PdfPage,PdfSharp.Drawing.XGraphicsPdfPageOptions,PdfSharp.Drawing.XPageDirection)">
            <summary>
            Creates a new instance of the XGraphics class from a PdfSharp.Pdf.PdfPage object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromPdfPage(PdfSharp.Pdf.PdfPage,PdfSharp.Drawing.XGraphicsPdfPageOptions,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Creates a new instance of the XGraphics class from a PdfSharp.Pdf.PdfPage object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromPdfPage(PdfSharp.Pdf.PdfPage,PdfSharp.Drawing.XGraphicsPdfPageOptions,PdfSharp.Drawing.XGraphicsUnit,PdfSharp.Drawing.XPageDirection)">
            <summary>
            Creates a new instance of the XGraphics class from a PdfSharp.Pdf.PdfPage object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromPdfForm(PdfSharp.Drawing.XPdfForm)">
            <summary>
            Creates a new instance of the XGraphics class from a PdfSharp.Drawing.XPdfForm object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.FromForm(PdfSharp.Drawing.XForm)">
            <summary>
            Creates a new instance of the XGraphics class from a PdfSharp.Drawing.XForm object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.Initialize">
            <summary>
            Internal setup.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.Dispose">
            <summary>
            Releases all resources used by this object.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphics.targetContext">
            <summary>
            A value indicating whether GDI+ or WPF is used as context.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.Clear(PdfSharp.Drawing.XColor)">
            <summary>
            Fills the entire drawing surface with the specified color. The functions works only if
            the current transformation is identity, i.e. the function should be called only immediately
            after the XGraphics object was created.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawLine(PdfSharp.Drawing.XPen,System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Draws a line connecting two Point structures.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawLine(PdfSharp.Drawing.XPen,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Draws a line connecting two PointF structures.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawLine(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Draws a line connecting two XPoint structures.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawLine(PdfSharp.Drawing.XPen,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a line connecting the two points specified by coordinate pairs.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawLine(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a line connecting the two points specified by coordinate pairs.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawLines(PdfSharp.Drawing.XPen,System.Drawing.Point[])">
            <summary>
            Draws a series of line segments that connect an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawLines(PdfSharp.Drawing.XPen,System.Drawing.PointF[])">
            <summary>
            Draws a series of line segments that connect an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawLines(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[])">
            <summary>
            Draws a series of line segments that connect an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawLines(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double[])">
            <summary>
            Draws a series of line segments that connect an array of x and y pairs.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawBezier(PdfSharp.Drawing.XPen,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Draws a Bézier spline defined by four points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawBezier(PdfSharp.Drawing.XPen,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Draws a Bézier spline defined by four points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawBezier(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XPoint)">
            <summary>
            Draws a Bézier spline defined by four points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawBezier(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a Bézier spline defined by four points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawBeziers(PdfSharp.Drawing.XPen,System.Drawing.Point[])">
            <summary>
            Draws a series of Bézier splines from an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawBeziers(PdfSharp.Drawing.XPen,System.Drawing.PointF[])">
            <summary>
            Draws a series of Bézier splines from an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawBeziers(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[])">
            <summary>
            Draws a series of Bézier splines from an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawCurve(PdfSharp.Drawing.XPen,System.Drawing.Point[])">
            <summary>
            Draws a cardinal spline through a specified array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawCurve(PdfSharp.Drawing.XPen,System.Drawing.PointF[])">
            <summary>
            Draws a cardinal spline through a specified array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[])">
            <summary>
            Draws a cardinal spline through a specified array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawCurve(PdfSharp.Drawing.XPen,System.Drawing.Point[],System.Double)">
            <summary>
            Draws a cardinal spline through a specified array of points using a specified tension. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawCurve(PdfSharp.Drawing.XPen,System.Drawing.PointF[],System.Double)">
            <summary>
            Draws a cardinal spline through a specified array of points using a specified tension. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[],System.Double)">
            <summary>
            Draws a cardinal spline through a specified array of points using a specified tension. 
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawArc(PdfSharp.Drawing.XPen,System.Drawing.Rectangle,System.Double,System.Double)">
            <summary>
            Draws an arc representing a portion of an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawArc(PdfSharp.Drawing.XPen,System.Drawing.RectangleF,System.Double,System.Double)">
            <summary>
            Draws an arc representing a portion of an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawArc(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XRect,System.Double,System.Double)">
            <summary>
            Draws an arc representing a portion of an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawArc(PdfSharp.Drawing.XPen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws an arc representing a portion of an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawArc(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws an arc representing a portion of an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XPen,System.Drawing.Rectangle)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XPen,System.Drawing.RectangleF)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XRect)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XPen,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XBrush,System.Drawing.Rectangle)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XBrush,System.Drawing.RectangleF)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XBrush,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.Rectangle)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.RectangleF)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangles(PdfSharp.Drawing.XPen,System.Drawing.Rectangle[])">
            <summary>
            Draws a series of rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangles(PdfSharp.Drawing.XPen,System.Drawing.RectangleF[])">
            <summary>
            Draws a series of rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangles(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XRect[])">
            <summary>
            Draws a series of rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangles(PdfSharp.Drawing.XBrush,System.Drawing.Rectangle[])">
            <summary>
            Draws a series of rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangles(PdfSharp.Drawing.XBrush,System.Drawing.RectangleF[])">
            <summary>
            Draws a series of rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangles(PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect[])">
            <summary>
            Draws a series of rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangles(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.Rectangle[])">
            <summary>
            Draws a series of rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangles(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.RectangleF[])">
            <summary>
            Draws a series of rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRectangles(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect[])">
            <summary>
            Draws a series of rectangles.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XPen,System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XPen,System.Drawing.RectangleF,System.Drawing.SizeF)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XSize)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XPen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XBrush,System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XBrush,System.Drawing.RectangleF,System.Drawing.SizeF)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XSize)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XBrush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.RectangleF,System.Drawing.SizeF)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XSize)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawRoundedRectangle(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a rectangles with round corners.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XPen,System.Drawing.Rectangle)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XPen,System.Drawing.RectangleF)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XRect)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XPen,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XBrush,System.Drawing.Rectangle)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XBrush,System.Drawing.RectangleF)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XBrush,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.Rectangle)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.RectangleF)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawEllipse(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws an ellipse defined by a bounding rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPolygon(PdfSharp.Drawing.XPen,System.Drawing.Point[])">
            <summary>
            Draws a polygon defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPolygon(PdfSharp.Drawing.XPen,System.Drawing.PointF[])">
            <summary>
            Draws a polygon defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPolygon(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[])">
            <summary>
            Draws a polygon defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPolygon(PdfSharp.Drawing.XBrush,System.Drawing.Point[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a polygon defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPolygon(PdfSharp.Drawing.XBrush,System.Drawing.PointF[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a polygon defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPolygon(PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a polygon defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPolygon(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.Point[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a polygon defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPolygon(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.PointF[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a polygon defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPolygon(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a polygon defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XPen,System.Drawing.Rectangle,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XPen,System.Drawing.RectangleF,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XRect,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XPen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XPen,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XBrush,System.Drawing.Rectangle,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XBrush,System.Drawing.RectangleF,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XBrush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.Rectangle,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.RectangleF,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPie(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a pie defined by an ellipse.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,System.Drawing.Point[])">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,System.Drawing.PointF[])">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[])">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,System.Drawing.Point[],System.Double)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,System.Drawing.PointF[],System.Double)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XPoint[],System.Double)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XBrush,System.Drawing.Point[])">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XBrush,System.Drawing.PointF[])">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint[])">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XBrush,System.Drawing.Point[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XBrush,System.Drawing.PointF[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XBrush,System.Drawing.Point[],PdfSharp.Drawing.XFillMode,System.Double)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XBrush,System.Drawing.PointF[],PdfSharp.Drawing.XFillMode,System.Double)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint[],PdfSharp.Drawing.XFillMode,System.Double)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.Point[])">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.PointF[])">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint[])">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.Point[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.PointF[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint[],PdfSharp.Drawing.XFillMode)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.Point[],PdfSharp.Drawing.XFillMode,System.Double)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,System.Drawing.PointF[],PdfSharp.Drawing.XFillMode,System.Double)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawClosedCurve(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint[],PdfSharp.Drawing.XFillMode,System.Double)">
            <summary>
            Draws a closed cardinal spline defined by an array of points.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPath(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XGraphicsPath)">
            <summary>
            Draws a graphical path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPath(PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XGraphicsPath)">
            <summary>
            Draws a graphical path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawPath(PdfSharp.Drawing.XPen,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XGraphicsPath)">
            <summary>
            Draws a graphical path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,System.Drawing.PointF)">
            <summary>
            Draws the specified text string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint)">
            <summary>
            Draws the specified text string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,System.Drawing.PointF,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Draws the specified text string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Draws the specified text string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,System.Double,System.Double)">
            <summary>
            Draws the specified text string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,System.Double,System.Double,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Draws the specified text string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,System.Drawing.RectangleF)">
            <summary>
            Draws the specified text string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect)">
            <summary>
            Draws the specified text string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,System.Drawing.RectangleF,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Draws the specified text string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Draws the specified text string.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.MeasureString(System.String,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XStringFormat)">
            <summary>
            Measures the specified string when drawn with the specified font.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.MeasureString(System.String,PdfSharp.Drawing.XFont)">
            <summary>
            Measures the specified string when drawn with the specified font.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,System.Drawing.Point)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,System.Drawing.PointF)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,PdfSharp.Drawing.XPoint)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,System.Int32,System.Int32)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,System.Double,System.Double)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,System.Drawing.Rectangle)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,System.Drawing.RectangleF)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,PdfSharp.Drawing.XRect)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,System.Drawing.Rectangle,System.Drawing.Rectangle,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,System.Drawing.RectangleF,System.Drawing.RectangleF,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawImage(PdfSharp.Drawing.XImage,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Draws the specified image.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.CheckXPdfFormConsistence(PdfSharp.Drawing.XImage)">
            <summary>
            Checks whether drawing is allowed and disposes the XGraphics object, if necessary.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawBarCode(PdfSharp.Drawing.BarCodes.BarCode,PdfSharp.Drawing.XPoint)">
            <summary>
            Draws the specified bar code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawBarCode(PdfSharp.Drawing.BarCodes.BarCode,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint)">
            <summary>
            Draws the specified bar code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawBarCode(PdfSharp.Drawing.BarCodes.BarCode,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XFont,PdfSharp.Drawing.XPoint)">
            <summary>
            Draws the specified bar code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawMatrixCode(PdfSharp.Drawing.BarCodes.MatrixCode,PdfSharp.Drawing.XPoint)">
            <summary>
            Draws the specified data matrix code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.DrawMatrixCode(PdfSharp.Drawing.BarCodes.MatrixCode,PdfSharp.Drawing.XBrush,PdfSharp.Drawing.XPoint)">
            <summary>
            Draws the specified data matrix code.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.Save">
            <summary>
            Saves the current state of this XGraphics object and identifies the saved state with the
            returned XGraphicsState object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.Restore(PdfSharp.Drawing.XGraphicsState)">
            <summary>
            Restores the state of this XGraphics object to the state represented by the specified 
            XGraphicsState object.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.Restore">
            <summary>
            Restores the state of this XGraphics object to the state before the most recently call of Save.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.BeginContainer">
            <summary>
            Saves a graphics container with the current state of this XGraphics and 
            opens and uses a new graphics container.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.BeginContainer(System.Drawing.Rectangle,System.Drawing.Rectangle,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Saves a graphics container with the current state of this XGraphics and 
            opens and uses a new graphics container.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.BeginContainer(System.Drawing.RectangleF,System.Drawing.RectangleF,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Saves a graphics container with the current state of this XGraphics and 
            opens and uses a new graphics container.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.BeginContainer(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XRect,PdfSharp.Drawing.XGraphicsUnit)">
            <summary>
            Saves a graphics container with the current state of this XGraphics and 
            opens and uses a new graphics container.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.EndContainer(PdfSharp.Drawing.XGraphicsContainer)">
            <summary>
            Closes the current graphics container and restores the state of this XGraphics 
            to the state saved by a call to the BeginContainer method.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.TranslateTransform(System.Double,System.Double)">
            <summary>
            Applies the specified translation operation to the transformation matrix of this object by 
            prepending it to the object's transformation matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.TranslateTransform(System.Double,System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Applies the specified translation operation to the transformation matrix of this object
            in the specified order.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.ScaleTransform(System.Double,System.Double)">
            <summary>
            Applies the specified scaling operation to the transformation matrix of this object by 
            prepending it to the object's transformation matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.ScaleTransform(System.Double,System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Applies the specified scaling operation to the transformation matrix of this object
            in the specified order.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.ScaleTransform(System.Double)">
            <summary>
            Applies the specified scaling operation to the transformation matrix of this object by 
            prepending it to the object's transformation matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.ScaleTransform(System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Applies the specified scaling operation to the transformation matrix of this object
            in the specified order.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.RotateTransform(System.Double)">
            <summary>
            Applies the specified rotation operation to the transformation matrix of this object by 
            prepending it to the object's transformation matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.RotateTransform(System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Applies the specified rotation operation to the transformation matrix of this object
            in the specified order. The angle unit of measure is degree.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.RotateAtTransform(System.Double,PdfSharp.Drawing.XPoint)">
            <summary>
            Applies the specified rotation operation to the transformation matrix of this object by 
            prepending it to the object's transformation matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.RotateAtTransform(System.Double,PdfSharp.Drawing.XPoint,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Applies the specified rotation operation to the transformation matrix of this object by 
            prepending it to the object's transformation matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.ShearTransform(System.Double,System.Double)">
            <summary>
            Applies the specified shearing operation to the transformation matrix of this object by 
            prepending it to the object's transformation matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.ShearTransform(System.Double,System.Double,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Applies the specified shearing operation to the transformation matrix of this object
            in the specified order.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.MultiplyTransform(PdfSharp.Drawing.XMatrix)">
            <summary>
            Multiplies the transformation matrix of this object and specified matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.MultiplyTransform(PdfSharp.Drawing.XMatrix,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Multiplies the transformation matrix of this object and specified matrix in the specified order.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.AddTransform(PdfSharp.Drawing.XMatrix,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Gets or sets the transformation matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.ResetTransform">
            <summary>
            Resets the transformation matrix of this object to the identity matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.SetClip(System.Drawing.Rectangle)">
            <summary>
            Sets the clipping region to the specified rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.SetClip(System.Drawing.RectangleF)">
            <summary>
            Sets the clipping region to the specified rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.SetClip(PdfSharp.Drawing.XRect)">
            <summary>
            Sets the clipping region to the specified rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.SetClip(PdfSharp.Drawing.XGraphicsPath)">
            <summary>
            Sets the clipping region to the specified graphical path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.SetClip(PdfSharp.Drawing.XRect,PdfSharp.Drawing.XCombineMode)">
            <summary>
            Sets the clipping region to the specified graphical path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.SetClip(PdfSharp.Drawing.XGraphicsPath,PdfSharp.Drawing.XCombineMode)">
            <summary>
            Sets the clipping region to the specified graphical path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.IntersectClip(System.Drawing.Rectangle)">
            <summary>
            Updates the clip region of this XGraphics to the intersection of the 
            current clip region and the specified rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.IntersectClip(System.Drawing.RectangleF)">
            <summary>
            Updates the clip region of this XGraphics to the intersection of the 
            current clip region and the specified rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.IntersectClip(PdfSharp.Drawing.XRect)">
            <summary>
            Updates the clip region of this XGraphics to the intersection of the 
            current clip region and the specified rectangle.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.IntersectClip(PdfSharp.Drawing.XGraphicsPath)">
            <summary>
            Updates the clip region of this XGraphics to the intersection of the 
            current clip region and the specified graphical path.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.ResetClip">
            <summary>
            Resets the clip region of this XGraphics to an infinite region, 
            i.e. no clipping takes place.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.WriteComment(System.String)">
            <summary>
            Writes a comment to the output stream. Comments have no effect on the rendering of the output.
            They may be useful to mark a position in a content stream of a PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.MakePointFArray(System.Drawing.Point[])">
            <summary>
            Converts a Point[] into a PointF[].
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.MakePointFArray(PdfSharp.Drawing.XPoint[])">
            <summary>
            Converts a XPoint[] into a PointF[].
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.MakeXPointArray(System.Drawing.Point[])">
            <summary>
            Converts a Point[] into a XPoint[].
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.MakeXPointArray(System.Drawing.PointF[])">
            <summary>
            Converts a PointF[] into a XPoint[].
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphics.gfx">
            <summary>
            Always defined System.Drawing.Graphics object. Used as 'query context' for PDF pages.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphics.defaultViewMatrix">
            <summary>
            The transformation matrix from the XGraphics page space to the Graphics world space.
            (The name 'default view matrix' comes from Microsoft OS/2 Presentation Manager. I choose
            this name because I have no better one.)
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphics.drawGraphics">
            <summary>
            Indicates whether to send drawing operations to this.gfx or this.dc.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphics.renderer">
            <summary>
            Interface to an (optional) renderer. Currently it is the XGraphicsPdfRenderer, if defined.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphics.transform">
            <summary>
            The transformation matrix from XGraphics world space to page unit space.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XGraphics.gsStack">
            <summary>
            The graphics state stack.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.MUH">
            <summary>
            Internal hack for MigraDoc. Will be removed in further releases.
            Unicode support requires a global refactoring of MigraDoc and will be done in further releases.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.MFEH">
            <summary>
            Internal hack for MigraDoc. Will be removed in further releases.
            Font embedding support requires a global refactoring of MigraDoc and will be done in further releases.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.PageUnit">
            <summary>
            Gets or sets the unit of measure used for page coordinates.
            CURRENTLY ONLY POINT IS IMPLEMENTED.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.PageDirection">
            <summary>
            Gets or sets the a value indicating in which direction y-value grow.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.PageOrigin">
            <summary>
            Gets the current page origin. Setting the origin is not yet implemented.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.PageSize">
            <summary>
            Gets the current size of the page.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.GraphicsStateLevel">
            <summary>
            Gets the current graphics state level. The default value is 0. Each call of Save or BeginContainer
            increased and each call of Restore or EndContainer decreased the value by 1.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.SmoothingMode">
            <summary>
            Gets or sets the smoothing mode.
            </summary>
            <value>The smoothing mode.</value>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.Transform">
            <summary>
            Gets or sets the transformation matrix.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.Internals">
            <summary>
            Permits access to internal data.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.Transformer">
            <summary>
            (Under construction. May change in future versions.)
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.PdfPage">
            <summary>
            Gets the PDF page that serves as drawing surface if PDF is rendered, otherwise null.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.Graphics">
            <summary>
            Gets the System.Drawing.Graphics objects that serves as drawing surface if no PDF is rendered,
            or null, if no such object exists.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphics.XGraphicsInternals">
            <summary>
            Provides access to internal data structures of the XGraphics class.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.XGraphicsInternals.SetPdfTz(System.Double)">
            <summary>
            If PDF is rendered, sets the tz value.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XGraphics.XGraphicsInternals.Graphics">
            <summary>
            Gets the underlying Graphics object.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphics.SpaceTransformer">
            <summary>
            (This class is under construction.)
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XGraphics.SpaceTransformer.WorldToDefaultPage(PdfSharp.Drawing.XRect)">
            <summary>
            Gets the smallest rectangle in default page space units that completely encloses the specified rect
            in world space units.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XFont">
            <summary>
            Defines an object used to draw text.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFont.#ctor(System.String,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XFont" /> class.
            </summary>
            <param name="familyName">Name of the font family.</param>
            <param name="emSize">The em size.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XFont.#ctor(System.String,System.Double,PdfSharp.Drawing.XFontStyle)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XFont" /> class.
            </summary>
            <param name="familyName">Name of the font family.</param>
            <param name="emSize">The em size.</param>
            <param name="style">The font style.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XFont.#ctor(System.String,System.Double,PdfSharp.Drawing.XFontStyle,PdfSharp.Drawing.XPdfFontOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XFont" /> class.
            </summary>
            <param name="familyName">Name of the font family.</param>
            <param name="emSize">The em size.</param>
            <param name="style">The font style.</param>
            <param name="pdfOptions">Additional PDF options.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XFont.#ctor(System.Drawing.FontFamily,System.Double,PdfSharp.Drawing.XFontStyle,PdfSharp.Drawing.XPdfFontOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XFont" /> class.
            </summary>
            <param name="family">The font family.</param>
            <param name="emSize">The em size.</param>
            <param name="style">The font style.</param>
            <param name="pdfOptions">Additional PDF options.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XFont.#ctor(System.Drawing.Font,PdfSharp.Drawing.XPdfFontOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Drawing.XFont" /> class from a System.Drawing.Font.
            </summary>
            <param name="font">A System.Drawing.Font.</param>
            <param name="pdfOptions">Additional PDF options.</param>
        </member>
        <member name="M:PdfSharp.Drawing.XFont.Initialize">
            <summary>
            Connects the specifications of a font from XFont to a real glyph type face.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFont.GetHeight">
            <summary>
            Returns the line spacing, in pixels, of this font. The line spacing is the vertical distance
            between the base lines of two consecutive lines of text. Thus, the line spacing includes the
            blank space between lines along with the height of the character itself.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFont.GetHeight(PdfSharp.Drawing.XGraphics)">
            <summary>
            Returns the line spacing, in the current unit of a specified Graphics object, of this font.
            The line spacing is the vertical distance between the base lines of two consecutive lines of
            text. Thus, the line spacing includes the blank space between lines along with the height of
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XFont.op_Implicit(System.Drawing.Font)~PdfSharp.Drawing.XFont">
            <summary>
            Implicit conversion form Font to XFont
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XFont.selector">
            <summary>
            Cache PdfFontTable.FontSelector to speed up finding the right PdfFont
            if this font is used more than once.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.GdiFamily">
            <summary>
            Gets the GDI family.
            </summary>
            <value>The GDI family.</value>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.FontFamily">
            <summary>
            Gets the XFontFamily object associated with this XFont object.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.Name">
            <summary>
            Gets the face name of this Font object.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.Size">
            <summary>
            Gets the em-size of this Font object measured in the unit of this Font object.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.Height">
            <summary>
            Gets the line spacing of this font.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.Style">
            <summary>
            Gets style information for this Font object.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.Bold">
            <summary>
            Indicates whether this XFont object is bold.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.Italic">
            <summary>
            Indicates whether this XFont object is italic.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.Strikeout">
            <summary>
            Indicates whether this XFont object is stroke out.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.Underline">
            <summary>
            Indicates whether this XFont object is underlined.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.IsVertical">
            <summary>
            Temporary HACK for XPS to PDF converter.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.PdfOptions">
            <summary>
            Gets the PDF options of the font.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.Unicode">
            <summary>
            Indicates whether this XFont is encoded as Unicode.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XFont.Metrics">
            <summary>
            Gets the metrics.
            </summary>
            <value>The metrics.</value>
        </member>
        <member name="T:PdfSharp.Drawing.XLineAlignment">
            <summary>
            Specifies the alignment of a text string relative to its layout rectangle
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLineAlignment.Near">
            <summary>
            Specifies the text be aligned near the layout.
            In a left-to-right layout, the near position is left. In a right-to-left layout, the near
            position is right.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLineAlignment.Center">
            <summary>
            Specifies that text is aligned in the center of the layout rectangle.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLineAlignment.Far">
            <summary>
            Specifies that text is aligned far from the origin position of the layout rectangle.
            In a left-to-right layout, the far position is right. In a right-to-left layout, the far
            position is left. 
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XLineAlignment.BaseLine">
            <summary>
            Specifies that text is aligned relative to its base line.
            With this option the layout rectangle must have a height of 0.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XFontStyle">
            <summary>
            Specifies style information applied to text.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XFontStyle.Regular">
            <summary>
            Normal text.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XFontStyle.Bold">
            <summary>
            Bold text.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XFontStyle.Italic">
            <summary>
            Italic text.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XFontStyle.BoldItalic">
            <summary>
            Bold and italic text. 
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XFontStyle.Underline">
            <summary>
            Underlined text.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XFontStyle.Strikeout">
            <summary>
            Text with a line through the middle.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.CLexer">
            <summary>
            Lexical analyzer for PDF content files. Adobe specifies no grammar, but it seems that it
            is a simple post-fix notation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the Lexer class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.ScanNextToken">
            <summary>
            Reads the next token and returns its type.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.ScanComment">
            <summary>
            Scans a comment line. (Not yet used, comments are skipped by lexer.)
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.ScanInlineImage">
            <summary>
            Scans the bytes of an inline image.
            NYI: Just scans over it.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.ScanName">
            <summary>
            Scans a name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.ScanNumber">
            <summary>
            Scans an integer or real number.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.ScanOperator">
            <summary>
            Scans an operator.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.ScanNextChar">
            <summary>
            Move current position one character further in content stream.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.ClearToken">
            <summary>
            Resets the current token to the empty string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.AppendAndScanNextChar">
            <summary>
            Appends current character to the token and reads next one.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.MoveToNonWhiteSpace">
            <summary>
            If the current character is not a white space, the function immediately returns it.
            Otherwise the PDF cursor is moved forward to the first non-white space or EOF.
            White spaces are NUL, HT, LF, FF, CR, and SP.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.IsWhiteSpace(System.Char)">
            <summary>
            Indicates whether the specified character is a content stream white-space character.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.IsOperatorChar(System.Char)">
            <summary>
            Indicates whether the specified character is an content operator character.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Content.CLexer.IsDelimiter(System.Char)">
            <summary>
            Indicates whether the specified character is a PDF delimiter character.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.CLexer.Symbol">
            <summary>
            Gets or sets the current symbol.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.CLexer.Token">
            <summary>
            Gets the current token.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.CLexer.TokenToInteger">
            <summary>
            Interprets current token as integer literal.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Content.CLexer.TokenToReal">
            <summary>
            Interpret current token as real or integer literal.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.GenericFontTable">
            <summary>
            Generic font table. Not yet used
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.FontTechnology">
            <summary>
            Identifies the technology of an OpenType font file.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.FontTechnology.PostscriptOutlines">
            <summary>
            Font is Adobe Postscript font in CFF.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.FontTechnology.TrueTypeOutlines">
            <summary>
            Font is a TrueType font.
            </summary>
        </member>
        <member name="F:PdfSharp.Fonts.OpenType.FontTechnology.TrueTypeCollection">
            <summary>
            Font is a TrueType font collection.
            </summary>
        </member>
        <member name="T:PdfSharp.ProductVersionInfo">
            <summary>
            Version info base for all PDFsharp related assemblies.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Title">
            <summary>
            The title of the product.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Description">
            <summary>
            A characteristic description of the product.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Producer">
            <summary>
            The PDF producer information string.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Version">
            <summary>
            The full version number.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Version2">
            <summary>
            The full version string.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Url">
            <summary>
            The home page of this product.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Configuration">
            <summary />
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Company">
            <summary>
            The company that created/owned the product.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Product">
            <summary>
            The name of the product.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Copyright">
            <summary>
            The copyright information. Also used as NuGet Copyright.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Trademark">
            <summary>
            The trademark the product.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Culture">
            <summary>
            Unused - must be empty string.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.VersionMajor">
            <summary>
            The major version number of the product. Also used for NuGet Version.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.VersionMinor">
            <summary>
            The minor version number of the product. Also used for NuGet Version.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.VersionBuild">
            <summary>
            The build number of the product. Also used for NuGet Version.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.VersionPatch">
            <summary>
            The patch number of the product. Also used for NuGet Version.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.VersionReferenceDate">
            <summary>
            E.g. "1/1/2005", for use in NuGet Script.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetID">
            <summary>
            Use _ instead of blanks and special characters. Can be complemented with a suffix in the NuGet Script.
            Nuspec Doc: The unique identifier for the package. This is the package name that is shown when packages
            are listed using the Package Manager Console. These are also used when installing a package using the
            Install-Package command within the Package Manager Console. Package IDs may not contain any spaces
            or characters that are invalid in an URL. In general, they follow the same rules as .NET namespaces do.
            So Foo.Bar is a valid ID, Foo! and Foo Bar are not. 
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetTitle">
            <summary>
            Nuspec Doc: The human-friendly title of the package displayed in the Manage NuGet Packages dialog.
            If none is specified, the ID is used instead. 
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetAuthors">
            <summary>
            Nuspec Doc: A comma-separated list of authors of the package code.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetOwners">
            <summary>
            Nuspec Doc: A comma-separated list of the package creators. This is often the same list as in authors.
            This is ignored when uploading the package to the NuGet.org Gallery. 
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetDescription">
            <summary>
            Nuspec Doc: A long description of the package. This shows up in the right pane of the Add Package Dialog
            as well as in the Package Manager Console when listing packages using the Get-Package command. 
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetReleaseNotes">
            <summary>
            Nuspec Doc: A description of the changes made in each release of the package. This field only shows up
            when the _Updates_ tab is selected and the package is an update to a previously installed package.
            It is displayed where the Description would normally be displayed. 
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetSummary">
            <summary>
            Nuspec Doc: A short description of the package. If specified, this shows up in the middle pane of the
            Add Package Dialog. If not specified, a truncated version of the description is used instead.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetLanguage">
            <summary>
            Nuspec Doc: The locale ID for the package, such as en-us.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetProjectUrl">
            <summary>
            Nuspec Doc: A URL for the home page of the package.
            </summary>
            <remarks>
            http://www.pdfsharp.net/NuGetPackage_PDFsharp-GDI.ashx
            http://www.pdfsharp.net/NuGetPackage_PDFsharp-WPF.ashx
            </remarks>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetIconUrl">
            <summary>
            Nuspec Doc: A URL for the image to use as the icon for the package in the Manage NuGet Packages
            dialog box. This should be a 32x32-pixel .png file that has a transparent background.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetLicenseUrl">
            <summary>
            Nuspec Doc: A link to the license that the package is under.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetRequireLicenseAcceptance">
            <summary>
            Nuspec Doc: A Boolean value that specifies whether the client needs to ensure that the package license (described by licenseUrl) is accepted before the package is installed.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.NuGetTags">
            <summary>
            Nuspec Doc: A space-delimited list of tags and keywords that describe the package. This information is used to help make sure users can find the package using
            searches in the Add Package Reference dialog box or filtering in the Package Manager Console window.
            </summary>
        </member>
        <member name="F:PdfSharp.ProductVersionInfo.Technologie">
            <summary>
            The technology tag of the product:
            -g: GDI+,
            -w: WPF,
            -h: Both GDI+ and WPF (hybrid).
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfLiteral">
            <summary>
            Represents text that is written 'as it is' into the PDF stream. This class can lead to invalid PDF files.
            E.g. strings in a literal are not encrypted when the document is saved with a password.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfLiteral.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfLiteral" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfLiteral.#ctor(System.String)">
            <summary>
            Initializes a new instance with the specified string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfLiteral.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance with the culture invariant formatted specified arguments.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfLiteral.FromMatrix(PdfSharp.Drawing.XMatrix)">
            <summary>
            Creates a literal from an XMatrix
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfLiteral.ToString">
            <summary>
            Returns a string that represents the current value.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfLiteral.Value">
            <summary>
            Gets the value as litaral string.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfNameObject">
            <summary>
            Represents an indirect name value. This type is not used by PDFsharp. If it is imported from
            an external PDF file, the value is converted into a direct object. Acrobat sometime uses indirect
            names to save space, because an indirect reference to a name may be shorter than a long name.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNameObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfNameObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNameObject.#ctor(PdfSharp.Pdf.PdfDocument,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfNameObject" /> class.
            </summary>
            <param name="document">The document.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNameObject.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNameObject.GetHashCode">
            <summary>
            Serves as a hash function for this type.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNameObject.ToString">
            <summary>
            Returns the name. The string always begins with a slash.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNameObject.op_Equality(PdfSharp.Pdf.PdfNameObject,System.String)">
            <summary>
            Determines whether a name is equal to a string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNameObject.op_Inequality(PdfSharp.Pdf.PdfNameObject,System.String)">
            <summary>
            Determines whether a name is not equal to a string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNameObject.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the name including the leading slash.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfNameObject.Value">
            <summary>
            Gets or sets the name value.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfBoolean">
            <summary>
            Represents a direct boolean value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfBoolean.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfBoolean" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfBoolean.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfBoolean" /> class.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfBoolean.True">
            <summary>
            A pre-defined value that represents <c>true</c>.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfBoolean.False">
            <summary>
            A pre-defined value that represents <c>false</c>.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfBoolean.ToString">
            <summary>
            Returns 'false' or 'true'.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfBoolean.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes 'true' or 'false'.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfBoolean.Value">
            <summary>
            Gets the value of this instance as boolean value.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfCustomValues">
            <summary>
            This class is intended for empira internal use only and may change or drop in future releases.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfCustomValues.Contains(System.String)">
            <summary>
            This function is intended for empira internal use only.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfCustomValues.ClearAllCustomValues(PdfSharp.Pdf.PdfDocument)">
            <summary>
            This function is intended for empira internal use only.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfCustomValues.CompressionMode">
            <summary>
            This function is intended for empira internal use only.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfCustomValues.Item(System.String)">
            <summary>
            This function is intended for empira internal use only.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Security.PdfStandardSecurityHandler">
            <summary>
            Represents the standard PDF security handler.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EncryptDocument">
            <summary>
            Encrypts the whole document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EncryptObject(PdfSharp.Pdf.PdfObject)">
            <summary>
            Encrypts an indirect object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EncryptDictionary(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Encrypts a dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EncryptArray(PdfSharp.Pdf.PdfArray)">
            <summary>
            Encrypts an array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EncryptString(PdfSharp.Pdf.PdfString)">
            <summary>
            Encrypts a string.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EncryptBytes(System.Byte[])">
            <summary>
            Encrypts an array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.ValidatePassword(System.String)">
            <summary>
            Checks the password.
            </summary>
            <param name="inputPassword">Password or null if no password is provided.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.PadPassword(System.String)">
            <summary>
            Pads a password to a 32 byte array.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.InitWidhUserPassword(System.Byte[],System.String,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Generates the user key based on the padded user password.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.InitWidhOwnerPassword(System.Byte[],System.String,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Generates the user key based on the padded owner password.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.ComputeOwnerKey(System.Byte[],System.Byte[],System.Boolean)">
            <summary>
            Computes the padded user password from the padded owner password.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.InitEncryptionKey(System.Byte[],System.Byte[],System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Computes the encryption key.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.SetupUserKey(System.Byte[])">
            <summary>
            Computes the user key.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.PrepareKey">
            <summary>
            Prepare the encryption key.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.PrepareRC4Key(System.Byte[])">
            <summary>
            Prepare the encryption key.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.PrepareRC4Key(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Prepare the encryption key.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EncryptRC4(System.Byte[])">
            <summary>
            Encrypts the data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EncryptRC4(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encrypts the data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EncryptRC4(System.Byte[],System.Byte[])">
            <summary>
            Encrypts the data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EncryptRC4(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Encrypts the data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.EqualsKey(System.Byte[],System.Int32)">
            <summary>
            Checks whether the calculated key correct.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.SetHashKey(PdfSharp.Pdf.PdfObjectID)">
            <summary>
            Set the hash key for the specified object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.PrepareEncryption">
            <summary>
            Prepares the security handler for encrypting the document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.encryptionKey">
            <summary>
            The global encryption key.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.md5">
            <summary>
            The message digest algorithm MD5.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.state">
            <summary>
            Bytes used for RC4 encryption.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.ownerKey">
            <summary>
            The encryption key for the owner.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.userKey">
            <summary>
            The encryption key for the user.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.key">
            <summary>
            The encryption key for a particular object/generation.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.keySize">
            <summary>
            The encryption key length for a particular object/generation.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.UserPassword">
            <summary>
            Sets the user password of the document. Setting a password automatically sets the
            PdfDocumentSecurityLevel to PdfDocumentSecurityLevel.Encrypted128Bit if its current
            value is PdfDocumentSecurityLevel.None.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.OwnerPassword">
            <summary>
            Sets the owner password of the document. Setting a password automatically sets the
            PdfDocumentSecurityLevel to PdfDocumentSecurityLevel.Encrypted128Bit if its current
            value is PdfDocumentSecurityLevel.None.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.Permission">
            <summary>
            Gets or sets the user access permission represented as an integer in the P key.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.Keys.R">
            <summary>
            (Required) A number specifying which revision of the standard security handler
            should be used to interpret this dictionary:
            • 2 if the document is encrypted with a V value less than 2 and does not have any of
              the access permissions set (by means of the P entry, below) that are designated 
              "Revision 3 or greater".
            • 3 if the document is encrypted with a V value of 2 or 3, or has any "Revision 3 or 
              greater" access permissions set.
            • 4 if the document is encrypted with a V value of 4
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.Keys.O">
            <summary>
            (Required) A 32-byte string, based on both the owner and user passwords, that is
            used in computing the encryption key and in determining whether a valid owner
            password was entered.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.Keys.U">
            <summary>
            (Required) A 32-byte string, based on the user password, that is used in determining
            whether to prompt the user for a password and, if so, whether a valid user or owner 
            password was entered.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.Keys.P">
            <summary>
            (Required) A set of flags specifying which operations are permitted when the document
            is opened with user access.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.Keys.EncryptMetadata">
            <summary>
            (Optional; meaningful only when the value of V is 4; PDF 1.5) Indicates whether
            the document-level metadata stream is to be encrypted. Applications should respect this value.
            Default value: true.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfStandardSecurityHandler.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Internal.PdfEncoders">
            <summary>
            Groups a set of static encoding helper functions.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.PdfEncoders.ToStringLiteral(System.String,PdfSharp.Pdf.PdfStringEncoding,PdfSharp.Pdf.Security.PdfStandardSecurityHandler)">
            <summary>
            Converts a raw string into a raw string literal, possibly encrypted.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.PdfEncoders.ToStringLiteral(System.Byte[],System.Boolean,PdfSharp.Pdf.Security.PdfStandardSecurityHandler)">
            <summary>
            Converts a raw string into a raw string literal, possibly encrypted.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.PdfEncoders.ToHexStringLiteral(System.String,PdfSharp.Pdf.PdfStringEncoding,PdfSharp.Pdf.Security.PdfStandardSecurityHandler)">
            <summary>
            Converts a raw string into a raw hexadecimal string literal, possibly encrypted.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.PdfEncoders.ToHexStringLiteral(System.Byte[],System.Boolean,PdfSharp.Pdf.Security.PdfStandardSecurityHandler)">
            <summary>
            Converts a raw string into a raw hexadecimal string literal, possibly encrypted.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.PdfEncoders.FormatStringLiteral(System.Byte[],System.Boolean,System.Boolean,System.Boolean,PdfSharp.Pdf.Security.PdfStandardSecurityHandler)">
            <summary>
            Converts the specified byte array into a byte array representing a string literal.
            </summary>
            <param name="bytes">The bytes of the string.</param>
            <param name="unicode">Indicates whether one or two bytes are one character.</param>
            <param name="prefix">Indicates whether to use Unicode prefix.</param>
            <param name="hex">Indicates whether to create a hexadecimal string literal.</param>
            <param name="securityHandler">Encrypts the bytes if specified.</param>
            <returns>The PDF bytes.</returns>
        </member>
        <member name="F:PdfSharp.Pdf.Internal.PdfEncoders.docencode_______">
            <summary>
            Converts WinAnsi to DocEncode characters. Incomplete, just maps € and some other characters.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.PdfEncoders.Format(System.String,System.Object[])">
            <summary>
            ...because I always forget CultureInfo.InvariantCulture and wonder why Acrobat
            cannot understand my German decimal separator...
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.PdfEncoders.ToString(System.Double)">
            <summary>
            Converts a float into a string with up to 3 decimal digits and a decimal point.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.PdfEncoders.ToString(PdfSharp.Drawing.XColor,PdfSharp.Pdf.PdfColorMode)">
            <summary>
            Converts an XColor into a string with up to 3 decimal digits and a decimal point.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Internal.PdfEncoders.ToString(PdfSharp.Drawing.XMatrix)">
            <summary>
            Converts an XMatrix into a string with up to 3 decimal digits and a decimal point.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Internal.PdfEncoders.RawEncoding">
            <summary>
            Gets the raw encoding.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Internal.PdfEncoders.RawUnicodeEncoding">
            <summary>
            Gets the raw Unicode encoding.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Internal.PdfEncoders.WinAnsiEncoding">
            <summary>
            Gets the Windows 1252 (ANSI) encoding.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Internal.PdfEncoders.DocEncoding">
            <summary>
            Gets the PDF DocEncoding encoding.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Internal.PdfEncoders.UnicodeEncoding">
            <summary>
            Gets the UNICODE little-endian encoding.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Filters.FlateDecode">
            <summary>
            Implements the FlateDecode filter by wrapping SharpZipLib.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.FlateDecode.Encode(System.Byte[])">
            <summary>
            Encodes the specified data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.FlateDecode.Decode(System.Byte[],PdfSharp.Pdf.Filters.FilterParms)">
            <summary>
            Decodes the specified data.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfReference">
            <summary>
            Represents an indirect reference to a PdfObject.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfReference.#ctor(PdfSharp.Pdf.PdfObject)">
            <summary>
            Initializes a new PdfReference instance for the specified indirect object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfReference.#ctor(PdfSharp.Pdf.PdfObjectID,System.Int32)">
            <summary>
            Initializes a new PdfReference instance from the specified object identifier and file position.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfReference.WriteXRefEnty(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the object in PDF iref table format.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfReference.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes an indirect reference.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfReference.SetObject(PdfSharp.Pdf.PdfObject)">
            <summary>
            Hack for dead objects.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfReference.ToString">
            <summary>
            Gets a string representing the object identifier.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfReference.ObjectID">
            <summary>
            Gets or sets the object identifier.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfReference.ObjectNumber">
            <summary>
            Gets the object number of the object identifier.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfReference.GenerationNumber">
            <summary>
            Gets the generation number of the object identifier.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfReference.Position">
            <summary>
            Gets or sets the file position of the related PdfObject.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfReference.Value">
            <summary>
            Gets or sets the referenced PdfObject.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfReference.Document">
            <summary>
            Gets or sets the document this object belongs to.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfReference.PdfReferenceComparer">
            <summary>
            Implements a comparer that compares PdfReference objects by their PdfObjectID.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFormXObjectTable">
            <summary>
            Contains all external PDF files from which PdfFormXObjects are imported into the current document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFormXObjectTable.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of this class, which is a singleton for each document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFormXObjectTable.GetForm(PdfSharp.Drawing.XForm)">
            <summary>
            Gets a PdfFormXObject from an XPdfForm. Because the returned objects must be unique, always
            a new instance of PdfFormXObject is created if none exists for the specified form. 
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFormXObjectTable.GetImportedObjectTable(PdfSharp.Pdf.PdfPage)">
            <summary>
            Gets the imported object table.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfFormXObjectTable.forms">
            <summary>
            Map from Selector to PdfImportedObjectTable.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfFormXObjectTable.Selector">
            <summary>
            A collection of information that uniquely identifies a particular ImportedObjectTable.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFormXObjectTable.Selector.#ctor(PdfSharp.Drawing.XForm)">
            <summary>
            Initializes a new instance of FormSelector from an XPdfForm.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfFormXObjectTable.Selector.#ctor(PdfSharp.Pdf.PdfPage)">
            <summary>
            Initializes a new instance of FormSelector from a PdfPage.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfExtGStateTable">
            <summary>
            Contains all used ExtGState objects of a document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfExtGStateTable.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of this class, which is a singleton for each document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfExtGStateTable.GetExtGState(System.Double)">
            <summary>
            Gets a PdfExtGState with the keys 'CA' and 'ca' set to the specified alpha value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfExtGStateTable.GetExtGStateStroke(System.Double)">
            <summary>
            Gets a PdfExtGState with the key 'CA' set to the specified alpha value.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfExtGStateTable.GetExtGStateNonStroke(System.Double)">
            <summary>
            Gets a PdfExtGState with the key 'ca' set to the specified alpha value.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfExtGStateTable.alphaValues">
            <summary>
            Maps from alpha values (range "0" to "1000") to PdfExtGState objects.
            </summary>
        </member>
        <member name="T:PdfSharp.Internal.NativeMethods">
            <summary>
            Required native Win32 calls. Don't know what to do under Mono.
            </summary>
        </member>
        <member name="T:PdfSharp.Internal.NativeMethods.LOGFONT">
            <summary>
            Reflected from System.Drawing.SafeNativeMethods+LOGFONT
            </summary>
        </member>
        <member name="T:PdfSharp.Forms.RenderMode">
            <summary>
            Specifies how to reander the preview.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.RenderMode.Direct">
            <summary>
            Draw immediately.
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.RenderMode.Metafile">
            <summary>
            Draw using a metafile
            </summary>
        </member>
        <member name="F:PdfSharp.Forms.RenderMode.Bitmap">
            <summary>
            Draw using a bitmap image.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.OpenTypeDescriptor">
            <summary>
            The OpenType font descriptor.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.OpenTypeDescriptor.CharCodeToGlyphIndex(System.Char)">
            <summary>
            Maps a unicode to the index of the corresponding glyph.
            See OpenType spec "cmap - Character To Glyph Index Mapping Table / Format 4: Segment mapping to delta values"
            for details about this a little bit strange looking algorithm.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.OpenTypeDescriptor.GlyphIndexToPdfWidth(System.Int32)">
            <summary>
            Converts the width of a glyph identified by its index to PDF design units.
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.OpenTypeDescriptor.GlyphIndexToWidth(System.Int32)">
            <summary>
              //Converts the width of a glyph identified by its index to PDF design units.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.OpenType.OpenTypeDescriptor.IsBoldFace">
            <summary>
            Gets a value indicating whether this instance belongs to a bold font.
            </summary>
        </member>
        <member name="P:PdfSharp.Fonts.OpenType.OpenTypeDescriptor.IsItalicFace">
            <summary>
            Gets a value indicating whether this instance belongs to an italic font.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XConvert">
            <summary>
            Converts XGraphics enums to GDI+ enums.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XConvert.ToLineJoin(PdfSharp.Drawing.XLineJoin)">
            <summary>
            Converts XLineJoin to LineJoin.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.XConvert.ToLineCap(PdfSharp.Drawing.XLineCap)">
            <summary>
            Converts XLineCap to LineCap.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XColors">
            <summary>
             Represents a set of 141 pre-defined RGB colors. Incidentally the values are the same
             as in System.Drawing.Color.
             </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.AliceBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.AntiqueWhite">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Aqua">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Aquamarine">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Azure">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Beige">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Bisque">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Black">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.BlanchedAlmond">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Blue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.BlueViolet">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Brown">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.BurlyWood">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.CadetBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Chartreuse">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Chocolate">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Coral">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.CornflowerBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Cornsilk">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Crimson">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Cyan">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkCyan">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkGoldenrod">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkGray">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkKhaki">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkMagenta">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkOliveGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkOrange">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkOrchid">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkRed">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkSalmon">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkSeaGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkSlateBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkSlateGray">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkTurquoise">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DarkViolet">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DeepPink">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DeepSkyBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DimGray">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.DodgerBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Firebrick">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.FloralWhite">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.ForestGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Fuchsia">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Gainsboro">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.GhostWhite">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Gold">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Goldenrod">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Gray">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Green">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.GreenYellow">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Honeydew">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.HotPink">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.IndianRed">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Indigo">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Ivory">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Khaki">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Lavender">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LavenderBlush">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LawnGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LemonChiffon">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightCoral">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightCyan">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightGoldenrodYellow">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightGray">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightPink">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightSalmon">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightSeaGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightSkyBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightSlateGray">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightSteelBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LightYellow">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Lime">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.LimeGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Linen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Magenta">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Maroon">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MediumAquamarine">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MediumBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MediumOrchid">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MediumPurple">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MediumSeaGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MediumSlateBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MediumSpringGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MediumTurquoise">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MediumVioletRed">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MidnightBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MintCream">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.MistyRose">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Moccasin">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.NavajoWhite">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Navy">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.OldLace">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Olive">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.OliveDrab">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Orange">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.OrangeRed">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Orchid">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.PaleGoldenrod">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.PaleGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.PaleTurquoise">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.PaleVioletRed">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.PapayaWhip">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.PeachPuff">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Peru">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Pink">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Plum">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.PowderBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Purple">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Red">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.RosyBrown">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.RoyalBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.SaddleBrown">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Salmon">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.SandyBrown">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.SeaGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.SeaShell">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Sienna">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Silver">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.SkyBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.SlateBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.SlateGray">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Snow">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.SpringGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.SteelBlue">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Tan">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Teal">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Thistle">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Tomato">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Transparent">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Turquoise">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Violet">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Wheat">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.White">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.WhiteSmoke">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.Yellow">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XColors.YellowGreen">
            <summary>Gets a predefined color.</summary>
        </member>
        <member name="T:PdfSharp.Drawing.XPageDirection">
            <summary>
            Specifies the direction of the y-axis.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XPageDirection.Downwards">
            <summary>
            Increasing Y values go downwards. This is the default.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XPageDirection.Upwards">
            <summary>
            Increasing Y values go upwards. This is only possible when drawing on a PDF page.
            It is not implemented when drawing on a System.Drawing.Graphics object.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XGraphicsPathItemType">
            <summary>
            Type of the path data.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.Pdf.PdfGraphicsState">
            <summary>
            Represents the current PDF graphics state.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.PdfGraphicsState.realizedCtm">
            <summary>
            The realized current transformation matrix.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.PdfGraphicsState.unrealizedCtm">
            <summary>
            The unrealized current transformation matrix.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Pdf.PdfGraphicsState.MustRealizeCtm">
            <summary>
            A flag indicating whether the CTM must be realized.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.PdfGraphicsState.MultiplyTransform(PdfSharp.Drawing.XMatrix,PdfSharp.Drawing.XMatrixOrder)">
            <summary>
            Modifies the current transformation matrix.
            </summary>
        </member>
        <member name="M:PdfSharp.Drawing.Pdf.PdfGraphicsState.RealizeCtm">
            <summary>
            Realizes the CTM.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.BarCodes.CodeDirection">
            <summary>
            Specifies the drawing direction of the code.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.CodeDirection.LeftToRight">
            <summary>
            Does not rotate the code.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.CodeDirection.BottomToTop">
            <summary>
            Rotates the code 180° at the anchor position.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.CodeDirection.RightToLeft">
            <summary>
            Rotates the code 180° at the anchor position.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.BarCodes.CodeDirection.TopToBottom">
            <summary>
            Rotates the code 180° at the anchor position.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.CSymbol">
            <summary>
            Terminal symbols recognized by PDF content stream lexer.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Content.Objects.OpCodeName">
            <summary>
            The names of the op-codes. 
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XTypefaceHack">
            <summary>
            Temporary hack to implement PrivateFontCollection.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XTypeface">
            <summary>
            NYI
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.PathStart">
            <summary>
            Indicates how to handle the first point of a path.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.PathStart.MoveTo1st">
            <summary>
            Set the current position to the first point.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.PathStart.LineTo1st">
            <summary>
            Draws a line to the first point.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.PathStart.Ignore1st">
            <summary>
            Ignores the first point.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.Layout.XParagraphAlignment">
            <summary>
            Specifies the alignment of a paragraph.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XParagraphAlignment.Default">
            <summary>
            Default alignment, typically left alignment.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XParagraphAlignment.Left">
            <summary>
            The paragraph is rendered left aligned.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XParagraphAlignment.Center">
            <summary>
            The paragraph is rendered centered.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XParagraphAlignment.Right">
            <summary>
            The paragraph is rendered right aligned.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.Layout.XParagraphAlignment.Justify">
            <summary>
            The paragraph is rendered justified.
            </summary>
        </member>
        <member name="T:PdfSharp.PSMsgID">
            <summary>
            Represents IDs for error and diagnostic messages generated by PDFsharp.
            </summary>
        </member>
        <member name="F:PdfSharp.PSMsgID.SampleMessage1">
            <summary>
            PSMsgID.
            </summary>
        </member>
        <member name="F:PdfSharp.PSMsgID.SampleMessage2">
            <summary>
            PSMsgID.
            </summary>
        </member>
        <member name="F:PdfSharp.PSMsgID.NameMustStartWithSlash">
            <summary>
            PSMsgID.
            </summary>
        </member>
        <member name="F:PdfSharp.PSMsgID.UserOrOwnerPasswordRequired">
            <summary>
            PSMsgID.
            </summary>
        </member>
        <member name="F:PdfSharp.PSMsgID.UnexpectedToken">
            <summary>
            PSMsgID.
            </summary>
        </member>
        <member name="F:PdfSharp.PSMsgID.UnknownEncryption">
            <summary>
            PSMsgID.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfViewerPreferences">
            <summary>
            Represents the PDF document viewer preferences dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfViewerPreferences.#ctor(PdfSharp.Pdf.PdfDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfViewerPreferences" /> class.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfViewerPreferences.HideToolbar">
            <summary>
            Gets or sets a value indicating whether to hide the viewer application’s tool
             bars when the document is active.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfViewerPreferences.HideMenubar">
            <summary>
            Gets or sets a value indicating whether to hide the viewer application’s
            menu bar when the document is active.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfViewerPreferences.HideWindowUI">
            <summary>
            Gets or sets a value indicating whether to hide user interface elements in
            the document’s window (such as scroll bars and navigation controls),
            leaving only the document’s contents displayed.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfViewerPreferences.FitWindow">
            <summary>
            Gets or sets a value indicating whether to resize the document’s window to
            fit the size of the first displayed page.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfViewerPreferences.CenterWindow">
            <summary>
            Gets or sets a value indicating whether to position the document’s window
            in the center of the screen.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfViewerPreferences.DisplayDocTitle">
            <summary>
            Gets or sets a value indicating whether the window’s title bar
            should display the document title taken from the Title entry of the document
            information dictionary. If false, the title bar should instead display the name
            of the PDF file containing the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfViewerPreferences.Direction">
            <summary>
            The predominant reading order for text: LeftToRight or RightToLeft 
            (including vertical writing systems, such as Chinese, Japanese, and Korean).
            This entry has no direct effect on the document’s contents or page numbering
            but can be used to determine the relative positioning of pages when displayed 
            side by side or printed n-up. Default value: LeftToRight.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfViewerPreferences.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfViewerPreferences.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.HideToolbar">
            <summary>
            (Optional) A flag specifying whether to hide the viewer application’s tool
             bars when the document is active. Default value: false.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.HideMenubar">
            <summary>
            (Optional) A flag specifying whether to hide the viewer application’s
            menu bar when the document is active. Default value: false.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.HideWindowUI">
            <summary>
            (Optional) A flag specifying whether to hide user interface elements in
             the document’s window (such as scroll bars and navigation controls),
             leaving only the document’s contents displayed. Default value: false.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.FitWindow">
            <summary>
            (Optional) A flag specifying whether to resize the document’s window to
            fit the size of the first displayed page. Default value: false.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.CenterWindow">
            <summary>
            (Optional) A flag specifying whether to position the document’s window
            in the center of the screen. Default value: false.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.DisplayDocTitle">
            <summary>
            (Optional; PDF 1.4) A flag specifying whether the window’s title bar
            should display the document title taken from the Title entry of the document
            information dictionary. If false, the title bar should instead display the name
            of the PDF file containing the document. Default value: false.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.NonFullScreenPageMode">
            <summary>
            (Optional) The document’s page mode, specifying how to display the document on 
            exiting full-screen mode:
              UseNone     Neither document outline nor thumbnail images visible
              UseOutlines Document outline visible
              UseThumbs   Thumbnail images visible
              UseOC       Optional content group panel visible
            This entry is meaningful only if the value of the PageMode entry in the catalog 
            dictionary is FullScreen; it is ignored otherwise. Default value: UseNone.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.Direction">
            <summary>
            (Optional; PDF 1.3) The predominant reading order for text:
              L2R  Left to right
              R2L  Right to left (including vertical writing systems, such as Chinese, Japanese, and Korean)
            This entry has no direct effect on the document’s contents or page numbering
            but can be used to determine the relative positioning of pages when displayed 
            side by side or printed n-up. Default value: L2R.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.ViewArea">
            <summary>
            (Optional; PDF 1.4) The name of the page boundary representing the area of a page
            to be displayed when viewing the document on the screen. The value is the key 
            designating the relevant page boundary in the page object. If the specified page
            boundary is not defined in the page object, its default value is used.
            Default value: CropBox.
            Note: This entry is intended primarily for use by prepress applications that
            interpret or manipulate the page boundaries as described in Section 10.10.1, “Page Boundaries.”
            Most PDF consumer applications disregard it.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.ViewClip">
            <summary>
            (Optional; PDF 1.4) The name of the page boundary to which the contents of a page 
            are to be clipped when viewing the document on the screen. The value is the key 
            designating the relevant page boundary in the page object. If the specified page 
            boundary is not defined in the page object, its default value is used.
            Default value: CropBox.
            Note: This entry is intended primarily for use by prepress applications that
            interpret or manipulate the page boundaries as described in Section 10.10.1, “Page Boundaries.”
            Most PDF consumer applications disregard it.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.PrintArea">
            <summary>
            (Optional; PDF 1.4) The name of the page boundary representing the area of a page
            to be rendered when printing the document. The value is the key designating the 
            relevant page boundary in the page object. If the specified page boundary is not 
            defined in the page object, its default value is used.
            Default value: CropBox.
            Note: This entry is intended primarily for use by prepress applications that
            interpret or manipulate the page boundaries as described in Section 10.10.1, “Page Boundaries.”
            Most PDF consumer applications disregard it.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.PrintClip">
            <summary>
            (Optional; PDF 1.4) The name of the page boundary to which the contents of a page
            are to be clipped when printing the document. The value is the key designating the 
            relevant page boundary in the page object. If the specified page boundary is not
            defined in the page object, its default value is used.
            Default value: CropBox.
            Note: This entry is intended primarily for use by prepress applications that interpret
            or manipulate the page boundaries. Most PDF consumer applications disregard it.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfViewerPreferences.Keys.PrintScaling">
            <summary>
            (Optional; PDF 1.6) The page scaling option to be selected when a print dialog is
            displayed for this document. Valid values are None, which indicates that the print
            dialog should reflect no page scaling, and AppDefault, which indicates that 
            applications should use the current print scaling. If this entry has an unrecognized
            value, applications should use the current print scaling.
            Default value: AppDefault.
            Note: If the print dialog is suppressed and its parameters are provided directly
            by the application, the value of this entry should still be used.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfViewerPreferences.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfNullObject">
            <summary>
            Represents an indirect null value. This type is not used by PDFsharp, but at least
            one tool from Adobe creates PDF files with a null object.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNullObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfNullObject" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNullObject.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.PdfNullObject" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNullObject.ToString">
            <summary>
            Returns the string "null".
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNullObject.WriteObject(PdfSharp.Pdf.IO.PdfWriter)">
            <summary>
            Writes the keyword «null».
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfNull">
            <summary>
            Represents a indirect reference that is not in the cross reference table.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.PdfNull.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
        </member>
        <member name="F:PdfSharp.Pdf.PdfNull.Value">
            <summary>
            The only instance of this class.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfColorMode">
            <summary>
            Specifies what color model is used in a PDF document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfColorMode.Undefined">
            <summary>
            All color values are written as specified in the XColor objects they come from.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfColorMode.Rgb">
            <summary>
            All colors are converted to RGB.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.PdfColorMode.Cmyk">
            <summary>
            All colors are converted to CMYK.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.PdfDocumentSettings">
            <summary>
            Holds PDF specific information of the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentSettings.PrivateFontCollection">
            <summary>
            Sets the private font collection.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.PdfDocumentSettings.TrimMargins">
            <summary>
            Gets or sets the default trim margins.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Security.PdfSecuritySettings">
            <summary>
            Encapsulates access to the security settings of a PDF document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Security.PdfSecuritySettings.CanSave(System.String@)">
            <summary>
            Determines whether the document can be saved.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.HasOwnerPermissions">
            <summary>
            Indicates whether the granted access to the document is 'owner permission'. Returns true if the document 
            is unprotected or was opened with the owner password. Returns false if the document was opened with the
            user password.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.DocumentSecurityLevel">
            <summary>
            Gets or sets the document security level. If you set the security level to anything but PdfDocumentSecurityLevel.None
            you must also set a user and/or an owner password. Otherwise saving the document will fail.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.UserPassword">
            <summary>
            Sets the user password of the document. Setting a password automatically sets the
            PdfDocumentSecurityLevel to PdfDocumentSecurityLevel.Encrypted128Bit if its current
            value is PdfDocumentSecurityLevel.None.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.OwnerPassword">
            <summary>
            Sets the owner password of the document. Setting a password automatically sets the
            PdfDocumentSecurityLevel to PdfDocumentSecurityLevel.Encrypted128Bit if its current
            value is PdfDocumentSecurityLevel.None.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.PermitPrint">
            <summary>
            Permits printing the document. Should be used in conjunction with PermitFullQualityPrint.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.PermitModifyDocument">
            <summary>
            Permits modifying the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.PermitExtractContent">
            <summary>
            Permits content copying or extraction.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.PermitAnnotations">
            <summary>
            Permits commenting the document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.PermitFormsFill">
            <summary>
            Permits filling of form fields.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.PermitAccessibilityExtractContent">
            <summary>
            Permits content extraction for accessibility.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.PermitAssembleDocument">
            <summary>
            Permits to insert, rotate, or delete pages and create bookmarks or thumbnail images even if
            PermitModifyDocument is not set.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.PermitFullQualityPrint">
            <summary>
            Permits to print in high quality. insert, rotate, or delete pages and create bookmarks or thumbnail images
            even if PermitModifyDocument is not set.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Security.PdfSecuritySettings.SecurityHandler">
            <summary>
            PdfStandardSecurityHandler is the only implemented handler.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.IO.PdfWriterOptions">
            <summary>
            INTERNAL USE ONLY.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfWriterOptions.Regular">
            <summary>
            If only this flag is specified the result is a regular valid PDF stream.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfWriterOptions.OmitStream">
            <summary>
            Omit writing stream data. For debugging purposes only. 
            With this option the result is not valid PDF.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.IO.PdfWriterOptions.OmitInflation">
            <summary>
            Omit inflate filter. For debugging purposes only.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Filters.ASCIIHexDecode">
            <summary>
            Implements the ASCIIHexDecode filter.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.ASCIIHexDecode.Encode(System.Byte[])">
            <summary>
            Encodes the specified data.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Filters.ASCIIHexDecode.Decode(System.Byte[],PdfSharp.Pdf.Filters.FilterParms)">
            <summary>
            Decodes the specified data.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotation">
            <summary>
            Represents a rubber stamp annotation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotation" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotation.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotation" /> class.
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotation.Icon">
            <summary>
            Gets or sets an icon to be used in displaying the annotation.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotation.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotation.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Annotations.PdfRubberStampAnnotation.Keys.Name">
            <summary>
            (Optional) The name of an icon to be used in displaying the annotation. Viewer
            applications should provide predefined icon appearances for at least the following
            standard names:
              Approved
              AsIs
              Confidential
              Departmental
              Draft
              Experimental
              Expired
              Final
              ForComment
              ForPublicRelease
              NotApproved
              NotForPublicRelease
              Sold
              TopSecret
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Annotations.PdfAnnotations">
            <summary>
            Represents the annotations array of a page.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfAnnotations.Add(PdfSharp.Pdf.Annotations.PdfAnnotation)">
            <summary>
            Adds the specified annotation.
            </summary>
            <param name="annotation">The annotation.</param>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfAnnotations.Remove(PdfSharp.Pdf.Annotations.PdfAnnotation)">
            <summary>
            Removes an annotation from the document.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfAnnotations.Clear">
            <summary>
            Removes all the annotations from the current page.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfAnnotations.FixImportedAnnotation(PdfSharp.Pdf.PdfPage)">
            <summary>
            Fixes the /P element in imported annotation.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Annotations.PdfAnnotations.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotations.Count">
            <summary>
            Gets the number of annotations in this collection.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotations.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:PdfSharp.Pdf.Annotations.PdfAnnotation" /> at the specified index.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Annotations.PdfAnnotations.Page">
            <summary>
            Gets the page the annotations belongs to.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfCatalog">
            <summary>
            Represents the catalog dictionary.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfCatalog.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:PdfSharp.Pdf.Advanced.PdfCatalog" /> class.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.Advanced.PdfCatalog.PrepareForSave">
            <summary>
            Dispatches PrepareForSave to the objects that need it.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCatalog.Version">
            <summary>
            Get or sets the version of the PDF specification to which the document conforms.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCatalog.Pages">
            <summary>
            Gets the pages collection of this document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCatalog.PageLayout">
            <summary>
            Implementation of PdfDocument.PageLayout.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCatalog.PageMode">
            <summary>
            Implementation of PdfDocument.PageMode.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCatalog.ViewerPreferences">
            <summary>
            Implementation of PdfDocument.ViewerPreferences.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCatalog.Outlines">
            <summary>
            Implementation of PdfDocument.Outlines.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCatalog.AcroForm">
            <summary>
            Gets the AcroForm dictionary of this document.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCatalog.Language">
            <summary>
            Implementation of PdfDocument.PageMode.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCatalog.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.Advanced.PdfCatalog.Keys">
            <summary>
            Predefined keys of this dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Type">
            <summary>
            (Required) The type of PDF object that this dictionary describes; 
            must be Catalog for the catalog dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Version">
            <summary>
            (Optional; PDF 1.4) The version of the PDF specification to which the document
            conforms (for example, 1.4) if later than the version specified in the file’s header.
            If the header specifies a later version, or if this entry is absent, the document 
            conforms to the version specified in the header. This entry enables a PDF producer 
            application to update the version using an incremental update.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Pages">
            <summary>
            (Required; must be an indirect reference) The page tree node that is the root of 
            the document’s page tree.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.PageLabels">
            <summary>
            (Optional; PDF 1.3) A number tree defining the page labeling for the document. 
            The keys in this tree are page indices; the corresponding values are page label dictionaries.
            Each page index denotes the first page in a labeling range to which the specified page 
            label dictionary applies. The tree must include a value for pageindex 0.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Names">
            <summary>
            (Optional; PDF 1.2) The document’s name dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Dests">
            <summary>
            (Optional; PDF 1.1; must be an indirect reference) A dictionary of names and 
            corresponding destinations.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.ViewerPreferences">
            <summary>
            (Optional; PDF 1.2) A viewer preferences dictionary specifying the way the document 
            is to be displayed on the screen. If this entry is absent, applications should use
            their own current user preference settings.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.PageLayout">
            <summary>
            (Optional) A name object specifying the page layout to be used when the document is 
            opened:
            SinglePage - Display one page at a time.
            OneColumn - Display the pages in one column.
            TwoColumnLeft - Display the pages in two columns, with oddnumbered pages on the left.
            TwoColumnRight - Display the pages in two columns, with oddnumbered pages on the right.
            TwoPageLeft - (PDF 1.5) Display the pages two at a time, with odd-numbered pages on the left
            TwoPageRight - (PDF 1.5) Display the pages two at a time, with odd-numbered pages on the right.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.PageMode">
            <summary>
            (Optional) A name object specifying how the document should be displayed when opened:
            UseNone - Neither document outline nor thumbnail images visible.
            UseOutlines - Document outline visible.
            UseThumbs - Thumbnail images visible.
            FullScreen - Full-screen mode, with no menu bar, windowcontrols, or any other window visible.
            UseOC - (PDF 1.5) Optional content group panel visible.
            UseAttachments (PDF 1.6) Attachments panel visible.
            Default value: UseNone.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Outlines">
            <summary>
            (Optional; must be an indirect reference) The outline dictionary that is the root 
            of the document’s outline hierarchy.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Threads">
            <summary>
            (Optional; PDF 1.1; must be an indirect reference) An array of thread dictionaries 
            representing the document’s article threads.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.OpenAction">
            <summary>
            (Optional; PDF 1.1) A value specifying a destination to be displayed or an action to be 
            performed when the document is opened. The value is either an array defining a destination 
            or an action dictionary representing an action. If this entry is absent, the document
            should be opened to the top of the first page at the default magnification factor.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.AA">
            <summary>
            (Optional; PDF 1.4) An additional-actions dictionary defining the actions to be taken 
            in response to various trigger events affecting the document as a whole.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.URI">
            <summary>
            (Optional; PDF 1.1) A URI dictionary containing document-level information for URI 
            (uniform resource identifier) actions.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.AcroForm">
            <summary>
            (Optional; PDF 1.2) The document’s interactive form (AcroForm) dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Metadata">
            <summary>
            (Optional; PDF 1.4; must be an indirect reference) A metadata stream 
            containing metadata  for the document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.StructTreeRoot">
            <summary>
            (Optional; PDF 1.3) The document’s structure tree root dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.MarkInfo">
            <summary>
            (Optional; PDF 1.4) A mark information dictionary containing information
            about the document’s usage of Tagged PDF conventions.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Lang">
            <summary>
            (Optional; PDF 1.4) A language identifier specifying the natural language for all 
            text in the document except where overridden by language specifications for structure 
            elements or marked content. If this entry is absent, the language is considered unknown.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.SpiderInfo">
            <summary>
            (Optional; PDF 1.3) A Web Capture information dictionary containing state information
            used by the Acrobat Web Capture (AcroSpider) plugin extension.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.OutputIntents">
            <summary>
            (Optional; PDF 1.4) An array of output intent dictionaries describing the color 
            characteristics of output devices on which the document might be rendered.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.PieceInfo">
            <summary>
            (Optional; PDF 1.4) A page-piece dictionary associated with the document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.OCProperties">
            <summary>
            (Optional; PDF 1.5; required if a document contains optional content) The document’s 
            optional content properties dictionary.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Perms">
            <summary>
            (Optional; PDF 1.5) A permissions dictionary that specifies user access permissions 
            for the document.
            </summary>
        </member>
        <member name="F:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Legal">
            <summary>
            (Optional; PDF 1.5) A dictionary containing attestations regarding the content of a 
            PDF document, as it relates to the legality of digital signatures.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.Advanced.PdfCatalog.Keys.Meta">
            <summary>
            Gets the KeysMeta for these keys.
            </summary>
        </member>
        <member name="T:PdfSharp.Drawing.XPens">
            <summary>
            Pens for all the pre-defined colors.
            </summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.AliceBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.AntiqueWhite">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Aqua">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Aquamarine">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Azure">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Beige">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Bisque">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Black">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.BlanchedAlmond">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Blue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.BlueViolet">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Brown">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.BurlyWood">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.CadetBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Chartreuse">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Chocolate">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Coral">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.CornflowerBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Cornsilk">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Crimson">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Cyan">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkCyan">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkGoldenrod">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkGray">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkKhaki">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkMagenta">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkOliveGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkOrange">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkOrchid">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkRed">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkSalmon">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkSeaGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkSlateBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkSlateGray">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkTurquoise">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DarkViolet">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DeepPink">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DeepSkyBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DimGray">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.DodgerBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Firebrick">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.FloralWhite">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.ForestGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Fuchsia">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Gainsboro">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.GhostWhite">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Gold">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Goldenrod">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Gray">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Green">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.GreenYellow">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Honeydew">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.HotPink">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.IndianRed">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Indigo">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Ivory">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Khaki">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Lavender">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LavenderBlush">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LawnGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LemonChiffon">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightCoral">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightCyan">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightGoldenrodYellow">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightGray">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightPink">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightSalmon">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightSeaGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightSkyBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightSlateGray">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightSteelBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LightYellow">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Lime">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.LimeGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Linen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Magenta">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Maroon">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MediumAquamarine">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MediumBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MediumOrchid">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MediumPurple">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MediumSeaGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MediumSlateBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MediumSpringGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MediumTurquoise">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MediumVioletRed">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MidnightBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MintCream">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.MistyRose">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Moccasin">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.NavajoWhite">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Navy">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.OldLace">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Olive">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.OliveDrab">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Orange">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.OrangeRed">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Orchid">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.PaleGoldenrod">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.PaleGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.PaleTurquoise">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.PaleVioletRed">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.PapayaWhip">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.PeachPuff">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Peru">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Pink">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Plum">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.PowderBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Purple">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Red">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.RosyBrown">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.RoyalBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.SaddleBrown">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Salmon">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.SandyBrown">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.SeaGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.SeaShell">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Sienna">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Silver">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.SkyBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.SlateBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.SlateGray">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Snow">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.SpringGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.SteelBlue">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Tan">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Teal">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Thistle">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Tomato">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Transparent">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Turquoise">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Violet">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Wheat">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.White">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.WhiteSmoke">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.Yellow">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="P:PdfSharp.Drawing.XPens.YellowGreen">
            <summary>Gets a pre-defined XPen object.</summary>
        </member>
        <member name="T:PdfSharp.Drawing.XFillMode">
            <summary>
            Specifies how the interior of a closed path is filled.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XFillMode.Alternate">
            <summary>
            Specifies the alternate fill mode. Called the 'odd-even rule' in PDF terminology.
            </summary>
        </member>
        <member name="F:PdfSharp.Drawing.XFillMode.Winding">
            <summary>
            Specifies the winding fill mode. Called the 'nonzero winding number rule' in PDF terminology.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfComboBoxField">
            <summary>
            Represents the combo box field.
            </summary>
        </member>
        <member name="M:PdfSharp.Pdf.AcroForms.PdfComboBoxField.#ctor(PdfSharp.Pdf.PdfDocument)">
            <summary>
            Initializes a new instance of PdfComboBoxField.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfComboBoxField.SelectedIndex">
            <summary>
            Gets or sets the index of the selected item.
            </summary>
        </member>
        <member name="P:PdfSharp.Pdf.AcroForms.PdfComboBoxField.Meta">
            <summary>
            Gets the KeysMeta of this dictionary type.
            </summary>
        </member>
        <member name="T:PdfSharp.Pdf.AcroForms.PdfComboBoxField.Keys">
            <summary>
            Predefined keys of this dictionary. 
            The description comes from PDF 1.4 Reference.
            </summary>
        </member>
        <member name="T:PdfSharp.Fonts.OpenType.ExternalHelper">
            <summary>
            PDFsharp internal stuff.
            For more information see Andrew Schulman "Undocumented PDFsharp"  :-))
            </summary>
        </member>
        <member name="M:PdfSharp.Fonts.OpenType.ExternalHelper.F74167FFE4044F53B28A4AF049E9EF25(PdfSharp.Drawing.XFont,PdfSharp.Drawing.XPdfFontOptions,System.Boolean)">
            <summary>
            This is an external helper function.
            </summary>
        </member>
    </members>
</doc>